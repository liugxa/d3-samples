(function() {
	var $ = {};
// $source: com/ibm/rave/core/internal/nativeImpl/ModuleHeader
/************************************************************************
** IBM Confidential
**
** IBM Business Analytics: Rapidly Adaptive Visualization Engine
**
** (C) Copyright IBM Corp. 2014, 2015
**
** The source code for this program is not published or otherwise divested of its trade secrets, 
** irrespective of what has been deposited with the U.S. Copyright Office.
************************************************************************/
// setup global object for strict mode (window and non-window environments)
// indirect eval call evaluates in global scope and sets 'this' to a global object
var global = (1,eval)('this');

// setup 
var rave_document = global.document;
var rave_externs = {};

function rave_documentElement(node) {
	if (node) {
		node = node._rave_isDOM ? node : node.rave_getOwner ? node.rave_getOwner() : node;
	}
	return node
      	&& (node.ownerDocument // node is a Node
      	|| node.document // node is a Window
      	|| node).documentElement; // node is a Document
}

function rave_window(node) {
	if (node) {
		node = node._rave_isDOM ? node : node.rave_getOwner ? node.rave_getOwner() : node;
	}
	return node
      	&& ((node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
        || (node.document && node) // node is a Window
        || node.defaultView); // node is a Document
}


// $source: com/ibm/rave/core/nativeImpl/Object
/************************************************************************
** IBM Confidential
**
** IBM Business Analytics: Rapidly Adaptive Visualization Engine
**
** (C) Copyright IBM Corp. 2015
**
** The source code for this program is not published or otherwise divested of its trade secrets, 
** irrespective of what has been deposited with the U.S. Copyright Office.
************************************************************************/

var com_ibm_rave_core_nativeImpl_Object = (function() {
	// object for all translated classes.
	var Obj = function(){};

	/**
	 * Checks if obj is an instanceof class cls. 
	 * 
	 * @param obj
	 *            the object to check
	 * @param cls
	 *            the class type
	 */
	/** @expose */
    Obj.isInstanceOf = function(obj, cls) {
    	if (obj) {
	    	if (obj instanceof cls) {
	    		return true;
	    	}
    	}
        return false;
    };
    
    var empty = {};
    
    Obj.mixin = function(dest, source) {
		for (var name in source) {
			_mixin(dest, source, name);
		}
    };
    
    // split off this piece from Obj.mixin to allow for optimization
    function _mixin(dest, source, name) {
    	var s = source[name];
		if ((dest[name] === undefined) || (dest[name] !== s && ((empty[name] === undefined) || empty[name] !== s))) {
			dest[name] = s;
		}
    }
	
	return Obj;
})();

// $source: com/ibm/rave/core/internal/util/NamespaceUtil
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
var com_ibm_rave_core_internal_util_NamespaceUtil = {


};

com_ibm_rave_core_internal_util_NamespaceUtil.initialize_NAMESPACES = function() {
	var NAMESPACES = {};
	NAMESPACES["svg"] = "http://www.w3.org/2000/svg";
	NAMESPACES["xhtml"] = "http://www.w3.org/1999/xhtml";
	NAMESPACES["xlink"] = "http://www.w3.org/1999/xlink";
	NAMESPACES["xml"] = "http://www.w3.org/XML/1998/namespace";
	NAMESPACES["xmlns"] = "http://www.w3.org/2000/xmlns/";
	return NAMESPACES;
};

com_ibm_rave_core_internal_util_NamespaceUtil.getQName = function(name) {
	var _name = name;
	var idx = _name.indexOf(":");
	var prefix = _name;
	if (idx >= 0) {
		prefix = _name.substring(0, idx);
		_name = _name.substring(idx + 1);
	}
	var qname = {};
	qname["local"] = _name;
	if (com_ibm_rave_core_internal_util_NamespaceUtil.NAMESPACES.hasOwnProperty(prefix)) {
		qname["space"] = com_ibm_rave_core_internal_util_NamespaceUtil.NAMESPACES[prefix];
	}
	return qname;
};

com_ibm_rave_core_internal_util_NamespaceUtil.NAMESPACES = com_ibm_rave_core_internal_util_NamespaceUtil.initialize_NAMESPACES();

// $source: com/ibm/rave/core/internal/selector/SelectorHelper
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/Configuration (runtime) // Configuration
//@import com/ibm/rave/core/internal/util/QueryUtil (runtime) // getQueryEngine
var com_ibm_rave_core_internal_selector_SelectorHelper = {


};

com_ibm_rave_core_internal_selector_SelectorHelper.each = function(selection, callback) {
	var node;
	for (var j = 0, m = selection.length; j < m; ++j) {
		var group = selection[j];
		for (var i = 0, n = group.length; i < n; ++i) {
			if ((node = group[i])) {
				callback.call(node, node.rave_getData(), i, j);
			}
		}
	}
	return selection;
};

com_ibm_rave_core_internal_selector_SelectorHelper.selector = function(selector) {
	return typeof selector === "function" ? selector : function(data, index, groupIndex) {
		return selector != null ? com_ibm_rave_core_Configuration.INSTANCE.filter(com_ibm_rave_core_internal_util_QueryUtil.getQueryEngine(this).querySelector(selector, this), selector) : null;
	};
};

com_ibm_rave_core_internal_selector_SelectorHelper.selectorAll = function(selector) {
	return typeof selector === "function" ? selector : function(data, index, groupIndex) {
		return selector != null ? com_ibm_rave_core_Configuration.INSTANCE.filterArray(com_ibm_rave_core_internal_util_QueryUtil.getQueryEngine(this).querySelectorAll(selector, this)) : null;
	};
};


// $source: com/ibm/rave/core/internal/util/QueryUtil
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/Configuration (runtime) // Configuration
var com_ibm_rave_core_internal_util_QueryUtil = {

	//constructor : function() {}
};

/**
 * Get a query engine for the given root node.
 * @param (com.ibm.rave.core.scene.SceneNode) root a scene node, may be <code>null</code>
 * @return (com.ibm.rave.core.internal.selector.SelectionQueryEngine)  a query engine
 */
com_ibm_rave_core_internal_util_QueryUtil.getQueryEngine = function(root) {
	var config = com_ibm_rave_core_Configuration.INSTANCE;
	if (root) {
		var result = config.getQueryEngine(root.rave_getQualifiedName());
		if (!result) {
			result = config.getQueryEngine(root.rave_getNamespaceURI());
		}
		return result;
	}
	return config.getQueryEngine(null);
};


// $source: com/ibm/rave/core/internal/nativeImpl/selector/EmptySceneNode
/************************************************************************
** IBM Confidential
**
** IBM Business Analytics: Rapidly Adaptive Visualization Engine
**
** (C) Copyright IBM Corp. 2014
**
** The source code for this program is not published or otherwise divested of its trade secrets, 
** irrespective of what has been deposited with the U.S. Copyright Office.
************************************************************************/

var com_ibm_rave_core_internal_nativeImpl_selector_EmptySceneNode = function(data) {
	this["__data__"] = data;
};

com_ibm_rave_core_internal_nativeImpl_selector_EmptySceneNode.prototype.rave_getData = function() {
	return this["__data__"];
};

com_ibm_rave_core_internal_nativeImpl_selector_EmptySceneNode.prototype.rave_setData = function(d) {
	this["__data__"] = d;
};

com_ibm_rave_core_internal_nativeImpl_selector_EmptySceneNode.prototype.rave_hasData = function() {
	return "__data__" in this;
};
// $source: com/ibm/rave/core/internal/nativeImpl/transitions/InheritedTransition
/************************************************************************
** IBM Confidential
**
** IBM Business Analytics: Rapidly Adaptive Visualization Engine
**
** (C) Copyright IBM Corp. 2014
**
** The source code for this program is not published or otherwise divested of its trade secrets, 
** irrespective of what has been deposited with the U.S. Copyright Office.
************************************************************************/

var com_ibm_rave_core_internal_nativeImpl_transitions_InheritedTransition = {
		
	get : function() {
		return this._inherited;
	},
		
	set : function(inherited) {
		this._inherited = inherited;
	}
};
// $source: com/ibm/rave/core/internal/nativeImpl/Vendor
/************************************************************************
** IBM Confidential
**
** IBM Business Analytics: Rapidly Adaptive Visualization Engine
**
** (C) Copyright IBM Corp. 2014
**
** The source code for this program is not published or otherwise divested of its trade secrets, 
** irrespective of what has been deposited with the U.S. Copyright Office.
************************************************************************/

var vendorPrefixes = ["webkit", "ms", "moz", "Moz", "o", "O"];

function vendorSymbol(object, name) {
	if (name in object) {
		return name;
	}
	name = name.charAt(0).toUpperCase() + name.substring(1);
	for (var i = 0, n = vendorPrefixes.length; i < n; ++i) {
		var prefixName = vendorPrefixes[i] + name;
		if (prefixName in object)
			return prefixName;
	}
}

// $source: com/ibm/rave/core/internal/nativeImpl/Lang
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2014, 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/

var com_ibm_rave_core_internal_nativeImpl_Lang = {

    /** @expose **/
    isNumber: function (object) {
        return (typeof object == 'number' || object instanceof Number);
    },
    /** @expose **/
    isString: function (object) {
        return (typeof object == 'string' || object instanceof String);
    },
    /** @expose **/
    isBoolean: function (object) {
        return (typeof object == 'boolean' || object instanceof Boolean);
    },
    /** @expose **/
    isList: function (object) {
    	// in JS for now we do nto really have lists , they all get translated to Array
        return false;
    },
    /** @expose **/
    isArray: function (object) {
        return (typeof object == 'Array' || object instanceof Array);
    },
    /** @expose **/
    isObject: function (object) {
        return typeof object == 'object';
    },
    /** @expose **/
    // Return the string as-is. If it's anything else, return an empty string.
    toString: function (object) {
        return (typeof object == 'string') ? object : "";
    }
};
// $source: com/ibm/rave/core/nativeImpl/interpolate/ObjectInterpolation
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2014
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
	/**
	 * Returns an object interpolator between the two objects a and b. 
	 * Internally, an object template is created that has the same properties as b.
	 * For each property in b, if there exists a corresponding property in a, a generic
	 * interpolator is created for the two elements using interpolate. If there is no
	 * such property, the static value from b is used in the template. 
	 * Then, for the given parameter t, the template's embedded interpolators are evaluated
	 * and the updated object template is then returned. 
	 * For example, if a is the object {x: 0, y: 1} and b is the object {x: 1, y: 10, z: 100},
	 * the result of the interpolator for t = .5 is the object {x: .5, y: 5.5, z: 100}.
	 * 
	 * Object interpolation is particularly useful for dataspace interpolation, where data is 
	 * interpolated rather than attribute values. For example, you can interpolate an object which
	 * describes an arc in a pie chart, and then use d3.svg.arc to compute the new SVG path data.
	 * 
	 * Note: no defensive copy of the template object is created; modifications of the returned 
	 * object may adversely affect subsequent evaluation of the interpolator. No copy is made because
	 * interpolators should be fast, as they are part of the inner loop of animation.
	 * @param (Object) a the start Object
	 * @param (Object) b the end Object
	 * @return (com.ibm.rave.core.interpolate.Interpolator)  q new interpolator
	 */
	/** @expose */
var com_ibm_rave_core_nativeImpl_interpolate_ObjectInterpolation = function(a, b) {
	var i = {}, c = {}, k;
	for (k in a) {
		if (k in b) {
			i[k] = com_ibm_rave_core_interpolate_Interpolators.INSTANCE.getInterpolator(a[k], b[k]);
		} else {
			c[k] = a[k];
		}
	}
	for (k in b) {
		if (!(k in a)) {
			c[k] = b[k];
		}
	}

	return function(t) {
		for (k in i)
			c[k] = i[k](t);
		return c;
	};
};

/** @expose */ 
com_ibm_rave_core_nativeImpl_interpolate_ObjectInterpolation.INSTANCE = com_ibm_rave_core_nativeImpl_interpolate_ObjectInterpolation;

// $source: com/ibm/rave/core/nativeImpl/format/Requote
/************************************************************************
** IBM Confidential
**
** IBM Business Analytics: Rapidly Adaptive Visualization Engine
**
** (C) Copyright IBM Corp. 2014
**
** The source code for this program is not published or otherwise divested of its trade secrets, 
** irrespective of what has been deposited with the U.S. Copyright Office.
************************************************************************/
var _requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
var com_ibm_rave_core_nativeImpl_format_Requote = {
	requote : function(s) {
		return s.replace(_requote_re, "\\$&");
	}
};



// $source: com/ibm/rave/core/scene/SceneNodeType
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
var com_ibm_rave_core_scene_SceneNodeType = rave_externs["SceneNodeType"] = {


};

/** @expose */ 
com_ibm_rave_core_scene_SceneNodeType.RECT = 1000;
/** @expose */ 
com_ibm_rave_core_scene_SceneNodeType.LINE = 1001;
/** @expose */ 
com_ibm_rave_core_scene_SceneNodeType.CIRCLE = 1002;
/** @expose */ 
com_ibm_rave_core_scene_SceneNodeType.TEXT = 1003;
/** @expose */ 
com_ibm_rave_core_scene_SceneNodeType.GROUP = 1004;
/** @expose */ 
com_ibm_rave_core_scene_SceneNodeType.TITLE = 1005;
/** @expose */ 
com_ibm_rave_core_scene_SceneNodeType.PATH = 1006;
/** @expose */ 
com_ibm_rave_core_scene_SceneNodeType.IMAGE = 1007;
/** @expose */ 
com_ibm_rave_core_scene_SceneNodeType.TEXT_CONTENT = 1008;
/** @expose */ 
com_ibm_rave_core_scene_SceneNodeType.POLYLINE = 1009;
/** @expose */ 
com_ibm_rave_core_scene_SceneNodeType.POLYGON = 1010;
/** @expose */ 
com_ibm_rave_core_scene_SceneNodeType.LINEARGRADIENT = 1011;
/** @expose */ 
com_ibm_rave_core_scene_SceneNodeType.RADIALGRADIENT = 1012;
/** @expose */ 
com_ibm_rave_core_scene_SceneNodeType.ELLIPSE = 1013;
/** @expose */ 
com_ibm_rave_core_scene_SceneNodeType.CLIP_PATH = 1014;
/** @expose */ 
com_ibm_rave_core_scene_SceneNodeType.DEFS = 1015;
/** @expose */ 
com_ibm_rave_core_scene_SceneNodeType.STOP = 1016;

/** @expose */ 
com_ibm_rave_core_scene_SceneNodeType.UNKNOWN = -1;

// $source: com/ibm/rave/core/arrays/Sort
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
/**
 * Utility for sorting numbers numerically and objects by their string representation.
 */
var com_ibm_rave_core_arrays_Sort = rave_externs["Sort"] = {

	//constructor : function() {}
};

/**
 * Descending sort. Sorts numbers numerically and all other objects by their string representation.
 */
/** @expose */ 
com_ibm_rave_core_arrays_Sort.descending = function(a, b) {
	return b<a ? -1 : b>a ? 1 : 0;
};
/**
 * Ascending sort. Sorts numbers numerically and all other objects by their string representation.
 */
/** @expose */ 
com_ibm_rave_core_arrays_Sort.ascending = function(a, b) {
	return a<b ? -1 : a>b ? 1 : 0;
};

// $source: com/ibm/rave/core/internal/nativeImpl/scene/SceneNodeUtil
/************************************************************************
 ** IBM Confidential
 ** 
 ** OCO Source Materials
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2014
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
var com_ibm_rave_core_internal_nativeImpl_scene_SceneNodeUtil = {
	// static property that caches our only check for getOwnerBoundingClientRect
	// a bit hacky. If we need additional browser checks in the future, we
	// should move all browser detection outside
	// to another utility
	_isOldFirefox : null,

	getOwnerBoundingClientRect : function(node) {
		// Firefox < v33 will not correctly calculate the size of an svg node
		// using getBoundingClientRect().
		// The bounds returned may only include the size of the items inside the
		// node or may be zero. For now
		// use getCalculatedStyle().
		if (this._isOldFirefox === null) {
			var versionIndex = -1;
			var userAgent = navigator.userAgent.toString();			
			// cache our browser result - only care about older versions of
			// firefox here. And also phantomjs for testing.
			// Useragent for Firefox is
			// Mozilla/5.0 (Macintosh; Intel Mac OS X 10.10; rv:31.0) Gecko/20100101 Firefox/31.0
			// So, try to determine the version after Firefox/
			this._isOldFirefox = userAgent.indexOf("PhantomJS") > -1 || ((versionIndex = userAgent.indexOf("Firefox")) > -1 && userAgent.slice(versionIndex + 8) < 33);
		}

		if (this._isOldFirefox && rave_window(node)) {
			var computedStyle = rave_window(node).getComputedStyle(node);
			var width = 0;
			var height = 0;

			[ 'height', 'paddingTop', 'paddingBottom', 'borderTopWidth', 'borderBottomWidth' ].forEach(function(attribute) {
				height += parseFloat(computedStyle[attribute]);
			});
			[ 'width', 'paddingLeft', 'paddingRight', 'borderLeftWidth', 'borderRightWidth' ].forEach(function(attribute) {
				width += parseFloat(computedStyle[attribute]);
			});
			return {
				"width" : width,
				"height" : height
			};
		}
		// Default is to just call getClientBoundingRect
		return node.getBoundingClientRect();
	}
};

// $source: com/ibm/rave/core/arrays/Merge
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
/**
 * Creates a flattened array
 */
var com_ibm_rave_core_arrays_Merge = rave_externs["Merge"] = {

	//constructor : function() {}
};

/**
 * Create a merged array.
 * @param (Array) arrays an array of arrays of any type to be merged. In other words, the array will be flattened. Ex] [[1,2,3],[4],[5,6] => [1,2,3,4,5,6]
 * @return (Array)  flattened array
 */
/** @expose */ 
com_ibm_rave_core_arrays_Merge.merge = function(arrays) {
	var n = arrays.length, m;
	var array;
	var newSize = 0;
	for (var __i_enFor0 = 0, __exp_enFor0 = arrays, __len_enFor0 = __exp_enFor0.length;
			__i_enFor0 < __len_enFor0; ++__i_enFor0) {
		var child = __exp_enFor0[__i_enFor0];
		newSize += child.length;
	}
	var merged = new Array(newSize);
	while (--n >= 0) {
		array = arrays[n];
		m = array.length;
		while (--m >= 0) {
			merged[--newSize] = array[m];
		}
	}
	return merged;
};


// $source: com/ibm/rave/core/arrays/MinMax
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
var com_ibm_rave_core_arrays_MinMax = rave_externs["MinMax"] = {

	//constructor : function() {}
};

/**
 * Get the max value in the array.
 * @param (Array) numbers an array of numbers.
 * @return (Object)  the max value in the array
 */
com_ibm_rave_core_arrays_MinMax.max$0 = function(numbers) {
	var i = -1;
	var n = numbers.length;
	var a, b;
	while (++i < n) {
		if ((b = numbers[i]) != null && b<=b) {
			a = b;
			break;
		}
	}
	while (++i < n) {
		if ((b = numbers[i]) != null && b>a) {
			a = b;
		}
	}
	return a;
};

/**
 * Get the max value in the data array extracted from the value function.
 * @param (Array) data an array of data
 * @param (com.ibm.rave.core.selector.ValueFunction) valueFunction a function that returns a number for each item in the data array
 * @return (Object)  the max value in the data
 */
com_ibm_rave_core_arrays_MinMax.max$1 = function(data, valueFunction) {
	var i = -1;
	var n = data.length;
	var a, b;
	while (++i < n) {
		if ((b = valueFunction.call(data, data[i], i, -1)) != null && b<=b) {
			a = b;
			break;
		}
	}
	while (++i < n) {
		if ((b = valueFunction.call(data, data[i], i, -1)) != null && b>a) {
			a = b;
		}
	}
	return a;
};

/**
 * Get the min value in the array.
 * @param (Array) numbers an array of numbers
 * @return (Object)  the min value in the array
 */
com_ibm_rave_core_arrays_MinMax.min$0 = function(numbers) {
	var i = -1;
	var n = numbers.length;
	var a, b;
	while (++i < n) {
		if ((b = numbers[i]) != null && b<=b) {
			a = b;
			break;
		}
	}
	while (++i < n) {
		if ((b = numbers[i]) != null && b<a) {
			a = b;
		}
	}
	return a;
};

/**
 * Get the min value in the data array extracted from the value function.
 * @param (Array) data an array of data
 * @param (com.ibm.rave.core.selector.ValueFunction) valueFunction a function that returns a number for each item in the data array
 * @return (Object)  the min value in the data
 */
com_ibm_rave_core_arrays_MinMax.min$1 = function(data, valueFunction) {
	var i = -1;
	var n = data.length;
	var a, b;
	while (++i < n) {
		if ((b = valueFunction.call(data, data[i], i, -1)) != null && b<=b) {
			a = b;
			break;
		}
	}
	while (++i < n) {
		if ((b = valueFunction.call(data, data[i], i, -1)) != null && b<a) {
			a = b;
		}
	}
	return a;
};

/** @expose */ 
com_ibm_rave_core_arrays_MinMax.max = function(a0, a1) {
	var args = arguments;
	if (args.length == 1) {
		return com_ibm_rave_core_arrays_MinMax.max$0(a0);
	}
	return com_ibm_rave_core_arrays_MinMax.max$1(a0, a1);
};

/** @expose */ 
com_ibm_rave_core_arrays_MinMax.min = function(a0, a1) {
	var args = arguments;
	if (args.length == 1) {
		return com_ibm_rave_core_arrays_MinMax.min$0(a0);
	}
	return com_ibm_rave_core_arrays_MinMax.min$1(a0, a1);
};


// $source: com/ibm/rave/core/arrays/Quantile
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
/**
 * Compute a quantile for a sorted array of numbers. Returns the p-quantile of the given sorted array of numbers, where p is a number in the range [0,1]. For example, the median can be computed using p = 0.5, the first quartile at p = 0.25, and the third quartile at p = 0.75. This particular implementation uses the R-7 algorithm, which is the default for the R programming language and Excel. This method requires that numbers contains numeric elements and is already sorted in ascending order.
 */
var com_ibm_rave_core_arrays_Quantile = rave_externs["Quantile"] = {

	//constructor : function() {}
};

/**
 * Returns the p-quantile of the given sorted array of numbers
 * @param (Array) values   Sorted array of values (in ascending order) 
 * @param (double) p   the p value, for median use p = 0.5
 * @return (Number)  the p-quantile value
 */
/** @expose */ 
com_ibm_rave_core_arrays_Quantile.quantile = function(values, p) {
	var H = (values.length - 1) * p + 1;
	var iH = Math.floor(H);
	var v = + (values[iH - 1]);
	var e = H - iH;
	return (e != 0) ? v + e * (+ (values[iH]) - v) : v;
};


// $source: com/ibm/rave/core/arrays/Deviation
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/arrays/Variance (runtime) // variance
/**
 * Computes the Standard Deviation, as defined by the square root of the bias-corrected variance. If the array has fewer than two values, the result is *undefined* An accessor function may be provided to process the data. This method ignores invalid values such as NaN and undefined.
 */
var com_ibm_rave_core_arrays_Deviation = rave_externs["Deviation"] = {

	//constructor : function() {}
};

/**
 * Calculates the standard deviation of an array of values.
 * @param (java.lang.Object[]) array the values used to calculate the deviation
 * @return (Number)  the deviation value
 */
com_ibm_rave_core_arrays_Deviation.deviation$0 = function(array) {
	var v = com_ibm_rave_core_arrays_Variance.variance(array);
	return (v) ? Math.sqrt(v) : v;
};

/**
 * Calculates the standard deviation of an array of values.
 * @param (java.lang.Object[]) array the values used to calculate the deviation
 * @param (com.ibm.rave.core.selector.ValueFunction) valueFunction the accessor function to use to get the value
 * @return (Number)  the deviation value
 */
com_ibm_rave_core_arrays_Deviation.deviation$1 = function(array, valueFunction) {
	var v = com_ibm_rave_core_arrays_Variance.variance(array, valueFunction);
	return (v) ? Math.sqrt(v) : v;
};

/** @expose */ 
com_ibm_rave_core_arrays_Deviation.deviation = function(a0, a1) {
	var args = arguments;
	if (args.length == 1) {
		return com_ibm_rave_core_arrays_Deviation.deviation$0(a0);
	}
	return com_ibm_rave_core_arrays_Deviation.deviation$1(a0, a1);
};


// $source: com/ibm/rave/core/internal/math/NumberUtil
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
/**
 * A collection of utility function for numbers.
 */
var com_ibm_rave_core_internal_math_NumberUtil = {


};

/**
 * Similar to  {@link this.ObjectConverter#this.toDouble(Object)} , but returns NaN if the object is null.
 * @param (Object) o the object to convert
 * @return (double)  a number value, or NaN if the object is null
 */
com_ibm_rave_core_internal_math_NumberUtil.toNumber = function(o) {
	return o == null ? NaN : + (o);
};


// $source: com/ibm/rave/core/arrays/Extent
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
var com_ibm_rave_core_arrays_Extent = rave_externs["Extent"] = {

	//constructor : function() {}
};

/**
 * Returns the extent (min,max) of the given array.
 * @param (java.lang.Object[]) array   the array to use to calculate the extent
 * @return (Array)  the extent array.
 */
com_ibm_rave_core_arrays_Extent.extent$0 = function(array) {
	var n = array.length;
	if (n <= 0) {
		return [undefined, undefined];
	}
	var a, b, c;
	var i = -1;
	while (++i < n) {
		if ((b = array[i]) != null && b>=b) {
			a = c = b;
			break;
		}
	}
	while (++i < n) {
		if ((b = array[i]) != null) {
			if (a>b) {
				a = b;
			}
			if (c<b) {
				c = b;
			}
		}
	}
	return [a, c];
};

/**
 * Returns the extent(min, max) of the values returned from the accessor function. 
 * @param (java.lang.Object[]) array   the data to iterator over.
 * @param (com.ibm.rave.core.selector.ValueFunction) valueFunction the accessor function to use to get the values.
 * @return (Array)  the extent
 */
com_ibm_rave_core_arrays_Extent.extent$1 = function(array, valueFunction) {
	var n = array.length;
	var a, b, c;
	var i = -1;
	if (n <= 0) {
		return [undefined, undefined];
	}
	while (++i < n) {
		if ((b = valueFunction.call(array, array[i], i, -1)) != null && b>=b) {
			a = c = b;
			break;
		}
	}
	while (++i < n) {
		b = valueFunction.call(array, array[i], i, -1);
		if (b != null) {
			if (a>b) {
				a = b;
			}
			if (c<b) {
				c = b;
			}
		}
	}
	return [a, c];
};

/** @expose */ 
com_ibm_rave_core_arrays_Extent.extent = function(a0, a1) {
	var args = arguments;
	if (args.length == 1) {
		return com_ibm_rave_core_arrays_Extent.extent$0(a0);
	}
	return com_ibm_rave_core_arrays_Extent.extent$1(a0, a1);
};


// $source: com/ibm/rave/core/arrays/Sum
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
var com_ibm_rave_core_arrays_Sum = rave_externs["Sum"] = {

	//constructor : function() {}
};

/**
 * Get the sum of the values  in the array.
 * @param (Array) numbers an array of numbers
 * @return (Number)  the sum of the values in the array
 */
com_ibm_rave_core_arrays_Sum.sum$0 = function(numbers) {
	var s = 0;
	var n = numbers.length;
	var a;
	var i = -1;
	while (++i < n) {
		a = + (numbers[i]);
		if (!(isNaN(a))) {
			s += a;
		}
	}
	return s;
};

/**
 * Get the sum of the values in the data array extracted from the value function.
 * @param (Array) data an array of data
 * @param (com.ibm.rave.core.selector.ValueFunction) valueFunction a function that returns a number for each item in the data array
 * @return (Number)  the sum of the values  in the data
 */
com_ibm_rave_core_arrays_Sum.sum$1 = function(data, valueFunction) {
	var s = 0;
	var n = data.length;
	var a;
	var i = -1;
	while (++i < n) {
		if ((a = valueFunction.call(data, data[i], i, -1)) != null && !(isNaN(a))) {
			s += a;
		}
	}
	return s;
};

/** @expose */ 
com_ibm_rave_core_arrays_Sum.sum = function(a0, a1) {
	var args = arguments;
	if (args.length == 1) {
		return com_ibm_rave_core_arrays_Sum.sum$0(a0);
	}
	return com_ibm_rave_core_arrays_Sum.sum$1(a0, a1);
};


// $source: com/ibm/rave/core/arrays/Zip
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/arrays/MinMax (runtime) // min
/**
 * Returns an array of arrays, where the ith array contains the ith element from each of the argument arrays. The returned array is truncated in length to the shortest array in arrays. If arrays contains only a single array,\ the returned array contains one-element arrays. With no arguments, the returned array is empty. Rave.zip([1, 2], [3, 4]); returns [[1, 3], [2, 4]]
 */
var com_ibm_rave_core_arrays_Zip = rave_externs["Zip"] = {

	//constructor : function() {}
};

/**
 * Returns an array of arrays, where the ith array contains the ith element from each of the argument arrays. The returned array is truncated in length to the shortest array in arrays. If arrays contains only a single array,\ the returned array contains one-element arrays. With no arguments, the returned array is empty. Rave.zip([1, 2], [3, 4]); returns [[1, 3], [2, 4]]
 * @param (java.util.List[]) objects the input arrays
 * @return (Array) 	and Array of Arrays zipped version of the arrays of objects provided
 */
/** @expose */ 
com_ibm_rave_core_arrays_Zip.zip = function(objects) {
	if (objects !== null || arguments.length > 1){
		objects = Array.prototype.slice.call(arguments);
	}
	{
		var n = objects.length;
		var zips = [];
		if (n == 0) {
			return zips;
		}
		var m = ~~+ (com_ibm_rave_core_arrays_MinMax.min(com_ibm_rave_core_arrays_Zip.toArrayEx(objects), com_ibm_rave_core_arrays_Zip.MIN_FN));
		for (var i = 0; i < m; ++i) {
			var zip = new Array(n);
			zips.push(zip);
			for (var j = 0; j < n; ++j) {
				zip[j] = objects[j][i];
			}
		}
		return zips;
	}
};

com_ibm_rave_core_arrays_Zip.toArrayEx = function(objects) {
	var retVal = [];
	for (var index = 0; index < objects.length; ++index) {
		retVal.push(objects[index]);
	}
	return retVal;
};

com_ibm_rave_core_arrays_Zip.MIN_FN = function(data, index, groupIndex) {
	return ((data).length);
};

// $source: com/ibm/rave/core/arrays/Permute
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
/**
 * Returns a permutation of the specified array using the specified array of indexes. The returned array contains the corresponding element in array for each index in indexes, in order. For example, permute(["a", "b", "c"], [1, 2, 0]) returns ["b", "c", "a"].  It is acceptable for the array of indexes to be a different length from the array of elements,  and for indexes to be duplicated or omitted. In the JS version only, This method can be used to extract the values from an object into an array with a stable order. (Array indexes in JavaScript are simply properties which have a special relationship to .length.) Extracting keyed values in order can be useful for generating data arrays in nested selections.  For example, we could display some of the Minnesota barley yield data above in table form: <code> var cols = ["site", "variety", "yield"]; thead.selectAll('th').data(cols) .enter().append('th').text(function (d) { return d.toUpperCase(); }); tbody.selectAll('tr').data(yields) .enter().append('tr').selectAll('td').data(function (row) { return d3.permute(row, cols); }) .enter().append('td').text(function (d) { return d; }); </code>
 */
var com_ibm_rave_core_arrays_Permute = rave_externs["Permute"] = {

	//constructor : function() {}
};

/**
 * Returns a permutation of the specified array using the specified array of indexes. 
 * @param (Array) inputArray  the array to permute
 * @param (Array) indexes  the indexes to use to do the permute
 * @return (Array)  the permuted array
 */
/** @expose */ 
com_ibm_rave_core_arrays_Permute.permute = function(inputArray, indexes) {
	var i = indexes.length;
	var permutes = new Array(i);
	while (i-- > 0) {
		if (0 <= indexes[i] && indexes[i] < inputArray.length) {
			permutes[i] = inputArray[indexes[i]];
		}
	}
	return permutes;
};


// $source: com/ibm/rave/core/arrays/Range
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
/**
 * Generates an array containing an arithmetic progression, similar to the Python built-in range. This method is often used to iterate over a sequence of numeric or integer values, such as the indexes into an array. Unlike the Python version, the arguments are not required to be integers, though the results are more predictable if they are due to floating point precision. If step is omitted, it defaults to 1. If start is omitted, it defaults to 0. The stop value is not included in the result. The full form returns an array of numbers [start, start + step, start + 2 * step, …]. If step is positive, the last element is the largest start + i * step less than stop; if step is negative, the last element is the smallest start + i * step greater than stop. If the returned array would contain an infinite number of values, an error is thrown rather than causing an infinite loop.
 */
var com_ibm_rave_core_arrays_Range = rave_externs["Range"] = {

	//constructor : function() {}
};

/**
 * Generates an array containing an arithmetic progression between 'start' and 'stop incrementing by 'step'. <p> Start defaults to 0.<br> Step defaults to 1.
 * @param (Object) stop the end range value
 * @return (Array)  an array containing an arithmetic progression
 */
com_ibm_rave_core_arrays_Range.create$0 = function(stop) {
	return com_ibm_rave_core_arrays_Range.createRange(0, + (stop), 1);
};

/**
 * Generates an array containing an arithmetic progression between 'start' and 'stop incrementing by 'step'. <p> Step defaults to 1.
 * @param (Object) start the starting range value
 * @param (Object) stop the end range value
 * @return (Array)  an array containing an arithmetic progression
 */
com_ibm_rave_core_arrays_Range.create$1 = function(start, stop) {
	return com_ibm_rave_core_arrays_Range.createRange(+ (start), + (stop), 1);
};

/**
 * Generates an array containing an arithmetic progression between 'start' and 'stop incrementing by 'step'.
 * @param (Object) start the starting range value
 * @param (Object) stop the end range value
 * @param (Object) step the step
 * @return (Array)  an array containing an arithmetic progression
 */
com_ibm_rave_core_arrays_Range.create$2 = function(start, stop, step) {
	return com_ibm_rave_core_arrays_Range.createRange(+ (start), + (stop), + (step));
};

com_ibm_rave_core_arrays_Range.createRange = function(start, stop, step) {
	var _start = start;
	var _stop = stop;
	var _step = step;
	var range = [];
	if ((_stop - _start) / _step == Infinity) {
		throw new Error("infinite range");
	}
	var k = com_ibm_rave_core_arrays_Range.integerScale(Math.abs(_step));
	var i = -1;
	var j;
	_start *= k;
	_stop *= k;
	_step *= k;
	if (_step < 0) {
		while ((j = _start + _step * ++i) > _stop) {
			range.push(j / k);
		}
	} else {
		while ((j = _start + _step * ++i) < _stop) {
			range.push(j / k);
		}
	}
	return range;
};

com_ibm_rave_core_arrays_Range.integerScale = function(x) {
	var k = 1;
	while ((x * k % 1)) {
		k *= 10;
	}
	return k;
};

/** @expose */ 
com_ibm_rave_core_arrays_Range.create = function(a0, a1, a2) {
	var args = arguments;
	if (args.length == 1) {
		return com_ibm_rave_core_arrays_Range.create$0(a0);
	}
	if (args.length == 2) {
		return com_ibm_rave_core_arrays_Range.create$1(a0, a1);
	}
	return com_ibm_rave_core_arrays_Range.create$2(a0, a1, a2);
};


// $source: com/ibm/rave/core/nativeImpl/event/EventTracker
/************************************************************************
** IBM Confidential
**
** IBM Business Analytics: Rapidly Adaptive Visualization Engine
**
** (C) Copyright IBM Corp. 2014
**
** The source code for this program is not published or otherwise divested of its trade secrets, 
** irrespective of what has been deposited with the U.S. Copyright Office.
************************************************************************/

var com_ibm_rave_core_nativeImpl_event_EventTracker = {
		
		eventSource : function() {
			var e = rave.event, s;
			while (s = e.sourceEvent) {
				e = s;
			}
			return e;
		}
};
// $source: com/ibm/rave/core/format/Round
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
var com_ibm_rave_core_format_Round = rave_externs["Round"] = {


};

/**
 * Returns the value x rounded to n digits after the decimal point. If n is omitted, it defaults to zero. The result is a number. Values are rounded to the closest multiple of 10 to the power minus n; if two multiples are equally close, the value is rounded up in accordance with the built-in round function.
 * @param (double) x the value to round
 * @param (double) n if specified, rounds x to n digits
 * @return (double)  the value x rounded to n digits
 */
/** @expose */ 
com_ibm_rave_core_format_Round.round = function(x, n) {
	var _n = n;
	return (_n) ? Math.round(x * (_n = Math.pow(10, _n))) / _n : Math.round(x);
};


// $source: com/ibm/rave/core/internal/format/Precision
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
var com_ibm_rave_core_internal_format_Precision = {


};

/**
 * Calculates the position of the decimal point in the value x.<br> eg. With p = 0: 123.456 has a precision value of -3 while 0.000123 has a precision value of 3 <p> The p value will offset the result by its value.<br> eg. With p = 2: 123.456 has a precision value of -1 while 0.000123 has a precision value of 5
 * @param (double) x the value to calculate precision for
 * @param (int) p a value to offset the precision value by
 * @return (double)  the calculated precision
 */
com_ibm_rave_core_internal_format_Precision.precision = function(x, p) {
	return p - ((x) ? Math.ceil(Math.log(x) / Math["LN10"]) : 1);
};


// $source: com/ibm/rave/core/nativeImpl/arrays/AssociativeArrays
/************************************************************************
** IBM Confidential
**
** IBM Business Analytics: Rapidly Adaptive Visualization Engine
**
** (C) Copyright IBM Corp. 2014
**
** The source code for this program is not published or otherwise divested of its trade secrets, 
** irrespective of what has been deposited with the U.S. Copyright Office.
************************************************************************/

/**
 * Another common data type in JavaScript is the associative array, or more simply
 * the object, which has a set of named properties. In Java this is referred to as a map,
 * and in Python, a dictionary. JavaScript provides a standard mechanism for 
 * iterating over the keys (or property names) in an associative array: the for…in
 * loop. However, note that the iteration order is undefined. D3 provides several 
 * operators for converting associative arrays to standard indexed arrays.
 */
var com_ibm_rave_core_nativeImpl_arrays_AssociativeArrays = {
	/**
	 * Returns an array containing the property names of the specified object (an 
	 * associative array). The order of the returned array is undefined. 
	 */
	keys : function(map){
		var keys=[];
		for (var key in map) keys.push(key);
		return keys;
	},
	/**
	 * Returns an array containing the property values of the specified object (an
	 * associative array). The order of the returned array is undefined.	  
	 */
	values : function(map){
		var values = [];
		for(var key in map) values.push(map[key]);
		return values;
	},
	/**
	 * Returns an array containing the property keys and values of the specified object
	 * (an associative array). Each entry is an object with a key and value attribute, such
	 * as {key: "foo", value: 42}. The order of the returned array is undefined	 
	 */
	entries : function(map){
		var entries=[];
		for(var key in map) entries.push({key:key,value:map[key]});
		return entries;
	}
};
// $source: com/ibm/rave/core/arrays/Entry
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
/**
 * Represents an entry in map
 */
var com_ibm_rave_core_arrays_Entry = rave_externs["Entry"] = function(){};


// $source: com/ibm/rave/core/arrays/Pairs
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
/**
 * Static class to call the pairs method
 * @author  Bryan
 */
var com_ibm_rave_core_arrays_Pairs = rave_externs["Pairs"] = {

	//constructor : function() {}
};

/**
 * For each adjacent pair of elements in the specified array, returns a new array of tuples of  element i and element i - 1. For example:  Rave.pairs([1, 2, 3, 4]); // returns [[1, 2], [2, 3], [3, 4]] If the specified array has fewer than two elements, returns the empty array.
 * @param (java.lang.Object[]) array
 * @return (java.lang.Object[])  Object[]
 */
/** @expose */ 
com_ibm_rave_core_arrays_Pairs.pairs = function(array) {
	var i = 0, n = array.length - 1;
	var pairs = [];
	if (array.length > 0) {
		var p0, p1 = array[0];
		while (i < n) {
			pairs[i] = [p0 = p1, p1 = array[++i]];
		}
	}
	return pairs;
};


// $source: com/ibm/rave/core/nativeImpl/textMetrics/GraphicContextFactory
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/

/**
 *  utility to create emulation of HTML canvas element 2d context functionality for text measurement
 */

/**
 * @param (int) width canvas width
 * @param (int) height canvas height
 * @return canvas element
 */
/** @expose */
var com_ibm_rave_core_nativeImpl_textMetrics_GraphicContextFactory = {

	create : function(width, height) {

		var canvas;

		if (typeof document !== "undefined") {
			canvas = document.createElement("canvas");
			canvas.width = width;
			canvas.height = height;
		} else {
			// Attempt to use node-canvas.
			canvas = new Canvas(width, height);
		}

		return canvas;
	}
};

// $source: com/ibm/rave/core/internal/geom/PolygonUtil
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
var com_ibm_rave_core_internal_geom_PolygonUtil = {


};

/**
 * Intersect two infinite lines cd and ab.
 * @param (Array) c starting point of the first line
 * @param (Array) d end point of the second line
 * @param (Array) a starting point of the first line
 * @param (Array) b end point of the second line
 * @return (Array)  The intersection point of the two lines
 */
com_ibm_rave_core_internal_geom_PolygonUtil.polygonIntersect = function(c, d, a, b) {
	var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
	return [x1 + ua * x21, y1 + ua * y21];
};


// $source: com/ibm/rave/core/internal/util/Identity
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
/**
 * Function class used typically for where Identity projection is needed. It return the same data passed to it.
 */
var com_ibm_rave_core_internal_util_Identity = {


};

com_ibm_rave_core_internal_util_Identity.create = function() {
	return function(data, index, groupIndex) {
		return data;
	};
};


// $source: com/ibm/rave/core/internal/math/Trigonometry
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
var com_ibm_rave_core_internal_math_Trigonometry = {

	//constructor : function() {}
};

com_ibm_rave_core_internal_math_Trigonometry.sgn = function(x) {
	return x > 0 ? 1 : x < 0 ? -1 : 0;
};

/**
 * returns the 2D cross product of AB and AC vectors, i.e., the z-component of the 3D cross product in a quadrant I Cartesian coordinate system (+x is right, +y is up). Returns a positive value if ABC is counter-clockwise, negative if clockwise, and zero if the points are collinear.
 * @param (Array) a the first point (A)
 * @param (Array) b the second point (B)
 * @param (Array) c the third point (C)
 * @return (double)  a positive value if ABC is counter-clockwise, negative if clockwise, and zero if the points are collinear.
 */
com_ibm_rave_core_internal_math_Trigonometry.cross2d = function(a, b, c) {
	return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
};

com_ibm_rave_core_internal_math_Trigonometry.acos = function(x) {
	return x > 1 ? 0 : x < -1 ? 3.141592653589793 : Math.acos(x);
};

com_ibm_rave_core_internal_math_Trigonometry.asin = function(x) {
	return x > 1 ? 1.5707963267948966 : x < -1 ? -1.5707963267948966 : Math.asin(x);
};

com_ibm_rave_core_internal_math_Trigonometry.sinh = function(x) {
	var _x = x;
	return ((_x = Math.exp(_x)) - 1 / _x) / 2;
};

com_ibm_rave_core_internal_math_Trigonometry.cosh = function(x) {
	var _x = x;
	return ((_x = Math.exp(_x)) + 1 / _x) / 2;
};

com_ibm_rave_core_internal_math_Trigonometry.tanh = function(x) {
	var _x = x;
	return ((_x = Math.exp(2 * _x)) - 1) / (_x + 1);
};

com_ibm_rave_core_internal_math_Trigonometry.haversin = function(x) {
	var _x = x;
	return (_x = Math.sin(_x / 2)) * _x;
};

com_ibm_rave_core_internal_math_Trigonometry.sinci = function(x) {
	return (x != 0) ? x / Math.sin(x) : 1;
};

com_ibm_rave_core_internal_math_Trigonometry.ε = 1E-6;

com_ibm_rave_core_internal_math_Trigonometry.π = Math.PI;
com_ibm_rave_core_internal_math_Trigonometry.τ = 2 * 3.141592653589793;
com_ibm_rave_core_internal_math_Trigonometry.halfπ = 3.141592653589793 / 2;
com_ibm_rave_core_internal_math_Trigonometry.ε2 = 1.0E-6 * 1.0E-6;
com_ibm_rave_core_internal_math_Trigonometry.radians = 3.141592653589793 / 180;
com_ibm_rave_core_internal_math_Trigonometry.degrees = 180 / 3.141592653589793;
com_ibm_rave_core_internal_math_Trigonometry.τε = 6.283185307179586 - 1.0E-6;

// $source: com/ibm/rave/core/internal/scales/Ranger
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
var com_ibm_rave_core_internal_scales_Ranger = function(t, a, padding, outerPadding) {
	this.t = t;
	this.a = a;
	this.padding = padding;
	this.outerPadding = outerPadding;
};


// $source: com/ibm/rave/core/time/TimeFormatter
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED

// $source: com/ibm/rave/core/internal/globalization/BidiStringDirection
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
/**
 * Enum describing valid bidi string directions.
 * @author  jim
 */
var com_ibm_rave_core_internal_globalization_BidiStringDirection = {

	//constructor : function() {}
};

com_ibm_rave_core_internal_globalization_BidiStringDirection.parse = function(textDirection) {
	var dir = textDirection;
	if (dir != null) {
		dir = textDirection.toLowerCase();
	}
	if ("ltr" == dir) {
		return 0;
	} else if ("rtl" == dir) {
		return 1;
	} else if ("auto" == dir) {
		return 3;
	}
	return 4;
};

com_ibm_rave_core_internal_globalization_BidiStringDirection.toString = function(dir) {
	switch (dir) {
	case 0:
		return "ltr";
	case 1:
		return "rtl";
	case 3:
		return "auto";
	default:
		return "ltr";
	}
};

com_ibm_rave_core_internal_globalization_BidiStringDirection.LTR = 0;
com_ibm_rave_core_internal_globalization_BidiStringDirection.RTL = 1;
com_ibm_rave_core_internal_globalization_BidiStringDirection.AUTO = 3;
com_ibm_rave_core_internal_globalization_BidiStringDirection.NONE = 4;
com_ibm_rave_core_internal_globalization_BidiStringDirection.LTR_STRING = "ltr";
com_ibm_rave_core_internal_globalization_BidiStringDirection.RTL_STRING = "rtl";
com_ibm_rave_core_internal_globalization_BidiStringDirection.AUTO_STRING = "auto";

com_ibm_rave_core_internal_globalization_BidiStringDirection.UNKNOWN = -1;

// $source: com/ibm/rave/core/internal/nativeImpl/globalization/BidiProcess
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2014, 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/

//@import com/ibm/rave/core/internal/globalization/BidiStringDirection (runtime)

/**
 * Platform specific bidi string processing. Used to determine the directionality of  strings based on their first "strong" character direction.
 * Uses the dbidi (dojo bidi) library.
 * 
 * @author  jim
 */
var com_ibm_rave_core_internal_nativeImpl_globalization_BidiProcess = {};

/**
 * Determine the direction of our string using the first "strong" character type found.
 * Parts of this code are from the dojo bidi project. https://github.com/ibm-js/dbidi/blob/master/LICENSE
 * 
 * @param (String) string String to check
 * @return (Number)  BidiStringDirection enum value.
 */
/** @expose */ 
com_ibm_rave_core_internal_nativeImpl_globalization_BidiProcess.determineDirection = function(string) {
	var UBAT_L	= 0; /* left to right				*/
	var UBAT_R	= 1; /* right to left				*/
	var UBAT_EN = 2; /* European digit				*/
	var UBAT_AN = 3; /* Arabic-Indic digit			*/
	var UBAT_ON = 4; /* neutral						*/
	var UBAT_B	= 5; /* block separator				*/
	var UBAT_S	= 6; /* segment separator			*/
	var UBAT_AL = 7; /* Arabic Letter				*/
	var UBAT_WS = 8; /* white space					*/
	var UBAT_CS = 9; /* common digit separator		*/
	var UBAT_ES = 10; /* European digit separator	*/
	var UBAT_ET = 11; /* European digit terminator	*/
	var UBAT_NSM = 12; /* Non Spacing Mark			*/
	var UBAT_LRE = 13; /* LRE						*/
	var UBAT_RLE = 14; /* RLE						*/
	var UBAT_PDF = 15; /* PDF						*/
	var UBAT_LRO = 16; /* LRO						*/
	var UBAT_RLO = 17; /* RLO						*/
	var UBAT_BN	= 18; /* Boundary Neutral			*/

	var TYPES_NAMES = [ "UBAT_L", "UBAT_R", "UBAT_EN", "UBAT_AN", "UBAT_ON", "UBAT_B", "UBAT_S", "UBAT_AL", "UBAT_WS",
						"UBAT_CS", "UBAT_ES", "UBAT_ET", "UBAT_NSM", "UBAT_LRE", "UBAT_RLE", "UBAT_PDF", "UBAT_LRO",
						"UBAT_RLO", "UBAT_BN" ];
	
	var TBBASE = 100;
	
	var TB00 = TBBASE + 0;
	var TB05 = TBBASE + 1;
	var TB06 = TBBASE + 2;
	var TB07 = TBBASE + 3;
	var TB20 = TBBASE + 4;
	var TBFB = TBBASE + 5;
	var TBFE = TBBASE + 6;
	var TBFF = TBBASE + 7;
	
	var L	= UBAT_L;
	var R	= UBAT_R;
	var EN	= UBAT_EN;
	var AN	= UBAT_AN;
	var ON	= UBAT_ON;
	var B	= UBAT_B;
	var S	= UBAT_S;
	var AL	= UBAT_AL;
	var WS	= UBAT_WS;
	var CS	= UBAT_CS;
	var ES	= UBAT_ES;
	var ET	= UBAT_ET;
	var NSM	= UBAT_NSM;
	var LRE	= UBAT_LRE;
	var RLE	= UBAT_RLE;
	var PDF	= UBAT_PDF;
	var LRO	= UBAT_LRO;
	var RLO	= UBAT_RLO;
	var BN	= UBAT_BN;
	
	var MasterTable = [
	                   /*******************************************************************************************************/
	                   /*     0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F     */
	                   /*******************************************************************************************************/
	                   /*0-*/ TB00, L,    L,    L,    L,    TB05, TB06, TB07, R,    L,    L,    L,    L,    L,    L,    L,
	                   /*1-*/ L,    L,    L,    L,    L,    L,    L,    L,    L,    L,    L,    L,    L,    L,    L,    L,
	                   /*2-*/ TB20, ON,   ON,   ON,   L,    ON,   L,    ON,   L,    ON,   ON,   ON,   L,    L,    ON,   ON,
	                   /*3-*/ L,    L,    L,    L,    L,    ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,
	                   /*4-*/ ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   L,    L,    ON,
	                   /*5-*/ ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,
	                   /*6-*/ ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,
	                   /*7-*/ ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,
	                   /*8-*/ ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,
	                   /*9-*/ ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   L,
	                   /*A-*/ L,    L,    L,    L,    L,    L,    L,    L,    L,    L,    L,    L,    L,    ON,   ON,   ON,
	                   /*B-*/ ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,
	                   /*C-*/ ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,
	                   /*D-*/ ON,   ON,   ON,   ON,   ON,   ON,   ON,   L,    L,    ON,   ON,   L,    L,    ON,   ON,   L,
	                   /*E-*/ L,    ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,
	                   /*F-*/ ON,   ON,   ON,   ON,   ON,   ON,   ON,   ON,   L,    L,    L,    TBFB, AL,   AL,   TBFE, TBFF
	                  	];
	
	
	var UnicodeTable = [
	                    [ /*	Table 00: Unicode 00xx */
	                /****************************************************************************************/
	                /*      0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F	*/
	                /****************************************************************************************/
	                /*0-*/  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  S,   B,   S,   WS,  B,   BN,  BN,
	                /*1-*/  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  B,   B,   B,   S,
	                /*2-*/  WS,  ON,  ON,  ET,  ET,  ET,  ON,  ON,  ON,  ON,  ON,  ES,  CS,  ES,  CS,  CS,
	                /*3-*/  EN,  EN,  EN,  EN,  EN,  EN,  EN,  EN,  EN,  EN,  CS,  ON,  ON,  ON,  ON,  ON,
	                /*4-*/  ON,  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,
	                /*5-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   ON,  ON,  ON,  ON,  ON,
	                /*6-*/  ON,  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,
	                /*7-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   ON,  ON,  ON,  ON,  BN,
	                /*8-*/  BN,  BN,  BN,  BN,  BN,  B,   BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,
	                /*9-*/  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,  BN,
	                /*A-*/  CS,  ON,  ET,  ET,  ET,  ET,  ON,  ON,  ON,  ON,  L,   ON,  ON,  BN,  ON,  ON,
	                /*B-*/  ET,  ET,  EN,  EN,  ON,  L,   ON,  ON,  ON,  EN,  L,   ON,  ON,  ON,  ON,  ON,
	                /*C-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,
	                /*D-*/  L,   L,   L,   L,   L,   L,   L,   ON,  L,   L,   L,   L,   L,   L,   L,   L,
	                /*E-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,
	                /*F-*/  L,   L,   L,   L,   L,   L,   L,   ON,  L,   L,   L,   L,   L,   L,   L,   L
	            		],
	            		[ /*	Table 01: Unicode 05xx */
	                /****************************************************************************************/
	                /*      0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F	*/
	                /****************************************************************************************/
	                /*0-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,
	                /*1-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,
	                /*2-*/  L,   L,   L,   L,   L,   L,   L,   L,   ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,
	                /*3-*/  ON,  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,
	                /*4-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,
	                /*5-*/  L,   L,   L,   L,   L,   L,   L,   ON,  ON,  L,   L,   L,   L,   L,   L,   L,
	                /*6-*/  ON,  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,
	                /*7-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,
	                /*8-*/  L,   L,   L,   L,   L,   L,   L,   L,   ON,  L,   ON,  ON,  ON,  ON,  ON,  ON,
	                /*9-*/  ON,  NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM,
	                /*A-*/  NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM,
	                /*B-*/  NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, R,   NSM,
	                /*C-*/  R,   NSM, NSM, R,   NSM, NSM, R,   NSM, ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,
	                /*D-*/  R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,
	                /*E-*/  R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   ON,  ON,  ON,  ON,  ON,
	                /*F-*/  R,   R,   R,   R,   R,   ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON
	            		],
	            		[ /*	Table 02: Unicode 06xx */
	                /****************************************************************************************/
	            	/*      0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F	*/
	            	/****************************************************************************************/
	                /*0-*/  AN,  AN,  AN,  AN,  ON,  ON,  ON,  ON,  AL,  ET,  ET,  AL,  CS,  AL,  ON,  ON,
	                /*1-*/  NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, AL,  ON,  ON,  AL,  AL,
	                /*2-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,
	                /*3-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,
	                /*4-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  NSM, NSM, NSM, NSM, NSM,
	                /*5-*/  NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM,
	                /*6-*/  AN,  AN,  AN,  AN,  AN,  AN,  AN,  AN,  AN,  AN,  ET,  AN,  AN,  AL,  AL,  AL,
	                /*7-*/  NSM, AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,
	                /*8-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,
	                /*9-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,
	                /*A-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,
	                /*B-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,
	                /*C-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,
	                /*D-*/  AL,  AL,  AL,  AL,  AL,  AL,  NSM, NSM, NSM, NSM, NSM, NSM, NSM, AN,  ON,  NSM,
	                /*E-*/  NSM, NSM, NSM, NSM, NSM, AL,  AL,  NSM, NSM, ON,  NSM, NSM, NSM, NSM, AL,  AL,
	                /*F-*/  EN,  EN,  EN,  EN,  EN,  EN,  EN,  EN,  EN,  EN,  AL,  AL,  AL,  AL,  AL,  AL
	            		],
	            		[	/*	Table	03:	Unicode	07xx	*/
	                /****************************************************************************************/
	                /*      0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F	*/
	                /****************************************************************************************/
	                /*0-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  ON,  AL,
	                /*1-*/  AL,  NSM, AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,
	                /*2-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,
	                /*3-*/  NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM,
	                /*4-*/  NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, ON,  ON,  AL,  AL,  AL,
	                /*5-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,
	                /*6-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,
	                /*7-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,
	                /*8-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,
	                /*9-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,
	                /*A-*/  AL,  AL,  AL,  AL,  AL,  AL,  NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM,
	                /*B-*/  NSM, AL,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,
	                /*C-*/  R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,
	                /*D-*/  R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,
	                /*E-*/  R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   R,   NSM, NSM, NSM, NSM, NSM,
	                /*F-*/  NSM, NSM, NSM, NSM, R,   R,   ON,  ON,  ON,  ON,  R,   ON,  ON,  ON,  ON,  ON
	            		],
	            		[	/*	Table	04:	Unicode	20xx	*/
	                /****************************************************************************************/
	                /*      0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F	*/
	                /****************************************************************************************/
	                /*0-*/  WS,  WS,  WS,  WS,  WS,  WS,  WS,  WS,  WS,  WS,  WS,  BN,  BN,  BN,  L,   R,
	                /*1-*/  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,
	                /*2-*/  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  WS,  B,   LRE, RLE, PDF, LRO, RLO, CS,
	                /*3-*/  ET,  ET,  ET,  ET,  ET,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,
	                /*4-*/  ON,  ON,  ON,  ON,  CS,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,
	                /*5-*/  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  WS,
	                /*6-*/  BN,  BN,  BN,  BN,  BN,  ON,  ON,  ON,  ON,  ON,  BN,  BN,  BN,  BN,  BN,  BN,
	                /*7-*/  EN,  L,   ON,  ON,  EN,  EN,  EN,  EN,  EN,  EN,  ES,  ES,  ON,  ON,  ON,  L,
	                /*8-*/  EN,  EN,  EN,  EN,  EN,  EN,  EN,  EN,  EN,  EN,  ES,  ES,  ON,  ON,  ON,  ON,
	                /*9-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   ON,  ON,  ON,
	                /*A-*/  ET,  ET,  ET,  ET,  ET,  ET,  ET,  ET,  ET,  ET,  ET,  ET,  ET,  ET,  ET,  ET,
	                /*B-*/  ET,  ET,  ET,  ET,  ET,  ET,  ET,  ET,  ET,  ET,  ON,  ON,  ON,  ON,  ON,  ON,
	                /*C-*/  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,
	                /*D-*/  NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM,
	                /*E-*/  NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM,
	                /*F-*/  NSM, ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON
	            		],
	            		[	/*	Table	05:	Unicode	FBxx	*/
	                /****************************************************************************************/
	                /*      0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F	*/
	                /****************************************************************************************/
	                /*0-*/  L,   L,   L,   L,   L,   L,   L,   ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,
	                /*1-*/  ON,  ON,  ON,  L,   L,   L,   L,   L,   ON,  ON,  ON,  ON,  ON,  R,   NSM, R,
	                /*2-*/  R,   R,   R,   R,   R,   R,   R,   R,   R,   ES,  R,   R,   R,   R,   R,   R,
	                /*3-*/  R,   R,   R,   R,   R,   R,   R,   ON,  R,   R,   R,   R,   R,   ON,  R,   ON,
	                /*4-*/  R,   R,   ON,  R,   R,   ON,  R,   R,   R,   R,   R,   R,   R,   R,   R,   R,
	                /*5-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,
	                /*6-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,
	                /*7-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,
	                /*8-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,
	                /*9-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,
	                /*A-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,
	                /*B-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,
	                /*C-*/  AL,  AL,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,
	                /*D-*/  ON,  ON,  ON,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,
	                /*E-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,
	                /*F-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL
	            		],
	            		[	/*	Table	06:	Unicode	FExx	*/
	                /****************************************************************************************/
	                /*      0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F	*/
	                /****************************************************************************************/
	                /*0-*/  NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM, NSM,
	                /*1-*/  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,
	                /*2-*/  NSM, NSM, NSM, NSM, NSM, NSM, NSM, ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,
	                /*3-*/  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,
	                /*4-*/  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,
	                /*5-*/  CS,  ON,  CS,  ON,  ON,  CS,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ET,
	                /*6-*/  ON,  ON,  ES,  ES,  ON,  ON,  ON,  ON,  ON,  ET,  ET,  ON,  ON,  ON,  ON,  ON,
	                /*7-*/  AL,  AL,  AL,  AL,  AL,  ON,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,
	                /*8-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,
	                /*9-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,
	                /*A-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,
	                /*B-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,
	                /*C-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,
	                /*D-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,
	                /*E-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,
	                /*F-*/  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  AL,  ON,  ON,  BN
	            		],
	            		[	/*	Table	07:	Unicode	FFxx	*/
	                /****************************************************************************************/
	                /*      0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F	*/
	                /****************************************************************************************/
	                /*0-*/  ON,  ON,  ON,  ET,  ET,  ET,  ON,  ON,  ON,  ON,  ON,  ES,  CS,  ES,  CS,  CS,
	                /*1-*/  EN,  EN,  EN,  EN,  EN,  EN,  EN,  EN,  EN,  EN,  CS,  ON,  ON,  ON,  ON,  ON,
	                /*2-*/  ON,  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,
	                /*3-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   ON,  ON,  ON,  ON,  ON,
	                /*4-*/  ON,  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,
	                /*5-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   ON,  ON,  ON,  ON,  ON,
	                /*6-*/  ON,  ON,  ON,  ON,  ON,  ON,  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,
	                /*7-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,
	                /*8-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,
	                /*9-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,
	                /*A-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,
	                /*B-*/  L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   L,   ON,
	                /*C-*/  ON,  ON,  L,   L,   L,   L,   L,   L,   ON,  ON,  L,   L,   L,   L,   L,   L,
	                /*D-*/  ON,  ON,  L,   L,   L,   L,   L,   L,   ON,  ON,  L,   L,   L,   ON,  ON,  ON,
	                /*E-*/  ET,  ET,  ON,  ON,  ON,  ET,  ET,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,
	                /*F-*/  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON,  ON
	            		]
	            	];

	var directionality = checkContextual(string);
	// if first STRONG character found
	if (directionality == com_ibm_rave_core_internal_globalization_BidiStringDirection.LTR
			|| directionality == com_ibm_rave_core_internal_globalization_BidiStringDirection.RTL) {
		return directionality;
	}

	return com_ibm_rave_core_internal_globalization_BidiStringDirection.UNKNOWN;	

	function checkContextual(text) {
		// summary:
		//		Determine the base direction of a bidi text according
		//		to its first strong directional character.
		// text: 
		//		The text to check.
		// returns: /*String*/
		//		"ltr" or "rtl" according to the first strong character.
		//		If there is no strong character, returns the value of the
		//		document dir property.
		// tags:
		//		public		
		var dir = firstStrongDir(text);
		if (!dir) {
			dir = document.dir.toLowerCase();
			if (dir !== "ltr" && dir !== "rtl") {
				dir = "ltr";
			}
		}
		
		var bidiDirection = com_ibm_rave_core_internal_globalization_BidiStringDirection.UNKNOWN;
		switch (dir) {
			case "ltr":
				bidiDirection = com_ibm_rave_core_internal_globalization_BidiStringDirection.LTR;
				break;
			case "rtl":
				bidiDirection = com_ibm_rave_core_internal_globalization_BidiStringDirection.RTL;
				break;
			default:
				break;
		}
		
		return bidiDirection;
	
		function firstStrongDir(/*String*/text) {
			// summary:
			//		Return the first strong character direction
			// text:
			//		The source string.
			// description:
			//		Iterates over the text string, letter by letter starting from its beginning,
			//		searching for first "strong" character. 
			//		Returns if strong character was found with the direction defined by this 
			//		character, if no strong character was found returns an empty string.
			// returns: String
			//		"ltr" - if the first strong character is Latin.
			//		"rtl" - if the first strong character is RTL directed character.
			//		"" - if the strong character wasn't found.
			// tags:
			//		private
		
			var type = null, uc = null, hi = null;
			for (var i = 0; i < text.length; i++) {
				uc = text.charAt(i).charCodeAt(0);
				hi = MasterTable[uc >> 8];
				type = hi < TBBASE ? hi : UnicodeTable[hi - TBBASE][uc & 0xFF];
				if (type === UBAT_R || type === UBAT_AL) {
					return "rtl";
				}
				if (type === UBAT_L) {
					return	"ltr";
				}
				if (type === UBAT_B) {
					break;
				}
			}
			return null;
		}
	
	};
};

// $source: com/ibm/rave/core/internal/nativeImpl/event/Event
/************************************************************************
** IBM Confidential
**
** IBM Business Analytics: Rapidly Adaptive Visualization Engine
**
** (C) Copyright IBM Corp. 2014
**
** The source code for this program is not published or otherwise divested of its trade secrets, 
** irrespective of what has been deposited with the U.S. Copyright Office.
************************************************************************/

var com_ibm_rave_core_internal_nativeImpl_event_Event = rave_window(rave_document) ? typeof rave_window(rave_document).Event === "function"
	
	? function(type, canBubble, canCancel) {
		return new Event(type, {
			'bubbles': canBubble || false,
			'cancelable': canCancel || false
		});
	}

	//IE doesn't support Event constructor
	: function(type, canBubble, canCancel) {
		var e;
		if (rave_document) {
			e = rave_document.createEvent('Event');
			e.initEvent(type, canBubble || false, canCancel || false);
		}
		return e;
	}
	
	// rave_window(rave_document) is undefined
	: undefined;
// $source: com/ibm/rave/core/internal/svg/symbol/SymbolCreatorsConstants
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
/**
 * constants needed by symbol creators
 */
var com_ibm_rave_core_internal_svg_symbol_SymbolCreatorsConstants = {


};

com_ibm_rave_core_internal_svg_symbol_SymbolCreatorsConstants.r2_svg_symbolTan30 = Math.tan(30 * (3.141592653589793 / 180));
com_ibm_rave_core_internal_svg_symbol_SymbolCreatorsConstants.r2_svg_symbolSqrt3 = Math.sqrt(3);

// $source: com/ibm/rave/core/geo/InvertiblePointProjector
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED

// $source: com/ibm/rave/core/internal/geo/ClipLineStreamListenerFactory
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED

// $source: com/ibm/rave/core/nativeImpl/xhr/Xhr
/************************************************************************
** IBM Confidential
**
** IBM Business Analytics: Rapidly Adaptive Visualization Engine
**
** (C) Copyright IBM Corp. 2014, 2015
**
** The source code for this program is not published or otherwise divested of its trade secrets, 
** irrespective of what has been deposited with the U.S. Copyright Office.
************************************************************************/

//@import com/ibm/rave/core/Rave (runtime)

var com_ibm_rave_core_nativeImpl_xhr_Xhr = (function() {
	
	function rave_xhr(url, mimeType, response, callback) {
		var rave = com_ibm_rave_core_Rave;
		var xhr = {},
		dispatch = rave.dispatch("beforesend", "progress", "load", "error"),
		headers = {},
		request = new XMLHttpRequest,
		responseType = null;
	
		// If IE does not support CORS, use XDomainRequest.
		if (global.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) {
			request = new XDomainRequest;
		}
		
		"onload" in request ? request.onload = request.onerror = respond:
			request.onreadystatechange = function() {
				request.readyState > 3 && respond();
			};
	    	  
	    function respond() {
			var status = request.status, result;
			if (!status && hasResponse(request) || status >= 200 && status < 300 || status === 304) {
				try {
					result = response.call(xhr, request);
				} 
				catch (e) {
					dispatch["error"].call(xhr, e);
					return;
				}
				dispatch["load"].call(xhr, result);
			} 
			else {
				dispatch["error"].call(xhr, request);
			}
	    }
	  
	    request.onprogress = function(event) {
			var o = rave.event;
			rave.event = event;
			try {
				dispatch["progress"].call(xhr, request);
			}
			finally {
				rave.event = o; 
			}
	    };
		  
	    /** @expose */
	    xhr.header = function(name, value) {
			name = (name + "").toLowerCase();
			if (arguments.length < 2) { 
				return headers[name];
			}
			if (value == null){ 
				delete headers[name];
			}
			else { 
				headers[name] = value + "";
			}
			return xhr;
	    };
		  
	    // If mimeType is non-null and no Accept header is set, a default is used.
	    /** @expose */
		xhr.mimeType = function(value) {
			if (!arguments.length) { 
				return mimeType;
			}
			mimeType = value == null ? null : value + "";
			return xhr;
		};
	
		// Specifies what type the response value should take;
		// for instance, arraybuffer, blob, document, or text.
		/** @expose */
		xhr.responseType = function(value) {
			if (!arguments.length) { 
				return responseType;
			}
			responseType = value;
			return xhr;
		};
	
		// Specify how to convert the response content to a specific type;
		// changes the callback value on "load" events.
		/** @expose */
		xhr.response = function(value) {
			response = value;
			return xhr;
		};
	
		/** @expose */
		xhr.get = function() {
			return xhr.send.apply(xhr, ["get"].concat([].slice.call(arguments)));
		};
		
		/** @expose */
		xhr.post = function() {
			return xhr.send.apply(xhr, ["post"].concat([].slice.call(arguments)));
		};
	
		// If callback is non-null, it will be used for error and load events.
		/** @expose */
		xhr.send = function(method, data, callback) {
			if (arguments.length === 2 && typeof data === "function") { 
				callback = data, data = null;
			}
			request.open(method, url, true);
			if (mimeType != null && !("accept" in headers)) {
				headers["accept"] = mimeType + ",*/*";
			}
			if (request.setRequestHeader) {
				for (var name in headers) {
					request.setRequestHeader(name, headers[name]);
				}
			}
			if (mimeType != null && request.overrideMimeType) {
				request.overrideMimeType(mimeType);
			}
			if (responseType != null) {
				request.responseType = responseType;
			}
			if (callback != null) {
				xhr.on("error", callback)
					.on("load", function(request) { 
						callback(null, request); 
					});
			}
			dispatch["beforesend"].call(xhr, request);
			request.send(data == null ? null : data);
			return xhr;
		};
		
		/** @expose */
		xhr.abort = function() {
			request.abort();
			return xhr;
		};
	
		// rebind
		/** @expose */
		xhr.on = function() {
			dispatch.on.apply(dispatch, arguments);
			return this;
		};
		
		return callback == null ? xhr : xhr.get(fixCallback(callback));
	};
	
	function fixCallback(callback) {
		return callback.length === 1 
				? function(error, request) { 
					callback(error == null ? request : null);
				}
				: callback;
	}
	
	function hasResponse(request) {
		var type = request.responseType;
		return type && type !== "text"
			? request.response // null on error
			: request.responseText; // "" on error
	}
	
	var Xhr = function(response) {
		return function(url, mimeType, callback) {
			if (arguments.length === 2 && typeof mimeType === "function") {
				callback = mimeType, mimeType = null;
			}
			return rave_xhr(url, mimeType, response, callback);
		};
	};
		
	Xhr.create = rave_xhr;
	return Xhr;
})();

// $source: com/ibm/rave/core/nativeImpl/Declare
/************************************************************************
** IBM Confidential
**
** IBM Business Analytics: Rapidly Adaptive Visualization Engine
**
** (C) Copyright IBM Corp. 2013, 2015
**
** The source code for this program is not published or otherwise divested of its trade secrets, 
** irrespective of what has been deposited with the U.S. Copyright Office.
************************************************************************/

// @import com/ibm/rave/core/nativeImpl/Object

var com_ibm_rave_core_nativeImpl_Declare = (function() {
	
	// must implement methods:
	// - extend(Object prop, Array classes)
	// - impelment(Array classes)
	// - create(Object cls, arguments args);
	// - prototype.isInstanceOf(Object cls);

	// use a faster more tailored version of declare
	
	// utility constructor
	var xConstructor = function(){};
	
	var mixin = com_ibm_rave_core_nativeImpl_Object.mixin;
	var subclass = {}.__proto__ ?
			function(object, prototype) {
				object.__proto__ = prototype;
			} : mixin;
	
	var bind;
	if (Function.prototype.bind) {
		bind = function(ctx, fnc) {
			return fnc.bind(ctx);
		};
	} else {
		bind = function(ctx, fnc) {
			return function() {
				return fnc.apply(ctx, arguments);
			};
		}
	}
	
	function createConstructor(prop, prototype, extend, fc, ctorReturnsValue, isArray) {
		var cls;
		
		// create the class constructor depending on whether delegation to
		// a super and/or this constructor is necessary
		var newConstructor = prop && prop.hasOwnProperty("constructor") ? prop.constructor : null;
		var superConstructor = extend && extend !== com_ibm_rave_core_nativeImpl_Object ? prototype.constructor : null;
		if (superConstructor && superConstructor._$defaultConstructor) {
			// ignore calling an empty super constructor
			superConstructor = null;
		}
		if (newConstructor) {
			if (superConstructor) {
				if (ctorReturnsValue) {
					cls = function() {
						var x = superConstructor.apply(this, arguments);
						newConstructor.apply(x, arguments);
						return x;
					};
				} else if (fc) {
					cls = function() {
						var x = fc.call();
						mixin(x, this);
						superConstructor.apply(x, arguments);
						newConstructor.apply(x, arguments);
						return x;
					};
				} else {
					cls = function() {
						superConstructor.apply(this, arguments);
						newConstructor.apply(this, arguments);
					};
				}
			} else {
				if (fc) {
					cls = function() {
						var x = fc.call();
						mixin(x, this);
						newConstructor.apply(x, arguments);
						return x;
					};
				} else if (isArray) {
					cls = function() {
						var x = [];
						subclass(x, this);
						newConstructor.apply(x, arguments);
						return x;
					};
				} else {
					cls = newConstructor;
				}
			}
		} else {
			if (superConstructor) {
				if (ctorReturnsValue) {
					cls = function() {
						return superConstructor.apply(this, arguments);
					};
				} else if (fc) {
					cls = function() {
						var x = fc.call();
						mixin(x, this);
						superConstructor.apply(x, arguments);
						return x;
					};
				} else {
					cls = function() {
						superConstructor.apply(this, arguments);
					};
				}
			} else {
				if (fc) {
					cls = function() {
						var x = fc.call();
						mixin(x, this);
						return x;
					};
				} else if (isArray) {
					cls = function() {
						var x = [];
						subclass(x, this);
						return x;
					};
				} else {
					cls = function(){};
					cls._$defaultConstructor = true;
				}
			}
		}
		return cls;
	}
	
	function initProperties(prop, prototype, realConstructor, ctorReturnsValue) {
		function initBindings(ctx) {
			for (var i = 0, len = bindingsArray.length; i < len; i++) {
				ctx[bindingsArray[i]] = bind(ctx, bindings[bindingsArray[i]]);
			}
		}
		
		var bindings, bindingsArray,
			cls = realConstructor;
		
		// copy properties
		mixin(prototype, prop);
		
		for (var i in prop) {
			if (typeof prop[i] === "function") {
				// bind functions
				if (prop[i]._$bind) {
					if (!bindings) {
						bindings = {};
						bindingsArray = [];
					}
					bindingsArray.push(i);
					bindings[i] = prop[i];
				}
			}
		}
		if (bindings) {
			// add another indirection to the constructor in order to bind functions
			if (cls._$defaultConstructor) {
				cls = function() {
					initBindings(this);
				};
			} else {
				if (ctorReturnsValue) {
					cls = function() {
						var x = realConstructor.apply(this, arguments);
						initBindings(x);
						return x;
					};
				} else {
					cls = function() {
						realConstructor.apply(this, arguments);
						initBindings(this);
					}
				}
			}
		}
		return cls;
	}
	
	// assign the declare function directly to the return value
	var ret = function(_classes, _prop) {
		var classes = _classes, prop = _prop;
		var cls, extend, interfaces, f, fc, extendsFunctionClass, prototype;
		
		// crack parameters
		if (arguments.length == 1) {
			// must be properties
			prop = classes;
			classes = undefined;
		}
		
		if (classes) {
			// force classes to be an array
			if (typeof classes !== "array" && !(classes instanceof Array)) {
				classes = [classes];
			}
			if (classes.length == 0) {
				extend = com_ibm_rave_core_nativeImpl_Object;
			} else if (!classes[0]._$isInterface) {
				extend = classes[0];
				if (classes.length > 1) {
					classes.shift();
					interfaces = classes;
				}
				extendsFunctionClass = extend._$type == 2;
			} else {
				extend = com_ibm_rave_core_nativeImpl_Object;
				interfaces = classes;
			}
		} else {
			extend = com_ibm_rave_core_nativeImpl_Object;
		}
		
		if (!extendsFunctionClass) {
			fc = prop && prop._$functionClassMethod;
		}
		var type = extend == Array ? 1 : extendsFunctionClass || fc ? 2 : +extend._$type; 
		if (type == 1) {
			prototype = [];
			if (extend != Array) {
				// we need to mixin the super prototype into this prototype
				mixin(prototype, extend.prototype);
			} else {
				extend = null;
			}
		} else {
			// construct the prototype from the class to extend
			xConstructor.prototype = extend.prototype;
			prototype = new xConstructor;
			xConstructor.prototype = null;
		}
		
		cls = createConstructor(prop, prototype, extend, fc, !fc && !!type, type == 1);
		
		if (prop) {
			cls = initProperties(prop, prototype, cls, !!type);
		}
		
		// assign the class to be the constructor
		prototype.constructor = cls;
		
		// assign meta data
		//cls._$functionClass = !!fc;
		cls._$type = type;
		cls["_$superClass"] = extend;
		cls._$interfaces = interfaces && interfaces.length > 0 ? interfaces : null;

		// assign the prototype
		cls.prototype = prototype;
		
		return cls;
	};
	
	/*
	 * Like declare, but declares an interface. Interfaces are used for instanceof checking
	 * and can have static properties but there's no point in including interfaces in the prototype
	 * chain of a class as it will add time to constructor chaining.
	 */
	/** @expose */
	ret.implement = function(classes) {
		// crack parameters
		if (arguments.length == 1) {
			// must be properties
			classes = undefined;
		}
		
		// force classes to be an array
		if (classes && typeof classes !== "array" && !(classes instanceof Array)) {
			classes = [classes];
		}
		
		// assumes all classes are interfaces
		var cls = function(){};
		cls._$isInterface = true;
		cls._$interfaces = classes && classes.length > 0 ? classes : null;
		return cls;
	};
	
	/*
	 * Create a new instance of the given class passing args to the constructor.
	 */ 
	/** @expose */
	ret.create = function(cls, args) {
		xConstructor.prototype = cls.prototype;
		var t = new xConstructor;
		xConstructor.prototype = null;// clean up
		cls.apply(t, args);
		return t;
	};
   
	/*
	 * Flags this function to be bound during object construction.
	 */
	/** @expose */
	ret.bind = function(fnc) {
		fnc._$bind = 1;
		return fnc;
	};
	
	// this instanceof check iterates over the implemented interfaces
	/** @expose */
	com_ibm_rave_core_nativeImpl_Object.prototype.isInstanceOf = function() {
		var checkInterfaces = function(obj, cls) {
			var interfaces = obj._$interfaces;
			if (interfaces) {
				for (var i = 0, len = interfaces.length; i < len; i++) {
					if (interfaces[i] === cls || checkInterfaces(interfaces[i], cls)) {
						return true;
					}
				}
			}
			if (obj["_$superClass"]) {
				return checkInterfaces(obj["_$superClass"], cls);
			}
			return false;
		};
		
		return function(cls) {
			if (this instanceof cls) {
				return true;
			}
			return checkInterfaces(this.constructor, cls);
		};
	}();
	
	return ret;
})();

// $source: com/ibm/rave/core/transform/Transform
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/transform/Matrix (runtime) // new
//@import com/ibm/rave/core/transform/MatrixUtil (runtime) // identity
/**
 * Parses the given 2D affine transform string, as defined by SVG's transform attribute. The transform is then decomposed to a standard representation of translate, rotate, x-skew and scale.  This behavior is standardized by CSS: see matrix decomposition for animation.
 */
var com_ibm_rave_core_transform_Transform = rave_externs["Transform"] = com_ibm_rave_core_nativeImpl_Declare({

	//m : null,

	/** @expose */ 
	translate : null,

	/** @expose */ 
	scale : null,

	kx : 0,

	ky : 0,

	kz : 0,

	/** @expose */ 
	rotate : 0,

	/** @expose */ 
	skew : 0,

	/** @expose */ 
	constructor : function(m0) {
		if (m0) {
			this.m = new com_ibm_rave_core_transform_Matrix(m0.a, m0.b, m0.c, m0.d, m0.e, m0.f);
		} else {
			this.m = com_ibm_rave_core_transform_MatrixUtil.identity();
		}
		var r0 = [];
		r0[0] = this.m.a;
		r0[1] = this.m.b;
		var r1 = [];
		r1[0] = this.m.c;
		r1[1] = this.m.d;
		this.kx = this.transformNormalize(r0);
		this.kz = this.transformDot(r0, r1);
		this.ky = this.transformNormalize(this.transformCombine(r1, r0, -this.kz));
		if (this.m.a * this.m.d < this.m.c * this.m.b) {
			this.m.a *= -1;
			this.m.b *= -1;
			this.kx *= -1;
			this.kz *= -1;
		}
		this.translate = this.getTranslation();
		this.rotate = this.getRotation();
		this.skew = this.getSkew();
		this.scale = this.getScale();
	},

	/**
	 * Returns the rotation angle θ of this transform, in degrees.
	 */
	getRotation : function() {
		var rotateResult;
		if (this.kx != 0) {
			rotateResult = Math.atan2(this.m.b, this.m.a);
		} else {
			rotateResult = Math.atan2(-this.m.c, this.m.d);
		}
		return rotateResult * 57.29577951308232;
	},

	/**
	 * Returns the [dx, dy] translation of this transform, as a two-element array in local coordinates (typically pixels).
	 */
	getTranslation : function() {
		return [this.m.e, this.m.f];
	},

	/**
	 * Returns the [kx, ky] scale of this transform, as a two-element array.
	 */
	getScale : function() {
		var list = [];
		list[0] = this.kx;
		list[1] = this.ky;
		return list;
	},

	/**
	 * Returns the x-skew φ of this transform, in degrees.
	 */
	getSkew : function() {
		var skewResult;
		if (this.ky != 0) {
			skewResult = Math.atan2(this.kz, this.ky) * 57.29577951308232;
		} else {
			skewResult = 0.0;
		}
		return skewResult;
	},

	/**
	 * Returns a string representation of this transform, in the form "translate(dx,dy)rotate(θ)skewX(φ)scale(kx,ky)".
	 */
	/** @expose */ 
	toString : function() {
		return "translate(" + this.translate[0] + "," + this.translate[1] + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale[0] + "," + this.scale[1] + ")";
	},

	/**
	 * Dot product of the passed in arrays
	 * @param (double[]) a
	 * @param (double[]) b
	 * @return (double)
	 */
	transformDot : function(a, b) {
		return a[0] * b[0] + a[1] * b[1];
	},

	/**
	 * Normalize the passed in array
	 * @param (double[]) r
	 * @return (double)
	 */
	transformNormalize : function(r) {
		var k = Math.sqrt(this.transformDot(r, r));
		if (k != 0) {
			r[0] /= k;
			r[1] /= k;
		}
		return k;
	},

	/**
	 * @param (double[]) a  Contains the 'a' and 'b' values from the passed in Matrix
	 * @param (double[]) b  Contains the 'c' and 'd' values from the passed in Matrix
	 * @param (double) k  Negative kz value (result from transformDot of a[] and b[] params)
	 * @return (double[])
	 */
	transformCombine : function(a, b, k) {
		a[0] += k * b[0];
		a[1] += k * b[1];
		return a;
	}
});


// $source: com/ibm/rave/core/transform/Matrix
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
/**
 * A matrix transform representation. Mimics an SVGMatrix. <pre> [ a  b  e ] [ x ]   [ a * x + b * y + e ] [ c  d  f ] [ y ] = [ c * x + d * y + f ] [ 0  0  1 ] [ 1 ]   [         1         ] </pre>
 */
var com_ibm_rave_core_transform_Matrix = rave_externs["Matrix"] = com_ibm_rave_core_nativeImpl_Declare({

	/** @expose */ 
	a : 0,

	/** @expose */ 
	b : 0,

	/** @expose */ 
	c : 0,

	/** @expose */ 
	d : 0,

	/** @expose */ 
	e : 0,

	/** @expose */ 
	f : 0,

	/** @expose */ 
	constructor : function(a, b, c, d, e, f) {
		this.a = a;
		this.b = b;
		this.c = c;
		this.d = d;
		this.e = e;
		this.f = f;
	},

	/**
	 * Multiply this matrix with another matrix. Returns new instance.
	 * @param (com.ibm.rave.core.transform.Matrix) matrix Matrix to multiply this matrix with.
	 * @return (com.ibm.rave.core.transform.Matrix)  New matrix that has been multiplied.
	 */
	/** @expose */ 
	multiply : function(matrix) {
		var a1 = matrix.a * this.a + matrix.b * this.c;
		var b1 = matrix.a * this.b + matrix.b * this.d;
		var c1 = matrix.c * this.a + matrix.d * this.c;
		var d1 = matrix.c * this.b + matrix.d * this.d;
		var e1 = matrix.e * this.a + matrix.f * this.c + this.e;
		var f1 = matrix.e * this.b + matrix.f * this.d + this.f;
		return new com_ibm_rave_core_transform_Matrix(a1, b1, c1, d1, e1, f1);
	},

	/**
	 * Inverse this matrix. If this matrix is not invertible, returns the identity matrix.
	 * @return (com.ibm.rave.core.transform.Matrix)  New matrix representing an inverted version of this one.
	 */
	/** @expose */ 
	inverse : function() {
		var determinant = this.a * this.d - this.b * this.c;
		if (determinant == 0) {
			return com_ibm_rave_core_transform_Matrix.identity();
		}
		var a1 = this.d / determinant;
		var b1 = -this.b / determinant;
		var c1 = -this.c / determinant;
		var d1 = this.a / determinant;
		var e1 = (this.c * this.f - this.d * this.e) / determinant;
		var f1 = (this.b * this.e - this.a * this.f) / determinant;
		return new com_ibm_rave_core_transform_Matrix(a1, b1, c1, d1, e1, f1);
	},

	/**
	 * Translate this matrix by the points x and y.
	 * @param (double) x Horizontal point to translate (move) this matrix.
	 * @param (double) y Vertical point to translate (move) this matrix.
	 * @return (com.ibm.rave.core.transform.Matrix)  New matrix with the translate transform applied.
	 */
	/** @expose */ 
	translate : function(x, y) {
		var e1 = (x * this.a + y * this.c) + this.e;
		var f1 = (x * this.b + y * this.d) + this.f;
		return new com_ibm_rave_core_transform_Matrix(this.a, this.b, this.c, this.d, e1, f1);
	},

	/**
	 * Scale this transform by scaleFactor. Applies uniformly along x and y.
	 * @param (double) scaleFactor Scale factor to apply to both dimensions.
	 * @return (com.ibm.rave.core.transform.Matrix)  New matrix with scale applied.
	 */
	/** @expose */ 
	scale : function(scaleFactor) {
		return this.scaleNonUniform(scaleFactor, scaleFactor);
	},

	/**
	 * Scale this transform using two different scale factors - one for the x dimension and one for the y.
	 * @param (double) scaleFactorX X dimension transform scale factor.
	 * @param (double) scaleFactorY Y dimension transform scale factor.
	 * @return (com.ibm.rave.core.transform.Matrix)  This matrix with non-uniform scales applied.
	 */
	/** @expose */ 
	scaleNonUniform : function(scaleFactorX, scaleFactorY) {
		var a1 = this.a * scaleFactorX;
		var b1 = this.b * scaleFactorX;
		var c1 = this.c * scaleFactorY;
		var d1 = this.d * scaleFactorY;
		return new com_ibm_rave_core_transform_Matrix(a1, b1, c1, d1, this.e, this.f);
	},

	/**
	 * Apply a rotate transform to this matrix by a number of degrees.
	 * @param (double) angle The number of degrees to rotate this matrix by. May be negative.
	 * @return (com.ibm.rave.core.transform.Matrix)  New matrix with a rotate transform applied.
	 */
	rotate$0 : function(angle) {
		var rads = com_ibm_rave_core_transform_Matrix.degreesToRadians(angle);
		var sin = Math.sin(rads);
		var cos = Math.cos(rads);
		return this.multiply(new com_ibm_rave_core_transform_Matrix(cos, sin, -sin, cos, 0, 0));
	},

	rotate$1 : function(angle, originX, originY) {
		return this.translate(originX, originY).rotate$0(angle).translate(-originX, -originY);
	},

	/**
	 * Performs a rotate based on a vector descibed as x,y. Effectively performs this calculation: 180 / Math.PI * Math.atan2(x,y); atan2(y, x) is the angle in radians between the x-axis of a plane and the point (x, y) on it
	 * @param (double) x The coordinate point x to get the angle from.
	 * @param (double) y The coordinate point x to get the angle from.
	 * @return (com.ibm.rave.core.transform.Matrix)  New matrix rotated the number of degrees based on atan2(y,x)
	 */
	/** @expose */ 
	rotateFromVector : function(x, y) {
		return this.rotate(com_ibm_rave_core_transform_Matrix.radiansToDegrees(Math.atan2(y, x)));
	},

	/**
	 * Apply a 'mirrored' horizontal flip on this transform matrix and return it.
	 * @return (com.ibm.rave.core.transform.Matrix)  New matrix with a (-1,1) scale applied.
	 */
	/** @expose */ 
	flipX : function() {
		return this.scaleNonUniform(-1, 1);
	},

	/**
	 * Apply a 'mirrored' vertical flip on this transform matrix and return it.
	 * @return (com.ibm.rave.core.transform.Matrix)  New matrix with a (1,-1) scale applied.
	 */
	/** @expose */ 
	flipY : function() {
		return this.scaleNonUniform(1, -1);
	},

	/**
	 * Skew this transform horizontally by an angle and return the resulting transform.
	 * @param (double) angle The angle by which to skew horizontally.
	 * @return (com.ibm.rave.core.transform.Matrix)  New matrix with horizontal skew applied.
	 */
	/** @expose */ 
	skewX : function(angle) {
		return this.skew(angle, 0);
	},

	/**
	 * Skew this transform vertically by an angle and return the resulting transform.
	 * @param (double) angle The angle by which to skew vertically.
	 * @return (com.ibm.rave.core.transform.Matrix)  This matrix with vertical skew applied.
	 */
	/** @expose */ 
	skewY : function(angle) {
		return this.skew(0, angle);
	},

	/**
	 * Skew this transform horizontally and vertically by two angles and return the resulting transform. Note that this is not public API. Must use skewX and skewY.
	 * @param (double) horizontalAngle The angle by which to skew horizontally.
	 * @param (double) verticalAngle The angle by which to skew vertically.
	 * @return (com.ibm.rave.core.transform.Matrix)  This matrix with skew applied.
	 */
	skew : function(horizontalAngle, verticalAngle) {
		var newMatrix = com_ibm_rave_core_transform_Matrix.identity();
		newMatrix.c = Math.tan(com_ibm_rave_core_transform_Matrix.degreesToRadians(horizontalAngle));
		newMatrix.b = Math.tan(com_ibm_rave_core_transform_Matrix.degreesToRadians(verticalAngle));
		return this.multiply(newMatrix);
	},

	/** @expose */ 
	toString : function() {
		return "matrix(" + this.a + ',' + this.b + ',' + this.c + ',' + this.d + ',' + this.e + ',' + this.f + ')';
	},

	/** @expose */ 
	rotate : function(a0, a1, a2) {
		var args = arguments;
		if (args.length == 1) {
			return this.rotate$0(a0);
		}
		return this.rotate$1(a0, a1, a2);
	}
});

/**
 * Return the identity matrix of (1,0,0,1,0,0);
 * @return (com.ibm.rave.core.transform.Matrix)  New instance of an identity matrix.
 */
com_ibm_rave_core_transform_Matrix.identity = function() {
	return new com_ibm_rave_core_transform_Matrix(1, 0, 0, 1, 0, 0);
};

com_ibm_rave_core_transform_Matrix.radiansToDegrees = function(rads) {
	return rads * 180 / Math.PI;
};

com_ibm_rave_core_transform_Matrix.degreesToRadians = function(angle) {
	return angle * Math.PI / 180;
};


// $source: com/ibm/rave/core/geom/PointStruct
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
var com_ibm_rave_core_geom_PointStruct = rave_externs["PointStruct"] = com_ibm_rave_core_nativeImpl_Declare({

	/** @expose */ 
	x : 0,
	/** @expose */ 
	y : 0,

	/** @expose */ 
	constructor : function(x, y) {
		this.x = x;
		this.y = y;
	}
});


// $source: com/ibm/rave/core/geom/RectStruct
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
var com_ibm_rave_core_geom_RectStruct = rave_externs["RectStruct"] = com_ibm_rave_core_nativeImpl_Declare({

	/** @expose */ 
	x : 0,
	/** @expose */ 
	y : 0,
	/** @expose */ 
	width : 0,
	/** @expose */ 
	height : 0,

	/** @expose */ 
	constructor : function(x, y, width, height) {
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
	}
});


// $source: com/ibm/rave/core/transform/MatrixUtil
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/geom/PointStruct (static) // new
//@import com/ibm/rave/core/geom/RectStruct (static) // new
//@import com/ibm/rave/core/transform/Matrix (static) // new
/**
 * Helper utilities for matrix transforms. Anything not in the SVGMatrix interface should be made a helper here.
 */
var com_ibm_rave_core_transform_MatrixUtil = rave_externs["MatrixUtil"] = {

	//constructor : function() {}
};

/**
 * Perform matrix multiplication on a set of points where odd values map to X coordinates and even values map to Y coordinates. Modifies points in place.
 * @param (double[]) points The array of points to multiply.
 * @param (com.ibm.rave.core.transform.Matrix) matrix The matrix to apply.
 */
/** @expose */ 
com_ibm_rave_core_transform_MatrixUtil.mapPoints = function(points, matrix) {
	var x, y;
	for (var i = 0, len = points.length; i < len; i += 2) {
		x = com_ibm_rave_core_transform_MatrixUtil.multiplyX(matrix, points[i], points[i + 1]);
		y = com_ibm_rave_core_transform_MatrixUtil.multiplyY(matrix, points[i], points[i + 1]);
		points[i] = x;
		points[i + 1] = y;
	}
};

/**
 * Internal method to create a new matrix object.
 * @param (double) a
 * @param (double) b
 * @param (double) c
 * @param (double) d
 * @param (double) e
 * @param (double) f
 * @return (com.ibm.rave.core.transform.Matrix)
 */
/** @expose */ 
com_ibm_rave_core_transform_MatrixUtil.create = function(a, b, c, d, e, f) {
	var matrix = com_ibm_rave_core_transform_MatrixUtil.identity();
	matrix.a = a;
	matrix.b = b;
	matrix.c = c;
	matrix.d = d;
	matrix.e = e;
	matrix.f = f;
	return matrix;
};

/**
 * Transform a point by this transform.
 * @param (com.ibm.rave.core.geom.PointStruct) point Point to transform
 * @param (com.ibm.rave.core.transform.Matrix) matrix Matrix to combine this point with.
 * @return (com.ibm.rave.core.geom.PointStruct) new instance of a point that has been transformed.
 */
com_ibm_rave_core_transform_MatrixUtil.transformPoint = function(point, matrix) {
	var x = com_ibm_rave_core_transform_MatrixUtil.multiplyX(matrix, point.x, point.y);
	var y = com_ibm_rave_core_transform_MatrixUtil.multiplyY(matrix, point.x, point.y);
	return new com_ibm_rave_core_geom_PointStruct(x, y);
};

com_ibm_rave_core_transform_MatrixUtil.multiplyX = function(matrix, x, y) {
	return x * matrix.a + y * matrix.c + matrix.e;
};

com_ibm_rave_core_transform_MatrixUtil.multiplyY = function(matrix, x, y) {
	return x * matrix.b + y * matrix.d + matrix.f;
};

/**
 * Transform the four corners of a rectangle and extend the original bounds so they encapsulate the transformed rect. Returns a new RectStruct.
 * @param (com.ibm.rave.core.geom.RectStruct) rect Rectangle to transform.
 * @param (com.ibm.rave.core.transform.Matrix) matrix Matrix to apply to rectangle transform.
 * @return (com.ibm.rave.core.geom.RectStruct) New RectStruct with the new bounds encapsulating the transformed rect.
 */
/** @expose */ 
com_ibm_rave_core_transform_MatrixUtil.transformBounds = function(rect, matrix) {
	var minX = Infinity;
	var minY = Infinity;
	var maxX = -Infinity;
	var maxY = -Infinity;
	for (var __i_enFor0 = 0, __exp_enFor0 = com_ibm_rave_core_transform_MatrixUtil.transformCorners(rect, matrix), __len_enFor0 = __exp_enFor0.length;
			__i_enFor0 < __len_enFor0; ++__i_enFor0) {
		var point = __exp_enFor0[__i_enFor0];
		minX = Math.min(minX, point.x);
		maxX = Math.max(maxX, point.x);
		minY = Math.min(minY, point.y);
		maxY = Math.max(maxY, point.y);
	}
	return new com_ibm_rave_core_geom_RectStruct(minX, minY, maxX - minX, maxY - minY);
};

/**
 * Transform the four corners of a RectStruct based on a transform matrix. Returns new RaveRect.
 * @param (com.ibm.rave.core.geom.RectStruct) rect Rectangle to transform
 * @param (com.ibm.rave.core.transform.Matrix) matrix Matrix to combine this rect with.
 * @return (Array) List of 4 corner points that have been transformed.
 */
com_ibm_rave_core_transform_MatrixUtil.transformCorners = function(rect, matrix) {
	var corners = [];
	corners.push(new com_ibm_rave_core_geom_PointStruct(rect.x, rect.y));
	corners.push(new com_ibm_rave_core_geom_PointStruct(rect.x + rect.width, rect.y));
	corners.push(new com_ibm_rave_core_geom_PointStruct(rect.x, rect.y + rect.height));
	corners.push(new com_ibm_rave_core_geom_PointStruct(rect.x + rect.width, rect.y + rect.height));
	return com_ibm_rave_core_transform_MatrixUtil.transformPoints(corners, matrix);
};

com_ibm_rave_core_transform_MatrixUtil.transformPoints = function(points, matrix) {
	var transformedPoints = [];
	for (var __i_enFor0 = 0, __exp_enFor0 = points, __len_enFor0 = __exp_enFor0.length;
			__i_enFor0 < __len_enFor0; ++__i_enFor0) {
		var point = __exp_enFor0[__i_enFor0];
		transformedPoints.push(com_ibm_rave_core_transform_MatrixUtil.transformPoint(point, matrix));
	}
	return transformedPoints;
};

/**
 * Create a an identity (initial) matrix.
 * @return (com.ibm.rave.core.transform.Matrix) identity matrix
 */
/** @expose */ 
com_ibm_rave_core_transform_MatrixUtil.identity = function() {
	return new com_ibm_rave_core_transform_Matrix(1, 0, 0, 1, 0, 0);
};

/**
 * Checks if the given matrix is an identity matrix.
 * @param (com.ibm.rave.core.transform.Matrix) m the matrix to check
 * @return (boolean)  <code>true</code> if the given matrix is an identity matrix, <code>false</code> otherwise
 */
/** @expose */ 
com_ibm_rave_core_transform_MatrixUtil.isIdentityMatrix = function(m) {
	return m.a == 1 && m.b == 0 && m.c == 0 && m.d == 1 && m.e == 0 && m.f == 0;
};


// $source: com/ibm/rave/core/nativeImpl/math/TransformParser
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2014, 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/

//@import com/ibm/rave/core/transform/Transform
//@import com/ibm/rave/core/internal/util/NamespaceUtil
var com_ibm_rave_core_nativeImpl_math_TransformParser= (function() {
	var g = null;
	if (rave_document) {
		g = rave_document.createElementNS(com_ibm_rave_core_internal_util_NamespaceUtil.NAMESPACES.svg,"g");
	}
	function myfunc(string) {
		if(string != null && g != null){
			g.setAttribute("transform", string);
			var t = g.transform.baseVal.consolidate();
			
		}
		return new com_ibm_rave_core_transform_Transform(t ? t.matrix : null);
	
	};

	return {create: myfunc};
})();

// $source: com/ibm/rave/core/selector/Selection
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
/**
 * The common interface for selections and transitions. Selections have attributes and functions applied immediately, while transitions have attributes and functions applied over time. This interface is generic with a self-reference to support use of the {@link this.Selection#this.call(com_ibm_rave_core_selector_RunFunction, Object...)}  method.
 * @param < (Object) T > The concrete selection implementation type, e.g. Selector.
 */
var com_ibm_rave_core_selector_Selection = rave_externs["Selection"] = com_ibm_rave_core_nativeImpl_Declare(Array, {

	attr$0 : function(value) {
		for (var __i_enFor0 = 0, __exp_enFor0 = Object.keys(value), __len_enFor0 = __exp_enFor0.length;
				__i_enFor0 < __len_enFor0; ++__i_enFor0) {
			var key = __exp_enFor0[__i_enFor0];
			var v = value[key];
			if (typeof v === "function") {
				this.attr$2(key, v);
			} else {
				this.attr$1(key, value[key]);
			}
		}
		return this;
	},

	/**
	 * Invokes the specified function once with this selection as the context.
	 * @param (com.ibm.rave.core.selector.RunFunction) callback the function to callback, must be annotated as {@link (com.ibm.rave.codegenerator.annotations.FunctionClass) FunctionClass}
	 * @param (java.lang.Object[]) args optional arguments to pass to the call function
	 * @return (Object)  this selection
	 */
	/** @expose */ 
	call : function(callback, args) {},

	/**
	 * Execute the callback for each  {@link (com.ibm.rave.core.scene.SceneNode) SceneNode}  in the selection.
	 * @param (com.ibm.rave.core.selector.CallbackFunction) callback the callback to run
	 * @return (Object)  this selection
	 */
	/** @expose */ 
	each : function(callback) {},

	/**
	 * Is the current selection empty.
	 * @return (boolean)  <code>true</code> if selection is empty, <code>false> otherwise
	 */
	/** @expose */ 
	empty : function() {
		return !this.node();
	},

	/**
	 * Remove the selected matches from this selection. Returns the resulting selection.
	 * @return (Object)  this selection
	 */
	/** @expose */ 
	remove : function() {},

	/**
	 * Return the current number of matches in this selection.
	 * @return (int)  Current number of matches.
	 */
	/** @expose */ 
	size : function() {
		var count = 0;
		for (var j = 0, m = this.length; j < m; ++j) {
			var group = this[j];
			for (var i = 0, n = group.length; i < n; ++i) {
				if (group[i]) {
					count++;
				}
			}
		}
		return count;
	},

	style$0 : function(value) {
		return this.style$1(value, null);
	},

	style$1 : function(value, priority) {
		for (var __i_enFor0 = 0, __exp_enFor0 = Object.keys(value), __len_enFor0 = __exp_enFor0.length;
				__i_enFor0 < __len_enFor0; ++__i_enFor0) {
			var key = __exp_enFor0[__i_enFor0];
			this.style$4(key, value[key], priority);
			var v = value[key];
			if (typeof v === "function") {
				this.style$5(key, v, priority);
			} else {
				this.style$4(key, v, priority);
			}
		}
		return this;
	},

	/**
	 * @return (boolean)  true if this selector is a transition, false otherwise
	 */
	/** @expose */ 
	isTransition : function() {},

	/**
	 * Return the first scene node contained in the current selection. May return null if there are matched selections.
	 */
	/** @expose */ 
	node : function() {
		for (var j = 0, m = this.length; j < m; ++j) {
			var group = this[j];
			for (var i = 0, n = group.length; i < n; ++i) {
				var node = group[i];
				if (node) {
					return node;
				}
			}
		}
		return null;
	},

	/** @expose */ 
	attr : function(a0, a1) {
		var args = arguments;
		if (args.length == 1) {
			return this.attr$0(a0);
		}
		if (args.length == 2 && (a0 == null || typeof a0 === "string") && typeof a1 === "function") {
			return this.attr$2(a0, a1);
		}
		return this.attr$1(a0, a1);
	},

	/** @expose */ 
	style : function(a0, a1, a2) {
		var args = arguments;
		if (args.length == 1) {
			return this.style$0(a0);
		}
		if (args.length == 2 && (a0 == null || typeof a0 === "string") && typeof a1 === "function") {
			return this.style$3(a0, a1);
		}
		if (args.length == 2 && (a0 == null || typeof a0 === "string") && (a1 == null || Object.prototype.toString.call(a1) !== "[object Array]")) {
			return this.style$2(a0, a1);
		}
		if (args.length == 2) {
			return this.style$1(a0, a1);
		}
		if (args.length == 3 && (a0 == null || typeof a0 === "string") && typeof a1 === "function" && (a2 == null || typeof a2 === "string")) {
			return this.style$5(a0, a1, a2);
		}
		return this.style$4(a0, a1, a2);
	},

	/** @expose */ 
	text : function(a0) {
		var args = arguments;
		if (args.length == 1 && typeof a0 === "function") {
			return this.text$1(a0);
		}
		return this.text$0(a0);
	},

	/** @expose */ 
	select : function(a0) {
		var args = arguments;
		if (args.length == 1 && typeof a0 === "function") {
			return this.select$1(a0);
		}
		return this.select$0(a0);
	},

	/** @expose */ 
	selectAll : function(a0) {
		var args = arguments;
		if (args.length == 1 && (a0 == null || typeof a0 === "string")) {
			return this.selectAll$0(a0);
		}
		return this.selectAll$1(a0);
	},

	/** @expose */ 
	filter : function(a0) {
		var args = arguments;
		if (args.length == 1 && typeof a0 === "function") {
			return this.filter$0(a0);
		}
		return this.filter$1(a0);
	},

	/** @expose */ 
	transition : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.transition$0();
		}
		return this.transition$1(a0);
	}

	/**
	 * Sets the value for the requested attribute for each  {@link (com.ibm.rave.core.scene.SceneNode) SceneNode}  in this selection.
	 * @param (String) attribute String attribute name.
	 * @param (Object) value Value for attribute.
	 * @return (Object)  this selection
	 */
	//attr$1 : function(attribute, value) {},

	/**
	 * Sets the passed attribute for each match in this selection based on value returned from the passed function . Passes in optional data associated with this selector.
	 * @param (String) attribute String attribute name to set.
	 * @param (com.ibm.rave.core.selector.ValueFunction) valueFunction "anonymous" function class to be executed for each attribute. In JavaScript, this will be translated into an actual anonymous function.
	 * @return (Object)  this selection
	 */
	//attr$2 : function(attribute, valueFunction) {},

	/**
	 * Sets the value for the requested style for each  {@link (com.ibm.rave.core.scene.SceneNode) SceneNode}  in this selection.
	 * @param (String) styleName String style name.
	 * @param (Object) value Value for attribute.
	 * @return (Object)  this selection
	 */
	//style$2 : function(styleName, value) {},

	/**
	 * Sets the value for the requested style for each  {@link (com.ibm.rave.core.scene.SceneNode) SceneNode}  in this selection.
	 * @param (String) styleName String style name.
	 * @param (com.ibm.rave.core.selector.ValueFunction) valueFunction "anonymous" function class to be executed for each attribute. In JavaScript, this will be translated into an actual anonymous function.
	 * @return (Object)  this selection
	 */
	//style$3 : function(styleName, valueFunction) {},

	/**
	 * Sets the value for the requested style for each  {@link (com.ibm.rave.core.scene.SceneNode) SceneNode}  in this selection.
	 * @param (String) styleName String style name.
	 * @param (Object) value Value for attribute.
	 * @param (String) priority the style priority (i.e., "important")
	 * @return (Object)  this selection
	 */
	//style$4 : function(styleName, value, priority) {},

	/**
	 * Sets the value for the requested style for each  {@link (com.ibm.rave.core.scene.SceneNode) SceneNode}  in this selection.
	 * @param (String) styleName String style name.
	 * @param (com.ibm.rave.core.selector.ValueFunction) valueFunction "anonymous" function class to be executed for each attribute. In JavaScript, this will be translated into an actual anonymous function.
	 * @param (String) priority the style priority (i.e., "important")
	 * @return (Object)  this selection
	 */
	//style$5 : function(styleName, valueFunction, priority) {},

	/**
	 * Sets the text content for each  {@link (com.ibm.rave.core.scene.SceneNode) SceneNode}  in this selection.
	 * @param (Object) value The text content.
	 * @return (Object)  this selection
	 */
	//text$0 : function(value) {},

	/**
	 * Sets the text content for each  {@link (com.ibm.rave.core.scene.SceneNode) SceneNode}  in this Selector.
	 * @param (com.ibm.rave.core.selector.ValueFunction) valueFunction "anonymous" function class to be executed for each text. In JavaScript, this will be translated into an actual anonymous function.
	 * @return (Object)  this selection
	 */
	//text$1 : function(valueFunction) {},

	/**
	 * Return a new selection based on 'query', only returning the first match. Also creates a new single data entry for the selection and sets the parent node for the next set of matches.
	 * @param (Object) query CSS3 Selection query syntax.
	 * @return (Object)  a new selection.
	 */
	//select$0 : function(query) {},

	/**
	 * Return a new selection based on the nodes returned by the value function. Also creates a new single data entry for the selection and sets the parent node for the next set of matches.
	 * @param (com.ibm.rave.core.selector.ValueFunction) valueFunction
	 * @return (Object)  a new selection.
	 */
	//select$1 : function(valueFunction) {},

	/**
	 * Return a single new selection based on 'query', returning all matches. Sets the parent node to the  {@link (com.ibm.rave.core.scene.SceneNode) SceneNode}  returned by the previous call to select(). If there was no previous selection, then set parentNode to the root.
	 * @param (String) query CSS3 Selection query syntax.
	 * @return (Object)  New selection containing new set of matches.
	 */
	//selectAll$0 : function(query) {},

	/**
	 * Return a single new selection based on the nodes returned by the value function, returning all matches. Sets the parent node to the {@link (com.ibm.rave.core.scene.SceneNode) SceneNode}  returned by the previous call to select(). If there was no previous selection, then set parentNode to the root.
	 * @param (com.ibm.rave.core.selector.ValueFunction) valueFunction
	 * @return (Object)  New selection containing new set of matches.
	 */
	//selectAll$1 : function(valueFunction) {},

	/**
	 * Return a new selection based on the filter function. To decide if a node is a match the filter method will be called and it should return true for match false for no match.
	 * @param (com.ibm.rave.core.selector.ValueFunction) filterFunction
	 * @return (Object)  the matched selection
	 */
	//filter$0 : function(filterFunction) {},

	/**
	 * Return a new selector based on the filter query selector string.
	 * @param (String) filter query selector string
	 * @return (Object)  the matched selection
	 */
	//filter$1 : function(filter) {},

	/**
	 * Create a new transition on the current selection.
	 * @return (com.ibm.rave.core.transition.Transition)  the transition
	 */
	//transition$0 : function() {},

	/**
	 * Create a new transition on the current selection with a given name.
	 * @param (String) name the transition name
	 * @return (com.ibm.rave.core.transition.Transition)  the transition
	 */
	//transition$1 : function(name) {}
});


// $source: com/ibm/rave/core/Configuration
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
var com_ibm_rave_core_Configuration = com_ibm_rave_core_nativeImpl_Declare({

	//nodeFactories : null,

	//imageSnapshotFactories : null,

	//queryEngines : null,

	//nodeExtensions : null,

	//filters : null,

	extCounter : 1,

	constructor : function() {
		this.nodeFactories = {};
		this.imageSnapshotFactories = {};
		this.queryEngines = {};
	},

	/** @expose */ 
	getSceneNodeFactory : function(nsuri) {
		return this.nodeFactories[nsuri];
	},

	/**
	 * Return an image factory associated with the given namespace
	 * @param (String) nsuri namespace associated with the image factory
	 * @return (com.ibm.rave.core.scene.ImageFactory)  a image factory registered for the given namespace
	 */
	/** @expose */ 
	getImageFactory : function(nsuri) {
		return this.imageSnapshotFactories[nsuri];
	},

	/** @expose */ 
	setSceneNodeFactory : function(nsuri, factory) {
		if (factory) {
			this.nodeFactories[nsuri] = factory;
		} else {
			delete this.nodeFactories[nsuri];
		}
	},

	/**
	 * Register image snapshot factory for the given namespace
	 * @param (String) nsuri namespace to associate with the new factory
	 * @param (com.ibm.rave.core.scene.ImageFactory) factory image factory
	 * @see (com.ibm.rave.core.scene.ImageFactory) ImageFactory
	 */
	/** @expose */ 
	setImageFactory : function(nsuri, factory) {
		if (factory) {
			this.imageSnapshotFactories[nsuri] = factory;
		} else {
			delete this.imageSnapshotFactories[nsuri];
		}
	},

	/** @expose */ 
	getQueryEngine : function(nsuri) {
		return this.queryEngines[nsuri];
	},

	/** @expose */ 
	setQueryEngine : function(nsuri, queryEngine) {
		if (queryEngine) {
			this.queryEngines[nsuri] = queryEngine;
		} else {
			delete this.queryEngines[nsuri];
		}
	},

	/** @expose */ 
	addSceneNodeExtensionFactory : function(namespaceUri, factory, priority) {
		if (!this.nodeExtensions) {
			this.nodeExtensions = {};
		}
		var list = this.nodeExtensions[namespaceUri];
		if (list) {
			if (priority <= 0) {
				list.splice(0, 0, factory);
			} else if (priority >= list.length) {
				list.push(factory);
			} else {
				list.splice(priority, 0, factory);
			}
		} else {
			list = [factory];
			this.nodeExtensions[namespaceUri] = list;
		}
		this.extCounter++;
	},

	/** @expose */ 
	removeSceneNodeExtensionFactory : function(namespaceUri, factory) {
		var list = this.nodeExtensions[namespaceUri];
		if (list) {
			var i = list.indexOf(factory);
			if (i >= 0) {
				list.splice(i, 1);
				this.extCounter++;
			}
		}
	},

	/**
	 * Extends the node if  {@link (com.ibm.rave.core.scene.SceneNodeExtensionFactory) SceneNodeExtensionFactory} s have been registered. The incoming node is returned for convenience. If the node has already been extended, this method will not apply the extensions again.
	 * @param (com.ibm.rave.core.scene.SceneNode) node the node to extend
	 * @param (com.ibm.rave.core.scene.SceneNode) context an optional context, typically the parent
	 * @return (com.ibm.rave.core.scene.SceneNode)  the scene node itself
	 */
	/** @expose */ 
	extend : function(node, context) {
		if (this.nodeExtensions) {
			var extId = node.rave_getProperty("__rave-node-ext__");
			var extend = extId == null;
			if (!extend && extId != this.extCounter) {
				node.rave_initExtensions();
			}
			if (extend) {
				node.rave_setProperty("__rave-node-ext__", this.extCounter);
				var nodeExtFactories = this.nodeExtensions[node.rave_getNamespaceURI()];
				if (nodeExtFactories) {
					var c = context ? context : node.rave_getParentNode();
					for (var __i_enFor0 = 0, __exp_enFor0 = nodeExtFactories, __len_enFor0 = __exp_enFor0.length;
							__i_enFor0 < __len_enFor0; ++__i_enFor0) {
						var extFactory = __exp_enFor0[__i_enFor0];
						extFactory(node, c);
					}
				}
			}
		}
		return node;
	},

	/**
	 * Like  {@link this.Configuration#this.extend(com_ibm_rave_core_scene_SceneNode, com_ibm_rave_core_scene_SceneNode)}  but will recurse through the node's children.
	 * @param (com.ibm.rave.core.scene.SceneNode) node the node to extend
	 * @return (com.ibm.rave.core.scene.SceneNode)  the scene node itself
	 */
	/** @expose */ 
	extendRecursive : function(node) {
		this.extend(node, null);
		if (node.rave_hasChildNodes()) {
			for (var __i_enFor0 = 0, __exp_enFor0 = node.rave_getChildNodes(), __len_enFor0 = __exp_enFor0.length;
					__i_enFor0 < __len_enFor0; ++__i_enFor0) {
				var child = __exp_enFor0[__i_enFor0];
				this.extendRecursive(child);
			}
		}
		return node;
	},

	/**
	 * Registers a filter function that can filter selection results.
	 */
	/** @expose */ 
	registerFilter : function(filterKey, filterFunction) {
		if (!this.filters) {
			this.filters = {};
		}
		this.filters[filterKey] = filterFunction;
	},

	/**
	 * Registers a filter function that can filter selection results.
	 */
	/** @expose */ 
	unregisterFilter : function(filterKey) {
		if (this.filters) {
			delete this.filters[filterKey];
		}
	},

	/**
	 * Filter a single scene node using any registered filters. Used by selectors to remove 'private' nodes from the results.
	 * @param (com.ibm.rave.core.scene.SceneNode) item SceneNode that's tested against our filter rules.
	 * @param (String) query The original selector query that got the item. Used for performing re-selections if required by the filter.
	 * @return (com.ibm.rave.core.scene.SceneNode)  The same scene node or null if this node was filtered.
	 */
	/** @expose */ 
	filter : function(item, query) {
		var result = item;
		if (this.filters && result) {
			for (var __i_enFor0 = 0, __exp_enFor0 = Object.keys(this.filters), __len_enFor0 = __exp_enFor0.length;
					__i_enFor0 < __len_enFor0; ++__i_enFor0) {
				var key = __exp_enFor0[__i_enFor0];
				var filterFunction = this.filters[key];
				result = filterFunction(item, query);
				if (!result) {
					break;
				}
			}
		}
		return result;
	},

	/**
	 * Filter an array of scene nodes using all registered filters. Used by selectors to remove 'private' nodes from the results.
	 * @param (Array) list SceneNode[] array who's elements are tested against our filter rules.
	 * @return (Array)  New array of SceneNodes that contain only those elements not filtered.
	 */
	/** @expose */ 
	filterArray : function(list) {
		if (this.filters && list) {
			var results = [];
			for (var __i_enFor0 = 0, __exp_enFor0 = list, __len_enFor0 = __exp_enFor0.length;
					__i_enFor0 < __len_enFor0; ++__i_enFor0) {
				var item = __exp_enFor0[__i_enFor0];
				for (var __i_enFor1 = 0, __exp_enFor1 = Object.keys(this.filters), __len_enFor1 = __exp_enFor1.length;
						__i_enFor1 < __len_enFor1; ++__i_enFor1) {
					var key = __exp_enFor1[__i_enFor1];
					var filterFunction = this.filters[key];
					item = filterFunction(item, null);
				}
				if (item) {
					results.push(item);
				}
			}
			return results;
		}
		return list;
	}

	//constructor : function() {}
});

//com_ibm_rave_core_Configuration.EXTENSION_KEY = "__rave-node-ext__";

/** @expose */ 
com_ibm_rave_core_Configuration.INSTANCE = new com_ibm_rave_core_Configuration();

// $source: com/ibm/rave/core/nativeImpl/arrays/ES6Map
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2014, 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// @import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare 
var com_ibm_rave_core_nativeImpl_arrays_ES6Map = rave_externs["ES6Map"] =(function() {
	
	var map_proto = "__proto__",
    	map_zero = "\0";
	
	function map_escape(key) {
		return (key += "") === map_proto || key[0] === map_zero ? map_zero + key : key;
	}

	function map_unescape(key) {
		return (key += "")[0] === map_zero ? key.slice(1) : key;
	}
	
	var Map = com_ibm_rave_core_nativeImpl_Declare({

		constructor : function() {
			this._ = Object.create(null);
		},
		
		/**
		 * Constructs a new map with the given comparator.
		 * @param (com.ibm.rave.core.internal.util.Comparator) comparator compares two data objects
		 */
		/** @expose */ 
		has: function(key) {
			return map_escape(key) in this._;
		},
		/** @expose */ 
		get: function(key) {
			return this._[map_escape(key)];
		},
		/** @expose */ 
		set: function(key, value) {
			return this._[map_escape(key)] = value;
		},
		/** @expose */ 
		remove: function(key) {
			return (key = map_escape(key)) in this._ && delete this._[key];
		},
		/** @expose */ 
		keys: function() {
			var keys = [];
			for (var key in this._) keys.push(map_unescape(key));
			return keys;
		},
		/** @expose */ 
		values: function() {
		    var values = [];
		    for (var key in this._) values.push(this._[key]);
		    return values;
		},
		/** @expose */ 
		entries: function() {
			var entries = [];
			for (var key in this._) entries.push({key: map_unescape(key), value: this._[key]});
			return entries;
		},
		/** @expose */ 
		size: function() {
			var size = 0;
			for (var key in this._) ++size;
			return size;
		},
		/** @expose */ 
		empty: function() {
			for (var key in this._) return false;
			return true;
		},
		/** @expose */ 
		forEach: function(f) {
			for (var key in this._) f.call(this, map_unescape(key), this._[key]);
		}
	});

	/**
	 * Creates a generic map
	 * @return (com.ibm.rave.core.arrays.Map) a new map
	 */
	Map.create$0 = function() {
		return new Map();
	};
	
	/**
	 * Creates a new Map from an existing Map
	 * @param (com.ibm.rave.core.arrays.Map) an existing map
	 * @return (com.ibm.rave.core.arrays.Map) a new map
	 */
	Map.create$1 = function(object) {
		var map = new Map();
		object.forEach(function(key, value) { map.set(key, value); });
		return map;
	};
	
	/**
	 * Creates a new Map from an array
	 * @param Object[] an array
	 * @return (com.ibm.rave.core.arrays.Map) a new map
	 */
	Map.create$2 = function(object) {
		var map = new Map();
		for (var key in object) map.set(key, object[key]);
		return map;
	};
	
	/** @expose */ 
	Map.create = function(a0) {
		if (arguments.length == 0) {
			return Map.create$0();
		} else if (arguments.length == 1 && (a0 instanceof Map)) {
			return Map.create$1(a0);
		}
		return Map.create$2(a0);
	};
	return Map;
})();




// $source: com/ibm/rave/core/nativeImpl/timer/Timer
/************************************************************************
** IBM Confidential
**
** IBM Business Analytics: Rapidly Adaptive Visualization Engine
**
** (C) Copyright IBM Corp. 2014, 2015
**
** The source code for this program is not published or otherwise divested of its trade secrets, 
** irrespective of what has been deposited with the U.S. Copyright Office.
************************************************************************/

// @import com/ibm/rave/core/internal/nativeImpl/Vendor

var com_ibm_rave_core_nativeImpl_timer_Timer = (function() {
	// use requestAnimationFrame if available
	// fallback to setTimeout
	var raf = global[vendorSymbol(global, "requestAnimationFrame")] || function(callback) { setTimeout(callback, 17); },
		active, qhead, qtail, sleepHandle, currentTime;
	
	function executeCallbacks(now) {
		currentTime = now;
		var sleep = Infinity,
			prev,
			item = qhead;
		
		while (item) {
			if (now >= item.time && item.callback(now - item.time)) {
				// remove item from the queue
				if (prev) {
					// set the previous next to the item next
					prev.next = item.next;
				} else {
					// since we never had a previous item
					// move the queue head pointer ahead
					qhead = item.next;
				}
			} else {
				// track previous item in queue
				prev = item;
				
				if (item.time < sleep) {
					// track the smallest time for all callbacks
					sleep = item.time;
				}
			}
			// get next item in the queue
			item = item.next;
		}
		// the previous item is always the new tail
		qtail = prev;
		return sleep;
	}
	
	function step() {
		var now = Date.now(),
			sleep = executeCallbacks(now) - now;
		
		// check if there are any items in the queue
		if (sleep > 24) {
			if (isFinite(sleep)) {
				// delay the loop as to not run the cpu needlessly
				sleepHandle = setTimeout(step, sleep);
			}
			active = 0;
		} else {
			active = 1;
			// continue the loop
			raf(step);
		}
	}
	
	var timer = function(callback, delay, start) {
		var argsLen = arguments.length;
		if (argsLen < 2) {
			delay = 0;
		}
		if (argsLen < 3) {
			start = Date.now();
		}
		
		var item = {
				callback: callback,
				// start time is based on real time
				time: delay + start
				//next: null // the next item in the queue
			};
		
		if (qtail) {
			// add item to end of queue
			qtail.next = item;
		} else {
			// set item as the head of the queue
			qhead = item;
		}
		// item is the new tail
		qtail = item;
		
		if (!active) {
			sleepHandle = clearTimeout(sleepHandle);
			active = 1;
			// begin the loop
			raf(step);
		}
	};
	
	/** @expose */
	timer.flush = function(callback, delay, duration) {
		executeCallbacks(Date.now());
	};
	
	/** @expose */
	timer.currentTime = function() {
		return currentTime;
	}
	
	return {
		/** @expose */
		INSTANCE : timer
	};
})();
// $source: com/ibm/rave/core/internal/transitions/TransitionInfo
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/ease/Easing (runtime) // Easing
//@import com/ibm/rave/core/event/Dispatcher (runtime) // create
var com_ibm_rave_core_internal_transitions_TransitionInfo = com_ibm_rave_core_nativeImpl_Declare({

	/**
	 * @expose  
	 */
	ease : null,

	/**
	 * @expose  
	 */
	tween : null,

	/**
	 * @expose  
	 */
	event : null,

	/**
	 * @expose  
	 */
	time : null,

	//node : null,

	//tracker : null,

	/**
	 * @expose  
	 */
	delay : 0,

	/**
	 * @expose  
	 */
	duration : 250,

	transitionId : 0,

	index : 0,

	groupIndex : 0,

	scheduled : false,

	constructor : function(tracker, id, node) {
		this.ease = com_ibm_rave_core_ease_Easing.DEFAULT;
		this.tween = {};
		{
			this.tracker = tracker;
			this.transitionId = id;
			this.node = node;
		}
	},

	getTransitionId : function() {
		return this.transitionId;
	},

	getTracker : function() {
		return this.tracker;
	},

	getSceneNode : function() {
		return this.node;
	},

	getOrCreateDispatcher : function() {
		if (!this.event) {
			this.event = com_ibm_rave_core_event_Dispatcher.create("start", "end", "interrupt");
		}
		return this.event;
	},

	getDispatcher : function() {
		return this.event;
	},

	setIndex : function(index) {
		this.index = index;
	},

	getIndex : function() {
		return this.index;
	},

	setGroupIndex : function(groupIndex) {
		this.groupIndex = groupIndex;
	},

	getGroupIndex : function() {
		return this.groupIndex;
	},

	setDelay : function(delay) {
		this.delay = delay;
	},

	getDelay : function() {
		return this.delay;
	},

	setDuration : function(duration) {
		this.duration = duration;
	},

	getDuration : function() {
		return this.duration;
	},

	setEase : function(ease) {
		this.ease = ease;
	},

	getEase : function() {
		return this.ease;
	},

	addTweenFactory : function(key, factory) {
		this.tween[key] = factory;
	},

	removeTweenFactory : function(key) {
		delete this.tween[key];
	},

	getTweenFactory : function(key) {
		return this.tween[key];
	},

	getTweens : function() {
		var sceneNode = this.node;
		var data = sceneNode.rave_getData();
		var i = this.index;
		var gi = this.groupIndex;
		var tweens = [];
		for (var __i_enFor0 = 0, __exp_enFor0 = Object.keys(this.tween), __len_enFor0 = __exp_enFor0.length;
				__i_enFor0 < __len_enFor0; ++__i_enFor0) {
			var key = __exp_enFor0[__i_enFor0];
			var tf = this.tween[key];
			var t = tf.call(sceneNode, data, i, gi);
			if (t) {
				tweens.push(t);
			}
		}
		return tweens;
	},

	getStartTime : function() {
		return this.time;
	},

	setStartTime : function(startTime) {
		this.time = startTime;
	},

	isScheduled : function() {
		return this.scheduled;
	},

	setScheduled : function() {
		this.scheduled = true;
	}
});


// $source: com/ibm/rave/core/ease/Easing
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
/**
 * Collection of built-in easing functions. Provides a utility to retrieve an easing function by named type.
 */
var com_ibm_rave_core_ease_Easing = com_ibm_rave_core_nativeImpl_Declare({

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * Returns a built-in easing function of the specified type, with any optional arguments. An easing function takes the current parameterized time value t in the domain [0,1], and maps it to another value in a similar range; it is typically used to set transition easing. The following easing types are supported: <ul> <li>linear - the identity function, t.</li> <li>poly(k) - raises t to the specified power k (e.g., 3).</li> <li>quad - equivalent to poly(2).</li> <li>cubic - equivalent to poly(3).</li> <li>sin - applies the trigonometric function sin.</li> <li>exp - raises 2 to a power based on t.</li> <li>circle - the quarter circle.</li> <li>elastic(a, p) - simulates an elastic band; may extend slightly beyond 0 and 1.</li> <li>back(s) - simulates backing into a parking space.</li> <li>bounce - simulates a bouncy collision.</li> </ul> These built-in types may be extended using a variety of modes: <ul> <li>in - the identity function.</li> <li>out - reverses the easing direction to [1,0].</li> <li>in-out- copies and mirrors the easing function from [0,.5] and [.5,1].</li> <li>out-in - copies and mirrors the easing function from [1,.5] and [.5,0].</li> </ul>
		 * @param (String) type the type of  {@link (com.ibm.rave.core.ease.EasingFunction) EasingFunction}
		 * @param (java.lang.Object[]) args the parameters that will be provided to the type of {@link (com.ibm.rave.core.ease.EasingFunction) EasingFunction}  specified.
		 * @return (com.ibm.rave.core.ease.EasingFunction)  an  {@link (com.ibm.rave.core.ease.EasingFunction) EasingFunction}  of the type Specified with the provided arguments applied
		 */
		function(type, args) {
			if (args !== null || arguments.length > 2){
				args = Array.prototype.slice.call(arguments, 1);
			}
			{
				var i = type.indexOf("-");
				var t = i >= 0 ? type.substring(0, i) : type;
				var m = i >= 0 ? type.substring(i + 1) : "in";
				var e = com_ibm_rave_core_ease_Easing.identity;
				if ("poly" == t) {
					e = com_ibm_rave_core_ease_Easing.poly((args[0]));
				} else if ("quad" == t) {
					e = com_ibm_rave_core_ease_Easing.quad;
				} else if ("cubic" == t) {
					e = com_ibm_rave_core_ease_Easing.cubic;
				} else if ("sin" == t) {
					e = com_ibm_rave_core_ease_Easing.sin;
				} else if ("exp" == t) {
					e = com_ibm_rave_core_ease_Easing.exp;
				} else if ("circle" == t) {
					e = com_ibm_rave_core_ease_Easing.circle;
				} else if ("elastic" == t) {
					if (!args || args.length == 0) {
						e = com_ibm_rave_core_ease_Easing.elastic$0();
					} else if (args.length == 1) {
						e = com_ibm_rave_core_ease_Easing.elastic$1((args[0]));
					} else if (args.length == 2) {
						e = com_ibm_rave_core_ease_Easing.elastic$2((args[0]), (args[1]));
					}
				} else if ("back" == t) {
					if (!args || args.length == 0) {
						e = com_ibm_rave_core_ease_Easing.back$0();
					} else if (args.length == 1) {
						e = com_ibm_rave_core_ease_Easing.back$1((args[0]));
					}
				} else if ("bounce" == t) {
					e = com_ibm_rave_core_ease_Easing.bounce;
				}
				if ("out" == m) {
					e = com_ibm_rave_core_ease_Easing.reverse(e);
				} else if ("in-out" == m) {
					e = com_ibm_rave_core_ease_Easing.reflect(e);
				} else if ("out-in" == m) {
					e = com_ibm_rave_core_ease_Easing.reflect(com_ibm_rave_core_ease_Easing.reverse(e));
				}
				return com_ibm_rave_core_ease_Easing.clamp(e);
			}
		};
		return _$self;
	}

	//constructor : function() {}
});

com_ibm_rave_core_ease_Easing.clamp = function(f) {
	return function(t) {
		return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
	};
};

com_ibm_rave_core_ease_Easing.reverse = function(f) {
	return function(t) {
		return 1 - f(1 - t);
	};
};

com_ibm_rave_core_ease_Easing.reflect = function(f) {
	return function(t) {
		return .5 * (t < .5 ? f(2 * t) : (2 - f(2 - 2 * t)));
	};
};

com_ibm_rave_core_ease_Easing.poly = function(e) {
	return function(t) {
		return Math.pow(t, e);
	};
};

com_ibm_rave_core_ease_Easing.elastic$0 = function() {
	return com_ibm_rave_core_ease_Easing.elastic$3(1, 0.45, 0.45 / 4);
};

com_ibm_rave_core_ease_Easing.elastic$1 = function(a) {
	return com_ibm_rave_core_ease_Easing.elastic$2(a, 0.45);
};

com_ibm_rave_core_ease_Easing.elastic$2 = function(a, p) {
	return com_ibm_rave_core_ease_Easing.elastic$3(a, p, p / 6.283185307179586 * Math.asin(1 / a));
};

com_ibm_rave_core_ease_Easing.elastic$3 = function(a, p, s) {
	return function(t) {
		return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * 6.283185307179586 / p);
	};
};

com_ibm_rave_core_ease_Easing.back$0 = function() {
	return com_ibm_rave_core_ease_Easing.back$1(1.70158);
};

com_ibm_rave_core_ease_Easing.back$1 = function(s) {
	return function(t) {
		return t * t * ((s + 1) * t - s);
	};
};

com_ibm_rave_core_ease_Easing.elastic = function(a0, a1, a2) {
	var args = arguments;
	if (args.length == 0) {
		return com_ibm_rave_core_ease_Easing.elastic$0();
	}
	if (args.length == 1) {
		return com_ibm_rave_core_ease_Easing.elastic$1(a0);
	}
	if (args.length == 2) {
		return com_ibm_rave_core_ease_Easing.elastic$2(a0, a1);
	}
	return com_ibm_rave_core_ease_Easing.elastic$3(a0, a1, a2);
};

com_ibm_rave_core_ease_Easing.back = function(a0) {
	var args = arguments;
	if (args.length == 0) {
		return com_ibm_rave_core_ease_Easing.back$0();
	}
	return com_ibm_rave_core_ease_Easing.back$1(a0);
};

/** @expose */ 
com_ibm_rave_core_ease_Easing.INSTANCE = new com_ibm_rave_core_ease_Easing();
com_ibm_rave_core_ease_Easing.HALF_PI = Math.PI / 2;
com_ibm_rave_core_ease_Easing.PI_2 = Math.PI * 2;
com_ibm_rave_core_ease_Easing.identity = function(t) {
	return t;
};
com_ibm_rave_core_ease_Easing.quad = function(t) {
	return t * t;
};
com_ibm_rave_core_ease_Easing.cubic = function(t) {
	return t * t * t;
};
com_ibm_rave_core_ease_Easing.cubicInOut = function(t) {
	if (t <= 0) {
		return 0;
	}
	if (t >= 1) {
		return 1;
	}
	var t2 = t * t, t3 = t2 * t;
	return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
};
com_ibm_rave_core_ease_Easing.sin = function(t) {
	return 1 - Math.cos(t * 1.5707963267948966);
};
com_ibm_rave_core_ease_Easing.exp = function(t) {
	return Math.pow(2, 10 * (t - 1));
};
com_ibm_rave_core_ease_Easing.circle = function(t) {
	return 1 - Math.sqrt(1 - t * t);
};
com_ibm_rave_core_ease_Easing.bounce = function(t) {
	var _t = t;
	return _t < 1 / 2.75 ? 7.5625 * _t * _t : _t < 2 / 2.75 ? 7.5625 * (_t -= 1.5 / 2.75) * _t + .75 : _t < 2.5 / 2.75 ? 7.5625 * (_t -= 2.25 / 2.75) * _t + .9375 : 7.5625 * (_t -= 2.625 / 2.75) * _t + .984375;
};
/**
 * The default easing function is "cubic-in-out" which provides suitable slow-in slow-out animations
 */
/** @expose */ 
com_ibm_rave_core_ease_Easing.DEFAULT = com_ibm_rave_core_ease_Easing.cubicInOut;

// $source: com/ibm/rave/core/event/Dispatcher
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare anonymous, declare
/**
 * Behaviors and higher level components, such as the brush, use dispatch to broadcast custom events. <p> For visualizations with coordinated views, dispatch provides a convenient lightweight mechanism for loosely-coupled components. Organizing your code with dispatch can assist with separation of concerns and make your code easier to maintain.
 * @param < (java.lang.Object) C > the event listener context
 */
var com_ibm_rave_core_event_Dispatcher = rave_externs["Dispatcher"] = com_ibm_rave_core_nativeImpl_Declare(Object, {

	/** @expose */ 
	init : function(types) {
		if (types !== null || arguments.length > 1){
			types = Array.prototype.slice.call(arguments);
		}
		{
			var i = -1, n = types.length;
			while (++i < n) {
				this[types[i]] = com_ibm_rave_core_event_Dispatcher.createEvent(this);
			}
		}
	},

	/** @expose */ 
	constructor : function() {},

	/**
	 * Returns the currently-assigned listener for the specified type, if any.
	 * @param (String) type the event type
	 * @return (com.ibm.rave.core.selector.RunFunction)  the currently-assigned listener for the specified type
	 */
	on$0 : function(type) {
		var t = type;
		var i = t.indexOf(".");
		var name = "";
		if (i >= 0) {
			name = t.substring(i + 1);
			t = t.substring(0, i);
		}
		if (t.length > 0) {
			return this[t].on$0(name);
		}
		return undefined;
	},

	/**
	 * Adds or removes an event listener for the specified type. The type is a string event type name, such as "start" or "end". The specified listener is invoked with the context and arguments determined by the caller. <p> If an event listener was already registered for the same type, the existing listener is removed before the new listener is added. To register multiple listeners for the same event type, the type may be followed by an optional namespace, such as "click.foo" and "click.bar". Likewise, you can remove all registered listeners for a given namespace by saying dispatch.on(".foo", null).
	 * @param (String) type the event type
	 * @param (com.ibm.rave.core.selector.RunFunction) listener the event listener to register, or <code>null</code> to remove the listener
	 * @return (com.ibm.rave.core.event.Dispatcher)  this  {@link (com.ibm.rave.core.event.Dispatcher) Dispatcher}
	 */
	on$1 : function(type, listener) {
		var t = type;
		var i = t.indexOf(".");
		var name = "";
		if (i >= 0) {
			name = t.substring(i + 1);
			t = t.substring(0, i);
		}
		if (t.length > 0) {
			return this[t].on$1(name, listener);
		}
		if (!listener) {
			for (var __i_enFor0 = 0, __exp_enFor0 = Object.keys(this), __len_enFor0 = __exp_enFor0.length;
					__i_enFor0 < __len_enFor0; ++__i_enFor0) {
				var key = __exp_enFor0[__i_enFor0];
				if (this.hasOwnProperty(key)) {
					this[key].on$1(name, null);
				}
			}
		}
		return this;
	},

	/** @expose */ 
	on : function(a0, a1) {
		var args = arguments;
		if (args.length == 1) {
			return this.on$0(a0);
		}
		return this.on$1(a0, a1);
	}
});

/**
 * Creates a new dispatcher object for the specified types. Each argument is a string representing the name of the event type, such as "zoom" or "change". The returned object is an associative array; each type name is associated with a  {@link (com.ibm.rave.core.event.Dispatcher.DispatcherEvent) DispatcherEvent} .
 * @param (java.lang.String[]) types event type names
 * @return (com.ibm.rave.core.event.Dispatcher)  a dispatcher for the given event types
 */
/** @expose */ 
com_ibm_rave_core_event_Dispatcher.create = function(types) {
	if (types !== null || arguments.length > 1){
		types = Array.prototype.slice.call(arguments);
	}
	{
		var dispatch = new com_ibm_rave_core_event_Dispatcher();
		dispatch.init.apply(dispatch, types);
		return dispatch;
	}
};

com_ibm_rave_core_event_Dispatcher.createEvent = function(dispatch) {
	var listeners = [];
	listeners[0] = [];
	var listenerByName = [];
	listenerByName[0] = {};
	return new (com_ibm_rave_core_nativeImpl_Declare({

		_$functionClassMethod : function() {
			var _$self = function(args) {
				if (args !== null || arguments.length > 1){
					args = Array.prototype.slice.call(arguments, 0);
				}
				{
					var z = listeners[0];
					var i = -1, n = z.length;
					var l;
					while (++i < n) {
						if ((l = z[i]).on) {
							l.on.apply(this, args);
						}
					}
					return dispatch;
				}
			};
			return _$self;
		},

		on$0 : function(name) {
			var l = listenerByName[0][name];
			return l && l.on ? l.on : null;
		},

		on$1 : function(name, listener) {
			var l = listenerByName[0][name];
			if (l) {
				var i;
				l.on = null;
				listeners[0] = listeners[0].slice(0, i = listeners[0].indexOf(l)).concat(listeners[0].slice(i + 1));
				delete listenerByName[0][name];
			}
			if (listener) {
				l = new com_ibm_rave_core_event_Dispatcher.ListenerWrapper(listener);
				listenerByName[0][name] = l;
				listeners[0].push(l);
			}
			return dispatch;
		},

		on : function(a0, a1) {
			var args = arguments;
			if (args.length == 1) {
				return this.on$0(a0);
			}
			return this.on$1(a0, a1);
		}

	}))();
};

com_ibm_rave_core_event_Dispatcher.ListenerWrapper = function(on) {
	this.on = on;
};


// $source: com/ibm/rave/core/internal/transitions/TransitionTracker
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
var com_ibm_rave_core_internal_transitions_TransitionTracker = com_ibm_rave_core_nativeImpl_Declare(Object, {

	/**
	 * @expose  
	 */
	active : 0,

	/**
	 * @expose  
	 */
	count : 0
});


// $source: com/ibm/rave/core/internal/transitions/TransitionUtil
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/internal/transitions/TransitionInfo (static) // new
//@import com/ibm/rave/core/internal/transitions/TransitionTracker (static) // new
var com_ibm_rave_core_internal_transitions_TransitionUtil = {


};

com_ibm_rave_core_internal_transitions_TransitionUtil.getTransitionInfo = function(node, namespace, id) {
	var tracker = com_ibm_rave_core_internal_transitions_TransitionUtil.getTransitionTracker(node, namespace);
	var info = tracker[id];
	if (!info) {
		tracker.count++;
		info = new com_ibm_rave_core_internal_transitions_TransitionInfo(tracker, id, node);
		tracker[id] = info;
	}
	return info;
};

com_ibm_rave_core_internal_transitions_TransitionUtil.getTransitionTracker = function(node, namespace) {
	var tracker = node.rave_getProperty(namespace);
	if (!tracker) {
		tracker = new com_ibm_rave_core_internal_transitions_TransitionTracker();
		node.rave_setProperty(namespace, tracker);
	}
	return tracker;
};

com_ibm_rave_core_internal_transitions_TransitionUtil.disposeTransition = function(node, namespace) {
	node.rave_setProperty(namespace, null);
};

com_ibm_rave_core_internal_transitions_TransitionUtil.interrupt = function(node) {
	com_ibm_rave_core_internal_transitions_TransitionUtil.interruptNS(node, com_ibm_rave_core_internal_transitions_TransitionUtil.transitionNamespace(null));
};

com_ibm_rave_core_internal_transitions_TransitionUtil.interruptNS = function(node, namespace) {
	var tracker = node.rave_getProperty(namespace);
	var active;
	if (tracker && (active = tracker[~~tracker.active])) {
		if (--tracker.count > 0) {
			delete tracker[~~tracker.active];
		} else {
			com_ibm_rave_core_internal_transitions_TransitionUtil.disposeTransition(node, namespace);
		}
		tracker.active += 0.5;
		if (active.event) {
			active.event["interrupt"].call(node, node.rave_getData(), active.index);
		}
	}
};

/**
 * @param (String) name the name of the transition
 * @return (String)  the transition namespace
 */
com_ibm_rave_core_internal_transitions_TransitionUtil.transitionNamespace = function(name) {
	return name == null ? "__transition_" + "_" : "__transition_" + name + "__";
};

//com_ibm_rave_core_internal_transitions_TransitionUtil.TRANSITION_PROPERTY = "__transition_";


// $source: com/ibm/rave/core/internal/transitions/Tweener
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/timer/Timer (static) // Timer
//@import com/ibm/rave/core/internal/transitions/TransitionUtil (static) // disposeTransition, getTransitionInfo
var com_ibm_rave_core_internal_transitions_Tweener = {


};

/**
 * Posts a timer event to perform the scheduling of the transitions if early scheduling is supported. This allows multiple transitions to be aligned on the same start time. <p> If early scheduling is not supported, adds the transition to a list of transitions to be scheduled by explicitly calling {@link #this.schedulePending()} .
 * @param (com.ibm.rave.core.transition.Transition) transition the transitions to schedule
 */
com_ibm_rave_core_internal_transitions_Tweener.schedule = function(transition) {
	if (com_ibm_rave_core_internal_transitions_Tweener.earlyScheduleSupport) {
		com_ibm_rave_core_nativeImpl_timer_Timer.INSTANCE(function(elapsed) {
			com_ibm_rave_core_internal_transitions_Tweener.scheduleTransition(transition, com_ibm_rave_core_nativeImpl_timer_Timer.INSTANCE.currentTime(), elapsed);
			return true;
		}, 0, Date.now());
	} else {
		com_ibm_rave_core_internal_transitions_Tweener.pending.push(transition);
	}
};

/**
 * Schedules the transitions by creating timer events.
 * @param (com.ibm.rave.core.transition.Transition) transition the transitions to schedule
 * @param (double) startTime the time used as the start time of all transitions
 * @param (double) elapsed the time elapsed, in milli-seconds, transition was scheduled
 */
com_ibm_rave_core_internal_transitions_Tweener.scheduleTransition = function(transition, startTime, elapsed) {
	var transitionId = transition.id;
	var namespace = transition.namespace;
	for (var j = 0, m = transition.length; j < m; ++j) {
		var group = transition[j];
		for (var i = 0, n = group.length; i < n; ++i) {
			var node = group[i];
			if (node) {
				var info = com_ibm_rave_core_internal_transitions_TransitionUtil.getTransitionInfo(node, namespace, transitionId);
				if (!(info.scheduled)) {
					info.setScheduled();
					var tracker = info.tracker;
					var infoStartTime = info.time;
					if (infoStartTime == null) {
						infoStartTime = startTime;
						info.time = startTime;
					}
					com_ibm_rave_core_internal_transitions_Tweener.doSchedule(info, tracker, namespace, transitionId, infoStartTime, elapsed);
				}
			}
		}
	}
};

com_ibm_rave_core_internal_transitions_Tweener.doSchedule = function(info, tracker, namespace, id, startTime, elapsed) {
	var node = info.node;
	if (tracker.active > id) {
		com_ibm_rave_core_internal_transitions_Tweener.stop(tracker, node, namespace, id);
	} else {
		var tick;
		var start = function(startElapsed) {
			if (!tick) {
				tick = com_ibm_rave_core_internal_transitions_Tweener.startAndCreateTick(info, tracker, namespace, id, startTime, startElapsed);
				return !tick;
			}
			return tick(startElapsed);
		};
		com_ibm_rave_core_nativeImpl_timer_Timer.INSTANCE(start, info.delay - elapsed, startTime);
	}
};

com_ibm_rave_core_internal_transitions_Tweener.startAndCreateTick = function(info, tracker, namespace, id, startTime, startElapsed) {
	var node = info.node;
	var index = info.index;
	var groupIndex = info.groupIndex;
	if (tracker.active > id) {
		com_ibm_rave_core_internal_transitions_Tweener.stop(tracker, node, namespace, id);
		return null;
	}
	var active = tracker[~~tracker.active];
	if (active) {
		--tracker.count;
		delete tracker[~~tracker.active];
		if (active.event) {
			active.event["interrupt"].call(node, node.rave_getData(), active.index);
		}
	}
	tracker.active = id;
	if (info.event) {
		info.event["start"].call(node, node.rave_getData(), index, groupIndex);
	}
	var tweens = info.getTweens();
	var ease = info.ease;
	var duration = info.duration;
	var tick = function(elapsed) {
		if (tracker.active != id) {
			return true;
		}
		var t = elapsed / duration;
		var v = !ease ? t : ease(t);
		for (var __i_enFor0 = 0, __exp_enFor0 = tweens, __len_enFor0 = __exp_enFor0.length;
				__i_enFor0 < __len_enFor0; ++__i_enFor0) {
			var tween = __exp_enFor0[__i_enFor0];
			tween.call(node, v);
		}
		if (t >= 1) {
			if (info.event) {
				info.event["end"].call(node, node.rave_getData(), index, groupIndex);
			}
			return com_ibm_rave_core_internal_transitions_Tweener.stop(tracker, node, namespace, id);
		}
		return false;
	};
	com_ibm_rave_core_nativeImpl_timer_Timer.INSTANCE(function(_) {
		tick(startElapsed);
		return true;
	}, 0, startTime);
	return startElapsed / duration < 1 ? tick : null;
};

com_ibm_rave_core_internal_transitions_Tweener.stop = function(tracker, node, namespace, id) {
	if (--tracker.count > 0) {
		delete tracker[id];
	} else {
		com_ibm_rave_core_internal_transitions_TransitionUtil.disposeTransition(node, namespace);
	}
	return true;
};


// $source: com/ibm/rave/core/internal/transitions/TweenFunctions
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/internal/nativeImpl/Lang (runtime) // isNumber
//@import com/ibm/rave/core/interpolate/Interpolators (runtime) // Interpolators
//@import com/ibm/rave/core/interpolate/TransformInterpolation (runtime) // TransformInterpolation
//@import com/ibm/rave/core/internal/transitions/TransitionUtil (runtime) // getTransitionInfo
//@import com/ibm/rave/core/internal/selector/SelectorHelper (static) // each
var com_ibm_rave_core_internal_transitions_TweenFunctions = {


};

com_ibm_rave_core_internal_transitions_TweenFunctions.style = function(name, value, priority) {
	return function(data, index, groupIndex) {
		var startValue = this.rave_getComputedStyle(name);
		var v = value;
		if (typeof v === "function") {
			v = (v).call(this, data, index, groupIndex);
		}
		if (v == null) {
			this.rave_removeStyle(name);
			return null;
		}
		if (!(com_ibm_rave_core_internal_nativeImpl_Lang.isNumber(v)) || !(com_ibm_rave_core_internal_nativeImpl_Lang.isNumber(startValue))) {
			v = v + "";
		}
		if (startValue!==v) {
			var interpolator = com_ibm_rave_core_interpolate_Interpolators.INSTANCE.getInterpolator(startValue, v);
			return function(t) {
				this.rave_setStyle(name, interpolator(t), priority);
			};
		}
		return null;
	};
};

com_ibm_rave_core_internal_transitions_TweenFunctions.styleTween = function(name, factory, priority) {
	return function(data, index, groupIndex) {
		var startValue = this.rave_getComputedStyle(name);
		var interpolator = factory.call(this, data, index, startValue);
		if (interpolator) {
			return function(t) {
				this.rave_setStyle(name, interpolator(t), priority);
			};
		}
		return null;
	};
};

com_ibm_rave_core_internal_transitions_TweenFunctions.attr = function(qname, value) {
	return function(data, index, groupIndex) {
		var startValue = qname["space"] == null ? this.getAttribute(qname["local"]) : this.getAttributeNS(qname["space"], qname["local"]);
		var v = value;
		if (typeof v === "function") {
			v = (v).call(this, data, index, groupIndex);
		}
		if (v == null) {
			if (qname["space"] == null) {
				this.removeAttribute(qname["local"]);
			} else {
				this.removeAttributeNS(qname["space"], qname["local"]);
			}
			return null;
		}
		if (!(com_ibm_rave_core_internal_nativeImpl_Lang.isNumber(v)) || !(com_ibm_rave_core_internal_nativeImpl_Lang.isNumber(startValue))) {
			v = v + "";
		}
		if (startValue!==v) {
			var interpolator = "transform" == qname["local"] && qname["space"] == null ? com_ibm_rave_core_interpolate_TransformInterpolation.INSTANCE(startValue == null ? null : ""+(startValue), v == null ? null : ""+(v)) : com_ibm_rave_core_interpolate_Interpolators.INSTANCE.getInterpolator(startValue, v);
			if (qname["space"] == null) {
				return function(t) {
					this.setAttribute(qname["local"], interpolator(t));
				};
			}
			return function(t) {
				this.setAttributeNS(qname["space"], qname["local"], interpolator(t));
			};
		}
		return null;
	};
};

com_ibm_rave_core_internal_transitions_TweenFunctions.attrTween = function(qname, factory) {
	return function(data, index, groupIndex) {
		var startValue = qname["space"] == null ? this.getAttribute(qname["local"]) : this.getAttributeNS(qname["space"], qname["local"]);
		var interpolator = factory.call(this, data, index, startValue);
		if (interpolator) {
			if (qname["space"] == null) {
				return function(t) {
					this.setAttribute(qname["local"], interpolator(t));
				};
			}
			return function(t) {
				this.setAttributeNS(qname["space"], qname["local"], interpolator(t));
			};
		}
		return null;
	};
};

com_ibm_rave_core_internal_transitions_TweenFunctions.tween = function(groups, name, value, getTween) {
	var id = groups.id;
	var namespace = groups.namespace;
	var callback;
	if (typeof value === "function") {
		callback = function(data, index, groupIndex) {
			com_ibm_rave_core_internal_transitions_TransitionUtil.getTransitionInfo(this, namespace, id).addTweenFactory(name, getTween((value).call(this, data, index, groupIndex)));
		};
	} else {
		var tweenFactory = getTween(value);
		callback = function(data, index, groupIndex) {
			com_ibm_rave_core_internal_transitions_TransitionUtil.getTransitionInfo(this, namespace, id).addTweenFactory(name, tweenFactory);
		};
	}
	return com_ibm_rave_core_internal_selector_SelectorHelper.each(groups, callback);
};


// $source: com/ibm/rave/core/interpolate/Interpolators
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/nativeImpl/Lang (runtime) // isList, isObject, isString, isArray
//@import com/ibm/rave/core/color/Colors (runtime) // isRGBColorName
//@import com/ibm/rave/core/interpolate/ColorInterpolation (runtime) // ColorInterpolation
//@import com/ibm/rave/core/interpolate/StringInterpolation (runtime) // StringInterpolation
//@import com/ibm/rave/core/color/Color (runtime) // new
//@import com/ibm/rave/core/interpolate/ArrayInterpolation (runtime) // ArrayInterpolation
//@import com/ibm/rave/core/nativeImpl/interpolate/ObjectInterpolation (runtime) // ObjectInterpolation
//@import com/ibm/rave/core/interpolate/NumberInterpolation (runtime) // NumberInterpolation
var com_ibm_rave_core_interpolate_Interpolators = com_ibm_rave_core_nativeImpl_Declare(Array, {

	constructor : function() {
		this.push(function(a, b) {
			if (com_ibm_rave_core_internal_nativeImpl_Lang.isString(b)) {
				if (com_ibm_rave_core_color_Colors.isRGBColorName(b) || (b).match("#[a-z|A-Z|0-9]*|rgba?\\(.*|hsla?\\(.*")) {
					return com_ibm_rave_core_interpolate_ColorInterpolation.RGBINSTANCE(a, b);
				}
				return com_ibm_rave_core_interpolate_StringInterpolation.INSTANCE(a, b);
			} else if (com_ibm_rave_core_nativeImpl_Object.isInstanceOf(b, com_ibm_rave_core_color_Color)) {
				return com_ibm_rave_core_interpolate_ColorInterpolation.RGBINSTANCE(a, b);
			} else if (com_ibm_rave_core_internal_nativeImpl_Lang.isArray(b)) {
				return com_ibm_rave_core_interpolate_ArrayInterpolation.INSTANCE(a, b);
			} else if (com_ibm_rave_core_internal_nativeImpl_Lang.isList(b) || (com_ibm_rave_core_internal_nativeImpl_Lang.isObject(b) && isNaN(b))) {
				return com_ibm_rave_core_nativeImpl_interpolate_ObjectInterpolation.INSTANCE(a, b);
			}
			return com_ibm_rave_core_interpolate_NumberInterpolation.INSTANCE(a, b);
		});
	},

	/**
	 * Get an interpolator for the given values.
	 * @param (Object) a the start value
	 * @param (Object) b the end value
	 * @return (com.ibm.rave.core.interpolate.Interpolator)  an interpolator
	 */
	/** @expose */ 
	getInterpolator : function(a, b) {
		var result;
		for (var i = this.length - 1; !result && i >= 0; --i) {
			result = this[i](a, b);
		}
		return result;
	}
});

/** @expose */ 
com_ibm_rave_core_interpolate_Interpolators.INSTANCE = new com_ibm_rave_core_interpolate_Interpolators();

// $source: com/ibm/rave/core/color/Color
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
var com_ibm_rave_core_color_Color = rave_externs["Color"] = com_ibm_rave_core_nativeImpl_Declare({

	/** @expose */ 
	constructor : function() {},

	/**
	 * Create a new RGB color object.
	 * @return (com.ibm.rave.core.color.RGB)  RGB New RGB color
	 */
	/** @expose */ 
	rgb : function() {},

	/**
	 * Return a color object that is one "level" brighter. The level of brightness is determined by the Color implementation.
	 * @return (com.ibm.rave.core.color.Color)  Color New Color that is one level brighter than the calling Color.
	 */
	brighter$0 : function() {
		return this.brighter$1(1);
	},

	/**
	 * Return a color object that is one "level" darker. The level of darkness is determined by the Color implementation.
	 * @return (com.ibm.rave.core.color.Color)  Color New Color that is one level darker than the calling Color.
	 */
	darker$0 : function() {
		return this.darker$1(1);
	},

	/**
	 * Return a string representation of this color. Typically returned as a string in the format "#rrggbb".
	 * @return (String)  String representation in "#rrggbb" format.
	 */
	/** @expose */ 
	toString : function() {
		return this.rgb().toString();
	},

	/** @expose */ 
	brighter : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.brighter$0();
		}
		return this.brighter$1(a0);
	},

	/** @expose */ 
	darker : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.darker$0();
		}
		return this.darker$1(a0);
	},

	/** @expose */ 
	contrastShift : function(a0, a1) {
		var args = arguments;
		if (args.length == 0) {
			return this.contrastShift$0();
		}
		if (args.length == 1 && (a0 == null || typeof a0 === "number")) {
			return this.contrastShift$2(a0);
		}
		if (args.length == 1) {
			return this.contrastShift$1(a0);
		}
		return this.contrastShift$3(a0, a1);
	}

	/**
	 * Return a color object that is "k" levels brighter than the current Color.
	 * @param (double) k Amount of brightness to apply to the current color.
	 * @return (com.ibm.rave.core.color.Color)  New color that is "k" levels brighter than the current color.
	 */
	//brighter$1 : function(k) {},

	/**
	 * Return a color object that is "k" levels brighter than the current Color.
	 * @param (double) k Amount of brightness to apply to the current color.
	 * @return (com.ibm.rave.core.color.Color)  New color that is "k" levels brighter than the current color.
	 */
	//darker$1 : function(k) {},

	/**
	 * Supplies a color that will contrast the color contained within the color object using the default ratio of 4.5
	 * @return (com.ibm.rave.core.color.Color)  A contrasting color
	 */
	//contrastShift$0 : function() {},

	/**
	 * Supplies a color that will contrast the color passed into the api using the default ratio of 4.5 <p> The object could be one of the following: <ul> <li>LAB color</li> <li>RGB color</li> <li>HCL color</li> <li>A string which could be in one of the following formats: <ul> <li>RGB decimal - "rgb(255,255,255)"</li> <li>HSL decimal - "hsl(120,50%,20%)"</li> <li>RGB hexadecimal - "#ffeeaa"</li> <li>RGB shorthand hexadecimal - "#fea"</li> <li>named RGB- "red", "white", "blue"</li> </ul> </ul> If the object passed is none of the above,it will be coerced to a string (by calling toString() on it) and processed as such, and if the resulting string does not conform to any of the above formats, it will be considered as a string representation of RGB black color.
	 * @param (Object) color The color to be contrasted
	 * @return (com.ibm.rave.core.color.Color)  A contrasting color
	 */
	//contrastShift$1 : function(color) {},

	/**
	 * Supplies a color that will contrast the color contained within the color object using the contrast ratio passed in
	 * @param (double) ratio The contrast ratio to obtain. May be a value from 1 - 21. If a value other outside of the range is passed in, the default ratio of 4.5 will be applied
	 * @return (com.ibm.rave.core.color.Color)  A contrasting color
	 */
	//contrastShift$2 : function(ratio) {},

	/**
	 * Supplies a color that will contrast the color passed in against the color object using the contrast ratio passed in. <p> The object could be one of the following: <ul> <li>LAB color</li> <li>RGB color</li> <li>HCL color</li> <li>A string which could be in one of the following formats: <ul> <li>RGB decimal - "rgb(255,255,255)"</li> <li>HSL decimal - "hsl(120,50%,20%)"</li> <li>RGB hexadecimal - "#ffeeaa"</li> <li>RGB shorthand hexadecimal - "#fea"</li> <li>named RGB- "red", "white", "blue"</li> </ul> </ul> If the object passed is none of the above,it will be coerced to a string (by calling toString() on it) and processed as such, and if the resulting string does not conform to any of the above formats, it will be considered as a string representation of RGB black color.
	 * @param (Object) color The color to be contrasted
	 * @param (double) ratio The contrast ratio to obtain. May be a value from 1 - 21. If a value other outside of the range is passed in, the default ratio of 4.5 will be applied
	 * @return (com.ibm.rave.core.color.Color)  A contrasting color
	 */
	//contrastShift$3 : function(color, ratio) {}
});


// $source: com/ibm/rave/core/color/HSL
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/color/Color (loadtime) // superclass
//@import com/ibm/rave/core/color/Colors (runtime) // newRGB, hsl_rgb
//@import com/ibm/rave/core/internal/color/ContrastShift (runtime) // updateColor
/**
 * An object representing HSL (hue-saturation-lightness) color which is basically a cylindrical-coordinate representations of points in an RGB color model. Hue is a degree on the color wheel; 0 (or 360) is red, 120 is green, 240 is blue. Numbers in between reflect different shades. Saturation is a percentage value; 100% is the full color. Lightness is also a percentage; 0% is dark (black), 100% is light (white), and 50% is the average.
 */
var com_ibm_rave_core_color_HSL = rave_externs["HSL"] = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_color_Color, {

	/**
	 * @expose  
	 */
	h : 0,

	/**
	 * @expose  
	 */
	s : 0,

	/**
	 * @expose  
	 */
	l : 0,

	/**
	 * @expose  
	 */
	a : 0,

	constructor : function(h, s, l, a) {
		this.h = + (h);
		this.s = + (s);
		this.l = + (l);
		this.a = + (a);
	},

	/** @expose */ 
	rgb : function() {
		return com_ibm_rave_core_color_Colors.hsl_rgb(this.h, this.s, this.l, this.a);
	},

	/** @expose */ 
	brighter$1 : function(k) {
		var _k = Math.pow(0.7, k);
		return new com_ibm_rave_core_color_HSL(this.h, this.s, this.l / _k, this.a);
	},

	/** @expose */ 
	darker$1 : function(k) {
		var _k = Math.pow(0.7, k);
		return new com_ibm_rave_core_color_HSL(this.h, this.s, _k * this.l, this.a);
	},

	/**
	 * A getter for the hue value
	 * @return (double)  the hue value
	 */
	/** @expose */ 
	getH : function() {
		return this.h;
	},

	/**
	 * A getter for the saturation value
	 * @return (double)  the saturation value
	 */
	/** @expose */ 
	getS : function() {
		return this.s;
	},

	/**
	 * A getter for the lightness value
	 * @return (double)  the lightness value
	 */
	/** @expose */ 
	getL : function() {
		return this.l;
	},

	/**
	 * Return the alpha value
	 * @return (double)  the alpha value
	 */
	/** @expose */ 
	getA : function() {
		return this.a;
	},

	contrastShift$0 : function() {
		return com_ibm_rave_core_internal_color_ContrastShift.updateColor$0(this.rgb(), this.rgb()).hsl();
	},

	contrastShift$1 : function(color) {
		return com_ibm_rave_core_internal_color_ContrastShift.updateColor$0(this.rgb(), com_ibm_rave_core_color_Colors.newRGB(color)).hsl();
	},

	contrastShift$2 : function(ratio) {
		return com_ibm_rave_core_internal_color_ContrastShift.updateColor$1(this.rgb(), this.rgb(), ratio).hsl();
	},

	contrastShift$3 : function(color, ratio) {
		return com_ibm_rave_core_internal_color_ContrastShift.updateColor$1(this.rgb(), com_ibm_rave_core_color_Colors.newRGB(color), ratio).hsl();
	},

	/** @expose */ 
	contrastShift : function(a0, a1) {
		var args = arguments;
		if (args.length == 0) {
			return this.contrastShift$0();
		}
		if (args.length == 1 && (a0 == null || typeof a0 === "number")) {
			return this.contrastShift$2(a0);
		}
		if (args.length == 1) {
			return this.contrastShift$1(a0);
		}
		return this.contrastShift$3(a0, a1);
	}
});


// $source: com/ibm/rave/core/color/RGB
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/color/Color (loadtime) // superclass
//@import com/ibm/rave/core/color/Colors (runtime) // rgb_hex, rgb_lab, newRGB, rgb_hsl
//@import com/ibm/rave/core/internal/color/ContrastShift (runtime) // updateColor
/**
 * A class representing the RGB color model is an additive color model in which red, green, and blue light are added together in various ways to reproduce a broad array of colors. In addition, it supports a constant alpha value of 1.0
 */
var com_ibm_rave_core_color_RGB = rave_externs["RGB"] = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_color_Color, {

	/**
	 * @expose  
	 */
	r : 0,

	/**
	 * @expose  
	 */
	g : 0,

	/**
	 * @expose  
	 */
	b : 0,

	/**
	 * @expose  
	 */
	a : 0,

	constructor : function(r, g, b, a) {
		this.r = ~~r;
		this.g = ~~g;
		this.b = ~~b;
		this.a = a;
	},

	/** @expose */ 
	rgb : function() {
		return this;
	},

	/** @expose */ 
	hsl : function() {
		return com_ibm_rave_core_color_Colors.rgb_hsl(this.r, this.g, this.b, this.a);
	},

	lab : function() {
		return com_ibm_rave_core_color_Colors.rgb_lab(this.r, this.g, this.b);
	},

	/** @expose */ 
	brighter$1 : function(k) {
		var r = this.r, g = this.g, b = this.b, i = 30;
		if (r == 0 && g == 0 && b == 0) {
			return new com_ibm_rave_core_color_RGB(i, i, i, this.a);
		}
		if (r != 0 && r < i) {
			r = i;
		}
		if (g != 0 && g < i) {
			g = i;
		}
		if (b != 0 && b < i) {
			b = i;
		}
		var _k = Math.pow(0.7, k);
		return new com_ibm_rave_core_color_RGB(~~Math.min(255, r / _k), ~~Math.min(255, g / _k), ~~Math.min(255, b / _k), this.a);
	},

	/** @expose */ 
	darker$1 : function(k) {
		var _k = Math.pow(0.7, k);
		return new com_ibm_rave_core_color_RGB(~~(_k * this.r), ~~(_k * this.g), ~~(_k * this.b), this.a);
	},

	/** @expose */ 
	toString : function() {
		if (this.a != 1) {
			return "rgba(" + this.r + "," + this.g + "," + this.b + "," + this.a + ")";
		}
		return "#" + com_ibm_rave_core_color_Colors.rgb_hex(this.r) + com_ibm_rave_core_color_Colors.rgb_hex(this.g) + com_ibm_rave_core_color_Colors.rgb_hex(this.b);
	},

	/**
	 * A getter for the R-channel (red)
	 * @return (int)  the R-channel value
	 */
	/** @expose */ 
	getR : function() {
		return this.r;
	},

	/**
	 * A getter for the G-channel (green) value
	 * @return (int)  the G-channel value
	 */
	/** @expose */ 
	getG : function() {
		return this.g;
	},

	/**
	 * A getter for the B-channel (blue) value
	 * @return (int)  the B-channel value
	 */
	/** @expose */ 
	getB : function() {
		return this.b;
	},

	/**
	 * A getter for the A-channel (alpha channel for opacity) value
	 * @return (double)  the A-channel value
	 */
	/** @expose */ 
	getA : function() {
		return this.a;
	},

	contrastShift$0 : function() {
		return com_ibm_rave_core_internal_color_ContrastShift.updateColor$0(this.rgb(), this.rgb());
	},

	contrastShift$1 : function(color) {
		return com_ibm_rave_core_internal_color_ContrastShift.updateColor$0(this.rgb(), com_ibm_rave_core_color_Colors.newRGB(color));
	},

	contrastShift$2 : function(ratio) {
		return com_ibm_rave_core_internal_color_ContrastShift.updateColor$1(this.rgb(), this.rgb(), ratio);
	},

	contrastShift$3 : function(color, ratio) {
		return com_ibm_rave_core_internal_color_ContrastShift.updateColor$1(this.rgb(), com_ibm_rave_core_color_Colors.newRGB(color), ratio);
	},

	/** @expose */ 
	contrastShift : function(a0, a1) {
		var args = arguments;
		if (args.length == 0) {
			return this.contrastShift$0();
		}
		if (args.length == 1 && (a0 == null || typeof a0 === "number")) {
			return this.contrastShift$2(a0);
		}
		if (args.length == 1) {
			return this.contrastShift$1(a0);
		}
		return this.contrastShift$3(a0, a1);
	}
});


// $source: com/ibm/rave/core/color/LAB
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/color/Color (loadtime) // superclass
//@import com/ibm/rave/core/color/Colors (runtime) // Colors, lab_rgb, newRGB, lab_hcl
//@import com/ibm/rave/core/internal/color/ContrastShift (runtime) // updateColor
/**
 * The LAB color model is a three axis color system and LAB colors are absolute, meaning that the color is exact. It’s what’s known as device independent; meaning that the LAB color space is the only way to communicate different colors across different devices. LAB color is a three axis system. The first axis, the L-channel or Lightness, goes up and down the 3D color model and it consists of white to black – and all of your gray colors will be exactly right down the center. All neutral colors will be relatively in the center of this axis. The A axis, goes from cyan color across to magenta/red color. And the B axis goes from blue to yellow.
 */
var com_ibm_rave_core_color_LAB = rave_externs["LAB"] = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_color_Color, {

	/**
	 * @expose  
	 */
	l : 0,

	/**
	 * @expose  
	 */
	a : 0,

	/**
	 * @expose  
	 */
	b : 0,

	constructor : function(l, a, b) {
		this.l = + (l);
		this.a = + (a);
		this.b = + (b);
	},

	/** @expose */ 
	rgb : function() {
		return com_ibm_rave_core_color_Colors.lab_rgb(this.l, this.a, this.b);
	},

	/** @expose */ 
	brighter$1 : function(k) {
		return new com_ibm_rave_core_color_LAB(Math.min(100, this.l + com_ibm_rave_core_color_Colors.lab_K * (k)), this.a, this.b);
	},

	/** @expose */ 
	darker$1 : function(k) {
		return new com_ibm_rave_core_color_LAB(Math.max(0, this.l - com_ibm_rave_core_color_Colors.lab_K * (k)), this.a, this.b);
	},

	hcl : function() {
		return com_ibm_rave_core_color_Colors.lab_hcl(this.l, this.a, this.b);
	},

	/**
	 * A getter for the L-channel/Lightness value
	 * @return (double)  the L-channel value
	 */
	/** @expose */ 
	getL : function() {
		return this.l;
	},

	/**
	 * A getter for the A-channel value
	 * @return (double)  the A-channel value
	 */
	/** @expose */ 
	getA : function() {
		return this.a;
	},

	/**
	 * A getter for the B-channel value
	 * @return (double)  the B-channel value
	 */
	/** @expose */ 
	getB : function() {
		return this.b;
	},

	contrastShift$0 : function() {
		return com_ibm_rave_core_internal_color_ContrastShift.updateColor$0(this.rgb(), this.rgb()).lab();
	},

	contrastShift$1 : function(color) {
		return com_ibm_rave_core_internal_color_ContrastShift.updateColor$0(this.rgb(), com_ibm_rave_core_color_Colors.newRGB(color)).lab();
	},

	contrastShift$2 : function(ratio) {
		return com_ibm_rave_core_internal_color_ContrastShift.updateColor$1(this.rgb(), this.rgb(), ratio).lab();
	},

	contrastShift$3 : function(color, ratio) {
		return com_ibm_rave_core_internal_color_ContrastShift.updateColor$1(this.rgb(), com_ibm_rave_core_color_Colors.newRGB(color), ratio).lab();
	},

	/** @expose */ 
	contrastShift : function(a0, a1) {
		var args = arguments;
		if (args.length == 0) {
			return this.contrastShift$0();
		}
		if (args.length == 1 && (a0 == null || typeof a0 === "number")) {
			return this.contrastShift$2(a0);
		}
		if (args.length == 1) {
			return this.contrastShift$1(a0);
		}
		return this.contrastShift$3(a0, a1);
	}
});


// $source: com/ibm/rave/core/color/HCL
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/color/Color (loadtime) // superclass
//@import com/ibm/rave/core/color/Colors (runtime) // Colors, newRGB, hcl_lab
//@import com/ibm/rave/core/internal/color/ContrastShift (runtime) // updateColor
/**
 * The Hue-Chroma-Luminance (HCL) color space is basically the cylindrical version of LUV color space. It is based on how the human eye perceives colors, where perceived difference between two colors is proportional to their Euclidean distance in color space. This special property, called perceptual uniformity, makes them ideal for accurate visual encoding of data.
 */
var com_ibm_rave_core_color_HCL = rave_externs["HCL"] = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_color_Color, {

	/**
	 * @expose  
	 */
	h : 0,

	/**
	 * @expose  
	 */
	c : 0,

	/**
	 * @expose  
	 */
	l : 0,

	constructor : function(h, c, l) {
		this.h = + (h);
		this.c = + (c);
		this.l = + (l);
	},

	/** @expose */ 
	rgb : function() {
		return this.lab().rgb();
	},

	/** @expose */ 
	brighter$1 : function(k) {
		return new com_ibm_rave_core_color_HCL(this.h, this.c, Math.min(100, this.l + com_ibm_rave_core_color_Colors.lab_K * (k)));
	},

	/** @expose */ 
	darker$1 : function(k) {
		return new com_ibm_rave_core_color_HCL(this.h, this.c, Math.max(0, this.l - com_ibm_rave_core_color_Colors.lab_K * (k)));
	},

	lab : function() {
		return com_ibm_rave_core_color_Colors.hcl_lab(this.h, this.c, this.l);
	},

	/**
	 * A getter for the hue value
	 * @return (double)  the hue value
	 */
	/** @expose */ 
	getH : function() {
		return this.h;
	},

	/**
	 * A getter for the chroma value
	 * @return (double)  the chroma value
	 */
	/** @expose */ 
	getC : function() {
		return this.c;
	},

	/**
	 * A getter for the luminance value
	 * @return (double)  the luminance value
	 */
	/** @expose */ 
	getL : function() {
		return this.l;
	},

	contrastShift$0 : function() {
		return com_ibm_rave_core_internal_color_ContrastShift.updateColor$0(this.rgb(), this.rgb()).lab().hcl();
	},

	contrastShift$1 : function(color) {
		return com_ibm_rave_core_internal_color_ContrastShift.updateColor$0(this.rgb(), com_ibm_rave_core_color_Colors.newRGB(color)).lab().hcl();
	},

	contrastShift$2 : function(ratio) {
		return com_ibm_rave_core_internal_color_ContrastShift.updateColor$1(this.rgb(), this.rgb(), ratio).lab().hcl();
	},

	contrastShift$3 : function(color, ratio) {
		return com_ibm_rave_core_internal_color_ContrastShift.updateColor$1(this.rgb(), com_ibm_rave_core_color_Colors.newRGB(color), ratio).lab().hcl();
	},

	/** @expose */ 
	contrastShift : function(a0, a1) {
		var args = arguments;
		if (args.length == 0) {
			return this.contrastShift$0();
		}
		if (args.length == 1 && (a0 == null || typeof a0 === "number")) {
			return this.contrastShift$2(a0);
		}
		if (args.length == 1) {
			return this.contrastShift$1(a0);
		}
		return this.contrastShift$3(a0, a1);
	}
});


// $source: com/ibm/rave/core/color/Colors
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/color/HSL (static) // new
//@import com/ibm/rave/core/color/RGB (static) // new
//@import com/ibm/rave/core/color/LAB (static) // new
//@import com/ibm/rave/core/color/HCL (static) // new
//@import com/ibm/rave/core/color/Color (static) // new
/**
 * A utility class with methods needed to create and different Color objects in different color spaces
 */
var com_ibm_rave_core_color_Colors = com_ibm_rave_core_nativeImpl_Declare({

	//constructor : function() {}
});

com_ibm_rave_core_color_Colors.initialize_rgb_names = function() {
	var rgb_names = {};
	rgb_names["aliceblue"] = com_ibm_rave_core_color_Colors.rgbNumber(0xf0f8ff);
	rgb_names["antiquewhite"] = com_ibm_rave_core_color_Colors.rgbNumber(0xfaebd7);
	rgb_names["aqua"] = com_ibm_rave_core_color_Colors.rgbNumber(0x00ffff);
	rgb_names["aquamarine"] = com_ibm_rave_core_color_Colors.rgbNumber(0x7fffd4);
	rgb_names["azure"] = com_ibm_rave_core_color_Colors.rgbNumber(0xf0ffff);
	rgb_names["beige"] = com_ibm_rave_core_color_Colors.rgbNumber(0xf5f5dc);
	rgb_names["bisque"] = com_ibm_rave_core_color_Colors.rgbNumber(0xffe4c4);
	rgb_names["black"] = com_ibm_rave_core_color_Colors.rgbNumber(0x000000);
	rgb_names["blanchedalmond"] = com_ibm_rave_core_color_Colors.rgbNumber(0xffebcd);
	rgb_names["blue"] = com_ibm_rave_core_color_Colors.rgbNumber(0x0000ff);
	rgb_names["blueviolet"] = com_ibm_rave_core_color_Colors.rgbNumber(0x8a2be2);
	rgb_names["brown"] = com_ibm_rave_core_color_Colors.rgbNumber(0xa52a2a);
	rgb_names["burlywood"] = com_ibm_rave_core_color_Colors.rgbNumber(0xdeb887);
	rgb_names["cadetblue"] = com_ibm_rave_core_color_Colors.rgbNumber(0x5f9ea0);
	rgb_names["chartreuse"] = com_ibm_rave_core_color_Colors.rgbNumber(0x7fff00);
	rgb_names["chocolate"] = com_ibm_rave_core_color_Colors.rgbNumber(0xd2691e);
	rgb_names["coral"] = com_ibm_rave_core_color_Colors.rgbNumber(0xff7f50);
	rgb_names["cornflowerblue"] = com_ibm_rave_core_color_Colors.rgbNumber(0x6495ed);
	rgb_names["cornsilk"] = com_ibm_rave_core_color_Colors.rgbNumber(0xfff8dc);
	rgb_names["crimson"] = com_ibm_rave_core_color_Colors.rgbNumber(0xdc143c);
	rgb_names["cyan"] = com_ibm_rave_core_color_Colors.rgbNumber(0x00ffff);
	rgb_names["darkblue"] = com_ibm_rave_core_color_Colors.rgbNumber(0x00008b);
	rgb_names["darkcyan"] = com_ibm_rave_core_color_Colors.rgbNumber(0x008b8b);
	rgb_names["darkgoldenrod"] = com_ibm_rave_core_color_Colors.rgbNumber(0xb8860b);
	rgb_names["darkgray"] = com_ibm_rave_core_color_Colors.rgbNumber(0xa9a9a9);
	rgb_names["darkgreen"] = com_ibm_rave_core_color_Colors.rgbNumber(0x006400);
	rgb_names["darkgrey"] = com_ibm_rave_core_color_Colors.rgbNumber(0xa9a9a9);
	rgb_names["darkkhaki"] = com_ibm_rave_core_color_Colors.rgbNumber(0xbdb76b);
	rgb_names["darkolivegreen"] = com_ibm_rave_core_color_Colors.rgbNumber(0x556b2f);
	rgb_names["darkorange"] = com_ibm_rave_core_color_Colors.rgbNumber(0xff8c00);
	rgb_names["darkorchid"] = com_ibm_rave_core_color_Colors.rgbNumber(0x9932cc);
	rgb_names["darkred"] = com_ibm_rave_core_color_Colors.rgbNumber(0x8b0000);
	rgb_names["darksalmon"] = com_ibm_rave_core_color_Colors.rgbNumber(0xe9967a);
	rgb_names["darkseagreen"] = com_ibm_rave_core_color_Colors.rgbNumber(0x8fbc8f);
	rgb_names["darkslateblue"] = com_ibm_rave_core_color_Colors.rgbNumber(0x483d8b);
	rgb_names["darkslategray"] = com_ibm_rave_core_color_Colors.rgbNumber(0x2f4f4f);
	rgb_names["darkslategrey"] = com_ibm_rave_core_color_Colors.rgbNumber(0x2f4f4f);
	rgb_names["darkturquoise"] = com_ibm_rave_core_color_Colors.rgbNumber(0x00ced1);
	rgb_names["darkviolet"] = com_ibm_rave_core_color_Colors.rgbNumber(0x9400d3);
	rgb_names["deeppink"] = com_ibm_rave_core_color_Colors.rgbNumber(0xff1493);
	rgb_names["deepskyblue"] = com_ibm_rave_core_color_Colors.rgbNumber(0x00bfff);
	rgb_names["dimgray"] = com_ibm_rave_core_color_Colors.rgbNumber(0x696969);
	rgb_names["dimgrey"] = com_ibm_rave_core_color_Colors.rgbNumber(0x696969);
	rgb_names["dodgerblue"] = com_ibm_rave_core_color_Colors.rgbNumber(0x1e90ff);
	rgb_names["firebrick"] = com_ibm_rave_core_color_Colors.rgbNumber(0xb22222);
	rgb_names["floralwhite"] = com_ibm_rave_core_color_Colors.rgbNumber(0xfffaf0);
	rgb_names["forestgreen"] = com_ibm_rave_core_color_Colors.rgbNumber(0x228b22);
	rgb_names["fuchsia"] = com_ibm_rave_core_color_Colors.rgbNumber(0xff00ff);
	rgb_names["gainsboro"] = com_ibm_rave_core_color_Colors.rgbNumber(0xdcdcdc);
	rgb_names["ghostwhite"] = com_ibm_rave_core_color_Colors.rgbNumber(0xf8f8ff);
	rgb_names["gold"] = com_ibm_rave_core_color_Colors.rgbNumber(0xffd700);
	rgb_names["goldenrod"] = com_ibm_rave_core_color_Colors.rgbNumber(0xdaa520);
	rgb_names["gray"] = com_ibm_rave_core_color_Colors.rgbNumber(0x808080);
	rgb_names["green"] = com_ibm_rave_core_color_Colors.rgbNumber(0x008000);
	rgb_names["greenyellow"] = com_ibm_rave_core_color_Colors.rgbNumber(0xadff2f);
	rgb_names["grey"] = com_ibm_rave_core_color_Colors.rgbNumber(0x808080);
	rgb_names["honeydew"] = com_ibm_rave_core_color_Colors.rgbNumber(0xf0fff0);
	rgb_names["hotpink"] = com_ibm_rave_core_color_Colors.rgbNumber(0xff69b4);
	rgb_names["indianred"] = com_ibm_rave_core_color_Colors.rgbNumber(0xcd5c5c);
	rgb_names["indigo"] = com_ibm_rave_core_color_Colors.rgbNumber(0x4b0082);
	rgb_names["ivory"] = com_ibm_rave_core_color_Colors.rgbNumber(0xfffff0);
	rgb_names["khaki"] = com_ibm_rave_core_color_Colors.rgbNumber(0xf0e68c);
	rgb_names["lavender"] = com_ibm_rave_core_color_Colors.rgbNumber(0xe6e6fa);
	rgb_names["lavenderblush"] = com_ibm_rave_core_color_Colors.rgbNumber(0xfff0f5);
	rgb_names["lawngreen"] = com_ibm_rave_core_color_Colors.rgbNumber(0x7cfc00);
	rgb_names["lemonchiffon"] = com_ibm_rave_core_color_Colors.rgbNumber(0xfffacd);
	rgb_names["lightblue"] = com_ibm_rave_core_color_Colors.rgbNumber(0xadd8e6);
	rgb_names["lightcoral"] = com_ibm_rave_core_color_Colors.rgbNumber(0xf08080);
	rgb_names["lightcyan"] = com_ibm_rave_core_color_Colors.rgbNumber(0xe0ffff);
	rgb_names["lightgoldenrodyellow"] = com_ibm_rave_core_color_Colors.rgbNumber(0xfafad2);
	rgb_names["lightgray"] = com_ibm_rave_core_color_Colors.rgbNumber(0xd3d3d3);
	rgb_names["lightgreen"] = com_ibm_rave_core_color_Colors.rgbNumber(0x90ee90);
	rgb_names["lightgrey"] = com_ibm_rave_core_color_Colors.rgbNumber(0xd3d3d3);
	rgb_names["lightpink"] = com_ibm_rave_core_color_Colors.rgbNumber(0xffb6c1);
	rgb_names["lightsalmon"] = com_ibm_rave_core_color_Colors.rgbNumber(0xffa07a);
	rgb_names["lightseagreen"] = com_ibm_rave_core_color_Colors.rgbNumber(0x20b2aa);
	rgb_names["lightskyblue"] = com_ibm_rave_core_color_Colors.rgbNumber(0x87cefa);
	rgb_names["lightslategray"] = com_ibm_rave_core_color_Colors.rgbNumber(0x778899);
	rgb_names["lightslategrey"] = com_ibm_rave_core_color_Colors.rgbNumber(0x778899);
	rgb_names["lightsteelblue"] = com_ibm_rave_core_color_Colors.rgbNumber(0xb0c4de);
	rgb_names["lightyellow"] = com_ibm_rave_core_color_Colors.rgbNumber(0xffffe0);
	rgb_names["lime"] = com_ibm_rave_core_color_Colors.rgbNumber(0x00ff00);
	rgb_names["limegreen"] = com_ibm_rave_core_color_Colors.rgbNumber(0x32cd32);
	rgb_names["linen"] = com_ibm_rave_core_color_Colors.rgbNumber(0xfaf0e6);
	rgb_names["magenta"] = com_ibm_rave_core_color_Colors.rgbNumber(0xff00ff);
	rgb_names["maroon"] = com_ibm_rave_core_color_Colors.rgbNumber(0x800000);
	rgb_names["mediumaquamarine"] = com_ibm_rave_core_color_Colors.rgbNumber(0x66cdaa);
	rgb_names["mediumblue"] = com_ibm_rave_core_color_Colors.rgbNumber(0x0000cd);
	rgb_names["mediumorchid"] = com_ibm_rave_core_color_Colors.rgbNumber(0xba55d3);
	rgb_names["mediumpurple"] = com_ibm_rave_core_color_Colors.rgbNumber(0x9370db);
	rgb_names["mediumseagreen"] = com_ibm_rave_core_color_Colors.rgbNumber(0x3cb371);
	rgb_names["mediumslateblue"] = com_ibm_rave_core_color_Colors.rgbNumber(0x7b68ee);
	rgb_names["mediumspringgreen"] = com_ibm_rave_core_color_Colors.rgbNumber(0x00fa9a);
	rgb_names["mediumturquoise"] = com_ibm_rave_core_color_Colors.rgbNumber(0x48d1cc);
	rgb_names["mediumvioletred"] = com_ibm_rave_core_color_Colors.rgbNumber(0xc71585);
	rgb_names["midnightblue"] = com_ibm_rave_core_color_Colors.rgbNumber(0x191970);
	rgb_names["mintcream"] = com_ibm_rave_core_color_Colors.rgbNumber(0xf5fffa);
	rgb_names["mistyrose"] = com_ibm_rave_core_color_Colors.rgbNumber(0xffe4e1);
	rgb_names["moccasin"] = com_ibm_rave_core_color_Colors.rgbNumber(0xffe4b5);
	rgb_names["navajowhite"] = com_ibm_rave_core_color_Colors.rgbNumber(0xffdead);
	rgb_names["navy"] = com_ibm_rave_core_color_Colors.rgbNumber(0x000080);
	rgb_names["oldlace"] = com_ibm_rave_core_color_Colors.rgbNumber(0xfdf5e6);
	rgb_names["olive"] = com_ibm_rave_core_color_Colors.rgbNumber(0x808000);
	rgb_names["olivedrab"] = com_ibm_rave_core_color_Colors.rgbNumber(0x6b8e23);
	rgb_names["orange"] = com_ibm_rave_core_color_Colors.rgbNumber(0xffa500);
	rgb_names["orangered"] = com_ibm_rave_core_color_Colors.rgbNumber(0xff4500);
	rgb_names["orchid"] = com_ibm_rave_core_color_Colors.rgbNumber(0xda70d6);
	rgb_names["palegoldenrod"] = com_ibm_rave_core_color_Colors.rgbNumber(0xeee8aa);
	rgb_names["palegreen"] = com_ibm_rave_core_color_Colors.rgbNumber(0x98fb98);
	rgb_names["paleturquoise"] = com_ibm_rave_core_color_Colors.rgbNumber(0xafeeee);
	rgb_names["palevioletred"] = com_ibm_rave_core_color_Colors.rgbNumber(0xdb7093);
	rgb_names["papayawhip"] = com_ibm_rave_core_color_Colors.rgbNumber(0xffefd5);
	rgb_names["peachpuff"] = com_ibm_rave_core_color_Colors.rgbNumber(0xffdab9);
	rgb_names["peru"] = com_ibm_rave_core_color_Colors.rgbNumber(0xcd853f);
	rgb_names["pink"] = com_ibm_rave_core_color_Colors.rgbNumber(0xffc0cb);
	rgb_names["plum"] = com_ibm_rave_core_color_Colors.rgbNumber(0xdda0dd);
	rgb_names["powderblue"] = com_ibm_rave_core_color_Colors.rgbNumber(0xb0e0e6);
	rgb_names["purple"] = com_ibm_rave_core_color_Colors.rgbNumber(0x800080);
	rgb_names["rebeccapurple"] = com_ibm_rave_core_color_Colors.rgbNumber(0x663399);
	rgb_names["red"] = com_ibm_rave_core_color_Colors.rgbNumber(0xff0000);
	rgb_names["rosybrown"] = com_ibm_rave_core_color_Colors.rgbNumber(0xbc8f8f);
	rgb_names["royalblue"] = com_ibm_rave_core_color_Colors.rgbNumber(0x4169e1);
	rgb_names["saddlebrown"] = com_ibm_rave_core_color_Colors.rgbNumber(0x8b4513);
	rgb_names["salmon"] = com_ibm_rave_core_color_Colors.rgbNumber(0xfa8072);
	rgb_names["sandybrown"] = com_ibm_rave_core_color_Colors.rgbNumber(0xf4a460);
	rgb_names["seagreen"] = com_ibm_rave_core_color_Colors.rgbNumber(0x2e8b57);
	rgb_names["seashell"] = com_ibm_rave_core_color_Colors.rgbNumber(0xfff5ee);
	rgb_names["sienna"] = com_ibm_rave_core_color_Colors.rgbNumber(0xa0522d);
	rgb_names["silver"] = com_ibm_rave_core_color_Colors.rgbNumber(0xc0c0c0);
	rgb_names["skyblue"] = com_ibm_rave_core_color_Colors.rgbNumber(0x87ceeb);
	rgb_names["slateblue"] = com_ibm_rave_core_color_Colors.rgbNumber(0x6a5acd);
	rgb_names["slategray"] = com_ibm_rave_core_color_Colors.rgbNumber(0x708090);
	rgb_names["slategrey"] = com_ibm_rave_core_color_Colors.rgbNumber(0x708090);
	rgb_names["snow"] = com_ibm_rave_core_color_Colors.rgbNumber(0xfffafa);
	rgb_names["springgreen"] = com_ibm_rave_core_color_Colors.rgbNumber(0x00ff7f);
	rgb_names["steelblue"] = com_ibm_rave_core_color_Colors.rgbNumber(0x4682b4);
	rgb_names["tan"] = com_ibm_rave_core_color_Colors.rgbNumber(0xd2b48c);
	rgb_names["teal"] = com_ibm_rave_core_color_Colors.rgbNumber(0x008080);
	rgb_names["thistle"] = com_ibm_rave_core_color_Colors.rgbNumber(0xd8bfd8);
	rgb_names["tomato"] = com_ibm_rave_core_color_Colors.rgbNumber(0xff6347);
	rgb_names["turquoise"] = com_ibm_rave_core_color_Colors.rgbNumber(0x40e0d0);
	rgb_names["violet"] = com_ibm_rave_core_color_Colors.rgbNumber(0xee82ee);
	rgb_names["wheat"] = com_ibm_rave_core_color_Colors.rgbNumber(0xf5deb3);
	rgb_names["white"] = com_ibm_rave_core_color_Colors.rgbNumber(0xffffff);
	rgb_names["whitesmoke"] = com_ibm_rave_core_color_Colors.rgbNumber(0xf5f5f5);
	rgb_names["yellow"] = com_ibm_rave_core_color_Colors.rgbNumber(0xffff00);
	rgb_names["yellowgreen"] = com_ibm_rave_core_color_Colors.rgbNumber(0x9acd32);
	return rgb_names;
};

/**
 * Create HSL for an RGB.  The HSL has the given alpha.
 * @param (double) r  Red (0-255)
 * @param (double) g  Green (0-255)
 * @param (double) b  Blue (0-255)
 * @param (double) a  Alpha (0.0-1.0)
 * @return (com.ibm.rave.core.color.HSL)  HSL HSL color
 */
com_ibm_rave_core_color_Colors.rgb_hsl = function(r, g, b, a) {
	var _r = r;
	var _g = g;
	var _b = b;
	var min = Math.min(Math.min(_r /= 255, _g /= 255), _b /= 255);
	var max = Math.max(Math.max(_r, _g), _b);
	var d = max - min;
	var h, s;
	var l = (max + min) / 2;
	if (d != 0) {
		s = l < .5 ? d / (max + min) : d / (2 - max - min);
		if (_r == max) {
			h = (_g - _b) / d + (_g < _b ? 6 : 0);
		} else if (_g == max) {
			h = (_b - _r) / d + 2;
		} else {
			h = (_r - _g) / d + 4;
		}
		h *= 60;
	} else {
		h = NaN;
		s = l > 0 && l < 1 ? 0 : h;
	}
	return new com_ibm_rave_core_color_HSL(h, s, l, a);
};

/**
 * Returns a hexadecimal string representation of an integer representing an RGB color specific channel (either r, g or b)
 * @param (int) v the RGB component (r,g, or b) to get the hex string for
 * @return (String)  the hex string for the RGB channel
 */
/** @expose */ 
com_ibm_rave_core_color_Colors.rgb_hex = function(v) {
	var _v = v;
	if (_v < 0) {
		_v = 0;
	} else if (_v > 255) {
		_v = 255;
	}
	return com_ibm_rave_core_color_Colors.hexDigits[(_v >> 4) & 0x0f] + com_ibm_rave_core_color_Colors.hexDigits[_v & 0x0f];
};

/**
 * Create an RGB color from HSL color values
 * @param (double) h the hue value
 * @param (double) s the saturation value
 * @param (double) l the lightness value
 * @param (double) a the alpha value
 * @return (com.ibm.rave.core.color.RGB)  the newly constructed RGB color
 */
/** @expose */ 
com_ibm_rave_core_color_Colors.hsl_rgb = function(h, s, l, a) {
	var _h = h;
	var _s = s;
	var _l = l;
	var m1, m2;
	_h = isNaN(_h) ? 0 : (_h %= 360) < 0 ? _h + 360 : _h;
	_s = isNaN(_s) ? 0 : _s < 0 ? 0 : _s > 1 ? 1 : _s;
	_l = _l < 0 ? 0 : _l > 1 ? 1 : _l;
	m2 = _l <= .5 ? _l * (1 + _s) : _l + _s - _l * _s;
	m1 = 2 * _l - m2;
	return new com_ibm_rave_core_color_RGB(Math.round(com_ibm_rave_core_color_Colors.normalizeHue(_h + 120, m1, m2) * 255), Math.round(com_ibm_rave_core_color_Colors.normalizeHue(_h, m1, m2) * 255), Math.round(com_ibm_rave_core_color_Colors.normalizeHue(_h - 120, m1, m2) * 255), a);
};

com_ibm_rave_core_color_Colors.normalizeHue = function(h, m1, m2) {
	var _h = h;
	if (_h > 360) {
		_h -= 360;
	} else if (_h < 0) {
		_h += 360;
	}
	if (_h < 60) {
		return m1 + (m2 - m1) * _h / 60;
	}
	if (_h < 180) {
		return m2;
	}
	if (_h < 240) {
		return m1 + (m2 - m1) * (240 - _h) / 60;
	}
	return m1;
};

com_ibm_rave_core_color_Colors.rgbNumber = function(value) {
	return new com_ibm_rave_core_color_RGB(value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff, 1.0);
};

com_ibm_rave_core_color_Colors.rgbString = function(value) {
	return com_ibm_rave_core_color_Colors.rgbNumber(value).toString();
};

com_ibm_rave_core_color_Colors.rgb_parseNumber = function(c) {
	var d = parseFloat(c);
	return c.charCodeAt(c.length - 1) == 37 ? Math.round(d * 2.55) : d;
};

com_ibm_rave_core_color_Colors.rgb_parse = function(format) {
	if (format == null || format.length == 0) {
		return new com_ibm_rave_core_color_RGB(0, 0, 0, 1.0);
	}
	var r = 0, g = 0, b = 0;
	var m1;
	var m2;
	var color;
	m1 = com_ibm_rave_core_color_Colors.REG_EXP.exec(format);
	if (m1 && m1.length > 0) {
		m2 = m1[2].split(new RegExp(","));
		if ("hsl" == m1[1]) {
			return new com_ibm_rave_core_color_HSL(parseFloat(m2[0]), parseFloat(m2[1].replace("%", "")) / 100, parseFloat(m2[2].replace("%", "")) / 100, 1.0);
		}
		if ("hsla" == m1[1]) {
			return new com_ibm_rave_core_color_HSL(parseFloat(m2[0]), parseFloat(m2[1].replace("%", "")) / 100, parseFloat(m2[2].replace("%", "")) / 100, parseFloat(m2[3]));
		}
		if ("rgba" == m1[1]) {
			return new com_ibm_rave_core_color_RGB(~~com_ibm_rave_core_color_Colors.rgb_parseNumber(m2[0]), ~~com_ibm_rave_core_color_Colors.rgb_parseNumber(m2[1]), ~~com_ibm_rave_core_color_Colors.rgb_parseNumber(m2[2]), com_ibm_rave_core_color_Colors.rgb_parseNumber(m2[3]));
		}
		if ("rgb" == m1[1]) {
			return new com_ibm_rave_core_color_RGB(~~com_ibm_rave_core_color_Colors.rgb_parseNumber(m2[0]), ~~com_ibm_rave_core_color_Colors.rgb_parseNumber(m2[1]), ~~com_ibm_rave_core_color_Colors.rgb_parseNumber(m2[2]), 1.0);
		}
	}
	if ((format.charCodeAt(0) != 35) && (color = com_ibm_rave_core_color_Colors.rgb_names[format.toLowerCase()])) {
		return new com_ibm_rave_core_color_RGB(color.r, color.g, color.b, 1.0);
	}
	var colorValue = 0;
	if (format.charCodeAt(0) == 35 && !(isNaN(colorValue = parseInt(format.substring(1), 16)))) {
		if (format.length == 4) {
			r = (colorValue & 0xf00) >> 4;
			r = (r >> 4) | r;
			g = (colorValue & 0xf0);
			g = (g >> 4) | g;
			b = (colorValue & 0xf);
			b = (b << 4) | b;
		} else if (format.length == 7) {
			r = (colorValue & 0xff0000) >> 16;
			g = (colorValue & 0xff00) >> 8;
			b = (colorValue & 0xff);
		}
	}
	return new com_ibm_rave_core_color_RGB(r, g, b, 1.0);
};

com_ibm_rave_core_color_Colors.rgb_lab = function(r, g, b) {
	var _r = r;
	var _g = g;
	var _b = b;
	_r = com_ibm_rave_core_color_Colors.rgb_xyz(_r);
	_g = com_ibm_rave_core_color_Colors.rgb_xyz(_g);
	_b = com_ibm_rave_core_color_Colors.rgb_xyz(_b);
	var x = com_ibm_rave_core_color_Colors.xyz_lab((0.4124564 * _r + 0.3575761 * _g + 0.1804375 * _b) / com_ibm_rave_core_color_Colors.lab_X);
	var y = com_ibm_rave_core_color_Colors.xyz_lab((0.2126729 * _r + 0.7151522 * _g + 0.0721750 * _b) / com_ibm_rave_core_color_Colors.lab_Y);
	var z = com_ibm_rave_core_color_Colors.xyz_lab((0.0193339 * _r + 0.1191920 * _g + 0.9503041 * _b) / com_ibm_rave_core_color_Colors.lab_Z);
	return new com_ibm_rave_core_color_LAB(116 * y - 16, 500 * (x - y), 200 * (y - z));
};

/**
 * Create an LAB color from HCL color values
 * @param (double) h the hue value
 * @param (double) c the chroma value
 * @param (double) l the luminance value
 * @return (com.ibm.rave.core.color.LAB)  the newly constructed LAB color
 */
/** @expose */ 
com_ibm_rave_core_color_Colors.hcl_lab = function(h, c, l) {
	var _h = h;
	var _c = c;
	if (isNaN(_h)) {
		_h = 0;
	}
	if (isNaN(_c)) {
		_c = 0;
	}
	return new com_ibm_rave_core_color_LAB(l, Math.cos(_h *= 0.017453292519943295) * _c, Math.sin(_h) * _c);
};

com_ibm_rave_core_color_Colors.xyz_lab = function(x) {
	return x > 0.008856 ? Math.pow(x, 1.0 / 3.0) : 7.787037 * x + 4.0 / 29.0;
};

com_ibm_rave_core_color_Colors.xyz_rgb = function(r) {
	return Math.round(255 * (r <= 0.00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - 0.055));
};

com_ibm_rave_core_color_Colors.rgb_xyz = function(r) {
	var _r = r;
	return (_r /= 255) <= 0.04045 ? _r / 12.92 : Math.pow((_r + 0.055) / 1.055, 2.4);
};

com_ibm_rave_core_color_Colors.lab_hcl = function(l, a, b) {
	return (l > 0) ? new com_ibm_rave_core_color_HCL(Math.atan2(b, a) * 57.29577951308232, Math.sqrt(a * a + b * b), l) : new com_ibm_rave_core_color_HCL(NaN, NaN, l);
};

/**
 * Create an RGB color from LAB color values
 * @param (double) l the L-channel (Lightness) value
 * @param (double) a the A-channel value
 * @param (double) b the B-channel value
 * @return (com.ibm.rave.core.color.RGB)  the newly constructed RGB color
 */
/** @expose */ 
com_ibm_rave_core_color_Colors.lab_rgb = function(l, a, b) {
	var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
	x = com_ibm_rave_core_color_Colors.lab_xyz(x) * com_ibm_rave_core_color_Colors.lab_X;
	y = com_ibm_rave_core_color_Colors.lab_xyz(y) * com_ibm_rave_core_color_Colors.lab_Y;
	z = com_ibm_rave_core_color_Colors.lab_xyz(z) * com_ibm_rave_core_color_Colors.lab_Z;
	return new com_ibm_rave_core_color_RGB(~~com_ibm_rave_core_color_Colors.xyz_rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z), ~~com_ibm_rave_core_color_Colors.xyz_rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z), ~~com_ibm_rave_core_color_Colors.xyz_rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z), 1.0);
};

com_ibm_rave_core_color_Colors.lab_xyz = function(x) {
	return x > 0.206893034 ? x * x * x : (x - 4.0 / 29.0) / 7.787037;
};

/**
 * Creates an LAB color object from its basic channel values
 * @param (double) l the L-channel (Lightness) value
 * @param (double) a the A-channe value
 * @param (double) b the B-channel value
 * @return (com.ibm.rave.core.color.LAB)  the newly constructed LAB color
 */
com_ibm_rave_core_color_Colors.newLAB$0 = function(l, a, b) {
	return new com_ibm_rave_core_color_LAB(l, a, b);
};

/**
 * Creates an LAB color object from the passed object This object could be one of the following: - LAB color, in which case a clone of it would be returned - RGB color - HCL color - A string which could be in one of the following formats: - RGB decimal - "rgb(255,255,255)" - HSL decimal - "hsl(120,50%,20%)" - RGB hexadecimal - "#ffeeaa" - RGB shorthand hexadecimal - "#fea" - named RGB- "red", "white", "blue"  If the object passed is none of the above,it will be coerced to a string (by calling toString() on it) and processed as such, and if the resulting string does not conform to any of the above formats, it will be considered as a string representation of RGB black color
 * @param (Object) color the object to use to create the LAB color object
 * @return (com.ibm.rave.core.color.LAB)  the newly constructed LAB color
 */
com_ibm_rave_core_color_Colors.newLAB$1 = function(color) {
	if (com_ibm_rave_core_nativeImpl_Object.isInstanceOf(color, com_ibm_rave_core_color_LAB)) {
		var lab = color;
		return new com_ibm_rave_core_color_LAB(lab.l, lab.a, lab.b);
	} else if (com_ibm_rave_core_nativeImpl_Object.isInstanceOf(color, com_ibm_rave_core_color_RGB)) {
		return (color).lab();
	} else if (com_ibm_rave_core_nativeImpl_Object.isInstanceOf(color, com_ibm_rave_core_color_HCL)) {
		return (color).lab();
	} else {
		return com_ibm_rave_core_color_Colors.rgb_parse((color == null) ? "" : color.toString()).rgb().lab();
	}
};

/**
 * Creates an HCL color object from its basic channel values
 * @param (double) h the hue value
 * @param (double) c the chroma value
 * @param (double) l the luminance value
 * @return (com.ibm.rave.core.color.HCL)  the newly constructed HCL color
 */
com_ibm_rave_core_color_Colors.newHCL$0 = function(h, c, l) {
	return new com_ibm_rave_core_color_HCL(h, c, l);
};

/**
 * Creates an HCL color object from the passed object This object could be one of the following: <ul> <li>HCL color, in which case a clone of it would be returned</li> <li>LAB color</li> <li>A string which could be in one of the following formats:</li> <ul> <li>RGB decimal - "rgb(255,255,255)"</li> <li>HSL decimal - "hsl(120,50%,20%)"</li> <li>RGB hexadecimal - "#ffeeaa"</li> <li>RGB shorthand hexadecimal - "#fea"</li> <li>named RGB- "red", "white", "blue"</li> </ul> </ul> If the object passed is none of the above, it will be coerced to a string (by calling toString() on it) and processed as such, and if the resulting string does not conform to any of the above formats, it will be considered as a string representation of RGB black color.
 * @param (Object) color the object to use to create the HCL color object
 * @return (com.ibm.rave.core.color.HCL)  the newly constructed HCL color
 */
com_ibm_rave_core_color_Colors.newHCL$1 = function(color) {
	if (com_ibm_rave_core_nativeImpl_Object.isInstanceOf(color, com_ibm_rave_core_color_HCL)) {
		var hcl = color;
		return new com_ibm_rave_core_color_HCL(hcl.h, hcl.c, hcl.l);
	} else if (com_ibm_rave_core_nativeImpl_Object.isInstanceOf(color, com_ibm_rave_core_color_LAB)) {
		return (color).hcl();
	} else {
		return com_ibm_rave_core_color_Colors.rgb_parse((color == null) ? "" : color.toString()).rgb().lab().hcl();
	}
};

/**
 * Creates an HSL color object from its basic channel values
 * @param (double) h the hue value
 * @param (double) s the saturation value
 * @param (double) l the lightness value
 * @return (com.ibm.rave.core.color.HSL)  the newly constructed HSL color
 */
com_ibm_rave_core_color_Colors.newHSL$0 = function(h, s, l) {
	return new com_ibm_rave_core_color_HSL(h, s, l, 1.0);
};

/**
 * Creates an HSL color object from its basic channel values including alpha.
 * @param (double) h the hue value
 * @param (double) s the saturation value
 * @param (double) l the lightness value
 * @param (double) a the alpha value
 * @return (com.ibm.rave.core.color.HSL)  the newly constructed HSL color
 */
/** @expose */ 
com_ibm_rave_core_color_Colors.newHSLA = function(h, s, l, a) {
	return new com_ibm_rave_core_color_HSL(h, s, l, a);
};

/**
 * Creates an HSL color object from the passed object This object could be one of the following: <ul> <li>HSL color, in which case a clone of it would be returned</li> <li>RGB color</li> <li>A string which could be in one of the following formats:</li> <ul> <li>RGB decimal - "rgb(255,255,255)"</li> <li>HSL decimal - "hsl(120,50%,20%)"</li> <li>RGB hexadecimal - "#ffeeaa"</li> <li>RGB shorthand hexadecimal - "#fea"</li> <li>named RGB- "red", "white", "blue"</li> </ul> </ul> If the object passed is none of the above, it will be coerced to a string (by calling toString() on it) and processed as such, and if the resulting string does not conform to any of the above formats, it will be considered as a string representation of RGB black color.
 * @param (Object) color the object to use to create the HSL color object
 * @return (com.ibm.rave.core.color.HSL)  the newly constructed HSL color
 */
com_ibm_rave_core_color_Colors.newHSL$1 = function(color) {
	if (com_ibm_rave_core_nativeImpl_Object.isInstanceOf(color, com_ibm_rave_core_color_HSL)) {
		var hsl = color;
		return new com_ibm_rave_core_color_HSL(hsl.h, hsl.s, hsl.l, hsl.a);
	} else if (com_ibm_rave_core_nativeImpl_Object.isInstanceOf(color, com_ibm_rave_core_color_RGB)) {
		return (color).hsl();
	} else {
		var c = com_ibm_rave_core_color_Colors.rgb_parse((color == null) ? "" : color.toString());
		if (com_ibm_rave_core_nativeImpl_Object.isInstanceOf(c, com_ibm_rave_core_color_HSL)) {
			return c;
		}
		return (c).hsl();
	}
};

/**
 * Creates an RGB color object from its basic channel values
 * @param (int) r the red value
 * @param (int) g the green value
 * @param (int) b the blue value
 * @return (com.ibm.rave.core.color.RGB)  the newly constructed RGB color
 */
com_ibm_rave_core_color_Colors.newRGB$0 = function(r, g, b) {
	return new com_ibm_rave_core_color_RGB(r, g, b, 1.0);
};

/**
 * Creates an RGBA color object from its basic channel values
 * @param (int) r the red value
 * @param (int) g the green value
 * @param (int) b the blue value
 * @param (double) a the alpha value
 * @return (com.ibm.rave.core.color.RGB)  the newly constructed RGB color
 */
/** @expose */ 
com_ibm_rave_core_color_Colors.newRGBA = function(r, g, b, a) {
	return new com_ibm_rave_core_color_RGB(r, g, b, a);
};

/**
 * Creates an RGB color object from the passed object. This object could be one of the following: <ul> <li>Any color object: RGB, HCL, LAB or HSL</li> <li>A string which could be in one of the following formats:</li> <ul> <li>RGB decimal - "rgb(255,255,255)"</li> <li>HSL decimal - "hsl(120,50%,20%)"</li> <li>RGB hexadecimal - "#ffeeaa"</li> <li>RGB shorthand hexadecimal - "#fea"</li> <li>named RGB- "red", "white", "blue"</li> </ul> </ul> If the object passed is none of the above, it will be coerced to a string (by calling toString() on it) and processed as such, and if the resulting string does not conform to any of the above formats, it will be considered as a string representation of RGB black color.
 * @param (Object) color the object to use to create the RGB color object
 * @return (com.ibm.rave.core.color.RGB)  the newly constructed RGB color. Returns 'black' color if parsing fails.
 */
com_ibm_rave_core_color_Colors.newRGB$1 = function(color) {
	if (com_ibm_rave_core_nativeImpl_Object.isInstanceOf(color, com_ibm_rave_core_color_Color)) {
		var rgb = (color).rgb();
		return new com_ibm_rave_core_color_RGB(rgb.r, rgb.g, rgb.b, rgb.a);
	}
	return com_ibm_rave_core_color_Colors.rgb_parse((color == null) ? "" : color.toString()).rgb();
};

/**
 * Checks whether a string is one of HTML color names (RGB colors)
 * @param (String) str the name of color to check
 * @return (boolean)  true if the name is an HTML color names, false otherwise
 */
/** @expose */ 
com_ibm_rave_core_color_Colors.isRGBColorName = function(str) {
	return com_ibm_rave_core_color_Colors.rgb_names.hasOwnProperty(str);
};

/** @expose */ 
com_ibm_rave_core_color_Colors.newLAB = function(a0, a1, a2) {
	var args = arguments;
	if (args.length == 1) {
		return com_ibm_rave_core_color_Colors.newLAB$1(a0);
	}
	return com_ibm_rave_core_color_Colors.newLAB$0(a0, a1, a2);
};

/** @expose */ 
com_ibm_rave_core_color_Colors.newHCL = function(a0, a1, a2) {
	var args = arguments;
	if (args.length == 1) {
		return com_ibm_rave_core_color_Colors.newHCL$1(a0);
	}
	return com_ibm_rave_core_color_Colors.newHCL$0(a0, a1, a2);
};

/** @expose */ 
com_ibm_rave_core_color_Colors.newHSL = function(a0, a1, a2) {
	var args = arguments;
	if (args.length == 1) {
		return com_ibm_rave_core_color_Colors.newHSL$1(a0);
	}
	return com_ibm_rave_core_color_Colors.newHSL$0(a0, a1, a2);
};

/** @expose */ 
com_ibm_rave_core_color_Colors.newRGB = function(a0, a1, a2) {
	var args = arguments;
	if (args.length == 1) {
		return com_ibm_rave_core_color_Colors.newRGB$1(a0);
	}
	return com_ibm_rave_core_color_Colors.newRGB$0(a0, a1, a2);
};

//com_ibm_rave_core_color_Colors.HSL_STR = "hsl";
//com_ibm_rave_core_color_Colors.HSLA_STR = "hsla";
//com_ibm_rave_core_color_Colors.RGB_STR = "rgb";
//com_ibm_rave_core_color_Colors.RGBA_STR = "rgba";
//com_ibm_rave_core_color_Colors.COMMA_STR = ",";
//com_ibm_rave_core_color_Colors.PERCENT_STR = "%";
//com_ibm_rave_core_color_Colors.EMPTY_STR = "";
com_ibm_rave_core_color_Colors.lab_X = 0.950470;
com_ibm_rave_core_color_Colors.lab_Y = 1;
com_ibm_rave_core_color_Colors.lab_Z = 1.088830;
com_ibm_rave_core_color_Colors.lab_K = 18;

com_ibm_rave_core_color_Colors.REG_EXP = new RegExp("([a-z]+)\\((.*)\\)", "i");
com_ibm_rave_core_color_Colors.hexDigits = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
com_ibm_rave_core_color_Colors.rgb_names = com_ibm_rave_core_color_Colors.initialize_rgb_names();

// $source: com/ibm/rave/core/internal/color/ContrastShift
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/color/Colors (static) // newRGB
/**
 * The contrast API will either use the default contrast ratio or the ratio passed into the API. If the ratio passed into the API is not within the range of 1 - 21, the API will use the default contrast ratio of 4.5.  This API will first check to ensure that the contrast ratio provided with the colors provided is actually attainable. This is done by checking the  contrast ratio against both white and black.  If the contrast ratio is attainable, the API will shift the color until the contrast is met. If the ratio is not attainable, then we will return a  color which is at least greater than the default contrast ratio of 4.5.
 */
var com_ibm_rave_core_internal_color_ContrastShift = {

	/**
	 * Private constructor - cannot instantiate 
	 */
	//constructor : function() {}
};

/**
 * Calls the updateColor method using the default ratio of 4.5 
 * @param (com.ibm.rave.core.color.RGB) staticColor Refers to the color that will not be adjusted
 * @param (com.ibm.rave.core.color.RGB) nonStaticColor Refers to the color that will be adjusted to obtain the appropriate contrast ratio value
 * @return (com.ibm.rave.core.color.RGB)  A contrasting color
 */
com_ibm_rave_core_internal_color_ContrastShift.updateColor$0 = function(staticColor, nonStaticColor) {
	return com_ibm_rave_core_internal_color_ContrastShift.updateColor$1(staticColor, nonStaticColor, 4.5);
};

/**
 * Creates a new color which attains the contrast ratio specified by the user.  If the contrast ratio is not attainable or does not fall within the contrast ratio range of 1 - 21, a color with at least the default contrast ratio will be  returned 
 * @param (com.ibm.rave.core.color.RGB) staticColor Refers to the color that will not be adjusted
 * @param (com.ibm.rave.core.color.RGB) nonStaticColor Refers to the color that will be adjusted to obtain the appropriate contrast ratio value
 * @param (double) contrastRatio The contrast ratio to obtain. May be a value from 1 - 21. If a value other outside of the range is passed in, the default ratio of 4.5 will be applied
 * @return (com.ibm.rave.core.color.RGB)  A contrasting color
 */
com_ibm_rave_core_internal_color_ContrastShift.updateColor$1 = function(staticColor, nonStaticColor, contrastRatio) {
	var luminance1 = com_ibm_rave_core_internal_color_ContrastShift.getLuminance(nonStaticColor);
	var luminance2 = com_ibm_rave_core_internal_color_ContrastShift.getLuminance(staticColor);
	var ratio = com_ibm_rave_core_internal_color_ContrastShift.calculateRatio(luminance1, luminance2);
	var cRatio = contrastRatio;
	var color = nonStaticColor;
	if (cRatio < 1 || cRatio > 21) {
		cRatio = 4.5;
	}
	var contrastWhite = com_ibm_rave_core_internal_color_ContrastShift.calculateRatio(1.0, luminance2);
	var contrastBlack = com_ibm_rave_core_internal_color_ContrastShift.calculateRatio(0.0, luminance2);
	if (contrastWhite < cRatio && contrastBlack < cRatio) {
		return contrastWhite > contrastBlack ? com_ibm_rave_core_internal_color_ContrastShift.WHITE : com_ibm_rave_core_internal_color_ContrastShift.BLACK;
	}
	var step = 25 * (com_ibm_rave_core_internal_color_ContrastShift.moveDarker(luminance1, luminance2) ? -1 : 1);
	while (ratio < cRatio) {
		color = com_ibm_rave_core_internal_color_ContrastShift.shiftColor(color, step);
		luminance1 = com_ibm_rave_core_internal_color_ContrastShift.getLuminance(color);
		ratio = com_ibm_rave_core_internal_color_ContrastShift.calculateRatio(luminance1, luminance2);
		if ((luminance1 >= 1.0 || luminance1 <= 0.0) && ratio < cRatio) {
			color = nonStaticColor;
			step *= -1;
		}
	}
	return color;
};

/**
 * Determine if a color needs to be made darker.
 * @param (double) shiftingLuminance The shifting color's luminance.
 * @param (double) staticLuminance The static color's luminance.
 * @return (boolean)  true if the color needs to be darker, false otherwise.
 */
com_ibm_rave_core_internal_color_ContrastShift.moveDarker = function(shiftingLuminance, staticLuminance) {
	var darker = true;
	if (shiftingLuminance == staticLuminance) {
		darker = (shiftingLuminance - 0.5 >= 0) ? true : false;
	} else if (shiftingLuminance > staticLuminance) {
		darker = false;
	}
	return darker;
};

/**
 * Calculates and returns the luminance of a specific color
 * @param (com.ibm.rave.core.color.RGB) rgb The RGB color to attain the luminance of
 * @return (double)  the luminance value of the color passed in 
 */
com_ibm_rave_core_internal_color_ContrastShift.getLuminance = function(rgb) {
	return (0.2126 * com_ibm_rave_core_internal_color_ContrastShift.adjustColor(rgb.r / 255.0)) + (0.7152 * com_ibm_rave_core_internal_color_ContrastShift.adjustColor(rgb.g / 255.0)) + (0.0722 * com_ibm_rave_core_internal_color_ContrastShift.adjustColor(rgb.b / 255.0));
};

/**
 * Adjusts the color in order to calculate the relative luminance
 * @param (double) color Color value to adjust
 * @return (double)  The adjusted color value
 */
com_ibm_rave_core_internal_color_ContrastShift.adjustColor = function(color) {
	var adjustedColor = 0;
	if (color <= 0.03928) {
		adjustedColor = color / 12.92;
	} else {
		adjustedColor = Math.pow(((color + 0.055) / 1.055), 2.4);
	}
	return adjustedColor;
};

/**
 * Shifts the color by the specified amount and returns a new color object 
 * @param (com.ibm.rave.core.color.RGB) color The color we are shifting 
 * @param (int) amount The amount by which we are shifting the color 
 * @return (com.ibm.rave.core.color.RGB)  A new Color Object containing the new color after the shift is complete
 */
com_ibm_rave_core_internal_color_ContrastShift.shiftColor = function(color, amount) {
	var r = Math.max(0, Math.min(color.r + amount, 255));
	var g = Math.max(0, Math.min(color.g + amount, 255));
	var b = Math.max(0, Math.min(color.b + amount, 255));
	return com_ibm_rave_core_color_Colors.newRGB(r, g, b);
};

/**
 * Calculates and returns the contrast ratio using the luminance of both the colors it is contrasting against 
 * @param (double) l1 The luminance of the first color 
 * @param (double) l2 The luminance of the second color
 * @return (double)  The contrast ratio calculated 
 */
com_ibm_rave_core_internal_color_ContrastShift.calculateRatio = function(l1, l2) {
	if (l1 >= l2) {
		return (l1 + .05) / (l2 + .05);
	}
	return (l2 + .05) / (l1 + .05);
};

com_ibm_rave_core_internal_color_ContrastShift.updateColor = function(a0, a1, a2) {
	var args = arguments;
	if (args.length == 2) {
		return com_ibm_rave_core_internal_color_ContrastShift.updateColor$0(a0, a1);
	}
	return com_ibm_rave_core_internal_color_ContrastShift.updateColor$1(a0, a1, a2);
};

com_ibm_rave_core_internal_color_ContrastShift.DEFAULT_RATIO = 4.5;
com_ibm_rave_core_internal_color_ContrastShift.STEP = 25;
com_ibm_rave_core_internal_color_ContrastShift.MAX_RATIO = 21;
com_ibm_rave_core_internal_color_ContrastShift.MIN_RATIO = 1;
com_ibm_rave_core_internal_color_ContrastShift.BLACK_LUMINANCE = 0;
com_ibm_rave_core_internal_color_ContrastShift.WHITE_LUMINANCE = 1;

com_ibm_rave_core_internal_color_ContrastShift.BLACK = com_ibm_rave_core_color_Colors.newRGB(0, 0, 0);
com_ibm_rave_core_internal_color_ContrastShift.WHITE = com_ibm_rave_core_color_Colors.newRGB(255, 255, 255);

// $source: com/ibm/rave/core/interpolate/ColorInterpolation
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/Rave (runtime) // hcl, hsl, rgb, lab
//@import com/ibm/rave/core/color/Colors (runtime) // newRGBA, lab_rgb, hcl_lab, hsl_rgb
/**
 * A class that holds the various instances of color interpolator factories
 */
var com_ibm_rave_core_interpolate_ColorInterpolation = rave_externs["ColorInterpolation"] = com_ibm_rave_core_nativeImpl_Declare({


});

com_ibm_rave_core_interpolate_ColorInterpolation.HSLInterpolation = com_ibm_rave_core_nativeImpl_Declare({

	_$functionClassMethod : function() {
		var _$self = function(a, b) {
			var aColor = com_ibm_rave_core_Rave.hsl(a);
			var bColor = com_ibm_rave_core_Rave.hsl(b);
			var ah = aColor.h, as = aColor.s, al = aColor.l, bh = bColor.h - ah, bs = bColor.s - as, bl = bColor.l - al;
			if (isNaN(bs)) {
				bs = 0;
				as = isNaN(as) ? bColor.s : as;
			}
			if (isNaN(bh)) {
				bh = 0;
				ah = isNaN(ah) ? bColor.h : ah;
			} else if (bh > 180) {
				bh -= 360;
			} else if (bh < -180) {
				bh += 360;
			}
			var ahf = ah, bhf = bh, asf = as, bsf = bs, alf = al, blf = bl;
			var a_alpha = aColor.a;
			var b_alpha = bColor.a;
			return function(t) {
				var a = (a_alpha + ((b_alpha - a_alpha) * t));
				return com_ibm_rave_core_color_Colors.hsl_rgb(ahf + bhf * t, asf + bsf * t, alf + blf * t, a).toString();
			};
		};
		return _$self;
	}
});

com_ibm_rave_core_interpolate_ColorInterpolation.HCLInterpolation = com_ibm_rave_core_nativeImpl_Declare({

	_$functionClassMethod : function() {
		var _$self = function(a, b) {
			var aColor = com_ibm_rave_core_Rave.hcl(a);
			var bColor = com_ibm_rave_core_Rave.hcl(b);
			var ah = aColor.h, ac = aColor.c, al = aColor.l, bh = bColor.h - ah, bc = bColor.c - ac, bl = bColor.l - al;
			if (isNaN(bc)) {
				bc = 0;
				ac = isNaN(ac) ? bColor.c : ac;
			}
			if (isNaN(bh)) {
				bh = 0;
				ah = isNaN(ah) ? bColor.h : ah;
			} else if (bh > 180) {
				bh -= 360;
			} else if (bh < -180) {
				bh += 360;
			}
			var ahf = ah, bhf = bh, acf = ac, bcf = bc, alf = al, blf = bl;
			return function(t) {
				return com_ibm_rave_core_color_Colors.hcl_lab(ahf + bhf * t, acf + bcf * t, alf + blf * t).toString();
			};
		};
		return _$self;
	}
});

com_ibm_rave_core_interpolate_ColorInterpolation.LABInterpolation = com_ibm_rave_core_nativeImpl_Declare({

	_$functionClassMethod : function() {
		var _$self = function(a, b) {
			var aColor = com_ibm_rave_core_Rave.lab(a);
			var bColor = com_ibm_rave_core_Rave.lab(b);
			var al = aColor.l, aa = aColor.a, ab = aColor.b, bl = bColor.l - al, ba = bColor.a - aa, bb = bColor.b - ab;
			return function(t) {
				return com_ibm_rave_core_color_Colors.lab_rgb(al + bl * t, aa + ba * t, ab + bb * t).toString();
			};
		};
		return _$self;
	}
});

com_ibm_rave_core_interpolate_ColorInterpolation.RGBInterpolation = com_ibm_rave_core_nativeImpl_Declare({

	_$functionClassMethod : function() {
		var _$self = function(a, b) {
			var aColor = com_ibm_rave_core_Rave.rgb(a);
			var bColor = com_ibm_rave_core_Rave.rgb(b);
			var ar = aColor.r, ag = aColor.g, ab = aColor.b, br = bColor.r - ar, bg = bColor.g - ag, bb = bColor.b - ab;
			var a_alpha = aColor.a;
			var b_alpha = bColor.a;
			return function(t) {
				var r = Math.round(ar + br * t);
				var g = Math.round(ag + bg * t);
				var b = Math.round(ab + bb * t);
				var a = (a_alpha + ((b_alpha - a_alpha) * t));
				return com_ibm_rave_core_color_Colors.newRGBA(r, g, b, a).toString();
			};
		};
		return _$self;
	}
});

/**
 * An HSL interpolator factory that returns an HSL color space interpolator between the two colors a and b. The colors a and b need not be in HSL, but they will be converted to HSL using Rave.hsl(Object). The hue, saturation and lightness are interpolated linearly in a manner equivalent to interpolateNumber.(The shortest path between the start and end hue is used.) The return value of the interpolator is a hexadecimal RGB string.
 */
/** @expose */ 
com_ibm_rave_core_interpolate_ColorInterpolation.HSLINSTANCE = new com_ibm_rave_core_interpolate_ColorInterpolation.HSLInterpolation();
/**
 * An HCL interpolator factory that returns an HCL color space interpolator between the two colors a and b. The colors a and b will be converted to HCL if necessary using Rave.hcl(Object). The color channels are then interpolated linearly in a manner equivalent to interpolateNumber. (The shortest path between the start and end hue is used.) The return value of the interpolator is a hexadecimal RGB string.
 */
/** @expose */ 
com_ibm_rave_core_interpolate_ColorInterpolation.HCLINSTANCE = new com_ibm_rave_core_interpolate_ColorInterpolation.HCLInterpolation();
/**
 * An LAB interpolator factory that returns a LAB color space interpolator between the two colors a and b. The colors a and b will be converted to LAB if necessary using Rave.lab(Object). The color channels are then interpolated linearly in a manner equivalent to interpolateNumber. The return value of the interpolator is a hexadecimal RGB string.
 */
/** @expose */ 
com_ibm_rave_core_interpolate_ColorInterpolation.LABINSTANCE = new com_ibm_rave_core_interpolate_ColorInterpolation.LABInterpolation();
/**
 * An RGB interpolator factory that returns an RGB color space interpolator between the two colors a and b. The colors a and b need not be in RGB, but they will be converted to RGB using Rave.rgb(Object) The red, green and blue channels are interpolated linearly in a manner equivalent to interpolateRound, as fractional channel values are not allowed. The return value of the interpolator is a hexadecimal RGB string. If alpha is not equal to 1, then an rgba(r,g,b,a) string is returned instead.
 */
/** @expose */ 
com_ibm_rave_core_interpolate_ColorInterpolation.RGBINSTANCE = new com_ibm_rave_core_interpolate_ColorInterpolation.RGBInterpolation();

// $source: com/ibm/rave/core/interpolate/StringInterpolation
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/interpolate/NumberInterpolation (runtime) // NumberInterpolation
var com_ibm_rave_core_interpolate_StringInterpolation = rave_externs["StringInterpolation"] = com_ibm_rave_core_nativeImpl_Declare({

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * Creates an interpolator that will interpolate all numbers found within the start end values.
		 * @param (Object) a the start value
		 * @param (Object) b the end value
		 * @return (com.ibm.rave.core.interpolate.Interpolator)  a new interpolator
		 */
		function(a, b) {
			var are = com_ibm_rave_core_interpolate_StringInterpolation.aRegExp, bre = com_ibm_rave_core_interpolate_StringInterpolation.bRegExp;
			are["lastIndex"] = bre["lastIndex"] = 0;
			var ax = a + "", bx = b + "";
			var ls = [];
			var lq = [];
			var bs;
			var bi = 0, i = -1, bsi;
			var am;
			var bm;
			while ((am = are.exec(ax)) && (bm = bre.exec(bx))) {
				if ((bsi = bm.index) > bi) {
					bs = bx.substring(bi, bsi);
					var tmp = (i >= 0 && i < ls.length) ? ls[i] : null;
					if (tmp != null) {
						ls[i] = tmp + bs;
					} else {
						ls.push(bs);
						i++;
					}
				}
				if (am[0] == bm[0]) {
					var tmp = (i > 0 && i < ls.length) ? ls[i] : null;
					if (tmp != null) {
						ls[i] = tmp + bm[0];
					} else {
						ls.push(bm[0]);
						i++;
					}
				} else {
					ls.push(null);
					i++;
					lq.push(new com_ibm_rave_core_interpolate_StringInterpolation.IndexInterpolator(i, com_ibm_rave_core_interpolate_NumberInterpolation.INSTANCE(am[0], bm[0])));
				}
				bi = bre["lastIndex"];
			}
			if (bi < bx.length) {
				bs = bx.substring(bi);
				var tmp = (i > 0 && i < ls.length) ? ls[i] : null;
				if (tmp != null) {
					ls[i] = tmp + bs;
				} else {
					ls.push(bs);
					i++;
				}
			}
			if (ls.length < 2) {
				if (lq.length > 0) {
					var lq0Interpolator = lq[0].x;
					return function(t) {
						return lq0Interpolator(t) + "";
					};
				}
				var fb = bx;
				return function(t) {
					return fb;
				};
			}
			var lqSize = lq.length;
			return function(t) {
				var o;
				for (var i = 0; i < lqSize; ++i) {
					ls[(o = lq[i]).i] = o.x(t);
				}
				return ls.join("");
			};
		};
		return _$self;
	}
});

com_ibm_rave_core_interpolate_StringInterpolation.IndexInterpolator = function(i, interpolator) {
	this.i = i;
	this.x = interpolator;
};

/** @expose */ 
com_ibm_rave_core_interpolate_StringInterpolation.INSTANCE = new com_ibm_rave_core_interpolate_StringInterpolation();
com_ibm_rave_core_interpolate_StringInterpolation.aRegExp = new RegExp("[-+]?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]?\\d+)?", "g");
com_ibm_rave_core_interpolate_StringInterpolation.bRegExp = new RegExp(com_ibm_rave_core_interpolate_StringInterpolation.aRegExp["source"], "g");

// $source: com/ibm/rave/core/interpolate/NumberInterpolation
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
var com_ibm_rave_core_interpolate_NumberInterpolation = com_ibm_rave_core_nativeImpl_Declare({

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * Creates an interpolator that can interpolate a number between the start and end value.
		 * @param (Object) a the start value
		 * @param (Object) b the end value
		 * @return (com.ibm.rave.core.interpolate.Interpolator)  q new interpolator
		 */
		function(a, b) {
			var da = + (a);
			var db = + (b);
			return function(t) {
				return da * (1 - t) + db * t;
			};
		};
		return _$self;
	}

	//constructor : function() {}
});

/** @expose */ 
com_ibm_rave_core_interpolate_NumberInterpolation.INSTANCE = new com_ibm_rave_core_interpolate_NumberInterpolation();

// $source: com/ibm/rave/core/interpolate/ArrayInterpolation
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/interpolate/Interpolators (runtime) // Interpolators
var com_ibm_rave_core_interpolate_ArrayInterpolation = rave_externs["ArrayInterpolation"] = com_ibm_rave_core_nativeImpl_Declare({

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * Returns an array interpolator between the two arrays a and b. Internally, an array template is created that is the same length in b. For each element in b, if there exists a corresponding element in a, a generic interpolator is created for the two elements using interpolate. If there is no such element, the static value from b is used in the template. Then, for the given parameter t, the template's embedded interpolators are evaluated. The updated array template is then returned.  For example, if a is the array [0, 1] and b is the array [1, 10, 100], then the result  of the interpolator for t = .5 is the array [.5, 5.5, 100]. Note: no defensive copy of the template array is created; modifications of the returned array may adversely affect subsequent evaluation of the interpolator. No copy is made because interpolators should be fast, as they are part of the inner loop of animation.
		 * @param (java.lang.Object[]) a the first array
		 * @param (java.lang.Object[]) b the second array
		 * @return (com.ibm.rave.core.interpolate.Interpolator)  the new interpolator
		 */
		function(a, b) {
			var na = a.length;
			var nb = b.length;
			var n0 = Math.min(na, nb);
			var i = 0;
			var x = [];
			var c = [];
			for (i = 0; i < n0; ++i) {
				x[i] = com_ibm_rave_core_interpolate_Interpolators.INSTANCE.getInterpolator(a[i], b[i]);
			}
			for (; i < na; ++i) {
				c[i] = a[i];
			}
			for (; i < nb; ++i) {
				c[i] = b[i];
			}
			return function(t) {
				for (var index = 0; index < n0; ++index) {
					c[index] = x[index](t);
				}
				return c;
			};
		};
		return _$self;
	}
});

/** @expose */ 
com_ibm_rave_core_interpolate_ArrayInterpolation.INSTANCE = new com_ibm_rave_core_interpolate_ArrayInterpolation();

// $source: com/ibm/rave/core/interpolate/TransformInterpolation
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/nativeImpl/math/TransformParser (runtime) // create
//@import com/ibm/rave/core/interpolate/NumberInterpolation (runtime) // NumberInterpolation
var com_ibm_rave_core_interpolate_TransformInterpolation = com_ibm_rave_core_nativeImpl_Declare({

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * Returns an interpolator between the two 2D affine transforms represented  by a and b. Each transform is decomposed to a standard representation of translate,  rotate, x-skew and scale; these component transformations are then interpolated. This  behavior is standardized by CSS
		 * @param  Object  a - a String object
		 * @param  Object  b - a String object
		 */
		function(a, b) {
			var s = [];
			var q = [];
			var aTransform = com_ibm_rave_core_nativeImpl_math_TransformParser.create(a);
			var bTransform = com_ibm_rave_core_nativeImpl_math_TransformParser.create(b);
			var ta = aTransform.translate;
			var tb = bTransform.translate;
			var ra = aTransform.rotate;
			var rb = bTransform.rotate;
			var wa = aTransform.skew;
			var wb = bTransform.skew;
			var ka = aTransform.scale;
			var kb = bTransform.scale;
			var n;
			if (ta[0] != tb[0] || ta[1] != tb[1]) {
				s.push("translate(");
				s.push(null);
				s.push(",");
				s.push(null);
				s.push(")");
				var x0 = com_ibm_rave_core_interpolate_NumberInterpolation.INSTANCE(ta[0], tb[0]);
				var InterpolatedValue0 = new com_ibm_rave_core_interpolate_TransformInterpolation.InterpolatedValue(1, x0);
				q.push(InterpolatedValue0);
				var x1 = com_ibm_rave_core_interpolate_NumberInterpolation.INSTANCE(ta[1], tb[1]);
				var InterpolatedValue1 = new com_ibm_rave_core_interpolate_TransformInterpolation.InterpolatedValue(3, x1);
				q.push(InterpolatedValue1);
			} else if (tb[0] != 0 || tb[1] != 0) {
				s.push("translate(" + tb[0] + "," + tb[1] + ")");
			} else {
				s.push("");
			}
			if (ra != rb) {
				if (ra - rb > 180) {
					rb += 360;
				} else if (rb - ra > 180) {
					ra += 360;
				}
				s.push("rotate(");
				s.push(null);
				s.push(")");
				var i = s.length - 2;
				var x = com_ibm_rave_core_interpolate_NumberInterpolation.INSTANCE(ra, rb);
				var InterpolatedValue = new com_ibm_rave_core_interpolate_TransformInterpolation.InterpolatedValue(i, x);
				q.push(InterpolatedValue);
			} else if (rb != 0) {
				s.push("rotate(" + rb + ")");
			}
			if (wa != wb) {
				s.push("skewX(");
				s.push(null);
				s.push(")");
				var i = s.length - 2;
				var x = com_ibm_rave_core_interpolate_NumberInterpolation.INSTANCE(wa, wb);
				var InterpolatedValue = new com_ibm_rave_core_interpolate_TransformInterpolation.InterpolatedValue(i, x);
				q.push(InterpolatedValue);
			} else if (wb != 0) {
				s.push("skewX(" + wb + ")");
			}
			if (ka[0] != kb[0] || ka[1] != kb[1]) {
				s.push("scale(");
				s.push(null);
				s.push(",");
				s.push(null);
				s.push(")");
				n = s.length;
				var x0 = com_ibm_rave_core_interpolate_NumberInterpolation.INSTANCE(ka[0], kb[0]);
				var InterpolatedValue0 = new com_ibm_rave_core_interpolate_TransformInterpolation.InterpolatedValue(n - 4, x0);
				q.push(InterpolatedValue0);
				var x1 = com_ibm_rave_core_interpolate_NumberInterpolation.INSTANCE(ka[1], kb[1]);
				var InterpolatedValue1 = new com_ibm_rave_core_interpolate_TransformInterpolation.InterpolatedValue(n - 2, x1);
				q.push(InterpolatedValue1);
			} else if (kb[0] != 1 || kb[1] != 1) {
				s.push("scale(" + kb[0] + "," + kb[1] + ")");
			}
			n = q.length;
			var nFinal = n;
			var sFinal = s;
			var qFinal = q;
			return function(t) {
				if (t == 1) {
					return bTransform.toString();
				}
				var i = 0;
				var o;
				while (i < nFinal) {
					o = qFinal[i];
					sFinal[o.i] = o.x(t).toString();
					i++;
				}
				var transformString = "";
				for (var __i_enFor0 = 0, __exp_enFor0 = sFinal, __len_enFor0 = __exp_enFor0.length;
						__i_enFor0 < __len_enFor0; ++__i_enFor0) {
					var tS = __exp_enFor0[__i_enFor0];
					transformString += tS;
				}
				return transformString;
			};
		};
		return _$self;
	}

	//constructor : function() {}
});

com_ibm_rave_core_interpolate_TransformInterpolation.InterpolatedValue = com_ibm_rave_core_nativeImpl_Declare({

	//x : null,

	i : 0,

	constructor : function(i, x) {
		this.i = i;
		this.x = x;
	}
});

/** @expose */ 
com_ibm_rave_core_interpolate_TransformInterpolation.INSTANCE = new com_ibm_rave_core_interpolate_TransformInterpolation();

// $source: com/ibm/rave/core/internal/nativeImpl/scene/DOMSceneNode
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2014, 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/

// @import com/ibm/rave/core/nativeImpl/Declare
// @import com/ibm/rave/core/nativeImpl/format/Requote
// @import com/ibm/rave/core/nativeImpl/Object
// @import com/ibm/rave/core/scene/SceneNodeType
// @import com/ibm/rave/core/transform/MatrixUtil

/**
 * Represents all DOM nodes.
 */
(function () {

    function classed(domNode, className, add) {
        // split given className into an array
        var classes = className.match(/\S+/g) || [];
        if (classes.length) {
            // mimic node.className which is always a string value
            var domClassName = domNode.getAttribute("class") || "";
            // create a string where each value is separated by a single space
            // and contains spaces at the beginning and end to help with indexOf searches
            var newClassName = (domClassName ? (" " + domClassName + " ").replace(/[\t\r\n\f]/g, " ") : " ");
            for (var i = 0; i < classes.length; i++) {
                var clazz = classes[i];
                if (add) {
                    // add
                    if (newClassName.indexOf(" " + clazz + " ") < 0) {
                        // append to end
                        newClassName += clazz + " ";
                    }
                } else {
                    // remove
                    if (newClassName.indexOf(" " + clazz + " ") >= 0) {
                        // replace with empty space
                        newClassName = newClassName.replace(" " + clazz + " ", " ");
                    }
                }
            }

            // trim beginning and end spaces
            // assumes string#trim exists
            newClassName = newClassName ? newClassName.trim() : "";
            if (domClassName !== newClassName) {
                domNode.setAttribute("class", newClassName);
                return true;
            }
        } else {
            return true;
        }
        return false;
    }

    var protoExt = {

        _rave_isDOM: true,

        /** @expose */
        rave_getOwner: function () {
            // SVG node
            if ("http://www.w3.org/2000/svg" == this.namespaceURI) {
                var svgOwner = this.ownerSVGElement;
                if (svgOwner) {
                    svgOwner = svgOwner["__owner__"] || svgOwner;
                } else {
                    svgOwner = this["__owner__"];
                }
                // TODO do we need to extend the node here?
                return svgOwner || this;
            }
            // DOM node
            return this;
        },

        /** @expose */
        rave_setOwner: function (owner) {
            this["__owner__"] = owner;
        },

        /** @expose */
        rave_getParentNode: function (owner) {
            return this.parentNode;
        },

        /** @expose */
        rave_appendChild: function (node) {
            if (node._rave_isDOM) {
                this.appendChild(node);
            }
        },

        /** @expose */
        rave_insertBefore: function (node, before) {
            if (node._rave_isDOM) {
                this.insertBefore(node, before);
            }
        },

        /** @expose */
        rave_setStyle: function (style, value, priority) {
            this.style.setProperty(style, value, priority);
        },

        /** @expose */
        rave_getStyle: function (style) {
            return this.style.getPropertyValue(style);
        },

        /** @expose */
        rave_removeStyle: function (style) {
            this.style.removeProperty(style);
        },

        /** @expose */
        rave_setText: function (text) {
            this.textContent = text;
        },

        /** @expose */
        rave_getText: function () {
            return this.textContent;
        },

        /** @expose */
        rave_setHtml: function (html) {
            this.innerHTML = html;
        },

        /** @expose */
        rave_getHtml: function () {
            return this.innerHTML;
        },

        /** @expose */
        rave_getComputedStyle: function (style) {
            return rave_window(this).getComputedStyle(this).getPropertyValue(style);
        },

        /** @expose */
        rave_getComputedStyles: function () {
            return rave_window(this).getComputedStyle(this);
        },

        /** @expose */
        rave_containsClass: function (className) {
            var check = className.match(/\S+/g);
            if (check && check.length) {
                var classList = this.classList;
                if (classList && classList.length) {
                    for (var i = 0; i < check.length; ++i) {
                        if (!classList.contains(check[i])) {
                            return false;
                        }
                    }
                    return true;
                } else {
                    classList = (this.getAttribute("class") || "").match(/\S+/g);
                    if (classList && classList.length) {
                        for (var i = 0; i < check.length; ++i) {
                            if (classList.indexOf(check[i]) == -1) {
                                return false;
                            }
                        }
                        return true;
                    }
                }
                return false;
            }
            return true;
        },

        /** @expose */
        rave_addClass: function (className) {
            return classed(this, className, true);
        },

        /** @expose */
        rave_removeClass: function (className) {
            return classed(this, className, false);
        },

        /** @expose */
        rave_getEventListener: function (eventType) {
            return this["__on" + eventType];
        },

        /** @expose */
        rave_addEventListener: function (eventType, listener, useCapture, group) {
            var domNode = this,
                name = "__on" + eventType + (group != null ? "." + group : ""),
                existing = domNode[name];

            if (existing) {
                // remove existing listener
                domNode.removeEventListener(eventType, existing, existing.__useCapture);
            }

            listener.__useCapture = useCapture;

            // storing properties on the dom node is slower
            domNode[name] = listener;

            domNode.addEventListener(eventType, listener, useCapture);
        },

        /** @expose */
        rave_removeEventListener: function (eventType, group) {
            var domNode = this,
                name = "__on" + eventType + (group != null ? "." + group : ""),
                l = domNode[name];
            if (l) {
                domNode.removeEventListener(eventType, l, l.__useCapture);
                delete domNode[name];
            }
        },

        /** @expose */
        rave_removeEventListeners: function (group) {
            if (group != null) {
                group = "\." + com_ibm_rave_core_nativeImpl_format_Requote.requote(group);
            }
            var domNode = this,
                re = new RegExp("^__on([^.]+)" + group + "$"),
                match;
            for (var name in domNode) {
                if (match = name.match(re)) {
                    var l = domNode[name];
                    domNode.removeEventListener(match[1], l, l.__useCapture);
                    delete domNode[name];
                }
            }
        },

        /** @expose */
        rave_setData: function (newData) {
            this["__data__"] = newData;
        },

        /** @expose */
        rave_getData: function () {
            return this["__data__"];
        },

        /** @expose */
        rave_hasData: function () {
            return "__data__" in this;
        },

        /** @expose */
        rave_setProperty: function (key, value) {
            if (value == null) {
                delete this[key];
            } else {
                this[key] = value;
            }
        },

        /** @expose */
        rave_getProperty: function (key) {
            return this[key];
        },

        /** @expose */
        rave_hasProperty: function (propName) {
            return propName in this;
        },

        /** @expose */
        rave_getNextSibling: function () {
            return this.nextElementSibling;
        },

        /** @expose */
        rave_getPreviousSibling: function () {
            return this.previousElementSibling;
        },

        /** @expose */
        rave_getFirstChild: function () {
            if (this.hasChildNodes()) {
                var children = this.childNodes;
                for (var i = 0; i < children.length; i++) {
                    if (children[i].nodeType == 1) {
                        return children[i];
                    }
                }
            }
        },

        /** @expose */
        rave_hasChildNodes: function () {
            if (this.hasChildNodes()) {
                var children = this.childNodes;
                for (var i = 0; i < children.length; i++) {
                    if (children[i].nodeType == 1) {
                        return true;
                    }
                }
            }
            return false;
        },

        /** @expose */
        rave_getChildNodes: function () {
            if (this.hasChildNodes()) {
                var result = [],
                    children = this.childNodes;
                for (var i = 0; i < children.length; i++) {
                    if (children[i].nodeType == 1) {
                        result.push(children[i]);
                    }
                }
                return result;
            }
            return this.childNodes;
        },

        /** @expose */
        rave_getName: function () {
            return this.nodeName;
        },

        /** @expose */
        rave_getNamespaceURI: function () {
            return this.namespaceURI;
        },

        /** @expose */
        rave_getQualifiedName: function () {
            return this.namespaceURI + ":" + this.nodeName;
        },

        /** @expose */
        rave_getNodeType: function () {
            return this.nodeType;
        },

        /** @expose */
        rave_initExtensions: function () {
            // no extensions by default
        },

        /** @expose */
        rave_getDrawType: function () {
            // This is a list of internally supported node types. Only SVG nodes are supported here, not DOM nodes of any kind.
            // TODO - we cannot determine the difference between line, circle and other path shapes in SVG since they are all <path> nodes
            // TODO - do we need to tell the difference between these? 
            // TODO - currently this is only used in Mirroring to determine if a node is a group node.
            switch (this.nodeName) {
            case "text":
                return com_ibm_rave_core_scene_SceneNodeType.TEXT;
            case "image":
                return com_ibm_rave_core_scene_SceneNodeType.IMAGE;
            case "#text":
                return com_ibm_rave_core_scene_SceneNodeType.TEXT_CONTENT;
            case "g":
                return com_ibm_rave_core_scene_SceneNodeType.GROUP;
            case "rect":
                return com_ibm_rave_core_scene_SceneNodeType.RECT;
            default:
                return com_ibm_rave_core_scene_SceneNodeType.UNKNOWN;
            }
        },

        // TODO Firefox does not support svg#checkIntersection or svg#getIntersectionList

        /** @expose */
        rave_intersects: function (x, y) {

            // This API can be called in two ways (rect) or (x,y)
            var rect = y ? null : x;

            var root = this.rave_getProperty("__rave_canvas_root__");
            if (root) {
                // If we don't have a y, just pass in x which will be a rect.
                return rect ? root.rave_intersects(rect) : root.rave_intersects(x, y);
            }
            var owner = this.rave_getOwner();

            if (rect) {
                // assume x is a rect object
                rect = getSVGRect(owner, this, x.x, x.y, x.width, x.height);
            } else {
                rect = getSVGRect(owner, this, x, y, 1, 1);
            }
            return rect ? owner.checkIntersection(this, rect) : false;
        },

        /** @expose */
        rave_intersectionList: function (x, y) {
            // This API can be called in two ways (rect) or (x,y)
            var rect = y ? null : x;

            var root = this.rave_getProperty("__rave_canvas_root__");
            if (root) {
                // If we don't have a y, just pass in x which will be a rect.
                return !y ? root.rave_intersectionList(x) : root.rave_intersectionList(x, y);
            }
            var owner = this.rave_getOwner();

            if (rect) {
                // assume x is a rect object
                rect = getSVGRect(owner, this, x.x, x.y, x.width, x.height);
            } else {
                rect = getSVGRect(owner, this, x, y, 1, 1);
            }
            return rect ? owner.getIntersectionList(rect, this) : [];
        },

        /** @expose */
        rave_intersection: function (x, y) {
            return this.rave_intersectionList(x, y)[0];
        },

        /** @expose */
        rave_dispose: function () {
            var canvasRoot = this.rave_getProperty("__rave_canvas_root__");
            if (canvasRoot) {
                canvasRoot.dispose();
            }
        }
    };

    // converts a point or rect to an svg rect, applying the transform of the node's computed matrix
    function getSVGRect(owner, node, x, y, width, height) {
        var rect = x,
            ctm, x2, y2, tmp = x;

        if (owner && !(rect instanceof SVGRect)) {
            if (arguments.length == 6) {
                tmp = {};
                tmp.width = width;
                tmp.height = height;
                tmp.x = x;
                tmp.y = y;
            }

            if (ctm = node.getCTM()) {
                tmp = com_ibm_rave_core_transform_MatrixUtil.transformBounds(tmp, ctm);
            }

            // create an SVG rect
            rect = owner.createSVGRect();
            rect.x = tmp.x;
            rect.y = tmp.y;
            rect.width = tmp.width;
            rect.height = tmp.height;
        }
        return rect;
    }

    var type;

    var raveWindow = rave_window(global);
    if (rave_document && raveWindow) {
        // extend iframe prototype
        if (raveWindow.frameElement) {
            com_ibm_rave_core_nativeImpl_Object.mixin(Object.getPrototypeOf(raveWindow.frameElement), protoExt);
        }

        // extend window prototype
        com_ibm_rave_core_nativeImpl_Object.mixin(Object.getPrototypeOf(raveWindow), protoExt);

        // extend document prototype
        com_ibm_rave_core_nativeImpl_Object.mixin(((type = raveWindow["Document"]) ? type.prototype : type) || Object.getPrototypeOf(document), protoExt);

        // extend DOM element and SVG prototypes
        com_ibm_rave_core_nativeImpl_Object.mixin(((type = raveWindow["Node"]) ? type.prototype : type) ||
            Object.getPrototypeOf(rave_document.body),
            protoExt);

        com_ibm_rave_core_nativeImpl_Object.mixin(((type = (raveWindow["SVGElement"] || raveWindow["SVGGraphicsElement"])) ? type.prototype : type) ||
            Object.getPrototypeOf(rave_document.createElementNS("http://www.w3.org/2000/svg", "svg")),
            protoExt);
    }
})();
// $source: com/ibm/rave/core/internal/nativeImpl/selector/DOMSelectionQueryEngine
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2014, 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/

// @import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
/**
 * A CSS3 selection query engine for DOM nodes.
 * @author  sproulja
 */
var com_ibm_rave_core_internal_nativeImpl_selector_DOMSelectionQueryEngine = com_ibm_rave_core_nativeImpl_Declare({

	matches : (function() {
		if (rave_document) {
			var documentElement = rave_documentElement(rave_document);
			var matches = documentElement.matches || documentElement[vendorSymbol(documentElement, "matchesSelector")]
			return function(context, selectorString) {
				if (! context.nodeType) {
					return false; // This is not a DOM node. Could be a Rave internal scene node.
				}
				return matches.call(context, selectorString);
			};
		}
	})(),
	
	querySelector : function(query, rootNode) {
		return (rootNode || rave_document).querySelector(query);
	},
	
	querySelectorAll : function(query, rootNode) {
		return (rootNode || rave_document).querySelectorAll(query);
	}
});


// $source: com/ibm/rave/core/internal/selector/mirror/MirrorConstants
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
/**
 * Simple class that holds property names for mirrored nodes.
 * @author  jim
 */
var com_ibm_rave_core_internal_selector_mirror_MirrorConstants = com_ibm_rave_core_nativeImpl_Declare({


});

/**
 * all mirrored items get this property to signify that they are mirrored for future selections 
 */
com_ibm_rave_core_internal_selector_mirror_MirrorConstants.MIRRORED_PROPERTY = "__rave-mirrored__";
/**
 * grouping nodes for text and images get this property 
 */
com_ibm_rave_core_internal_selector_mirror_MirrorConstants.MIRRORED_GROUP_PROPERTY = "__rave-mirrored-group__";
/**
 * This is a property flag used to determine if we want 'raw' access to a node Used when creating 'wrapping' mirroring groups around a node. When appending, we want the 'real' nodes, not the filtered ones. 
 */
com_ibm_rave_core_internal_selector_mirror_MirrorConstants.RAW_NODE_ACCESS_PROPERTY = "__rave-raw-node-access__";
/**
 * Property used to hold the 'group' wrapping node reference. Used on 'owner' (svg) nodes. 
 */
com_ibm_rave_core_internal_selector_mirror_MirrorConstants.GROUP_NODE_PROPERTY = "__rave-group-node-property__";
/**
 * Property used to hold the 'parent' wrapping node reference - used on Text and Image nodes. 
 */
com_ibm_rave_core_internal_selector_mirror_MirrorConstants.PARENT_WRAPPING_NODE_PROPERTY = "__rave-parent-wrapping-node-property__";
/**
 * Property set on wrapping groups under owner nodes, or other group nodes. These nodes contain the main scale(-1,1) transform on them - they do the mirroring work.
 */
com_ibm_rave_core_internal_selector_mirror_MirrorConstants.MIRRORED_OWNER_GROUP_NODE_PROPERTY = "__rave-owner-group-node-property__";
/**
 * The original transform applied to a node by an external source.
 */
com_ibm_rave_core_internal_selector_mirror_MirrorConstants.ORIGINAL_TRANSFORM = "__rave-original-transform__";


// $source: com/ibm/rave/core/internal/selector/mirror/MirrorUtil
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/selector/mirror/MirrorConstants (static) // MirrorConstants
/**
 * Helper methods to determine properties on scene nodes for mirroring. 
 * @author  jim
 */
var com_ibm_rave_core_internal_selector_mirror_MirrorUtil = com_ibm_rave_core_nativeImpl_Declare({


});

/**
 * Is the passed node mirrored or not. Determines based on a special attribute set on the node. 
 * @return (boolean)  is this node mirrored
 */
com_ibm_rave_core_internal_selector_mirror_MirrorUtil.isMirrored = function(node) {
	return (node.rave_getProperty(com_ibm_rave_core_internal_selector_mirror_MirrorConstants.MIRRORED_PROPERTY));
};

/**
 * Helper static utility to determine if the passed item is a wrapping group node. This means a wrapping
 * @param (com.ibm.rave.core.scene.SceneNode) node SceneNode that may or may not be a wrapping group node.
 * @return (boolean) <code>true</code> if item is a mirrored group node, <code>false</code> otherwise.
 */
com_ibm_rave_core_internal_selector_mirror_MirrorUtil.isGroupNode = function(node) {
	return node && ((node.rave_getProperty(com_ibm_rave_core_internal_selector_mirror_MirrorConstants.MIRRORED_GROUP_PROPERTY)) || com_ibm_rave_core_internal_selector_mirror_MirrorUtil.isOwnerGroupNode(node));
};

/**
 * Helper static utility to determine if the passed node is a group underneath an owner node. This is the primary mirroring group node (with the Scale(-1,1) transform).
 * @param (com.ibm.rave.core.scene.SceneNode) node Check if this node is a wrapping group node under an owner.
 * @return (boolean) <code>true</code> if this node is an 'owner' grouping node. <code>false</code> otherwise.
 */
com_ibm_rave_core_internal_selector_mirror_MirrorUtil.isOwnerGroupNode = function(node) {
	return node && ((node.rave_getProperty(com_ibm_rave_core_internal_selector_mirror_MirrorConstants.MIRRORED_OWNER_GROUP_NODE_PROPERTY)));
};

com_ibm_rave_core_internal_selector_mirror_MirrorUtil.isWrappableNode = function(node) {
	var drawType = node.rave_getDrawType();
	return drawType == 1003 || drawType == 1007;
};

com_ibm_rave_core_internal_selector_mirror_MirrorUtil.isGroupOrOwnerNode = function(node) {
	return node == node.rave_getOwner() || node.rave_getDrawType() == 1004;
};

/**
 * Set raw node on this node. Actually sets raw node for the entire tree starting at this node's owner node. Raw node is used to bypass additional logic in mirrored nodes that recognizes group nodes that are only used for mirroring - these are typically ignored.
 * @param (com.ibm.rave.core.scene.SceneNode) node  
 * @param (boolean) value  
 */
com_ibm_rave_core_internal_selector_mirror_MirrorUtil.setRawNode = function(node, value) {
	node.rave_getOwner().rave_setProperty(com_ibm_rave_core_internal_selector_mirror_MirrorConstants.RAW_NODE_ACCESS_PROPERTY, value ? value : null);
};

/**
 * Determine if 'raw' node is enabled for this node's owner hierarchy. Raw node is used to bypass additional logic in mirrored nodes that recognizes group nodes that are only used for mirroring - these are typically ignored.
 * @param (com.ibm.rave.core.scene.SceneNode) node Node to check 
 * @return (boolean)  
 */
com_ibm_rave_core_internal_selector_mirror_MirrorUtil.isRawMode = function(node) {
	return ((node.rave_getOwner().rave_getProperty(com_ibm_rave_core_internal_selector_mirror_MirrorConstants.RAW_NODE_ACCESS_PROPERTY)));
};


// $source: com/ibm/rave/core/internal/selector/mirror/OwnerMirroredSceneNodeHelper
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/selector/mirror/MirrorConstants (static) // MirrorConstants
//@import com/ibm/rave/core/internal/nativeImpl/scene/SceneNodeUtil (runtime) // getOwnerBoundingClientRect
//@import com/ibm/rave/core/internal/selector/mirror/MirrorUtil (static) // setRawNode
//@import com/ibm/rave/core/selector/Selector (runtime) // new
/**
 * An "owner" scene node is one that contains a wrapping group node that performs the primary mirroring transform. These are typically created on 'svg' or 'canvas', etc nodes but may also be added to arbitrary group nodes. For instance, when mirroring a full svg node, the resulting tree looks like: &lt;svg>&lt;g "data-rave-mirror-owner"="true"&gt;{ children }&lt;/g&gt;&lt;/svg&gt;
 * @author  jim
 */
var com_ibm_rave_core_internal_selector_mirror_OwnerMirroredSceneNodeHelper = com_ibm_rave_core_nativeImpl_Declare({


});

com_ibm_rave_core_internal_selector_mirror_OwnerMirroredSceneNodeHelper.mirror = function(node) {
	if (!((node.rave_getProperty(com_ibm_rave_core_internal_selector_mirror_MirrorConstants.GROUP_NODE_PROPERTY)))) {
		var wrappingGroup = com_ibm_rave_core_internal_selector_mirror_OwnerMirroredSceneNodeHelper.createWrappingGroup(node);
		node.rave_setProperty(com_ibm_rave_core_internal_selector_mirror_MirrorConstants.GROUP_NODE_PROPERTY, wrappingGroup);
		com_ibm_rave_core_internal_selector_mirror_OwnerMirroredSceneNodeHelper.update(node);
	}
};

/**
 * Update the group node with new transform information.
 * @param (com.ibm.rave.core.scene.SceneNode) node
 */
com_ibm_rave_core_internal_selector_mirror_OwnerMirroredSceneNodeHelper.update = function(node) {
	var group = node.rave_getProperty(com_ibm_rave_core_internal_selector_mirror_MirrorConstants.GROUP_NODE_PROPERTY);
	if (group != null) {
		var translateWidth = com_ibm_rave_core_internal_nativeImpl_scene_SceneNodeUtil.getOwnerBoundingClientRect(node).width;
		(group).setAttribute("transform", "translate(" + translateWidth + ",0)" + " scale(-1,1)");
	}
};

com_ibm_rave_core_internal_selector_mirror_OwnerMirroredSceneNodeHelper.unmirror = function(node) {
	var group = node.rave_getProperty(com_ibm_rave_core_internal_selector_mirror_MirrorConstants.GROUP_NODE_PROPERTY);
	if (group != null) {
		var groupNode = group;
		com_ibm_rave_core_internal_selector_mirror_MirrorUtil.setRawNode(groupNode, true);
		groupNode.rave_setProperty(com_ibm_rave_core_internal_selector_mirror_MirrorConstants.MIRRORED_GROUP_PROPERTY, null);
		for (var __i_enFor0 = 0, __exp_enFor0 = groupNode.rave_getChildNodes(), __len_enFor0 = __exp_enFor0.length;
				__i_enFor0 < __len_enFor0; ++__i_enFor0) {
			var child = __exp_enFor0[__i_enFor0];
			node.rave_appendChild(child);
		}
		node.removeChild(groupNode);
		com_ibm_rave_core_internal_selector_mirror_MirrorUtil.setRawNode(groupNode, false);
	}
	node.rave_setProperty(com_ibm_rave_core_internal_selector_mirror_MirrorConstants.MIRRORED_PROPERTY, null);
	node.rave_setProperty(com_ibm_rave_core_internal_selector_mirror_MirrorConstants.GROUP_NODE_PROPERTY, null);
};

/**
 * Create our main wrapping group around this owner node. For a mirrored svg node, we'll create something like this: <svg><g transform="scale(-1,1)"/><child nodes></svg>
 * @return (com.ibm.rave.core.scene.SceneNode) new wrapping group node
 */
com_ibm_rave_core_internal_selector_mirror_OwnerMirroredSceneNodeHelper.createWrappingGroup = function(node) {
	com_ibm_rave_core_internal_selector_mirror_MirrorUtil.setRawNode(node, true);
	var existingChildren = [];
	for (var __i_enFor0 = 0, __exp_enFor0 = node.rave_getChildNodes(), __len_enFor0 = __exp_enFor0.length;
			__i_enFor0 < __len_enFor0; ++__i_enFor0) {
		var child = __exp_enFor0[__i_enFor0];
		existingChildren.push(child);
	}
	com_ibm_rave_core_internal_selector_mirror_MirrorUtil.setRawNode(node, false);
	var group = new com_ibm_rave_core_selector_Selector().init(node).append("g");
	group.property(com_ibm_rave_core_internal_selector_mirror_MirrorConstants.MIRRORED_GROUP_PROPERTY, true);
	group.property(com_ibm_rave_core_internal_selector_mirror_MirrorConstants.MIRRORED_OWNER_GROUP_NODE_PROPERTY, true);
	group.property(com_ibm_rave_core_internal_selector_mirror_MirrorConstants.MIRRORED_PROPERTY, true);
	var groupNode = group.node();
	com_ibm_rave_core_internal_selector_mirror_MirrorUtil.setRawNode(groupNode, true);
	for (var __i_enFor1 = 0, __exp_enFor1 = existingChildren, __len_enFor1 = __exp_enFor1.length;
			__i_enFor1 < __len_enFor1; ++__i_enFor1) {
		var child = __exp_enFor1[__i_enFor1];
		groupNode.rave_appendChild(child);
	}
	com_ibm_rave_core_internal_selector_mirror_MirrorUtil.setRawNode(groupNode, false);
	return groupNode;
};


// $source: com/ibm/rave/core/geom/RaveRect
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
/**
 * A class that describes a Rectangular shape in a non-native way. Immutable. Uses doubles as coordinates.
 * @author  jim
 */
var com_ibm_rave_core_geom_RaveRect = rave_externs["RaveRect"] = com_ibm_rave_core_nativeImpl_Declare({

	/** @expose */ 
	x : 0,

	/** @expose */ 
	y : 0,

	/** @expose */ 
	width : 0,

	/** @expose */ 
	height : 0,

	/** @expose */ 
	constructor : function(x, y, width, height) {
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
	},

	/** @expose */ 
	getX : function() {
		return this.x;
	},

	/** @expose */ 
	getX2 : function() {
		return this.x + this.width;
	},

	/** @expose */ 
	getY : function() {
		return this.y;
	},

	/** @expose */ 
	getY2 : function() {
		return this.y + this.height;
	},

	/** @expose */ 
	getWidth : function() {
		return this.width;
	},

	/** @expose */ 
	getHeight : function() {
		return this.height;
	}
});


// $source: com/ibm/rave/core/internal/selector/mirror/WrappedMirroredSceneNodeHelper
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/selector/mirror/MirrorConstants (static) // MirrorConstants
//@import com/ibm/rave/core/internal/selector/mirror/MirrorUtil (static) // setRawNode
//@import com/ibm/rave/core/selector/Selector (runtime) // new
//@import com/ibm/rave/core/geom/RaveRect (static) // new
/**
 * Helper methods for working with 'wrapped' mirrored scene nodes. These are nodes like text and image nodes that when mirrored are wrapped inside a parent wrapping group.  
 * @author  jim
 */
var com_ibm_rave_core_internal_selector_mirror_WrappedMirroredSceneNodeHelper = com_ibm_rave_core_nativeImpl_Declare({


});

com_ibm_rave_core_internal_selector_mirror_WrappedMirroredSceneNodeHelper.mirror = function(node) {
	var wrappingGroup = com_ibm_rave_core_internal_selector_mirror_WrappedMirroredSceneNodeHelper.createWrappingGroup(node);
	node.rave_setProperty(com_ibm_rave_core_internal_selector_mirror_MirrorConstants.PARENT_WRAPPING_NODE_PROPERTY, wrappingGroup);
};

/**
 * Remove the wrapping parent node from this node, causing it to be 'un' mirrored.
 */
com_ibm_rave_core_internal_selector_mirror_WrappedMirroredSceneNodeHelper.unmirror = function(node) {
	var group = com_ibm_rave_core_internal_selector_mirror_WrappedMirroredSceneNodeHelper.findWrappingGroup(node);
	if (group) {
		group.rave_setProperty(com_ibm_rave_core_internal_selector_mirror_MirrorConstants.MIRRORED_GROUP_PROPERTY, null);
		var parent = group.rave_getParentNode();
		parent.rave_appendChild(node);
		parent.removeChild(group);
		node.rave_setProperty(com_ibm_rave_core_internal_selector_mirror_MirrorConstants.PARENT_WRAPPING_NODE_PROPERTY, null);
	}
};

/**
 * Create a wrapping group around this node. The wrapper will be something like this: &lt;g data-rave-mirrored="true" data-rave-mirrored-group="true" transform="translate(0,0) scale(-1,1)"> &lt;text y="18" dy=".71em" data-rave-mirrored="true" style="text-anchor: middle;"&gt;0&lt;/text&gt; &lt;/g&gt; This always returns a 'raw' node, not a MirroredSceneNode.
 */
com_ibm_rave_core_internal_selector_mirror_WrappedMirroredSceneNodeHelper.createWrappingGroup = function(child) {
	com_ibm_rave_core_internal_selector_mirror_MirrorUtil.setRawNode(child, true);
	var parent = child.rave_getParentNode();
	var group = new com_ibm_rave_core_selector_Selector().init(parent).append("g");
	com_ibm_rave_core_internal_selector_mirror_MirrorUtil.setRawNode(child, false);
	parent.rave_insertBefore(group.node(), child);
	var groupNode = group.node();
	com_ibm_rave_core_internal_selector_mirror_MirrorUtil.setRawNode(groupNode, true);
	group.property(com_ibm_rave_core_internal_selector_mirror_MirrorConstants.MIRRORED_GROUP_PROPERTY, true);
	groupNode.rave_appendChild(child);
	com_ibm_rave_core_internal_selector_mirror_MirrorUtil.setRawNode(groupNode, false);
	return groupNode;
};

/**
 * Return if this node has a wrapping group. These groups are currently applied to Text and Image nodes.
 * @return (com.ibm.rave.core.scene.SceneNode) SceneNode containing this node's wrapping group. Null if it doesn't have one.
 */
com_ibm_rave_core_internal_selector_mirror_WrappedMirroredSceneNodeHelper.findWrappingGroup = function(node) {
	var parentNode = node.rave_getProperty(com_ibm_rave_core_internal_selector_mirror_MirrorConstants.PARENT_WRAPPING_NODE_PROPERTY);
	if (parentNode != null) {
		return parentNode;
	}
	return null;
};

com_ibm_rave_core_internal_selector_mirror_WrappedMirroredSceneNodeHelper.update = function(node) {
	var wrappingGroup = node.rave_getProperty(com_ibm_rave_core_internal_selector_mirror_MirrorConstants.PARENT_WRAPPING_NODE_PROPERTY);
	com_ibm_rave_core_internal_selector_mirror_MirrorUtil.setRawNode(node, true);
	if (wrappingGroup != null) {
		var originalTransform = com_ibm_rave_core_internal_selector_mirror_WrappedMirroredSceneNodeHelper.determineOriginalTransform(node);
		var rect = null;
		try {
			rect = node.getBBox();
		} catch (e) {
			if (com_ibm_rave_core_nativeImpl_Object.isInstanceOf(e, Object)) {
				rect = new com_ibm_rave_core_geom_RaveRect(0, 0, 0, 0);
			} else {
				throw e;
			}
		}
		var translateAmount = rect.width + 2 * rect.x;
		node.setAttribute("transform", originalTransform + "  translate(" + translateAmount + ",0) scale(-1,1)");
	} else {
		var transform = com_ibm_rave_core_internal_selector_mirror_WrappedMirroredSceneNodeHelper.determineOriginalTransform(node);
		if (transform.length > 0) {
			node.setAttribute("transform", transform);
		} else {
			node.removeAttribute("transform");
		}
	}
	com_ibm_rave_core_internal_selector_mirror_MirrorUtil.setRawNode(node, false);
};

com_ibm_rave_core_internal_selector_mirror_WrappedMirroredSceneNodeHelper.determineOriginalTransform = function(node) {
	var origTransform = node.rave_getProperty(com_ibm_rave_core_internal_selector_mirror_MirrorConstants.ORIGINAL_TRANSFORM);
	var transform = "";
	if (origTransform != null) {
		transform = origTransform;
	} else {
		var trans = node.getAttribute("transform");
		transform = trans != null ? trans : "";
		node.rave_setProperty(com_ibm_rave_core_internal_selector_mirror_MirrorConstants.ORIGINAL_TRANSFORM, transform);
	}
	return transform;
};

com_ibm_rave_core_internal_selector_mirror_WrappedMirroredSceneNodeHelper.TRANSFORM = "transform";


// $source: com/ibm/rave/core/internal/selector/mirror/MirroredSceneNodeHelper
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/selector/mirror/MirrorConstants (static) // MirrorConstants
//@import com/ibm/rave/core/internal/selector/mirror/OwnerMirroredSceneNodeHelper (static) // unmirror, update, mirror
//@import com/ibm/rave/core/internal/selector/mirror/WrappedMirroredSceneNodeHelper (static) // unmirror, update, mirror
//@import com/ibm/rave/core/internal/selector/mirror/MirrorUtil (static) // isWrappableNode, isMirrored, isGroupOrOwnerNode
//@import com/ibm/rave/core/Configuration (static) // Configuration
/**
 * A static helper class that handles mirroring operations on existing SceneNodes. Includes static methods to mirror and un-mirror nodes and methods to retrieve special mirroring group nodes.
 * @author  jim
 */
var com_ibm_rave_core_internal_selector_mirror_MirroredSceneNodeHelper = com_ibm_rave_core_nativeImpl_Declare({


});

/**
 * Internal static method used to update mirroring positioning on a passed node. This only applies to those nodes that require special mirror wrapping.
 * @param (com.ibm.rave.core.scene.SceneNode) node
 */
com_ibm_rave_core_internal_selector_mirror_MirroredSceneNodeHelper.update = function(node) {
	if (!node) {
		return;
	}
	if ((node.rave_getProperty(com_ibm_rave_core_internal_selector_mirror_MirrorConstants.GROUP_NODE_PROPERTY))) {
		com_ibm_rave_core_internal_selector_mirror_OwnerMirroredSceneNodeHelper.update(node);
	} else {
		switch (node.rave_getDrawType()) {
		case 1003:
		case 1007:
			com_ibm_rave_core_internal_selector_mirror_WrappedMirroredSceneNodeHelper.update(node);
			break;
		default:
			break;
		}
	}
};

/**
 * Perform a mirroring operation on a passed in node.
 * @param (com.ibm.rave.core.scene.SceneNode) node The node to be mirrored.
 */
com_ibm_rave_core_internal_selector_mirror_MirroredSceneNodeHelper.mirrorNode = function(node) {
	if (!(com_ibm_rave_core_internal_selector_mirror_MirrorUtil.isMirrored(node))) {
		com_ibm_rave_core_Configuration.INSTANCE.extendRecursive(node);
		if (com_ibm_rave_core_internal_selector_mirror_MirrorUtil.isWrappableNode(node)) {
			com_ibm_rave_core_internal_selector_mirror_WrappedMirroredSceneNodeHelper.mirror(node);
		}
		node.rave_setProperty(com_ibm_rave_core_internal_selector_mirror_MirrorConstants.MIRRORED_PROPERTY, true);
	}
	for (var __i_enFor0 = 0, __exp_enFor0 = node.rave_getChildNodes(), __len_enFor0 = __exp_enFor0.length;
			__i_enFor0 < __len_enFor0; ++__i_enFor0) {
		var child = __exp_enFor0[__i_enFor0];
		com_ibm_rave_core_internal_selector_mirror_MirroredSceneNodeHelper.mirrorNode(child);
	}
	com_ibm_rave_core_internal_selector_mirror_MirroredSceneNodeHelper.update(node);
};

/**
 * Perform a mirroring operation at a 'root' owner or group node. Recursively mirrors all children.
 * @param (com.ibm.rave.core.scene.SceneNode) context The root node to start at.
 */
com_ibm_rave_core_internal_selector_mirror_MirroredSceneNodeHelper.mirrorRoot = function(context) {
	if (com_ibm_rave_core_internal_selector_mirror_MirrorUtil.isGroupOrOwnerNode(context)) {
		com_ibm_rave_core_Configuration.INSTANCE.extendRecursive(context);
		if (!(com_ibm_rave_core_internal_selector_mirror_MirrorUtil.isMirrored(context))) {
			com_ibm_rave_core_internal_selector_mirror_OwnerMirroredSceneNodeHelper.mirror(context);
			com_ibm_rave_core_internal_selector_mirror_MirroredSceneNodeHelper.mirrorNode(context);
		}
	}
};

/**
 * Perform an 'un' mirroring of the passed in node. Recursively removes all mirroring properties.
 * @param (com.ibm.rave.core.scene.SceneNode) node Node to recursively 'un'-mirror.
 */
com_ibm_rave_core_internal_selector_mirror_MirroredSceneNodeHelper.unMirrorNode = function(node) {
	if ((node.rave_getProperty(com_ibm_rave_core_internal_selector_mirror_MirrorConstants.GROUP_NODE_PROPERTY))) {
		com_ibm_rave_core_internal_selector_mirror_OwnerMirroredSceneNodeHelper.unmirror(node);
	} else if (com_ibm_rave_core_internal_selector_mirror_MirrorUtil.isWrappableNode(node)) {
		com_ibm_rave_core_internal_selector_mirror_WrappedMirroredSceneNodeHelper.unmirror(node);
	}
	node.rave_setProperty(com_ibm_rave_core_internal_selector_mirror_MirrorConstants.MIRRORED_PROPERTY, null);
	for (var __i_enFor0 = 0, __exp_enFor0 = node.rave_getChildNodes(), __len_enFor0 = __exp_enFor0.length;
			__i_enFor0 < __len_enFor0; ++__i_enFor0) {
		var child = __exp_enFor0[__i_enFor0];
		com_ibm_rave_core_internal_selector_mirror_MirroredSceneNodeHelper.unMirrorNode(child);
	}
	com_ibm_rave_core_internal_selector_mirror_MirroredSceneNodeHelper.update(node);
};


// $source: com/ibm/rave/core/internal/selector/mirror/MirroredSceneNodeExtension
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/Rave (runtime) // Rave
//@import com/ibm/rave/core/internal/selector/mirror/MirrorUtil (runtime) // isRawMode, isGroupNode, isMirrored, isOwnerGroupNode
//@import com/ibm/rave/core/internal/selector/mirror/MirroredSceneNodeHelper (runtime) // mirrorNode, update
//@import com/ibm/rave/core/internal/selector/mirror/MirrorConstants (runtime) // MirrorConstants
/**
 * Extensions for an 'owner' mirrored scene node. These are typically 'owner' nodes (SVG for example). Once mirrored, they contain a single group node with a mirroring transform.
 * @author  jim
 */
var com_ibm_rave_core_internal_selector_mirror_MirroredSceneNodeExtension = com_ibm_rave_core_nativeImpl_Declare({


});

/**
 * Extend this node to provide mirroring functionality.
 * @param (com.ibm.rave.core.scene.SceneNode) node Scene node to extend with mirroring
 */
com_ibm_rave_core_internal_selector_mirror_MirroredSceneNodeExtension.extend = function(node) {
	var origGetChildNodes = node.rave_getChildNodes;
	var origHasChildNodes = node.rave_hasChildNodes;
	var origRemoveChild = node.removeChild;
	var origGetParent = node.rave_getParentNode;
	var origAppendChild = node.appendChild;
	var origInsertBefore = node.insertBefore;
	var origGetNextSibling = node.rave_getNextSibling;
	var origGetPreviousSibling = node.rave_getPreviousSibling;
	var origGetFirstChild = node.rave_getFirstChild;
	var origSetTextExt = node.rave_setText;
	var origSetStyleExt = node.rave_setStyle;
	var origSetAttributeExt = node.setAttribute;
	var origGetScreenCTM = node.getScreenCTM;
	var origGetCTM = node.getCTM;
	node.appendChild = function(appendChild) {
		com_ibm_rave_core_Rave.configuration.extendRecursive(appendChild);
		if (com_ibm_rave_core_internal_selector_mirror_MirrorUtil.isRawMode(this)) {
			origAppendChild.call(this, appendChild);
		} else {
			var appendNode = this;
			var firstChild = origGetFirstChild.call(this);
			if (firstChild && com_ibm_rave_core_internal_selector_mirror_MirrorUtil.isOwnerGroupNode(firstChild)) {
				appendNode = firstChild;
			}
			origAppendChild.call(appendNode, appendChild);
			if (com_ibm_rave_core_internal_selector_mirror_MirrorUtil.isMirrored(this)) {
				com_ibm_rave_core_internal_selector_mirror_MirroredSceneNodeHelper.mirrorNode(appendChild);
			}
			com_ibm_rave_core_internal_selector_mirror_MirroredSceneNodeHelper.update(appendChild);
		}
	};
	node.insertBefore = function(insert, before) {
		com_ibm_rave_core_Rave.configuration.extendRecursive(insert);
		var parent = this;
		var beforeNode = before;
		if (com_ibm_rave_core_internal_selector_mirror_MirrorUtil.isRawMode(this)) {
			origInsertBefore.call(parent, insert, beforeNode);
		} else {
			var firstChild = origGetFirstChild.call(this);
			if (firstChild && com_ibm_rave_core_internal_selector_mirror_MirrorUtil.isOwnerGroupNode(firstChild)) {
				parent = firstChild;
			}
			if (beforeNode) {
				var wrappedNode = beforeNode.rave_getProperty(com_ibm_rave_core_internal_selector_mirror_MirrorConstants.PARENT_WRAPPING_NODE_PROPERTY);
				if (wrappedNode != null) {
					beforeNode = wrappedNode;
				}
			}
			origInsertBefore.call(parent, insert, beforeNode);
			if (com_ibm_rave_core_internal_selector_mirror_MirrorUtil.isMirrored(this)) {
				com_ibm_rave_core_internal_selector_mirror_MirroredSceneNodeHelper.mirrorNode(insert);
			}
			com_ibm_rave_core_internal_selector_mirror_MirroredSceneNodeHelper.update(insert);
		}
	};
	node.rave_getNextSibling = function() {
		var sibling = this;
		var wrappedNode = this.rave_getProperty(com_ibm_rave_core_internal_selector_mirror_MirrorConstants.PARENT_WRAPPING_NODE_PROPERTY);
		if (wrappedNode != null) {
			sibling = wrappedNode;
		}
		sibling = origGetNextSibling.call(sibling);
		return sibling;
	};
	node.rave_getPreviousSibling = function() {
		var sibling = this;
		var wrappedNode = this.rave_getProperty(com_ibm_rave_core_internal_selector_mirror_MirrorConstants.PARENT_WRAPPING_NODE_PROPERTY);
		if (wrappedNode != null) {
			sibling = wrappedNode;
		}
		sibling = origGetPreviousSibling.call(sibling);
		return sibling;
	};
	node.rave_getFirstChild = function() {
		var child = origGetFirstChild.call(this);
		if (child && com_ibm_rave_core_internal_selector_mirror_MirrorUtil.isGroupNode(child)) {
			child = child.rave_getFirstChild();
		}
		return child;
	};
	node.rave_hasChildNodes = function() {
		var wrappedNode = this.rave_getProperty(com_ibm_rave_core_internal_selector_mirror_MirrorConstants.GROUP_NODE_PROPERTY);
		if (wrappedNode != null) {
			return (wrappedNode).rave_hasChildNodes();
		}
		return origHasChildNodes.call(this);
	};
	node.rave_getChildNodes = function() {
		if (com_ibm_rave_core_internal_selector_mirror_MirrorUtil.isRawMode(this)) {
			return origGetChildNodes.call(this);
		}
		var nodes = origGetChildNodes.call(this);
		var nonGroupNodes = [];
		for (var __i_enFor0 = 0, __exp_enFor0 = nodes, __len_enFor0 = __exp_enFor0.length;
				__i_enFor0 < __len_enFor0; ++__i_enFor0) {
			var child = __exp_enFor0[__i_enFor0];
			if (com_ibm_rave_core_internal_selector_mirror_MirrorUtil.isGroupNode(child)) {
				nonGroupNodes = nonGroupNodes.concat(child.rave_getChildNodes());
			} else {
				nonGroupNodes.push(child);
			}
		}
		return nonGroupNodes;
	};
	node.removeChild = function(childNode) {
		if (com_ibm_rave_core_internal_selector_mirror_MirrorUtil.isRawMode(this)) {
			return origRemoveChild.call(this, childNode);
		}
		var wrappedNode = childNode.rave_getProperty(com_ibm_rave_core_internal_selector_mirror_MirrorConstants.PARENT_WRAPPING_NODE_PROPERTY);
		var realChild = childNode;
		if (wrappedNode != null) {
			realChild = wrappedNode;
		}
		var parent = this;
		var group = this.rave_getProperty(com_ibm_rave_core_internal_selector_mirror_MirrorConstants.GROUP_NODE_PROPERTY);
		if (group != null && group != realChild) {
			parent = group;
		}
		return origRemoveChild.call(parent, realChild);
	};
	node.rave_getParentNode = function() {
		if (com_ibm_rave_core_internal_selector_mirror_MirrorUtil.isRawMode(this)) {
			return origGetParent.call(this);
		}
		var origParent = origGetParent.call(this);
		while (com_ibm_rave_core_internal_selector_mirror_MirrorUtil.isGroupNode(origParent)) {
			origParent = origGetParent.call(origParent);
		}
		return origParent;
	};
	node.setAttribute = function(key, value) {
		origSetAttributeExt.call(this, key, value);
		if (!(com_ibm_rave_core_internal_selector_mirror_MirrorUtil.isRawMode(this))) {
			if (key == "transform") {
				this.rave_setProperty(com_ibm_rave_core_internal_selector_mirror_MirrorConstants.ORIGINAL_TRANSFORM, value);
			}
			com_ibm_rave_core_internal_selector_mirror_MirroredSceneNodeHelper.update(this);
		}
	};
	node.rave_setText = function(text) {
		origSetTextExt.call(this, text);
		com_ibm_rave_core_internal_selector_mirror_MirroredSceneNodeHelper.update(this);
	};
	node.rave_setStyle = function(styleName, value, priority) {
		origSetStyleExt.call(this, styleName, value, priority);
		com_ibm_rave_core_internal_selector_mirror_MirroredSceneNodeHelper.update(this);
	};
	node.getScreenCTM = function() {
		var wrappedNode = this.rave_getProperty(com_ibm_rave_core_internal_selector_mirror_MirrorConstants.GROUP_NODE_PROPERTY);
		if (wrappedNode != null) {
			return (wrappedNode).getScreenCTM();
		}
		return origGetScreenCTM.call(this);
	};
	node.getCTM = function() {
		var wrappedNode = this.rave_getProperty(com_ibm_rave_core_internal_selector_mirror_MirrorConstants.GROUP_NODE_PROPERTY);
		if (wrappedNode != null) {
			return (wrappedNode).getCTM();
		}
		return origGetCTM.call(this);
	};
};


// $source: com/ibm/rave/core/RegistryService
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
/**
 * A registry service to provide mechanism of registering extensions above core functionality. Extension include, but not limited to - layouts, legends, geo objects, axis, etc. An object capable of producing extended objects is represented by: <p> In order to extend core with an additional capability, an extended objects factory must be registered with a respective registry service via: {@link RegistryService#this.extension(String, com_ibm_rave_core_ExtensionFactory)} <p> For example, to register a new layout an extension factory capable of producing new layout objects must be registered with layout registry service: <code>com.ibm.rave.core.Rave.layout#extension(String, ExtensionFactory)</code> * and use <code>com.ibm.rave.core.Rave.layout.extension(String id)</code> to obtain an extended layout object specified by the id.
 * @see ExtensionFactory
 */
var com_ibm_rave_core_RegistryService = rave_externs["RegistryService"] = com_ibm_rave_core_nativeImpl_Declare({

	//registry : null,

	getRegistry : function() {
		if (!this.registry) {
			this.registry = {};
		}
		return this.registry;
	},

	/**
	 * Returns an instance of extended object (e.g. layout, legend, etc) registered under id, <code>null</code> if nothing is registered under the given id.
	 * @param (String) id id used to register the extension
	 * @return (Object)  an instance of extended object (e.g. layout, legend, etc), <code>null</code> if this extension is not registered
	 */
	extension$0 : function(id) {
		if (this.registry && this.registry[id]) {
			return this.registry[id]();
		}
		return null;
	},

	/**
	 * Register an extended object factory using extension id. If the same id is already in use, registration will fail.
	 * @param (String) id extension id
	 * @param (com.ibm.rave.core.ExtensionFactory) factory extended factory to produce object instances of a type provided by id
	 * @return (boolean)  true, if the registration was successful, false otherwise
	 */
	extension$1 : function(id, factory) {
		if (this.getRegistry()[id]) {
			return false;
		}
		this.registry[id] = factory;
		return true;
	},

	/** @expose */ 
	extension : function(a0, a1) {
		var args = arguments;
		if (args.length == 1) {
			return this.extension$0(a0);
		}
		return this.extension$1(a0, a1);
	}
});


// $source: com/ibm/rave/core/selector/Selector
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/selector/Selection (loadtime) // superclass
//@import com/ibm/rave/core/internal/util/NamespaceUtil (runtime) // getQName
//@import com/ibm/rave/core/internal/selector/SelectorHelper (runtime) // each, selectorAll, selector
//@import com/ibm/rave/core/internal/util/QueryUtil (runtime) // getQueryEngine
//@import com/ibm/rave/core/selector/EnterSelector (runtime) // new
//@import com/ibm/rave/core/nativeImpl/arrays/ES6Map (runtime) // create
//@import com/ibm/rave/core/internal/nativeImpl/selector/EmptySceneNode (runtime) // new
//@import com/ibm/rave/core/internal/nativeImpl/transitions/InheritedTransition (runtime) // get
//@import com/ibm/rave/core/transition/Transition (runtime) // create
//@import com/ibm/rave/core/internal/transitions/TransitionUtil (runtime) // transitionNamespace, interruptNS
//@import com/ibm/rave/core/internal/nativeImpl/PlatformInitialization (runtime) // getDocument, getDocumentElement
//@import com/ibm/rave/core/Configuration (runtime) // Configuration
//@import com/ibm/rave/core/arrays/Sort (runtime) // Sort
//@import com/ibm/rave/core/internal/selector/mirror/MirroredSelector (runtime) // new, register
//@import com/ibm/rave/core/RegistryService (static) // new
/**
 * A selection is an array of elements. CSS3 queries are used to select elements. For example, you can select by tag ("rect"), class (".awesome"), unique identifier ("#foo"), attribute ("[color=red]"), or containment ("parent child"). Selectors can also be intersected (".this.that" for logical AND) or unioned (".this, .that" for logical OR). <p> After selecting elements, you apply operators to them to do stuff. These operators can get or set attributes, styles, properties, HTML and text content. Attribute values and such are specified as either constants or functions; the latter are evaluated for each element. You can also join selections to data; this data is available to operators for data-driven transformations. In addition, joining to data produces enter and exit subselections, so that you may add or remove elements in response to changes in data. <p> You won't generally need to use for loops or recursive functions. That's because you operate on entire selections at once, rather than looping over individual elements. However, you can still loop over elements manually if you wish: there's an each operator which invokes an arbitrary function, and selections are arrays, so elements can be accessed directly. RAVE supports method chaining for brevity when applying multiple operators: the operator return value is the selection.
 */
var com_ibm_rave_core_selector_Selector = rave_externs["Selector"] = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_selector_Selection, {

	//enterSelector : null, //exitSelector : null,

	/**
	 * Does this selector type require that we extend nodes with custom node extensions. By default, our main Selector does not require extensions.
	 */
	/** @expose */ 
	needsNodeExtension : false,

	/**
	 * @return (com.ibm.rave.core.ExtensionFactory)  The factory to create an instance of a Selector
	 */
	/** @expose */ 
	getSelectorFactory : function() {
		return com_ibm_rave_core_selector_Selector.factory;
	},

	/**
	 * Appends a new element with the specified name as the last child of each element in the current selection, returning a new selection containing the appended elements. Each new element inherits the data of the current elements, if any, in the same manner as select for subselections. <p> The name may have a namespace prefix of the form "namespace:tag". For example, "svg:text" will create a "text" element in the SVG namespace.If no namespace is specified, then the namespace will be inherited from the enclosing element; or, if the name is one of the known prefixes, the corresponding namespace will be used (for example, "svg" implies "svg:svg").
	 * @param (String) name the name of the new element
	 * @return (com.ibm.rave.core.selector.Selector)  a new  {@link (com.ibm.rave.core.selector.Selector) Selector}  containing the appended elements
	 */
	append$0 : function(name) {
		var qname = com_ibm_rave_core_internal_util_NamespaceUtil.getQName(name);
		return this.select(function(data, index, groupIndex) {
			var newNode = com_ibm_rave_core_selector_Selector.createSceneNode(qname["space"], qname["local"], this);
			if (newNode) {
				this.rave_appendChild(newNode);
			}
			return newNode;
		});
	},

	/**
	 * Appends a new element with the specified name as the last child of each element in the current selection, returning a new selection containing the appended elements. Each new element inherits the data of the current elements, if any, in the same manner as select for subselections.
	 * @param (com.ibm.rave.core.selector.ValueFunction) elementFunction a function that returns the element to append
	 * @return (com.ibm.rave.core.selector.Selector)  a new  {@link (com.ibm.rave.core.selector.Selector) Selector}  containing the appended elements
	 */
	append$1 : function(elementFunction) {
		return this.select(function(data, index, groupIndex) {
			var newNode = elementFunction.call(this, data, index, groupIndex);
			this.rave_appendChild(newNode);
			return newNode;
		});
	},

	/**
	 * Inserts a new element with the specified name before the element matching the specified before selector, for each element in the current selection, returning a new selection containing the inserted elements. If the before selector does not match any elements, then the new element will be the last child as with append. Each new element inherits the data of the current elements (if any), in the same manner as select for subselections.
	 * @param (com.ibm.rave.core.selector.ValueFunction) elementFunction a function that returns the element to append
	 * @param (String) before a selector query string identifying the element to insert before
	 * @return (com.ibm.rave.core.selector.Selector)  a new  {@link (com.ibm.rave.core.selector.Selector) Selector}  containing the inserted elements
	 */
	insert$0 : function(elementFunction, before) {
		return this.insert$1(elementFunction, com_ibm_rave_core_internal_selector_SelectorHelper.selector(before));
	},

	/**
	 * Inserts a new element with the specified name before the element matching the specified before selector, for each element in the current selection, returning a new selection containing the inserted elements. If the before selector does not match any elements, then the new element will be the last child as with append. Each new element inherits the data of the current elements (if any), in the same manner as select for subselections.
	 * @param (com.ibm.rave.core.selector.ValueFunction) nameFunction a function which returns the name of the new element to create
	 * @param (com.ibm.rave.core.selector.ValueFunction) beforeFunction a function which returns the element to insert before
	 * @return (com.ibm.rave.core.selector.Selector)  a new  {@link (com.ibm.rave.core.selector.Selector) Selector}  containing the inserted elements
	 */
	insert$1 : function(nameFunction, beforeFunction) {
		return this.select(function(data, index, groupIndex) {
			var qname = com_ibm_rave_core_internal_util_NamespaceUtil.getQName(nameFunction.call(this, data, index, groupIndex));
			var newNode = com_ibm_rave_core_selector_Selector.createSceneNode(qname["space"], qname["local"], this);
			if (newNode) {
				this.rave_insertBefore(newNode, beforeFunction ? beforeFunction.call(this, data, index, groupIndex) : null);
			}
			return newNode;
		});
	},

	/**
	 * Inserts a new element with the specified name before the element matching the specified before selector, for each element in the current selection, returning a new selection containing the inserted elements. If the before selector does not match any elements, then the new element will be the last child as with append. Each new element inherits the data of the current elements (if any), in the same manner as select for subselections. <p> The name may have a namespace prefix of the form "namespace:tag". For example, "svg:text" will create a "text" element in the SVG namespace.If no namespace is specified, then the namespace will be inherited from the enclosing element; or, if the name is one of the known prefixes, the corresponding namespace will be used (for example, "svg" implies "svg:svg").
	 * @param (String) name the name of the new element
	 * @param (String) before a selector query string identifying the element to insert before
	 * @return (com.ibm.rave.core.selector.Selector)  a new  {@link (com.ibm.rave.core.selector.Selector) Selector}  containing the inserted elements
	 */
	insert$2 : function(name, before) {
		return this.insert$3(name, com_ibm_rave_core_internal_selector_SelectorHelper.selector(before));
	},

	/**
	 * Inserts a new element with the specified name before the element matching the specified before selector, for each element in the current selection, returning a new selection containing the inserted elements. If the before selector does not match any elements, then the new element will be the last child as with append. Each new element inherits the data of the current elements (if any), in the same manner as select for subselections. <p> The name may have a namespace prefix of the form "namespace:tag". For example, "svg:text" will create a "text" element in the SVG namespace.If no namespace is specified, then the namespace will be inherited from the enclosing element; or, if the name is one of the known prefixes, the corresponding namespace will be used (for example, "svg" implies "svg:svg").
	 * @param (String) type the name of the new element
	 * @param (com.ibm.rave.core.selector.ValueFunction) beforeFunction a function which returns the element to insert before
	 * @return (com.ibm.rave.core.selector.Selector)  a new  {@link (com.ibm.rave.core.selector.Selector) Selector}  containing the inserted elements
	 */
	insert$3 : function(type, beforeFunction) {
		var qname = com_ibm_rave_core_internal_util_NamespaceUtil.getQName(type);
		return this.select(function(data, index, groupIndex) {
			var newNode = com_ibm_rave_core_selector_Selector.createSceneNode(qname["space"], qname["local"], this);
			if (newNode) {
				this.rave_insertBefore(newNode, beforeFunction ? beforeFunction.call(this, data, index, groupIndex) : null);
			}
			return newNode;
		});
	},

	/**
	 * Removes the elements in the current selection from the current scene. Returns the current selection (the same elements that were removed) which are now “off-screen”, detached from the scene. Note that there is not currently a dedicated API to add removed elements back to the scene; however, you can pass a function to selection.append or selection.insert to re-add elements.
	 * @return (com.ibm.rave.core.selector.Selector)  this  {@link (com.ibm.rave.core.selector.Selector) Selector}
	 */
	/** @expose */ 
	remove : function() {
		var node;
		for (var j = 0, m = this.length; j < m; ++j) {
			var group = this[j];
			for (var i = 0, n = group.length; i < n; ++i) {
				if ((node = group[i])) {
					var parent = node.rave_getParentNode();
					if (parent) {
						parent.removeChild(node);
					}
				}
			}
		}
		return this;
	},

	on$0 : function(eventName) {
		var node = this.node();
		if (node) {
			var eventListener = node.rave_getEventListener(eventName);
			if (typeof eventListener === "function") {
				return (eventListener)._listener;
			}
		}
		return undefined;
	},

	on$1 : function(value) {
		for (var __i_enFor0 = 0, __exp_enFor0 = Object.keys(value), __len_enFor0 = __exp_enFor0.length;
				__i_enFor0 < __len_enFor0; ++__i_enFor0) {
			var key = __exp_enFor0[__i_enFor0];
			this.on$3(key, value[key], false);
		}
		return this;
	},

	/**
	 * Adds an event listener for the given event type if a listener is specified. If no listener is specified, removes the event listener for the given event name. The event name may be a simple type, eg 'click', or may be contain a qualified dot separated suffix, eg 'click.myapp'. If a suffix is supplied, the event type is extracted from the name up to the first dot.
	 * @param (String) eventName the event name
	 * @param (com.ibm.rave.core.selector.SelectorEventListener) listener the event listener
	 * @return (com.ibm.rave.core.selector.Selector)  this selector
	 */
	on$2 : function(eventName, listener) {
		return this.on$3(eventName, listener, false);
	},

	/**
	 * Adds an event listener for the given event type if a listener is specified. If no listener is specified, removes the event listener for the given event name. The event name may be a simple type, eg 'click', or may be contain a qualified dot separated suffix, eg 'click.myapp'. If a suffix is supplied, the event type is extracted from the name up to the first dot.
	 * @param (String) eventName the event name
	 * @param (com.ibm.rave.core.selector.SelectorEventListener) listener the event listener
	 * @param (boolean) useCapture whether or not the listener is to be added to the capture phase; not supported by all clients
	 * @return (com.ibm.rave.core.selector.Selector)  this selector
	 */
	on$3 : function(eventName, listener, useCapture) {
		var self = this;
		var type, group;
		var idx = eventName.indexOf(".");
		if (idx >= 0) {
			type = idx > 0 ? eventName.substring(0, idx) : null;
			group = eventName.substring(idx + 1);
		} else {
			type = eventName;
			group = null;
		}
		this.each(function(data, index, groupIndex) {
			if (type != null && type.length > 0) {
				if (listener) {
					var fNode = this;
					var eventListener = function(event) {
						self.notifyEvent(listener, fNode, index, groupIndex, event);
					};
					eventListener._listener = listener;
					if (group != null && group.length > 0) {
						this.rave_removeEventListener(type, group);
						this.rave_addEventListener(type, eventListener, useCapture, group);
					} else {
						this.rave_removeEventListener(type);
						this.rave_addEventListener(type, eventListener, useCapture);
					}
				} else if (group != null && group.length > 0) {
					this.rave_removeEventListener(type, group);
				} else {
					this.rave_removeEventListener(type);
				}
			} else {
				this.rave_removeEventListeners(group);
			}
		});
		return this;
	},

	/**
	 * Hook to allow JavaScript to wrap the listener.
	 * @param (com.ibm.rave.core.selector.SelectorEventListener) listener the listener to wrap
	 */
	/** @expose */ 
	notifyEvent : function(listener, node, index, groupIndex, event) {
		var o = rave.event;
		rave.event = event;
		try {
			listener.call(node, node.rave_getData(), index, groupIndex, event);
		} finally {
			rave.event = o;
		}
	},

	/**
	 * Returns the owner of the first  {@link (com.ibm.rave.core.scene.SceneNode) SceneNode}  in this Selector.
	 * @return (com.ibm.rave.core.scene.SceneNode)  owner of this attribute for the first  {@link (com.ibm.rave.core.scene.SceneNode) SceneNode} .
	 */
	owner$0 : function() {
		var node = this.node();
		return node ? node.rave_getOwner() : null;
	},

	/**
	 * Sets the owner for each  {@link (com.ibm.rave.core.scene.SceneNode) SceneNode}  in this Selector. {@link (com.ibm.rave.core.scene.SceneNode) SceneNode}  in this Selector.
	 * @param (com.ibm.rave.core.scene.SceneNode) owner the  {@link (com.ibm.rave.core.scene.SceneNode) SceneNode}  to set as the owner
	 * @return (com.ibm.rave.core.selector.Selector)  Selector
	 */
	owner$1 : function(owner) {
		return this.each(function(data, index, groupIndex) {
			this.rave_setOwner(owner);
		});
	},

	/**
	 * Sets the owner for each  {@link (com.ibm.rave.core.scene.SceneNode) SceneNode}  in this Selector. {@link (com.ibm.rave.core.scene.SceneNode) SceneNode}  in this Selector.
	 * @param (com.ibm.rave.core.selector.ValueFunction) owner the function which returns a  {@link (com.ibm.rave.core.scene.SceneNode) SceneNode}  to set as the owner
	 * @return (com.ibm.rave.core.selector.Selector)  Selector
	 */
	owner$2 : function(owner) {
		if (!owner) {
			return this.owner$1(owner);
		}
		return this.each(function(data, index, groupIndex) {
			this.rave_setOwner(owner.call(this, data, index, groupIndex));
		});
	},

	/**
	 * Returns the value of the requested attribute for the first {@link (com.ibm.rave.core.scene.SceneNode) SceneNode}  in this Selector.
	 * @param (String) attribute String attribute name.
	 * @return (Object)  value for this attribute for the first  {@link (com.ibm.rave.core.scene.SceneNode) SceneNode} .
	 */
	attr$3 : function(attribute) {
		var node = this.node();
		if (node) {
			var qname = com_ibm_rave_core_internal_util_NamespaceUtil.getQName(attribute);
			if (qname["space"] == null) {
				return node.getAttribute(qname["local"]);
			}
			return node.getAttributeNS(qname["space"], qname["local"]);
		}
		return null;
	},

	/**
	 * Sets the value for the requested attribute for each  {@link (com.ibm.rave.core.scene.SceneNode) SceneNode}  in this Selector.
	 * @param (String) attribute String attribute name.
	 * @param (Object) value Value for attribute.
	 * @return (com.ibm.rave.core.selector.Selector)  Selector
	 */
	attr$1 : function(attribute, value) {
		var qname = com_ibm_rave_core_internal_util_NamespaceUtil.getQName(attribute);
		var node;
		for (var j = 0, m = this.length; j < m; ++j) {
			var group = this[j];
			for (var i = 0, n = group.length; i < n; ++i) {
				if ((node = group[i])) {
					if (value == null) {
						if (qname["space"] == null) {
							node.removeAttribute(qname["local"]);
						} else {
							node.removeAttributeNS(qname["space"], qname["local"]);
						}
					} else {
						if (qname["space"] == null) {
							node.setAttribute(qname["local"], value);
						} else {
							node.setAttributeNS(qname["space"], qname["local"], value);
						}
					}
				}
			}
		}
		return this;
	},

	/**
	 * Sets the passed attribute for each match in this selector based on value returned from the passed function . Passes in optional data associated with this selector.
	 * @param (String) attribute String attribute name to set.
	 * @param (com.ibm.rave.core.selector.ValueFunction) valueFunction "anonymous" function class to be executed for each attribute. In javascript, this will be translated into an actual anonymous function.
	 * @return (com.ibm.rave.core.selector.Selector)  Selector
	 */
	attr$2 : function(attribute, valueFunction) {
		if (!valueFunction) {
			return this.attr$1(attribute, null);
		}
		var qname = com_ibm_rave_core_internal_util_NamespaceUtil.getQName(attribute);
		var node;
		for (var j = 0, m = this.length; j < m; ++j) {
			var group = this[j];
			for (var i = 0, n = group.length; i < n; ++i) {
				if ((node = group[i])) {
					var value = valueFunction.call(node, node.rave_getData(), i, j);
					if (value == null) {
						if (qname["space"] == null) {
							node.removeAttribute(qname["local"]);
						} else {
							node.removeAttributeNS(qname["space"], qname["local"]);
						}
					} else {
						if (qname["space"] == null) {
							node.setAttribute(qname["local"], value);
						} else {
							node.setAttributeNS(qname["space"], qname["local"], value);
						}
					}
				}
			}
		}
		return this;
	},

	/**
	 * Returns the value of the requested style for the first  {@link (com.ibm.rave.core.scene.SceneNode) SceneNode} in this Selector.
	 * @param (String) styleName String style name.
	 * @return (Object)  value for this style attribute for the first  {@link (com.ibm.rave.core.scene.SceneNode) SceneNode} .
	 */
	style$6 : function(styleName) {
		var node = this.node();
		return node ? node.rave_getComputedStyle(styleName) : null;
	},

	/**
	 * Sets the passed style attribute for each match in this selector based on value returned from the passed function.
	 * @param (String) styleName String style name to set.
	 * @param (Object) value value for the attribute.   This can be a ValueFunction or something that can be coerced to a String.
	 * @return (com.ibm.rave.core.selector.Selector)  Selector
	 */
	style$2 : function(styleName, value) {
		return (typeof value === "function") ? this.style$5(styleName, value, null) : this.style$4(styleName, value, null);
	},

	/**
	 * Sets the value for the requested style for each  {@link (com.ibm.rave.core.scene.SceneNode) SceneNode}  in this Selector.
	 * @param (String) styleName String style name.
	 * @param (Object) value Value for attribute.
	 * @return (com.ibm.rave.core.selector.Selector)  Selector
	 */
	style$4 : function(styleName, value, priority) {
		var newPriority = priority != null ? priority : "";
		var node;
		for (var j = 0, m = this.length; j < m; ++j) {
			var group = this[j];
			for (var i = 0, n = group.length; i < n; ++i) {
				if ((node = group[i])) {
					if (value == null) {
						node.rave_removeStyle(styleName);
					} else {
						node.rave_setStyle(styleName, value, newPriority);
					}
				}
			}
		}
		return this;
	},

	style$3 : function(styleName, valueFunction) {
		return this.style$5(styleName, valueFunction, null);
	},

	/**
	 * Sets the passed style attribute for each match in this selector based on value returned from the passed function . Passes in optional data associated with this selector.
	 * @param (String) styleName String style name to set.
	 * @param (com.ibm.rave.core.selector.ValueFunction) valueFunction "anonymous" function class to be executed for each attribute. In javascript, this will be translated into an actual anonymous function.
	 * @return (com.ibm.rave.core.selector.Selector)  Selector
	 */
	style$5 : function(styleName, valueFunction, priority) {
		if (!valueFunction) {
			return this.style$2(styleName, null);
		}
		var node;
		for (var j = 0, m = this.length; j < m; ++j) {
			var group = this[j];
			for (var i = 0, n = group.length; i < n; ++i) {
				if ((node = group[i])) {
					var value = valueFunction.call(node, node.rave_getData(), i, j);
					if (value == null) {
						node.rave_removeStyle(styleName);
					} else {
						node.rave_setStyle(styleName, value, priority);
					}
				}
			}
		}
		return this;
	},

	/**
	 * Returns the value of the requested property for the first {@link (com.ibm.rave.core.scene.SceneNode) SceneNode}  in this Selector.
	 * @param (String) key the property string key
	 * @return (Object)  value for this property for the first  {@link (com.ibm.rave.core.scene.SceneNode) SceneNode} .
	 */
	property$0 : function(key) {
		var node = this.node();
		return node ? node.rave_getProperty(key) : null;
	},

	property$1 : function(value) {
		for (var __i_enFor0 = 0, __exp_enFor0 = Object.keys(value), __len_enFor0 = __exp_enFor0.length;
				__i_enFor0 < __len_enFor0; ++__i_enFor0) {
			var key = __exp_enFor0[__i_enFor0];
			var v = value[key];
			if (typeof v === "function") {
				this.property$3(key, v);
			} else {
				this.property$2(key, v);
			}
		}
		return this;
	},

	/**
	 * Sets the property value for the given key for each  {@link (com.ibm.rave.core.scene.SceneNode) SceneNode}  in this Selector.
	 * @param (String) key the property string key
	 * @param (Object) value the property value
	 * @return (com.ibm.rave.core.selector.Selector)  Selector
	 */
	property$2 : function(key, value) {
		var node;
		for (var j = 0, m = this.length; j < m; ++j) {
			var group = this[j];
			for (var i = 0, n = group.length; i < n; ++i) {
				if ((node = group[i])) {
					node.rave_setProperty(key, value);
				}
			}
		}
		return this;
	},

	/**
	 * Sets the passed property for each match in this selector based on value returned from the passed function.
	 * @param (String) key the property string key
	 * @param (com.ibm.rave.core.selector.ValueFunction) valueFunction "anonymous" function class to be executed for each property.
	 * @return (com.ibm.rave.core.selector.Selector)  Selector
	 */
	property$3 : function(key, valueFunction) {
		if (!valueFunction) {
			return this.property$2(key, null);
		}
		var node;
		for (var j = 0, m = this.length; j < m; ++j) {
			var group = this[j];
			for (var i = 0, n = group.length; i < n; ++i) {
				if ((node = group[i])) {
					node.rave_setProperty(key, valueFunction.call(node, node.rave_getData(), i, j));
				}
			}
		}
		return this;
	},

	/**
	 * The text content for the first non-null element in the selection. This is generally useful only if you know the selection contains exactly one element.
	 * @return (String)  text content for the first non-null element in the selection
	 */
	text$2 : function() {
		var node = this.node();
		return node ? node.rave_getText() : null;
	},

	/**
	 * Sets the text content for each  {@link (com.ibm.rave.core.scene.SceneNode) SceneNode}  in this Selector.
	 * @param (Object) value The text content.
	 * @return (com.ibm.rave.core.selector.Selector)  Selector
	 */
	text$0 : function(value) {
		var text = value == null ? "" : value + "";
		var node;
		for (var j = 0, m = this.length; j < m; ++j) {
			var group = this[j];
			for (var i = 0, n = group.length; i < n; ++i) {
				if ((node = group[i])) {
					node.rave_setText(text);
				}
			}
		}
		return this;
	},

	/**
	 * Sets the text content for each  {@link (com.ibm.rave.core.scene.SceneNode) SceneNode}  in this Selector.
	 * @param (com.ibm.rave.core.selector.ValueFunction) valueFunction "anonymous" function class to be executed for each attribute. In javascript, this will be translated into an actual anonymous function.
	 * @return (com.ibm.rave.core.selector.Selector)  Selector
	 */
	text$1 : function(valueFunction) {
		var node;
		for (var j = 0, m = this.length; j < m; ++j) {
			var group = this[j];
			for (var i = 0, n = group.length; i < n; ++i) {
				if ((node = group[i])) {
					var value = valueFunction.call(node, node.rave_getData(), i, j);
					node.rave_setText(value == null ? "" : value + "");
				}
			}
		}
		return this;
	},

	/**
	 * Returns the html value for the first  {@link (com.ibm.rave.core.scene.SceneNode) SceneNode}  in this Selector.
	 * @return (String)  html value for the first  {@link (com.ibm.rave.core.scene.SceneNode) SceneNode} .
	 */
	html$0 : function() {
		var node = this.node();
		return node ? node.rave_getHtml() : null;
	},

	/**
	 * Sets the html content for each  {@link (com.ibm.rave.core.scene.SceneNode) SceneNode}  in this Selector.
	 * @param (Object) value The html content.
	 * @return (com.ibm.rave.core.selector.Selector)  Selector
	 */
	html$1 : function(value) {
		var html = value == null ? "" : value + "";
		var node;
		for (var j = 0, m = this.length; j < m; ++j) {
			var group = this[j];
			for (var i = 0, n = group.length; i < n; ++i) {
				if ((node = group[i])) {
					node.rave_setHtml(html);
				}
			}
		}
		return this;
	},

	/**
	 * Sets the html content for each  {@link (com.ibm.rave.core.scene.SceneNode) SceneNode}  in this Selector.
	 * @param (com.ibm.rave.core.selector.ValueFunction) valueFunction "anonymous" function class to be executed for each attribute. In javascript, this will be translated into an actual anonymous function.
	 * @return (com.ibm.rave.core.selector.Selector)  Selector
	 */
	html$2 : function(valueFunction) {
		var node;
		for (var j = 0, m = this.length; j < m; ++j) {
			var group = this[j];
			for (var i = 0, n = group.length; i < n; ++i) {
				if ((node = group[i])) {
					var value = valueFunction.call(node, node.rave_getData(), i, j);
					node.rave_setHtml(value == null ? "" : value + "");
				}
			}
		}
		return this;
	},

	filter$0 : function(filterFunction) {
		var subgroups = this.getSelectorFactory()();
		var subgroup;
		var group;
		var node;
		for (var j = 0, m = this.length; j < m; ++j) {
			group = this[j];
			subgroup = [];
			subgroups.push(subgroup);
			subgroup["parentNode"] = group["parentNode"];
			for (var i = 0, n = group.length; i < n; ++i) {
				if ((node = group[i]) && filterFunction.call(node, node.rave_getData(), i, j)) {
					subgroup.push(node);
				}
			}
		}
		return subgroups;
	},

	filter$1 : function(filter) {
		return this.filter$0(function(data, index, groupIndex) {
			return com_ibm_rave_core_internal_util_QueryUtil.getQueryEngine(this).matches(this, filter);
		});
	},

	/** @expose */ 
	isTransition : function() {
		return false;
	},

	/**
	 * Returns <code>true</code> only if the first node in the selection has the specified class or classes.
	 * @param (String) className the class name
	 * @return (boolean)  <code>true</code> if the first node has the class set, <code>false</code> otherwise
	 */
	classed$0 : function(className) {
		var node = this.node();
		return node && node.rave_containsClass(className);
	},

	classed$1 : function(value) {
		for (var __i_enFor0 = 0, __exp_enFor0 = Object.keys(value), __len_enFor0 = __exp_enFor0.length;
				__i_enFor0 < __len_enFor0; ++__i_enFor0) {
			var key = __exp_enFor0[__i_enFor0];
			var v = value[key];
			if (typeof v === "function") {
				this.classed$3(key, v);
			} else {
				this.classed$2(key, (v));
			}
		}
		return this;
	},

	/**
	 * Sets the value for the specified class for each  {@link (com.ibm.rave.core.scene.SceneNode) SceneNode}  in this Selector.
	 * @param (String) className the class name
	 * @param (boolean) add Whether to add the class or not.
	 * @return (com.ibm.rave.core.selector.Selector)  Selector
	 */
	classed$2 : function(className, add) {
		var newClassName = className + "";
		var node;
		for (var j = 0, m = this.length; j < m; ++j) {
			var group = this[j];
			for (var i = 0, n = group.length; i < n; ++i) {
				if ((node = group[i])) {
					if (add) {
						node.rave_addClass(newClassName);
					} else {
						node.rave_removeClass(newClassName);
					}
				}
			}
		}
		return this;
	},

	/**
	 * Sets the passed class attribute for each match in this selector based on value returned from the passed function . Passes in optional data associated with this selector.
	 * @param (String) className String class name to set.
	 * @param (com.ibm.rave.core.selector.ValueFunction) valueFunction "anonymous" function class to be executed for each attribute. In javascript, this will be translated into an actual anonymous function.
	 * @return (com.ibm.rave.core.selector.Selector)  Selector
	 */
	classed$3 : function(className, valueFunction) {
		var newClassName = className != null ? className + "" : "";
		var node;
		for (var j = 0, m = this.length; j < m; ++j) {
			var group = this[j];
			for (var i = 0, n = group.length; i < n; ++i) {
				if ((node = group[i])) {
					if (valueFunction.call(node, node.rave_getData(), i, j)) {
						node.rave_addClass(newClassName);
					} else {
						node.rave_removeClass(newClassName);
					}
				}
			}
		}
		return this;
	},

	/**
	 * Get the first data value in the selection.
	 * @return (java.lang.Object[])  the first data value in the selection
	 */
	data$0 : function() {
		if (this.length > 0) {
			var group = this[0];
			var node;
			var n = group.length;
			var value = [];
			for (var i = 0; i < n; ++i) {
				if ((node = group[i])) {
					value[i] = node.rave_getData();
				}
			}
			return value;
		}
		return null;
	},

	/**
	 * Gets the bound data for each selected element. Unlike the selection.data method, this method does not compute a join (and thus does not compute enter and exit selections)
	 * @return (Object)  the data value in the selection
	 */
	datum$0 : function() {
		var node = this.node();
		if (node) {
			return node.rave_getData();
		}
		return null;
	},

	/**
	 * Sets the bound data for each selected element. Unlike the selection.data method, this method does not compute a join (and thus does not compute enter and exit selections)
	 * @param (com.ibm.rave.core.selector.ValueFunction) valueFn the function to call back to provide the value to set
	 * @return (com.ibm.rave.core.selector.Selector)  this  {@link (com.ibm.rave.core.selector.Selector) Selector}
	 */
	datum$1 : function(valueFn) {
		var node;
		for (var j = 0, m = this.length; j < m; ++j) {
			var group = this[j];
			for (var i = 0, n = group.length; i < n; ++i) {
				if ((node = group[i])) {
					node.rave_setProperty("__data__", valueFn.call(node, node.rave_getData(), i, j));
				}
			}
		}
		return this;
	},

	/**
	 * Sets the bound data for each selected element. Unlike the selection.data method, this method does not compute a join (and thus does not compute enter and exit selections)
	 * @param (Object) value the value to set
	 * @return (com.ibm.rave.core.selector.Selector)  this  {@link (com.ibm.rave.core.selector.Selector) Selector}
	 */
	datum$2 : function(value) {
		return this.datum$1(function(data, index, groupIndex) {
			return value;
		});
	},

	/**
	 * Joins the array of data values from the value function with the current selection.
	 * @param (com.ibm.rave.core.selector.ValueFunction) value the data to join
	 * @return (com.ibm.rave.core.selector.Selector)  the update selector with joined data
	 */
	data$1 : function(value) {
		return this.doData(value, null);
	},

	/**
	 * Joins the array of data values from the value function with the current selection.
	 * @param (com.ibm.rave.core.selector.ValueFunction) value the data to join
	 * @param (com.ibm.rave.core.selector.ValueFunction) key the function to extra data keys
	 * @return (com.ibm.rave.core.selector.Selector)  the update selector with joined data
	 */
	data$2 : function(value, key) {
		return this.doData(value, key);
	},

	/**
	 * Joins the specified array of data with the current selection.
	 * @param (java.lang.Object[]) value the data to join
	 * @return (com.ibm.rave.core.selector.Selector)  the update selector with joined data
	 */
	data$3 : function(value) {
		return this.doData(value, null);
	},

	/**
	 * Joins the specified array of data with the current selection.
	 * @param (java.lang.Object[]) value the data to join
	 * @param (com.ibm.rave.core.selector.ValueFunction) key the function to extra data keys
	 * @return (com.ibm.rave.core.selector.Selector)  the update selector with joined data
	 */
	data$4 : function(value, key) {
		return this.doData(value, key);
	},

	/**
	 * Joins the specified array of data with the current selection.
	 * @param (Object) value the data to join (Object[] or ValueFunction)
	 * @param (com.ibm.rave.core.selector.ValueFunction) key the function to extra data keys, may be <code>null</code>
	 * @return (com.ibm.rave.core.selector.Selector)  the update selector with joined data
	 */
	doData : function(value, key) {
		var i = -1;
		var n = this.length;
		var group;
		var extFactory = this.getSelectorFactory();
		var enter = new com_ibm_rave_core_selector_EnterSelector().setSelectorFactory(extFactory);
		var exit = extFactory();
		var update = extFactory();
		update.enterSelector = enter;
		update.exitSelector = exit;
		var self = this;
		var bind = function(group, groupData) {
			var i, n = group.length, m = groupData.length, n0 = Math.min(n, m);
			var updateNodes = new Array(m);
			var enterNodes = new Array(m);
			var exitNodes = new Array(n);
			var node;
			var nodeData;
			if (key) {
				var nodeByKeyValue = com_ibm_rave_core_nativeImpl_arrays_ES6Map.create();
				var keyValues = new Array(n);
				var keyValue;
				for (i = 0; i < n; ++i) {
					keyValue = key.call(node = group[i], (node).rave_getData(), i, -1);
					if (nodeByKeyValue.has(keyValue)) {
						exitNodes[i] = node;
					} else {
						nodeByKeyValue.set(keyValue, node);
					}
					keyValues[i] = keyValue;
				}
				for (i = 0; i < m; ++i) {
					keyValue = key.call(groupData, nodeData = groupData[i], i, -1);
					if (!((node = nodeByKeyValue.get(keyValue)))) {
						enterNodes[i] = new com_ibm_rave_core_internal_nativeImpl_selector_EmptySceneNode(nodeData);
					} else if (node != self) {
						updateNodes[i] = node;
						(node).rave_setData(nodeData);
					}
					nodeByKeyValue.set(keyValue, self);
				}
				for (i = 0; i < n; ++i) {
					if (nodeByKeyValue.get(keyValues[i]) != self) {
						exitNodes[i] = group[i];
					}
				}
			} else {
				for (i = 0; i < n0; ++i) {
					node = group[i];
					nodeData = groupData[i];
					if ((node)) {
						(node).rave_setData(nodeData);
						updateNodes[i] = node;
					} else {
						enterNodes[i] = new com_ibm_rave_core_internal_nativeImpl_selector_EmptySceneNode(nodeData);
					}
				}
				for (; i < m; ++i) {
					enterNodes[i] = new com_ibm_rave_core_internal_nativeImpl_selector_EmptySceneNode(groupData[i]);
				}
				for (; i < n; ++i) {
					exitNodes[i] = group[i];
				}
			}
			enterNodes["update"] = updateNodes;
			enterNodes["parentNode"] = updateNodes["parentNode"] = exitNodes["parentNode"] = group["parentNode"];
			enter.push(enterNodes);
			update.push(updateNodes);
			exit.push(exitNodes);
		};
		if (typeof value === "function") {
			while (++i < n) {
				bind((group = this[i]), (value).call(group["parentNode"], group["parentNode"].rave_getData(), i, -1));
			}
		} else {
			var array = ((typeof value === "array" || value instanceof Array)) ? (value) : value;
			while (++i < n) {
				bind(this[i], array);
			}
		}
		return update;
	},

	/**
	 * Returns the enter selection: placeholder nodes for each data element for which no corresponding existing element was found in the current selection. This method is only defined on the update selection, which is returned by the data operator. In addition, the enter selection only defines the append, insert, select and call operators; you must use these operators to instantiate the entering elements before modifying any content. Enter selections also support empty and size.
	 * @return (com.ibm.rave.core.selector.Selector)  the enter selection
	 */
	/** @expose */ 
	enter : function() {
		return this.enterSelector;
	},

	/**
	 * Returns the exit selection: existing elements in the current selection for which no new data element was found. This method is only defined on the update selection, which is returned by the data operator. The exit selection defines all the normal operators, though typically the main one you'll want to use is remove; the other operators exist primarily so you can define an exiting transition as desired. Note that the exit operator merely returns a reference to the exit selection, and it is up to you to remove the new nodes.
	 * @return (com.ibm.rave.core.selector.Selector)  the exit selection
	 */
	/** @expose */ 
	exit : function() {
		return this.exitSelector;
	},

	/**
	 * Starts a transition for the current selection. Transitions behave much like selections, except operators animate smoothly over time rather than applying instantaneously. <p> Transitions of the same name are exclusive per-element. When the new transition starts on a given element, it will interrupt an active transition of the same name on the element, if any. If a name is not specified, the empty name ("") is used.
	 * @return (com.ibm.rave.core.transition.Transition)  a new transition for the current selection
	 */
	transition$0 : function() {
		return this.transition$1(null);
	},

	/**
	 * Starts a transition for the current selection. Transitions behave much like selections, except operators animate smoothly over time rather than applying instantaneously. <p> Transitions of the same name are exclusive per-element. When the new transition starts on a given element, it will interrupt an active transition of the same name on the element, if any. If a name is not specified, the empty name ("") is used.
	 * @param (String) name the name of the transition
	 * @return (com.ibm.rave.core.transition.Transition)  a new transition for the current selection
	 */
	transition$1 : function(name) {
		var inherit = com_ibm_rave_core_internal_nativeImpl_transitions_InheritedTransition.get();
		if (inherit) {
			return com_ibm_rave_core_transition_Transition.create(this, name, inherit);
		}
		return com_ibm_rave_core_transition_Transition.create(this, name);
	},

	/**
	 * Immediately interrupts the active transition of the specified name on the selected elements, if any. If a name is not specified, the empty name (“”) is used. Does not cancel any scheduled transitions that have not yet started. To cancel scheduled transitions as well, simply create a new zero-delay transition after interrupting the current transition: <pre> selection.interrupt() // cancel the current transition .transition(); // preempt any scheduled transitions </pre>
	 * @return (com.ibm.rave.core.selector.Selector)  this  {@link (com.ibm.rave.core.selector.Selector) Selector}
	 */
	interrupt$0 : function() {
		return this.interrupt$1(null);
	},

	/**
	 * Immediately interrupts the active transition of the specified name on the selected elements, if any. If a name is not specified, the empty name (“”) is used. Does not cancel any scheduled transitions that have not yet started. To cancel scheduled transitions as well, simply create a new zero-delay transition after interrupting the current transition: <pre> selection.interrupt() // cancel the current transition .transition(); // preempt any scheduled transitions </pre>
	 * @param (String) name the name of the transition
	 * @return (com.ibm.rave.core.selector.Selector)  this  {@link (com.ibm.rave.core.selector.Selector) Selector}
	 */
	interrupt$1 : function(name) {
		var node;
		for (var j = 0, m = this.length; j < m; ++j) {
			var group = this[j];
			for (var i = 0, n = group.length; i < n; ++i) {
				if ((node = group[i])) {
					com_ibm_rave_core_internal_transitions_TransitionUtil.interruptNS(node, com_ibm_rave_core_internal_transitions_TransitionUtil.transitionNamespace(name));
				}
			}
		}
		return this;
	},

	/**
	 * Return a new selector based on 'query', only returning the first match. Also creates a new single data entry for the selection and sets the parent node for the next set of matches.
	 * @param (Object) query CSS3 Selection query syntax.
	 * @return (com.ibm.rave.core.selector.Selector)  a new selector
	 */
	select$0 : function(query) {
		return this.select$1(com_ibm_rave_core_internal_selector_SelectorHelper.selector(query));
	},

	/**
	 * Return a new selector based on the nodes returned by the value function. Also creates a new single data entry for the selection and sets the parent node for the next set of matches.
	 * @param (com.ibm.rave.core.selector.ValueFunction) valueFunction
	 * @return (com.ibm.rave.core.selector.Selector)  a new selector
	 */
	select$1 : function(valueFunction) {
		var subgroups = this.getSelectorFactory()();
		var subgroup;
		var subnode;
		var group;
		var node;
		for (var j = 0, m = this.length; j < m; ++j) {
			group = this[j];
			subgroup = [];
			subgroups.push(subgroup);
			subgroup["parentNode"] = group["parentNode"];
			for (var i = 0, n = group.length; i < n; ++i) {
				if ((node = group[i]) && valueFunction) {
					subgroup.push(subnode = valueFunction.call(node, node.rave_getData(), i, j));
					if (subnode && node.rave_hasData()) {
						subnode.rave_setData(node.rave_getData());
					}
				} else {
					subgroup.push(null);
				}
			}
		}
		return subgroups;
	},

	selectAll$0 : function(query) {
		return this.selectAll$1(com_ibm_rave_core_internal_selector_SelectorHelper.selectorAll(query));
	},

	selectAll$1 : function(selector) {
		var subgroups = this.getSelectorFactory()();
		var subgroup;
		var group;
		var node;
		for (var j = 0, m = this.length; j < m; ++j) {
			subgroup = [];
			group = this[j];
			for (var i = 0, n = group.length; i < n; ++i) {
				if ((node = group[i])) {
					subgroups.push(subgroup = com_ibm_rave_core_selector_Selector.createSelectorGroupFromNodes(selector ? selector.call(node, node.rave_getData(), i, j) : null));
					subgroup["parentNode"] = node;
				}
			}
		}
		return subgroups;
	},

	/**
	 * Invokes the specified function for each element in the current selection, passing in the current datum and index, with the this context of the current element. This operator can be used to invoke arbitrary code for each selected element.
	 * @param (com.ibm.rave.core.selector.CallbackFunction) callback the callback to run for each element in the current selection
	 * @return (com.ibm.rave.core.selector.Selector)  this  {@link (com.ibm.rave.core.selector.Selector) Selector}
	 */
	/** @expose */ 
	each : function(callback) {
		return com_ibm_rave_core_internal_selector_SelectorHelper.each(this, callback);
	},

	/**
	 * Invokes the specified function once with this selector as the context. Selects the first element that matches the specified selector string, returning a single-element selection. If no elements in the current document match the specified selector, returns the empty selection. If multiple elements match the selector, only the first matching element (in document traversal order) will be selected.
	 * @param (com.ibm.rave.core.selector.RunFunction) callback the function to callback, must be annotated as {@link (com.ibm.rave.codegenerator.annotations.FunctionClass) FunctionClass}
	 * @param (java.lang.Object[]) args optional arguments to pass to the call function
	 * @return (com.ibm.rave.core.selector.Selector)  this selector
	 */
	/** @expose */ 
	call : function(callback, args) {
		if (args !== null || arguments.length > 2){
			args = Array.prototype.slice.call(arguments, 1);
		}
		{
			var list = (args);
			list.splice(0, 0, this);
			callback.apply(this, list);
			return this;
		}
	},

	/**
	 * Selects the specified node. This is useful if you already have a reference to a node.
	 * @param (com.ibm.rave.core.scene.SceneNode) node the node to select
	 * @return (com.ibm.rave.core.selector.Selector)  this  {@link (com.ibm.rave.core.selector.Selector) Selector}
	 */
	init$0 : function(node) {
		var group = com_ibm_rave_core_selector_Selector.createSelectorGroupFromNode(node);
		this.push(group);
		group["parentNode"] = com_ibm_rave_core_internal_nativeImpl_PlatformInitialization.getDocumentElement(node);
		return this;
	},

	/**
	 * Selects the specified array of elements. This is useful if you already have a reference to nodes.
	 * @param (Array) nodes the nodes to select
	 * @return (com.ibm.rave.core.selector.Selector)  this  {@link (com.ibm.rave.core.selector.Selector) Selector}
	 */
	initAll$0 : function(nodes) {
		var group = com_ibm_rave_core_selector_Selector.createSelectorGroupFromNodes(nodes);
		this.push(group);
		group["parentNode"] = com_ibm_rave_core_internal_nativeImpl_PlatformInitialization.getDocumentElement(com_ibm_rave_core_internal_nativeImpl_PlatformInitialization.getDocument());
		return this;
	},

	/**
	 * Selects the first element that matches the specified selector string, returning a single-element selection. If no elements match the specified selector, returns the empty selection. If multiple elements match the selector, only the first matching element (in traversal order) will be selected.
	 * @param (String) query CSS3 selector query syntax
	 * @return (com.ibm.rave.core.selector.Selector)  this  {@link (com.ibm.rave.core.selector.Selector) Selector}
	 */
	init$1 : function(query) {
		var node = com_ibm_rave_core_Configuration.INSTANCE.filter(com_ibm_rave_core_internal_util_QueryUtil.getQueryEngine(null).querySelector(query), query);
		var group = com_ibm_rave_core_selector_Selector.createSelectorGroupFromNode(node);
		this.push(group);
		group["parentNode"] = com_ibm_rave_core_internal_nativeImpl_PlatformInitialization.getDocumentElement(node);
		return this;
	},

	/**
	 * Selects all elements that match the specified selector. The elements will be selected in traversal order (top-to-bottom). If no elements match the specified selector, returns the empty selection.
	 * @param (String) query CSS3 selector query syntax
	 * @return (com.ibm.rave.core.selector.Selector)  this  {@link (com.ibm.rave.core.selector.Selector) Selector}
	 */
	initAll$1 : function(query) {
		var nodes = com_ibm_rave_core_Configuration.INSTANCE.filterArray(com_ibm_rave_core_internal_util_QueryUtil.getQueryEngine(null).querySelectorAll(query));
		var group = com_ibm_rave_core_selector_Selector.createSelectorGroupFromNodes(nodes);
		this.push(group);
		group["parentNode"] = com_ibm_rave_core_internal_nativeImpl_PlatformInitialization.getDocumentElement(com_ibm_rave_core_internal_nativeImpl_PlatformInitialization.getDocument());
		return this;
	},

	/**
	 * Re-inserts elements such that the document order matches the selection order. This is equivalent to calling sort() if the data is already sorted, but much faster.
	 * @return (com.ibm.rave.core.selector.Selector)  this  {@link (com.ibm.rave.core.selector.Selector) Selector}
	 */
	/** @expose */ 
	order : function() {
		for (var j = 0, m = this.length; j < m; ++j) {
			var group = this[j];
			var i = group.length - 1;
			var next = group[i];
			while (--i >= 0) {
				var node;
				if ((node = group[i])) {
					if (next && !(next === node.rave_getNextSibling())) {
						next.rave_getParentNode().rave_insertBefore(node, next);
					}
					next = node;
				}
			}
		}
		return this;
	},

	/**
	 * Sort the nodes in this selection. The order is determined by the provided comparator. The comparator must be able to compare the data values associate with these nodes (i.e. number comparator for numeric data).
	 * @param (com.ibm.rave.core.util.Comparator) c {@link (com.ibm.rave.core.scene.SceneNode) SceneNode}  data value comparator.
	 * @return (com.ibm.rave.core.selector.Selector)  This selection with its nodes reordered. Note the nodes will be reinserted into the document to match the new sorted order (see {@link this.Selector#this.order()} ).
	 */
	sort$1 : function(c) {
		var comparator = function(a, b) {
			if (a && b) {
				return c(a.rave_getData(), b.rave_getData());
			}
			return +(!((a))) - +(!((b)));
		};
		var m = this.length;
		for (var j = 0; j < m; ++j) {
			this[j].sort(comparator);
		}
		return this.order();
	},

	/**
	 * Sorts the nodes in this selection in ascending order of their data values.
	 * @return (com.ibm.rave.core.selector.Selector)  this  {@link (com.ibm.rave.core.selector.Selector) Selector}
	 */
	sort$0 : function() {
		return this.sort$1(com_ibm_rave_core_arrays_Sort.ascending);
	},

	/**
	 * Perform a recursive mirror on each node in the current selection. This is typically performed on an 'owner' node (an SVG node for example). Calling mirror(true) will perform a horizontal scale so that all nodes move from the left of the viewport to their equivalent position from the right of the viewport. Special logic is included to ensure that &lt;image&gt; and &lt;text&gt; nodes do not appear backwards - they are flipped within their mirrored bounds. These nodes can be restored to their unflipped state by performing a new selection on them and calling mirror(false).
	 * @param (boolean) mirror - if <code>true</code> each node in this selection will be mirrored (if not already). Likewise, if <code>false</code> then they are 'un' mirrored.
	 * @return (com.ibm.rave.core.selector.Selector)  Selector containing the currently selected nodes.
	 */
	/** @expose */ 
	mirror : function(mirror) {
		var mirroredSelector = new com_ibm_rave_core_internal_selector_mirror_MirroredSelector();
		if (this.node()) {
			com_ibm_rave_core_internal_selector_mirror_MirroredSelector.register(this.node().rave_getNamespaceURI());
			mirroredSelector.initWithSelector(this);
			mirroredSelector.mirror(mirror);
		}
		return (mirror) ? mirroredSelector : this;
	},

	/**
	 * Init this selector with an existing selector. Assumes 'this' selector is empty.
	 * @param (com.ibm.rave.core.selector.Selector) selector
	 */
	/** @expose */ 
	initWithSelector : function(selector) {
		var group;
		var newgroup;
		var node;
		for (var j = 0, m = selector.length; j < m; ++j) {
			group = selector[j];
			newgroup = [];
			newgroup["parentNode"] = group["parentNode"];
			this.push(newgroup);
			for (var i = 0, n = group.length; i < n; ++i) {
				node = group[i];
				if (this.needsNodeExtension) {
					node = com_ibm_rave_core_Configuration.INSTANCE.extendRecursive(node);
				}
				newgroup.push(node);
			}
		}
	},

	/**
	 * Get the extended selector for the given id.
	 * @param (String) id The id associated with the extended selector.
	 * @return (com.ibm.rave.core.selector.Selector)  An instance of the extended selector, or null if none found.
	 */
	extension$0 : function(id) {
		var delegate = com_ibm_rave_core_selector_Selector.selectorDelegateRegistry.extension$0(id);
		return delegate != null ? (delegate).setDelegate(this) : null;
	},

	/**
	 * Dispose this selection; allow any clean up to be performed. The node is removed, then disposed.
	 * @return (com.ibm.rave.core.selector.Selector)  this  {@link (com.ibm.rave.core.selector.Selector) Selector}  
	 */
	/** @expose */ 
	dispose : function() {
		this.remove();
		var node;
		for (var j = 0, m = this.length; j < m; ++j) {
			var group = this[j];
			for (var i = 0, n = group.length; i < n; ++i) {
				if ((node = group[i])) {
					node.rave_dispose();
				}
			}
		}
		return this;
	},

	/** @expose */ 
	append : function(a0) {
		var args = arguments;
		if (args.length == 1 && (a0 == null || typeof a0 === "string")) {
			return this.append$0(a0);
		}
		return this.append$1(a0);
	},

	/** @expose */ 
	insert : function(a0, a1) {
		var args = arguments;
		if (args.length == 2 && typeof a0 === "function" && (a1 == null || typeof a1 === "string")) {
			return this.insert$0(a0, a1);
		}
		if (args.length == 2 && typeof a0 === "function" && typeof a1 === "function") {
			return this.insert$1(a0, a1);
		}
		if (args.length == 2 && (a0 == null || typeof a0 === "string") && (a1 == null || typeof a1 === "string")) {
			return this.insert$2(a0, a1);
		}
		return this.insert$3(a0, a1);
	},

	/** @expose */ 
	on : function(a0, a1, a2) {
		var args = arguments;
		if (args.length == 1 && (a0 == null || typeof a0 === "string")) {
			return this.on$0(a0);
		}
		if (args.length == 1) {
			return this.on$1(a0);
		}
		if (args.length == 2) {
			return this.on$2(a0, a1);
		}
		return this.on$3(a0, a1, a2);
	},

	/** @expose */ 
	owner : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.owner$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.owner$2(a0);
		}
		return this.owner$1(a0);
	},

	/** @expose */ 
	attr : function(a0, a1) {
		var args = arguments;
		if (args.length == 1 && (a0 == null || typeof a0 === "string")) {
			return this.attr$3(a0);
		}
		if (args.length == 2 && (a0 == null || typeof a0 === "string") && typeof a1 === "function") {
			return this.attr$2(a0, a1);
		}
		if (args.length == 2 && (a0 == null || typeof a0 === "string") && (a1 == null || Object.prototype.toString.call(a1) !== "[object Array]")) {
			return this.attr$1(a0, a1);
		}
		return com_ibm_rave_core_selector_Selection.prototype.attr.apply(this, args);
	},

	/** @expose */ 
	style : function(a0, a1, a2) {
		var args = arguments;
		if (args.length == 1 && (a0 == null || typeof a0 === "string")) {
			return this.style$6(a0);
		}
		if (args.length == 2 && (a0 == null || typeof a0 === "string") && typeof a1 === "function") {
			return this.style$3(a0, a1);
		}
		if (args.length == 2 && (a0 == null || typeof a0 === "string") && (a1 == null || Object.prototype.toString.call(a1) !== "[object Array]")) {
			return this.style$2(a0, a1);
		}
		if (args.length == 3 && (a0 == null || typeof a0 === "string") && typeof a1 === "function" && (a2 == null || typeof a2 === "string")) {
			return this.style$5(a0, a1, a2);
		}
		if (args.length == 3 && (a0 == null || typeof a0 === "string") && (a1 == null || Object.prototype.toString.call(a1) !== "[object Array]") && (a2 == null || typeof a2 === "string")) {
			return this.style$4(a0, a1, a2);
		}
		return com_ibm_rave_core_selector_Selection.prototype.style.apply(this, args);
	},

	/** @expose */ 
	property : function(a0, a1) {
		var args = arguments;
		if (args.length == 1 && (a0 == null || typeof a0 === "string")) {
			return this.property$0(a0);
		}
		if (args.length == 1) {
			return this.property$1(a0);
		}
		if (args.length == 2 && (a0 == null || typeof a0 === "string") && typeof a1 === "function") {
			return this.property$3(a0, a1);
		}
		return this.property$2(a0, a1);
	},

	/** @expose */ 
	text : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.text$2();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.text$1(a0);
		}
		return this.text$0(a0);
	},

	/** @expose */ 
	html : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.html$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.html$2(a0);
		}
		return this.html$1(a0);
	},

	/** @expose */ 
	filter : function(a0) {
		var args = arguments;
		if (args.length == 1 && typeof a0 === "function") {
			return this.filter$0(a0);
		}
		if (args.length == 1 && (a0 == null || typeof a0 === "string")) {
			return this.filter$1(a0);
		}
		return Array.prototype.filter.apply(this, args);
	},

	/** @expose */ 
	classed : function(a0, a1) {
		var args = arguments;
		if (args.length == 1 && (a0 == null || typeof a0 === "string")) {
			return this.classed$0(a0);
		}
		if (args.length == 1) {
			return this.classed$1(a0);
		}
		if (args.length == 2 && (a0 == null || typeof a0 === "string") && typeof a1 === "function") {
			return this.classed$3(a0, a1);
		}
		return this.classed$2(a0, a1);
	},

	/** @expose */ 
	data : function(a0, a1) {
		var args = arguments;
		if (args.length == 0) {
			return this.data$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.data$1(a0);
		}
		if (args.length == 1) {
			return this.data$3(a0);
		}
		if (args.length == 2 && typeof a0 === "function" && typeof a1 === "function") {
			return this.data$2(a0, a1);
		}
		return this.data$4(a0, a1);
	},

	/** @expose */ 
	datum : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.datum$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.datum$1(a0);
		}
		return this.datum$2(a0);
	},

	/** @expose */ 
	transition : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.transition$0();
		}
		return this.transition$1(a0);
	},

	/** @expose */ 
	interrupt : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.interrupt$0();
		}
		return this.interrupt$1(a0);
	},

	/** @expose */ 
	select : function(a0) {
		var args = arguments;
		if (args.length == 1 && typeof a0 === "function") {
			return this.select$1(a0);
		}
		return this.select$0(a0);
	},

	/** @expose */ 
	selectAll : function(a0) {
		var args = arguments;
		if (args.length == 1 && (a0 == null || typeof a0 === "string")) {
			return this.selectAll$0(a0);
		}
		return this.selectAll$1(a0);
	},

	/** @expose */ 
	init : function(a0) {
		var args = arguments;
		if (args.length == 1 && (a0 == null || typeof a0 === "string")) {
			return this.init$1(a0);
		}
		return this.init$0(a0);
	},

	/** @expose */ 
	initAll : function(a0) {
		var args = arguments;
		if (args.length == 1 && (a0 == null || Object.prototype.toString.call(a0) === "[object Array]")) {
			return this.initAll$0(a0);
		}
		return this.initAll$1(a0);
	},

	/** @expose */ 
	sort : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.sort$0();
		}
		return this.sort$1(a0);
	},

	/** @expose */ 
	extension : function(a0) {
		var args = arguments;
		return this.extension$0(a0);
	}
});

com_ibm_rave_core_selector_Selector.createSelectorGroupFromNodes = function(nodes) {
	var result = [];
	if (nodes) {
		for (var i = 0; i < nodes.length; ++i) {
			result.push(nodes[i]);
		}
	}
	return result;
};

com_ibm_rave_core_selector_Selector.createSelectorGroupFromNode = function(node) {
	var result = [];
	if (node) {
		result.push(node);
	}
	return result;
};

/**
 * Create a scene node for the given type.
 * @param (String) nsuri the namespace URI for the name, may be <code>null</code>
 * @param (String) name the scene node name
 * @param (com.ibm.rave.core.scene.SceneNode) context optional context in which the node is to reside
 * @return (com.ibm.rave.core.scene.SceneNode)  a new scene node
 */
com_ibm_rave_core_selector_Selector.createSceneNode = function(nsuri, name, context) {
	var _nsuri = nsuri;
	var config = com_ibm_rave_core_Configuration.INSTANCE;
	var nodeFactory;
	nodeFactory = config.getSceneNodeFactory(context.rave_getQualifiedName());
	if (_nsuri == null) {
		_nsuri = context.rave_getNamespaceURI();
	}
	if (!nodeFactory) {
		nodeFactory = config.getSceneNodeFactory(_nsuri);
	}
	return nodeFactory(_nsuri, name, context);
};

/**
 * Register a selector extension factory.
 * @param (String) id extension identifier
 * @param (com.ibm.rave.core.ExtensionFactory) extensionFactory The selector extension factory
 * @return (boolean)  true, if the registration was successful, false otherwise
 */
com_ibm_rave_core_selector_Selector.extension$1 = function(id, extensionFactory) {
	return com_ibm_rave_core_selector_Selector.selectorDelegateRegistry.extension$1(id, extensionFactory);
};

/** @expose */ 
com_ibm_rave_core_selector_Selector.extension = function(a0, a1) {
	var args = arguments;
	return com_ibm_rave_core_selector_Selector.extension$1(a0, a1);
};

com_ibm_rave_core_selector_Selector.factory = function() {
	return new com_ibm_rave_core_selector_Selector();
};
com_ibm_rave_core_selector_Selector.selectorDelegateRegistry = new com_ibm_rave_core_RegistryService();

// $source: com/ibm/rave/core/selector/EnterSelector
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/selector/Selector (loadtime) // superclass
var com_ibm_rave_core_selector_EnterSelector = rave_externs["EnterSelector"] = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_selector_Selector, {

	//factory : null,

	setSelectorFactory : function(factory) {
		this.factory = factory;
		return this;
	},

	insert$4 : function(type) {
		return this.insert$3(type, com_ibm_rave_core_selector_EnterSelector.enterInsertBefore(this));
	},

	insert$5 : function(type) {
		return this.insert$1(type, com_ibm_rave_core_selector_EnterSelector.enterInsertBefore(this));
	},

	/** @expose */ 
	select$1 : function(valueFunction) {
		var subgroups = this.factory();
		var subgroup;
		var subnode;
		var group;
		var upgroup;
		var node;
		for (var j = 0, m = this.length; j < m; ++j) {
			group = this[j];
			upgroup = group["update"];
			subgroup = [];
			subgroups.push(subgroup);
			subgroup["parentNode"] = group["parentNode"];
			for (var i = 0, n = group.length; i < n; ++i) {
				if ((node = group[i])) {
					subgroup.push(subnode = valueFunction.call(group["parentNode"], node.rave_getData(), i, j));
					upgroup[i] = subnode;
					subnode.rave_setData(node.rave_getData());
				} else {
					subgroup.push(null);
				}
			}
		}
		return subgroups;
	},

	/** @expose */ 
	insert : function(a0) {
		var args = arguments;
		if (args.length == 1 && (a0 == null || typeof a0 === "string")) {
			return this.insert$4(a0);
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.insert$5(a0);
		}
		return com_ibm_rave_core_selector_Selector.prototype.insert.apply(this, args);
	}
});

com_ibm_rave_core_selector_EnterSelector.enterInsertBefore = function(enter) {
	var i0, j0;
	return function(d, i, j) {
		var group = enter[j]["update"];
		var n = group.length;
		var node;
		if (j != j0) {
			j0 = j;
			i0 = 0;
		}
		if (i >= i0) {
			i0 = i + 1;
		}
		while (!(node = group[i0]) && ++i0 < n) {
		}
		return node;
	};
};


// $source: com/ibm/rave/core/internal/nativeImpl/PlatformInitialization
/************************************************************************
** IBM Confidential
**
** IBM Business Analytics: Rapidly Adaptive Visualization Engine
**
** (C) Copyright IBM Corp. 2014
**
** The source code for this program is not published or otherwise divested of its trade secrets, 
** irrespective of what has been deposited with the U.S. Copyright Office.
************************************************************************/

// @import ./scene/DOMSceneNode (static)
// @import ./selector/DOMSelectionQueryEngine (static)
// @import com/ibm/rave/core/Configuration (static)
// @import com/ibm/rave/core/selector/Selector (static)

var com_ibm_rave_core_internal_nativeImpl_PlatformInitialization = function() {
	var config = com_ibm_rave_core_Configuration.INSTANCE;
	
	var domFactory = function(nsuri, name, context) {
			var doc = context.ownerDocument || context.rave_getOwner().ownerDocument;
			return nsuri ? doc.createElementNS(nsuri, name) : doc.createElement(name);
		};
	
	config.setSceneNodeFactory(null, domFactory);
	config.setSceneNodeFactory("http://www.w3.org/1999/xhtml", domFactory);
	config.setSceneNodeFactory("http://www.w3.org/2000/svg", domFactory);
	
	// Query Engines
	
	var domQueryEngine = new com_ibm_rave_core_internal_nativeImpl_selector_DOMSelectionQueryEngine();
	config.setQueryEngine(null, domQueryEngine);
	config.setQueryEngine("http://www.w3.org/1999/xhtml", domQueryEngine);
	config.setQueryEngine("http://www.w3.org/2000/svg", domQueryEngine);
	
	
	// This is an optimization to reduce skip factory lookup if only the domFactory is present.
	var oriCreateSceneNode = com_ibm_rave_core_selector_Selector.createSceneNode;
	
	com_ibm_rave_core_selector_Selector.createSceneNode = function(nsuri, name, context) {
		var node = domFactory(nsuri == null ? context.namespaceURI : nsuri, name, context);
		if (config.nodeExtensions) {
			config.extend(node, context)
		}
		return node;
	};
	
	var oriSetSceneNodeFactory = com_ibm_rave_core_Configuration.prototype.setSceneNodeFactory;
		com_ibm_rave_core_Configuration.prototype.setSceneNodeFactory = function(namespaceUri, factory) {
			oriSetSceneNodeFactory.call(this, namespaceUri, factory);
		if (factory != domFactory) {
			com_ibm_rave_core_selector_Selector.createSceneNode = oriCreateSceneNode;
			com_ibm_rave_core_Configuration.prototype.setSceneNodeFactory = oriSetSceneNodeFactory;
		}
	}
};

com_ibm_rave_core_internal_nativeImpl_PlatformInitialization.getWindow = rave_window;
com_ibm_rave_core_internal_nativeImpl_PlatformInitialization.getDocumentElement = rave_documentElement;

com_ibm_rave_core_internal_nativeImpl_PlatformInitialization.getDocument = function() {
	return rave_document;
};

com_ibm_rave_core_internal_nativeImpl_PlatformInitialization.getDocumentBodyElement = function() {
	return rave_document.body;
};

// $source: com/ibm/rave/core/transition/Transition
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/selector/Selection (loadtime) // superclass
//@import com/ibm/rave/core/internal/transitions/Tweener (runtime) // schedule
//@import com/ibm/rave/core/internal/transitions/TransitionUtil (static) // transitionNamespace, getTransitionInfo, getTransitionTracker
//@import com/ibm/rave/core/internal/selector/SelectorHelper (runtime) // each, selectorAll, selector
//@import com/ibm/rave/core/ease/Easing (runtime) // Easing
//@import com/ibm/rave/core/internal/util/NamespaceUtil (runtime) // getQName
//@import com/ibm/rave/core/internal/transitions/TweenFunctions (runtime) // style, attr, styleTween, attrTween, tween
//@import com/ibm/rave/core/internal/nativeImpl/transitions/InheritedTransition (static) // set, get
//@import com/ibm/rave/core/internal/util/QueryUtil (runtime) // getQueryEngine
//@import com/ibm/rave/core/selector/Selector (static) // new
//@import com/ibm/rave/core/internal/nativeImpl/PlatformInitialization (static) // getDocument, getDocumentElement
/**
 * A transition is a special type of selection where the operators apply smoothly over time rather than instantaneously. You derive a transition from a selection using the transition operator. While transitions generally support the same operators as selections (such as attr and style), not all operators are supported; for example, you must append elements before a transition starts. A remove operator is provided for convenient removal of elements when the transition ends. <p> Transitions may have per-element delays and durations, computed using functions of data similar to other operators. This makes it easy to stagger a transition for different elements, either based on data or index. For example, you can sort elements and then stagger the transition for better perception of element reordering during the transition. <p> There are many built-in interpolators to simplify the transitioning of arbitrary values. For instance, you can transition from the font string "500 12px sans-serif" to "300 42px sans-serif", and the interpolator will find the numbers embedded within the string, interpolating both font size and weight automatically. You can even interpolate arbitrary nested objects and arrays or SVG path data. The addition of custom interpolators are supported should you find the built-in ones insufficient, using the attrTween and styleTween operators. <p> Only one transition may be active on a given element at a given time. However, multiple transitions may be scheduled on the same element; provided they are staggered in time, each transition will run in sequence. If a newer transition runs on a given element, it implicitly cancels any older transitions, including any that were scheduled but not yet run. This allows new transitions, such as those in response to a new user event, to supersede older transitions even if those older transitions are staged or have staggered delays. Multi-stage transitions (transitions that are created during the "end" event of an earlier transition) are considered the same "age" as the original transition; internally this is tracked by monotonically-increasing unique IDs which are inherited when multi-stage transitions are created. To interrupt an in-progress transition, use {@link this.Selector#this.interrupt()} .
 */
var com_ibm_rave_core_transition_Transition = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_selector_Selection, {

	/**
	 * @expose  
	 */
	//namespace : null,

	/**
	 * @expose  
	 */
	id : 0,

	/**
	 * Get the integer ID of this transition.
	 * @return (int)  the transition ID
	 */
	/** @expose */ 
	getId : function() {
		return this.id;
	},

	/**
	 * Get the String name of this transition.
	 * @return (String)  the transition name
	 */
	/** @expose */ 
	getNamespace : function() {
		return this.namespace;
	},

	/**
	 * Construct a new transition.
	 * @param (int) id the assigned transition ID
	 * @param (String) transitionNamespace the transition name
	 */
	constructor : function(id, transitionNamespace) {
		this.namespace = transitionNamespace;
		this.id = id;
		com_ibm_rave_core_internal_transitions_Tweener.schedule(this);
	},

	/**
	 * Returns the delay, in milliseconds, bound to the first non-null element in the transition. If no non-null element exists, returns the default delay 0.
	 * @return (double)  the delay in milliseconds
	 */
	delay$0 : function() {
		var node = this.node();
		return node ? com_ibm_rave_core_internal_transitions_TransitionUtil.getTransitionInfo(node, this.namespace, this.id).delay : 0;
	},

	/**
	 * Specifies the transition delay in milliseconds as a constant.
	 * @param (Object) delay the transition delay in milliseconds
	 * @return (com.ibm.rave.core.transition.Transition)  this  {@link (com.ibm.rave.core.transition.Transition) Transition}
	 */
	delay$1 : function(delay) {
		var d = + (delay);
		var transitionId = this.id;
		var transitionNamespace = this.namespace;
		return com_ibm_rave_core_internal_selector_SelectorHelper.each(this, function(data, index, groupIndex) {
			com_ibm_rave_core_internal_transitions_TransitionUtil.getTransitionInfo(this, transitionNamespace, transitionId).delay = d;
		});
	},

	/**
	 * Specifies the transition duration in milliseconds as a function. The function is evaluated for each selected element (in order), being passed the current datum and the current index, with the context as the current scene node. The function's return value is then used to set each element's delay.
	 * @param (com.ibm.rave.core.selector.ValueFunction) delayFunction the delay function to evaluate for each selected element
	 * @return (com.ibm.rave.core.transition.Transition)  this  {@link (com.ibm.rave.core.transition.Transition) Transition}
	 */
	delay$2 : function(delayFunction) {
		var transitionId = this.id;
		var transitionNamespace = this.namespace;
		return com_ibm_rave_core_internal_selector_SelectorHelper.each(this, function(data, index, groupIndex) {
			com_ibm_rave_core_internal_transitions_TransitionUtil.getTransitionInfo(this, transitionNamespace, transitionId).delay = + (delayFunction.call(this, this.rave_getData(), index, groupIndex));
		});
	},

	/**
	 * Returns the duration, in milliseconds, bound to the first non-null element in the transition. If no non-null element exists, returns the default duration 250.
	 * @return (double)  the delay in milliseconds
	 */
	duration$0 : function() {
		var node = this.node();
		return node ? com_ibm_rave_core_internal_transitions_TransitionUtil.getTransitionInfo(node, this.namespace, this.id).duration : 250;
	},

	/**
	 * Specifies the transition duration in milliseconds as a constant.
	 * @param (Object) duration the transition duration in milliseconds
	 * @return (com.ibm.rave.core.transition.Transition)  this  {@link (com.ibm.rave.core.transition.Transition) Transition}
	 */
	duration$1 : function(duration) {
		var transitionId = this.id;
		var transitionNamespace = this.namespace;
		var d = Math.max(1, + (duration));
		return com_ibm_rave_core_internal_selector_SelectorHelper.each(this, function(data, index, groupIndex) {
			com_ibm_rave_core_internal_transitions_TransitionUtil.getTransitionInfo(this, transitionNamespace, transitionId).duration = d;
		});
	},

	/**
	 * Specifies the transition duration in milliseconds as a function. The function is evaluated for each selected element (in order), being passed the current datum and the current index, with the context as the current scene node. The function's return value is then used to set each element's duration.
	 * @param (com.ibm.rave.core.selector.ValueFunction) durationFunction the duration function to evaluate for each selected element
	 * @return (com.ibm.rave.core.transition.Transition)  this  {@link (com.ibm.rave.core.transition.Transition) Transition}
	 */
	duration$2 : function(durationFunction) {
		var transitionId = this.id;
		var transitionNamespace = this.namespace;
		return com_ibm_rave_core_internal_selector_SelectorHelper.each(this, function(data, index, groupIndex) {
			var d = + (durationFunction.call(this, data, index, groupIndex));
			com_ibm_rave_core_internal_transitions_TransitionUtil.getTransitionInfo(this, transitionNamespace, transitionId).duration = Math.max(1, d);
		});
	},

	/**
	 * Returns the easing bound to the first non-null element in the transition. If no non-null element exists, returns the default easing 'cubic-in-out'.
	 * @return (com.ibm.rave.core.ease.EasingFunction)  an  {@link (com.ibm.rave.core.ease.EasingFunction) EasingFunction}
	 */
	ease$0 : function() {
		var node = this.node();
		return node ? com_ibm_rave_core_internal_transitions_TransitionUtil.getTransitionInfo(node, this.namespace, this.id).ease : com_ibm_rave_core_ease_Easing.DEFAULT;
	},

	/**
	 * Specifies the easing by name. Both name and arguments are passed to {@link this.Rave#com_ibm_rave_core_Rave.ease}  to generate an  {@link (com.ibm.rave.core.ease.EasingFunction) EasingFunction} .
	 * @param (String) name the easing function name
	 * @param (java.lang.Object[]) args the easing function arguments
	 * @return (com.ibm.rave.core.transition.Transition)  this  {@link (com.ibm.rave.core.transition.Transition) Transition}
	 */
	ease$1 : function(name, args) {
		if (args !== null || arguments.length > 2){
			args = Array.prototype.slice.call(arguments, 1);
		}
		{
			return this.ease$2(com_ibm_rave_core_ease_Easing.INSTANCE.apply(com_ibm_rave_core_ease_Easing.INSTANCE, [name].concat(args)));
		}
	},

	/**
	 * Specifies the easing function which is used to ease the current parametric timing value, which is typically in the range [0,1]. (At the end of a transition, timing value may be slightly greater than 1.) <p> The default easing function is "cubic-in-out". Note that it is not possible to customize the easing function per-element or per-attribute; however, if you use the "linear" easing function, you can apply custom easing inside your interpolator using attrTween or styleTween.
	 * @param (com.ibm.rave.core.ease.EasingFunction) easeFunction the easing function
	 * @return (com.ibm.rave.core.transition.Transition)  this  {@link (com.ibm.rave.core.transition.Transition) Transition}
	 */
	ease$2 : function(easeFunction) {
		var transitionId = this.id;
		var transitionNamespace = this.namespace;
		return com_ibm_rave_core_internal_selector_SelectorHelper.each(this, function(data, index, groupIndex) {
			com_ibm_rave_core_internal_transitions_TransitionUtil.getTransitionInfo(this, transitionNamespace, transitionId).ease = easeFunction;
		});
	},

	/**
	 * Transitions the value of the attribute with the specified name to the specified value. The starting value of the transition is the current attribute value (be sure to set an initial value beforehand if you don't want bad surprises), and the ending value is the specified value. If value is a constant, then all elements are transitioned to the same attribute value; otherwise, if value is a function, then the function is evaluated for each selected element (in order), being passed the current datum and the current index, with the context as the current element. The function's return value is then used to transition each element's attribute. Null values are not supported because the interpolator would be undefined; if you want to remove the attribute after the transition finishes, use  {@link #this.remove()} . <p> An interpolator is selected automatically based on the ending value. If the ending value is a number, the starting value is coerced to a number and interpolateNumber is used. If the ending value is a string, a check is performed to see if the string represents a color of the form /^(#|rgb\(|hsl\()/, or one of the CSS named colors; if so, the starting value is coerced to an RGB color and interpolateRgb is used. Otherwise, interpolateString is used, which interpolates numbers embedded within strings.
	 * @param (String) attribute the named attribute to tween
	 * @param (Object) value the attribute value as a constant or  {@link (com.ibm.rave.core.selector.ValueFunction) ValueFunction}
	 * @return (com.ibm.rave.core.transition.Transition)  this  {@link (com.ibm.rave.core.transition.Transition) Transition}
	 */
	attr$1 : function(attribute, value) {
		var qname = com_ibm_rave_core_internal_util_NamespaceUtil.getQName(attribute);
		return com_ibm_rave_core_internal_transitions_TweenFunctions.tween(this, "attr." + attribute, value, function(v) {
			return com_ibm_rave_core_internal_transitions_TweenFunctions.attr(qname, v);
		});
	},

	/**
	 * Convenience method for specifying an attr transition where the value is a function which is evaluated for each selected element.
	 * @param (String) attribute the named attribute to tween
	 * @param (com.ibm.rave.core.selector.ValueFunction) value the attribute value as a  {@link (com.ibm.rave.core.selector.ValueFunction) ValueFunction}
	 * @return (com.ibm.rave.core.transition.Transition)  this  {@link (com.ibm.rave.core.transition.Transition) Transition}
	 * @see #this.attr(String, Object)
	 */
	attr$2 : function(attribute, value) {
		return this.attr$1(attribute, value);
	},

	/**
	 * Transitions the value of the attribute with the specified name according to the specified tween function. The starting and ending value of the transition are determined by tween; the tween function is invoked when the transition starts on each element, being passed the current datum, the current index and the current attribute value, with the context as the current scene node. The return value of tween must be an interpolator: a function that maps a parametric value t in the domain [0,1] to a color, number or arbitrary value. <p> The attrTween operator is used when you need a custom interpolator, such as one that understands the semantics of SVG path data. One common technique is dataspace interpolation, where interpolateObject is used to interpolate two data values, and the result of this interpolation is then used (say, with a shape) to compute the new attribute value. Use the attr operator for the simpler common case where an interpolator can be automatically derived from the current attribute value to the desired end value.
	 * @param (String) attribute the named attribute to tween
	 * @param (com.ibm.rave.core.transition.TransitionInterpolatorFactory) factory a factory function which returns an interpolator
	 * @return (com.ibm.rave.core.transition.Transition)  this  {@link (com.ibm.rave.core.transition.Transition) Transition}
	 */
	/** @expose */ 
	attrTween : function(attribute, factory) {
		var qname = com_ibm_rave_core_internal_util_NamespaceUtil.getQName(attribute);
		return this.tween("attr." + attribute, com_ibm_rave_core_internal_transitions_TweenFunctions.attrTween(qname, factory));
	},

	/**
	 * Set the text content to the specified value on all selected elements when the transition starts. If value is a constant, then all elements are given the same text content; otherwise, if value is a function, then the function is evaluated for each selected element (in order), being passed the current datum and the current index, with the context as the current scene node. The function's return value is then used to set each element's text content. A null value will clear the content.
	 * @param (Object) value the text content value as a constant or a {@link (com.ibm.rave.core.selector.ValueFunction) ValueFunction}
	 * @return (com.ibm.rave.core.transition.Transition)  this  {@link (com.ibm.rave.core.transition.Transition) Transition}
	 */
	text$0 : function(value) {
		return com_ibm_rave_core_internal_transitions_TweenFunctions.tween(this, "text", value, function(v) {
			var textValue = (v == null ? "" : v + "");
			return function(data, index, groupIndex) {
				this.rave_setText(textValue);
				return null;
			};
		});
	},

	/**
	 * Convenience method for specifying a text transition where the value is a function which is evaluated for each selected element.
	 * @param (com.ibm.rave.core.selector.ValueFunction) value the text content value as a  {@link (com.ibm.rave.core.selector.ValueFunction) ValueFunction}
	 * @return (com.ibm.rave.core.transition.Transition)  this  {@link (com.ibm.rave.core.transition.Transition) Transition}
	 * @see #this.text(Object)
	 */
	text$1 : function(value) {
		return this.text$0(value);
	},

	/**
	 * Same as  {@link #this.style(String, Object, String)}  with a null priority.
	 * @param (String) styleName the named style to tween
	 * @param (Object) value the style value as a constant or  {@link (com.ibm.rave.core.selector.ValueFunction) ValueFunction}
	 * @return (com.ibm.rave.core.transition.Transition)  this  {@link (com.ibm.rave.core.transition.Transition) Transition}
	 */
	style$2 : function(styleName, value) {
		return this.style$4(styleName, value, null);
	},

	/**
	 * Transitions the value of the CSS style property with the specified name to the specified value. An optional priority may also be specified, either as null or the string "important" (without the exclamation point). The starting value of the transition is the current computed style property value, and the ending value is the specified value. If value is a constant, then all elements are transitioned to the same style property value; otherwise, if value is a function, then the function is evaluated for each selected element (in order), being passed the current datum and the current index, with the context as the current element. The function's return value is then used to transition each element's style property. Null values are not supported because the interpolator would be undefined; if you want to remove the style property after the transition finishes, listen to the end event. <p> An interpolator is selected automatically based on the ending value. If the ending value is a number, the starting value is coerced to a number and interpolateNumber is used. If the ending value is a string, a check is performed to see if the string represents a color of the form /^(#|rgb\(|hsl\()/, or one of the CSS named colors; if so, the starting value is coerced to an RGB color and interpolateRgb is used. Otherwise, interpolateString is used, which interpolates numbers embedded within strings. <p> Note that the computed starting value may be different than the value that was previously set, particularly if the style property was set using a shorthand property (such as the "font" style, which is shorthand for "font-size", "font-face", etc.). Moreover, computed dimensions such as "font-size" and "line-height" are always in pixels, so you should specify the ending value in pixels too if appropriate.
	 * @param (String) styleName the named style to tween
	 * @param (Object) value the style value as a constant or  {@link (com.ibm.rave.core.selector.ValueFunction) ValueFunction}
	 * @param (String) priority either null or the string "important"
	 * @return (com.ibm.rave.core.transition.Transition)  this  {@link (com.ibm.rave.core.transition.Transition) Transition}
	 */
	style$4 : function(styleName, value, priority) {
		var p = priority != null ? priority : "";
		return com_ibm_rave_core_internal_transitions_TweenFunctions.tween(this, "style." + styleName, value, function(v) {
			return com_ibm_rave_core_internal_transitions_TweenFunctions.style(styleName, v, p);
		});
	},

	/**
	 * Convenience method for specifying a style transition where the value is a function which is evaluated for each selected element.
	 * @param  styleName the named style to tween
	 * @param (com.ibm.rave.core.selector.ValueFunction) value the style value as a  {@link (com.ibm.rave.core.selector.ValueFunction) ValueFunction}
	 * @return (com.ibm.rave.core.transition.Transition)  this  {@link (com.ibm.rave.core.transition.Transition) Transition}
	 * @see #this.style(String, Object)
	 */
	style$3 : function(attribute, value) {
		return this.style$4(attribute, value, null);
	},

	/**
	 * Convenience method for specifying a style transition where the value is a function which is evaluated for each selected element.
	 * @param  styleName the named style to tween
	 * @param (com.ibm.rave.core.selector.ValueFunction) value the style value as a  {@link (com.ibm.rave.core.selector.ValueFunction) ValueFunction}
	 * @param (String) priority either null or the string "important"
	 * @return (com.ibm.rave.core.transition.Transition)  this  {@link (com.ibm.rave.core.transition.Transition) Transition}
	 * @see #this.style(String, Object, String)
	 */
	style$5 : function(attribute, value, priority) {
		return this.style$4(attribute, value, priority);
	},

	/**
	 * Same as {@link #this.styleTween(String, com_ibm_rave_core_transition_TransitionInterpolatorFactory, String)}  with a null priority.
	 * @param (String) styleName the named style to tween
	 * @param (com.ibm.rave.core.transition.TransitionInterpolatorFactory) factory a factory function which returns an interpolator
	 * @return (com.ibm.rave.core.transition.Transition)  this  {@link (com.ibm.rave.core.transition.Transition) Transition}
	 */
	styleTween$0 : function(styleName, factory) {
		return this.styleTween$1(styleName, factory, null);
	},

	/**
	 * Transitions the value of the CSS style property with the specified name according to the specified tween function. An optional priority may also be specified, either as null or the string "important" (without the exclamation point). The starting and ending value of the transition are determined by tween; the tween function is invoked when the transition starts on each element, being passed the current datum, the current index and the current attribute value, with the this context as the current scene node. The return value of tween must be an interpolator: a function that maps a parametric value t in the domain [0,1] to a color, number or arbitrary value. <p> The styleTween operator is used when you need a custom interpolator, such as one that understands the semantics of CSS3 transforms. Use the style operator for the simpler common case where an interpolator can be automatically derived from the current computed style property value to the desired end value.
	 * @param (String) styleName the named style to tween
	 * @param (com.ibm.rave.core.transition.TransitionInterpolatorFactory) factory a factory function which returns an interpolator
	 * @param (String) priority either null or the string "important"
	 * @return (com.ibm.rave.core.transition.Transition)  this  {@link (com.ibm.rave.core.transition.Transition) Transition}
	 */
	styleTween$1 : function(styleName, factory, priority) {
		return this.tween("style." + styleName, com_ibm_rave_core_internal_transitions_TweenFunctions.styleTween(styleName, factory, priority != null ? priority : ""));
	},

	/**
	 * Registers a custom tween for the specified name. When the transition starts, the specified factory function will be invoked for each selected element in the transition, being passed that element's datum and index as arguments, with the element as the context. The factory should return the tween function to be called over the course of the transition. The tween function is then called repeatedly, being passed the current normalized time in [0, 1]. If the factory returns null, then the tween is not run on the selected element. <p> The tween method is used internally to implement attr and style tweens, and can be used to interpolate other document content.
	 * @param (String) name the tween name
	 * @param (com.ibm.rave.core.selector.ValueFunction) factory the tween factory which returns a  {@link (com.ibm.rave.core.transition.Tween) Tween}  function, or <code>null</code> to remove the tween by name
	 * @return (com.ibm.rave.core.transition.Transition)  this  {@link (com.ibm.rave.core.transition.Transition) Transition}
	 */
	tween$0 : function(name, factory) {
		var transitionId = this.id;
		var transitionName = this.namespace;
		return com_ibm_rave_core_internal_selector_SelectorHelper.each(this, !factory ? function(data, index, groupIndex) {
			com_ibm_rave_core_internal_transitions_TransitionUtil.getTransitionInfo(this, transitionName, transitionId).removeTweenFactory(name);
		} : function(data, index, groupIndex) {
			com_ibm_rave_core_internal_transitions_TransitionUtil.getTransitionInfo(this, transitionName, transitionId).addTweenFactory(name, factory);
		});
	},

	/**
	 * Returns the  {@link (com.ibm.rave.core.transition.Tween) Tween}  associated with the given name bound to the first non-null element in the transition.
	 * @param (String) tweenName the tween name
	 * @return (com.ibm.rave.core.selector.ValueFunction)  the  {@link (com.ibm.rave.core.transition.Tween) Tween}  associated with the given name, may be <code> null</code>
	 */
	tween$1 : function(tweenName) {
		var node = this.node();
		return node ? com_ibm_rave_core_internal_transitions_TransitionUtil.getTransitionInfo(node, this.namespace, this.id).getTweenFactory(tweenName) : null;
	},

	/**
	 * Behaves similarly to selection.each: immediately invokes the specified function for each element in the current transition, passing in the current datum and index, with the context of the current scene node. Any transitions created within the scope of transition.each will inherit transition parameters from the parent transition, including id, delay, duration and easing. Thus, transitions created within a transition.each will not interrupt the parent transition, similar to subtransitions. <p> The transition.each method can be used to chain transitions and apply shared timing across a set of transitions. By using d3.select(this) within transition.each, you can even inherit staggered delay across a set of selected elements. This technique is used by the Axis component to support automatic transitions.
	 * @param (com.ibm.rave.core.selector.CallbackFunction) callback the callback function
	 */
	each$0 : function(callback) {
		var transitionId = this.id;
		var transitionNamespace = this.namespace;
		var inherit = com_ibm_rave_core_internal_nativeImpl_transitions_InheritedTransition.get();
		try {
			return com_ibm_rave_core_internal_selector_SelectorHelper.each(this, function(data, index, groupIndex) {
				var info = com_ibm_rave_core_internal_transitions_TransitionUtil.getTransitionInfo(this, transitionNamespace, transitionId);
				com_ibm_rave_core_internal_nativeImpl_transitions_InheritedTransition.set(info);
				callback.call(this, data, index, groupIndex);
			});
		} finally {
			com_ibm_rave_core_internal_nativeImpl_transitions_InheritedTransition.set(inherit);
		}
	},

	/**
	 * Adds a listener for transition events, supporting "start", and "end" events. The listener will be invoked for each individual element in the transition. <p> The start event is invoked during the first asynchronous callback (tick) of the transition, before any tweens are invoked. For transitions with zero delay, this is typically about 17ms after the transition is scheduled. State events are useful for triggering instantaneous changes to each element, such as changing attributes that cannot be interpolated. <p> The end event is invoked during the last asynchronous callback (tick) after the transition duration and delay expires, after all tweens are invoked with t=1. Note that if the transition is superseded by a later-scheduled transition on a given element, no end event will be dispatched for that element; interrupted transitions do not trigger end events. For example, transition.remove schedules each element to be removed when the transition ends, but if the transition is interrupted, the element will not be removed. End events can be used as an alternative to transition.transition to create chained transitions by selecting the current element, this, and deriving a new transition; however, this can lead to clock drift over time and thus transition.transition should be preferred.
	 * @param (String) type the event type
	 * @param (com.ibm.rave.core.selector.RunFunction) listener the event listener
	 * @return (com.ibm.rave.core.transition.Transition)  this  {@link (com.ibm.rave.core.transition.Transition) Transition}
	 */
	each$1 : function(type, listener) {
		var transitionId = this.id;
		var transitionNamespace = this.namespace;
		return com_ibm_rave_core_internal_selector_SelectorHelper.each(this, function(data, index, groupIndex) {
			com_ibm_rave_core_internal_transitions_TransitionUtil.getTransitionInfo(this, transitionNamespace, transitionId).getOrCreateDispatcher().on(type, listener);
		});
	},

	/**
	 * Remove the selected nodes at the end of a transition. If a newer transition is scheduled on any of the selected nodes, these nodes will not be removed; however, the "end" event will still be dispatched.
	 * @return (com.ibm.rave.core.transition.Transition)  this  {@link (com.ibm.rave.core.transition.Transition) Transition}
	 */
	/** @expose */ 
	remove : function() {
		var transitionNamespace = this.namespace;
		return this.each("end.transition", function(args) {
			if (args !== null || arguments.length > 1){
				args = Array.prototype.slice.call(arguments, 0);
			}
			{
				var p = this.rave_getParentNode();
				var t = com_ibm_rave_core_internal_transitions_TransitionUtil.getTransitionTracker(this, transitionNamespace);
				if (t.count < 2 && p) {
					p.removeChild(this);
				}
				return null;
			}
		});
	},

	/**
	 * Invokes the specified function once, passing in the current transition along with any optional arguments. The call operator always returns the current transition, regardless of the return value of the specified function. The call operator is identical to invoking a function by hand; but it makes it easier to use method chaining. <p> The this context of the called function is also the current transition. This is slightly redundant with the first argument, which we might fix in the future.
	 * @param (com.ibm.rave.core.selector.RunFunction) callback the callback function
	 * @param (java.lang.Object[]) args the array of arguments
	 * @return (com.ibm.rave.core.transition.Transition)  this instance of transition
	 */
	/** @expose */ 
	call : function(callback, args) {
		if (args !== null || arguments.length > 2){
			args = Array.prototype.slice.call(arguments, 1);
		}
		{
			var list = (args);
			list.splice(0, 0, this);
			callback.apply(this, list);
			return this;
		}
	},

	/**
	 * Creates a new transition on the same selected elements that starts when this transition ends. The new transition inherits this transition’s duration and easing. This can be used to define chained transitions without needing to listen for "end" events.
	 * @return (com.ibm.rave.core.transition.Transition)  a new  {@link (com.ibm.rave.core.transition.Transition) Transition} .
	 */
	transition$0 : function() {
		var parentId = this.id;
		var newId = ++com_ibm_rave_core_transition_Transition.idCount;
		var ns = this.namespace;
		var subgroups = new com_ibm_rave_core_transition_Transition(newId, ns);
		var subgroup;
		var group;
		var node;
		for (var j = 0, m = this.length; j < m; ++j) {
			group = this[j];
			subgroup = [];
			subgroups.push(subgroup);
			for (var i = 0, n = group.length; i < n; ++i) {
				if ((node = group[i])) {
					var info = com_ibm_rave_core_internal_transitions_TransitionUtil.getTransitionInfo(node, ns, newId);
					info.index = i;
					info.groupIndex = j;
					var pinfo = com_ibm_rave_core_internal_transitions_TransitionUtil.getTransitionInfo(node, ns, parentId);
					info.delay = pinfo.delay + pinfo.duration;
					info.duration = pinfo.duration;
					info.ease = pinfo.ease;
					info.time = pinfo.time;
				}
				subgroup.push(node);
			}
		}
		return subgroups;
	},

	/**
	 * Creates a new transition on the same selected elements that starts when this transition ends. The new transition inherits this transition’s duration and easing. This can be used to define chained transitions without needing to listen for "end" events.
	 * @param (String) transitionNamespace ignored
	 * @return (com.ibm.rave.core.transition.Transition)  a new  {@link (com.ibm.rave.core.transition.Transition) Transition} .
	 */
	transition$1 : function(transitionNamespace) {
		return this.transition$0();
	},

	/** @expose */ 
	isTransition : function() {
		return true;
	},

	/**
	 * Like  {@link #this.select(com_ibm_rave_core_selector_ValueFunction)}  using a string to specify a selector query.
	 */
	select$0 : function(query) {
		return this.select$1(com_ibm_rave_core_internal_selector_SelectorHelper.selector(query));
	},

	/**
	 * For each element in the current transition, selects the first descendant element that matches the specified selector. If no element matches the specified selector for the current element, the element at the current index will be null in the returned selection; operators (with the exception of data) automatically skip null elements, thereby preserving the index of the existing selection. If the current element has associated data, this data is inherited by the returned subselection, and automatically bound to the newly selected elements. If multiple elements match the selector, only the first matching element in document traversal order will be selected. <p> This method is approximately equivalent to: <pre> selection.select(selector).transition() </pre> where selection is the current transition's underlying selection. In addition, the returned new transition inherits easing, duration and delay from the current transition.
	 */
	select$1 : function(valueFunction) {
		var subgroups = new com_ibm_rave_core_transition_Transition(this.id, this.namespace);
		var subgroup;
		var subnode;
		var group;
		var node;
		for (var j = 0, m = this.length; j < m; ++j) {
			group = this[j];
			subgroup = [];
			subgroups.push(subgroup);
			for (var i = 0, n = group.length; i < n; ++i) {
				if ((node = group[i])) {
					subgroup.push(subnode = valueFunction.call(node, node.rave_getData(), i, j));
					if (subnode) {
						if (node.rave_hasData()) {
							subnode.rave_setData(node.rave_getData());
						}
						var inherit = com_ibm_rave_core_internal_transitions_TransitionUtil.getTransitionInfo(node, this.namespace, this.id);
						var info = com_ibm_rave_core_internal_transitions_TransitionUtil.getTransitionInfo(subnode, this.namespace, this.id);
						info.index = i;
						info.groupIndex = j;
						info.delay = inherit.delay;
						info.duration = inherit.duration;
						info.ease = inherit.ease;
					}
				} else {
					subgroup.push(null);
				}
			}
		}
		return subgroups;
	},

	/**
	 * Like  {@link #this.selectAll(com_ibm_rave_core_selector_ValueFunction)}  using a string to specify a selector query.
	 */
	selectAll$0 : function(query) {
		return this.selectAll$1(com_ibm_rave_core_internal_selector_SelectorHelper.selectorAll(query));
	},

	/**
	 * For each element in the current transition, selects descendant elements that match the specified selector. The returned selection is grouped by the ancestor node in the current selection. If no element matches the specified selector for the current element, the group at the current index will be empty in the returned selection. The subselection does not inherit data from the current selection; however, if data was previously bound to the selected elements, that data will be available to operators. <p> This method is approximately equivalent to: <pre> selection.selectAll(selector).transition() </pre> where selection is the current transition's underlying selection. In addition, the returned new transition inherits easing, duration and delay from the current transition. The duration and delay for each subelement is inherited from the duration and delay of the parent element in the current transition.
	 * @return (com.ibm.rave.core.transition.Transition)  a new  {@link (com.ibm.rave.core.transition.Transition) Transition}
	 */
	selectAll$1 : function(selector) {
		var subgroups = new com_ibm_rave_core_transition_Transition(this.id, this.namespace);
		var subgroup;
		var group;
		var node, subnode;
		var subnodes;
		for (var j = 0, m = this.length; j < m; ++j) {
			group = this[j];
			for (var i = 0, n = group.length; i < n; ++i) {
				if ((node = group[i])) {
					subgroup = [];
					subnodes = selector.call(node, node.rave_getData(), i, j);
					subgroups.push(subgroup);
					var inherit = com_ibm_rave_core_internal_transitions_TransitionUtil.getTransitionInfo(node, this.namespace, this.id);
					for (var k = 0, o = subnodes.length; k < o; ++k) {
						subnode = subnodes[k];
						if (subnode) {
							var info = com_ibm_rave_core_internal_transitions_TransitionUtil.getTransitionInfo(subnode, this.namespace, this.id);
							info.index = k;
							info.groupIndex = i;
							info.delay = inherit.delay;
							info.duration = inherit.duration;
							info.ease = inherit.ease;
						}
						subgroup.push(subnode);
					}
				}
			}
		}
		return subgroups;
	},

	/**
	 * Like  {@link #this.filter(com_ibm_rave_core_selector_ValueFunction)}  using a string to specify a selector query.
	 */
	filter$1 : function(filter) {
		return this.filter$0(function(data, index, groupIndex) {
			return com_ibm_rave_core_internal_util_QueryUtil.getQueryEngine(this).matches(this, filter);
		});
	},

	/**
	 * Filters the transition, returning a new transition that contains only the elements for which the specified selector is true. As with other operators, the function is passed the current datum and index, with the context as the current scene node. The returned selection does not preserve the index of the original selection; it returns a copy with elements removed. If you want to preserve the index, use select instead. <p> For example, to select every other element: <pre> var odds = transition.select(function(d, i) { return i & 1 ? this : null; }); </pre> Equivalently, using a filter function: <pre> var odds = transition.filter(function(d, i) { return i & 1; }); </pre> Or a filter selector: <pre> var odds = transition.filter(&quot;:nth-child(odd)&quot;); </pre> Thus, you can use either select or filter to apply tweens to a subset of elements.
	 * @param (com.ibm.rave.core.selector.ValueFunction) filterFunction the filter function
	 * @return (com.ibm.rave.core.transition.Transition)  a new  {@link (com.ibm.rave.core.transition.Transition) Transition}  subset of the current transition
	 */
	filter$0 : function(filterFunction) {
		var subgroups = new com_ibm_rave_core_transition_Transition(this.id, this.namespace);
		var subgroup;
		var group;
		var node;
		for (var j = 0, m = this.length; j < m; ++j) {
			subgroup = [];
			subgroups.push(subgroup);
			group = this[j];
			for (var i = 0, n = group.length; i < n; ++i) {
				node = group[i];
				if (node && filterFunction.call(node, node.rave_getData(), i, j)) {
					subgroup.push(node);
				}
			}
		}
		return subgroups;
	},

	/** @expose */ 
	delay : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.delay$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.delay$2(a0);
		}
		return this.delay$1(a0);
	},

	/** @expose */ 
	duration : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.duration$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.duration$2(a0);
		}
		return this.duration$1(a0);
	},

	/** @expose */ 
	ease : function(a0, a1) {
		var args = arguments;
		if (args.length == 0) {
			return this.ease$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.ease$2(a0);
		}
		return this.ease$1.apply(this, args);
	},

	/** @expose */ 
	attr : function(a0, a1) {
		var args = arguments;
		if (args.length == 2 && (a0 == null || typeof a0 === "string") && typeof a1 === "function") {
			return this.attr$2(a0, a1);
		}
		if (args.length == 2 && (a0 == null || typeof a0 === "string") && (a1 == null || Object.prototype.toString.call(a1) !== "[object Array]")) {
			return this.attr$1(a0, a1);
		}
		return com_ibm_rave_core_selector_Selection.prototype.attr.apply(this, args);
	},

	/** @expose */ 
	text : function(a0) {
		var args = arguments;
		if (args.length == 1 && typeof a0 === "function") {
			return this.text$1(a0);
		}
		return this.text$0(a0);
	},

	/** @expose */ 
	style : function(a0, a1, a2) {
		var args = arguments;
		if (args.length == 2 && (a0 == null || typeof a0 === "string") && typeof a1 === "function") {
			return this.style$3(a0, a1);
		}
		if (args.length == 2 && (a0 == null || typeof a0 === "string") && (a1 == null || Object.prototype.toString.call(a1) !== "[object Array]")) {
			return this.style$2(a0, a1);
		}
		if (args.length == 3 && (a0 == null || typeof a0 === "string") && typeof a1 === "function" && (a2 == null || typeof a2 === "string")) {
			return this.style$5(a0, a1, a2);
		}
		if (args.length == 3 && (a0 == null || typeof a0 === "string") && (a1 == null || Object.prototype.toString.call(a1) !== "[object Array]") && (a2 == null || typeof a2 === "string")) {
			return this.style$4(a0, a1, a2);
		}
		return com_ibm_rave_core_selector_Selection.prototype.style.apply(this, args);
	},

	/** @expose */ 
	styleTween : function(a0, a1, a2) {
		var args = arguments;
		if (args.length == 2) {
			return this.styleTween$0(a0, a1);
		}
		return this.styleTween$1(a0, a1, a2);
	},

	/** @expose */ 
	tween : function(a0, a1) {
		var args = arguments;
		if (args.length == 1) {
			return this.tween$1(a0);
		}
		return this.tween$0(a0, a1);
	},

	/** @expose */ 
	each : function(a0, a1) {
		var args = arguments;
		if (args.length == 1) {
			return this.each$0(a0);
		}
		return this.each$1(a0, a1);
	},

	/** @expose */ 
	transition : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.transition$0();
		}
		return this.transition$1(a0);
	},

	/** @expose */ 
	select : function(a0) {
		var args = arguments;
		if (args.length == 1 && typeof a0 === "function") {
			return this.select$1(a0);
		}
		return this.select$0(a0);
	},

	/** @expose */ 
	selectAll : function(a0) {
		var args = arguments;
		if (args.length == 1 && (a0 == null || typeof a0 === "string")) {
			return this.selectAll$0(a0);
		}
		return this.selectAll$1(a0);
	},

	/** @expose */ 
	filter : function(a0) {
		var args = arguments;
		if (args.length == 1 && (a0 == null || typeof a0 === "string")) {
			return this.filter$1(a0);
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.filter$0(a0);
		}
		return Array.prototype.filter.apply(this, args);
	}
});

/**
 * Create a transition on the top-level (documentElement) scene node.
 * @return (com.ibm.rave.core.transition.Transition)  A new transition on documentElement.
 */
com_ibm_rave_core_transition_Transition.newTransition$0 = function() {
	return new com_ibm_rave_core_selector_Selector().init(com_ibm_rave_core_internal_nativeImpl_PlatformInitialization.getDocumentElement(com_ibm_rave_core_internal_nativeImpl_PlatformInitialization.getDocument())).transition(null);
};

/**
 * Create a transition on the top-level (documentElement) scene node.
 * @param (String) name the name for the transition
 * @return (com.ibm.rave.core.transition.Transition)  A new transition on documentElement.
 */
com_ibm_rave_core_transition_Transition.newTransition$1 = function(name) {
	return new com_ibm_rave_core_selector_Selector().init(com_ibm_rave_core_internal_nativeImpl_PlatformInitialization.getDocumentElement(com_ibm_rave_core_internal_nativeImpl_PlatformInitialization.getDocument())).transition(name);
};

/**
 * This constructor will typically just return the provided selection. However, in the context of  {@link this.Transition#this.each(com_ibm_rave_core_selector_CallbackFunction)} , this will return a new transition which inherits the parent transition's delay, duration, easing, etc.
 * @param (com.ibm.rave.core.selector.Selection) selection a  {@link (com.ibm.rave.core.selector.Selection) Selection} , may be a  {@link (com.ibm.rave.core.transition.Transition) Transition}
 * @return (com.ibm.rave.core.selector.Selection)  the given  {@link (com.ibm.rave.core.selector.Selection) Selection}  (a no-op) if not a  {@link (com.ibm.rave.core.transition.Transition) Transition} , otherwise a new  {@link (com.ibm.rave.core.transition.Transition) Transition}
 */
com_ibm_rave_core_transition_Transition.newTransition$2 = function(selection) {
	return com_ibm_rave_core_transition_Transition.newTransition$3(selection, null);
};

/**
 * This constructor will typically just return the provided selection. However, in the context of  {@link this.Transition#this.each(com_ibm_rave_core_selector_CallbackFunction)} , this will return a new transition which inherits the parent transition's delay, duration, easing, etc.
 * @param (com.ibm.rave.core.selector.Selection) selection a  {@link (com.ibm.rave.core.selector.Selection) Selection} , may be a  {@link (com.ibm.rave.core.transition.Transition) Transition}
 * @param (String) name the name for the transition
 * @return (com.ibm.rave.core.selector.Selection)  the given  {@link (com.ibm.rave.core.selector.Selection) Selection}  (a no-op) if not a  {@link (com.ibm.rave.core.transition.Transition) Transition} , otherwise a new  {@link (com.ibm.rave.core.transition.Transition) Transition}
 */
com_ibm_rave_core_transition_Transition.newTransition$3 = function(selection, name) {
	if (selection && com_ibm_rave_core_internal_nativeImpl_transitions_InheritedTransition.get()) {
		return selection.transition(com_ibm_rave_core_internal_transitions_TransitionUtil.transitionNamespace(null));
	}
	return selection;
};

/**
 * Creates a  {@link (com.ibm.rave.core.transition.Transition) Transition}  for the given selector.
 * @param (com.ibm.rave.core.selector.Selector) selector the selector to transition
 * @param (String) name the name for the transition
 * @return (com.ibm.rave.core.transition.Transition)  a  {@link (com.ibm.rave.core.transition.Transition) Transition}  containing the same nodes as the given selector
 */
com_ibm_rave_core_transition_Transition.create$0 = function(selector, name) {
	var id = ++com_ibm_rave_core_transition_Transition.idCount;
	var namespace = com_ibm_rave_core_internal_transitions_TransitionUtil.transitionNamespace(name);
	var subgroups = new com_ibm_rave_core_transition_Transition(id, namespace);
	var subgroup;
	var group;
	var node;
	for (var j = 0, m = selector.length; j < m; ++j) {
		group = selector[j];
		subgroup = [];
		subgroups.push(subgroup);
		for (var i = 0, n = group.length; i < n; ++i) {
			if ((node = group[i])) {
				var info = com_ibm_rave_core_internal_transitions_TransitionUtil.getTransitionInfo(node, namespace, id);
				info.index = i;
				info.groupIndex = j;
			}
			subgroup.push(node);
		}
	}
	return subgroups;
};

/**
 * Creates a  {@link (com.ibm.rave.core.transition.Transition) Transition}  for the given selector while inheriting an existing transition ID and transition delay, duration and easing.
 * @param (com.ibm.rave.core.selector.Selector) selector the selector to transition
 * @param (com.ibm.rave.core.internal.transitions.TransitionInfo) inherit transition properties to inherit
 * @return (com.ibm.rave.core.transition.Transition)  a  {@link (com.ibm.rave.core.transition.Transition) Transition}  containing the same nodes as the given selector
 */
com_ibm_rave_core_transition_Transition.create$1 = function(selector, inherit) {
	return com_ibm_rave_core_transition_Transition.create$2(selector, null, inherit);
};

/**
 * Creates a  {@link (com.ibm.rave.core.transition.Transition) Transition}  for the given selector while inheriting an existing transition ID and transition delay, duration and easing.
 * @param (com.ibm.rave.core.selector.Selector) selector the selector to transition
 * @param (String) name the name for the transition
 * @param (com.ibm.rave.core.internal.transitions.TransitionInfo) inherit transition properties to inherit
 * @return (com.ibm.rave.core.transition.Transition)  a  {@link (com.ibm.rave.core.transition.Transition) Transition}  containing the same nodes as the given selector
 */
com_ibm_rave_core_transition_Transition.create$2 = function(selector, name, inherit) {
	var namespace = com_ibm_rave_core_internal_transitions_TransitionUtil.transitionNamespace(name);
	var subgroups = new com_ibm_rave_core_transition_Transition(inherit.transitionId, namespace);
	var subgroup;
	var group;
	var node;
	for (var j = 0, m = selector.length; j < m; ++j) {
		group = selector[j];
		subgroup = [];
		subgroups.push(subgroup);
		for (var i = 0, n = group.length; i < n; ++i) {
			if ((node = group[i])) {
				var info = com_ibm_rave_core_internal_transitions_TransitionUtil.getTransitionInfo(node, namespace, inherit.transitionId);
				info.index = i;
				info.groupIndex = j;
				info.delay = inherit.delay;
				info.duration = inherit.duration;
				info.ease = inherit.ease;
			}
			subgroup.push(node);
		}
	}
	return subgroups;
};

/** @expose */ 
com_ibm_rave_core_transition_Transition.newTransition = function(a0, a1) {
	var args = arguments;
	if (args.length == 0) {
		return com_ibm_rave_core_transition_Transition.newTransition$0();
	}
	if (args.length == 1 && (a0 == null || typeof a0 === "string")) {
		return com_ibm_rave_core_transition_Transition.newTransition$1(a0);
	}
	if (args.length == 1) {
		return com_ibm_rave_core_transition_Transition.newTransition$2(a0);
	}
	return com_ibm_rave_core_transition_Transition.newTransition$3(a0, a1);
};

/** @expose */ 
com_ibm_rave_core_transition_Transition.create = function(a0, a1, a2) {
	var args = arguments;
	if (args.length == 2 && (a1 == null || typeof a1 === "string")) {
		return com_ibm_rave_core_transition_Transition.create$0(a0, a1);
	}
	if (args.length == 2) {
		return com_ibm_rave_core_transition_Transition.create$1(a0, a1);
	}
	return com_ibm_rave_core_transition_Transition.create$2(a0, a1, a2);
};

com_ibm_rave_core_transition_Transition.idCount = 0;
//com_ibm_rave_core_transition_Transition.TEXT_PREFIX = "text";
//com_ibm_rave_core_transition_Transition.ATTR_PREFIX = "attr.";
//com_ibm_rave_core_transition_Transition.STYLE_PREFIX = "style.";


// $source: com/ibm/rave/core/arrays/Variance
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/internal/math/NumberUtil (static) // toNumber
/**
 * Returns an unbiased estimator of the population variance of a given array. If the array has fewer than two values the result is *undefined An accessor function may be provided to process the data. This method ignores invalid values such as NaN and undefined.
 */
var com_ibm_rave_core_arrays_Variance = rave_externs["Variance"] = {

	//constructor : function() {}
};

/**
 * Returns the variance of the given array.
 * @param (java.lang.Object[]) array the array to use to calculate the variance.
 * @return (Number)  the extent array
 */
com_ibm_rave_core_arrays_Variance.variance$0 = function(array) {
	var d, s = 0, m = 0, a;
	var i = -1, j = 0;
	while (++i < array.length) {
		a = com_ibm_rave_core_internal_math_NumberUtil.toNumber(array[i]);
		if (!(isNaN(a))) {
			d = a - m;
			m += d / ++j;
			s += d * (a - m);
		}
	}
	return (j > 1) ? s / (j - 1) : undefined;
};

/**
 * Returns the variance of the values returned from the accessor function.
 * @param (java.lang.Object[]) array the data to iterate over.
 * @param (com.ibm.rave.core.selector.ValueFunction) valueFunction the accessor function to use to get the values.
 * @return (Number)  the variance
 */
com_ibm_rave_core_arrays_Variance.variance$1 = function(array, valueFunction) {
	var d, s = 0, m = 0, a;
	var i = -1, j = 0;
	while (++i < array.length) {
		a = com_ibm_rave_core_internal_math_NumberUtil.toNumber(valueFunction.call(array, array[i], i, -1));
		if (!(isNaN(a))) {
			d = a - m;
			m += d / ++j;
			s += d * (a - m);
		}
	}
	return (j != 0 && !(isNaN(j))) ? s / (j - 1) : undefined;
};

/** @expose */ 
com_ibm_rave_core_arrays_Variance.variance = function(a0, a1) {
	var args = arguments;
	if (args.length == 1) {
		return com_ibm_rave_core_arrays_Variance.variance$0(a0);
	}
	return com_ibm_rave_core_arrays_Variance.variance$1(a0, a1);
};


// $source: com/ibm/rave/core/arrays/Mean
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/internal/math/NumberUtil (static) // toNumber
/**
 * Compute the arithmetic mean of an array of numbers. Returns the mean of the given array. If the array is empty, returns null. An optional accessor function may be specified, which is equivalent to callingarray.map(accessor) before computing the mean. This method ignores invalid values such as NaN and undefined; this is useful for computing the mean of data while only considering the well-defined values.
 */
var com_ibm_rave_core_arrays_Mean = rave_externs["Mean"] = {

	//constructor : function() {}
};

/**
 * Returns the mean of the given array
 * @param (java.lang.Object[]) array the array to use to calculate the mean
 * @return (Number)  the mean value
 */
com_ibm_rave_core_arrays_Mean.mean$0 = function(array) {
	var s = 0;
	var i = -1;
	var n = array.length;
	var j = n;
	while (++i < n) {
		var a = com_ibm_rave_core_internal_math_NumberUtil.toNumber(array[i]);
		if (!(isNaN(a))) {
			s += a;
		} else {
			j--;
		}
	}
	return (j != 0 && !(isNaN(j))) ? s / j : undefined;
};

/**
 * Returns the mean of the values returned from the accessor function
 * @param (java.lang.Object[]) data the data to iterator over
 * @param (com.ibm.rave.core.selector.ValueFunction) valueFunction the accessor function to use to get the value
 * @return (Number)  the mean value
 */
com_ibm_rave_core_arrays_Mean.mean$1 = function(data, valueFunction) {
	var s = 0;
	var i = -1;
	var n = data.length;
	var j = n;
	var a;
	while (++i < n) {
		var val = valueFunction.call(data, data[i], i, -1);
		a = com_ibm_rave_core_internal_math_NumberUtil.toNumber(val);
		if (!(isNaN(a))) {
			s += a;
		} else {
			j--;
		}
	}
	return (j != 0 && !(isNaN(j))) ? s / j : undefined;
};

/** @expose */ 
com_ibm_rave_core_arrays_Mean.mean = function(a0, a1) {
	var args = arguments;
	if (args.length == 1) {
		return com_ibm_rave_core_arrays_Mean.mean$0(a0);
	}
	return com_ibm_rave_core_arrays_Mean.mean$1(a0, a1);
};


// $source: com/ibm/rave/core/arrays/Median
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/internal/math/NumberUtil (static) // toNumber
//@import com/ibm/rave/core/arrays/Quantile (static) // quantile
//@import com/ibm/rave/core/arrays/Sort (static) // Sort
var com_ibm_rave_core_arrays_Median = rave_externs["Median"] = {

	//constructor : function() {}
};

/**
 * Returns the median of the given array.
 * @param (java.lang.Object[]) array the array to use to calculate the median
 * @return (Number)  the median value
 */
com_ibm_rave_core_arrays_Median.median$0 = function(array) {
	var numbers = [];
	var n = array.length;
	var a;
	var i = -1;
	while (++i < n) {
		a = com_ibm_rave_core_internal_math_NumberUtil.toNumber(array[i]);
		if (!(isNaN(a))) {
			numbers.push(a);
		}
	}
	return (numbers.length > 0 ? com_ibm_rave_core_arrays_Quantile.quantile(numbers.sort(com_ibm_rave_core_arrays_Sort.ascending), .5) : undefined);
};

/**
 * Returns the median of the values returned from the accessor function.
 * @param (java.lang.Object[]) data the data to iterator over.
 * @param (com.ibm.rave.core.selector.ValueFunction) valueFunction the accessor function to use to get the value.
 * @return (Number)  the median value
 */
com_ibm_rave_core_arrays_Median.median$1 = function(data, valueFunction) {
	var numbers = [];
	var i = -1;
	var n = data.length;
	var a;
	while (++i < n) {
		var val = valueFunction.call(data, data[i], i, -1);
		a = com_ibm_rave_core_internal_math_NumberUtil.toNumber(val);
		if (!(isNaN(a))) {
			numbers.push(a);
		}
	}
	return (numbers.length > 0 ? com_ibm_rave_core_arrays_Quantile.quantile(numbers.sort(com_ibm_rave_core_arrays_Sort.ascending), .5) : undefined);
};

/** @expose */ 
com_ibm_rave_core_arrays_Median.median = function(a0, a1) {
	var args = arguments;
	if (args.length == 1) {
		return com_ibm_rave_core_arrays_Median.median$0(a0);
	}
	return com_ibm_rave_core_arrays_Median.median$1(a0, a1);
};


// $source: com/ibm/rave/core/math/Random
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
var com_ibm_rave_core_math_Random = com_ibm_rave_core_nativeImpl_Declare({

	/**
	 * Default random() function.
	 */
	//randomizerFunc : null,

	constructor : function() {
		this.randomizerFunc = function() {
			return Math.random();
		};
	},

	/**
	 * Returns a function for generating a random number between 0-1 by using the default random number generator for the running platform. For both Java and Javascript, this defaults to Math.random(). <p> May be overridden using the setter.
	 * @return (com.ibm.rave.core.math.Random.Randomizer)  Randomizer function that will return a platform specific random number.
	 */
	randomizer$0 : function() {
		return this.randomizerFunc;
	},

	/**
	 * Sets the function for generating random numbers system wide. This function is used by some layouts (cloud, force) to "randomly" position shapes. Overriding this function would allow consistent positioning for these layouts. Note that this does not affect the other random generation APIs (irwinHall, Bates, etc).
	 * @param (com.ibm.rave.core.math.Random.Randomizer) randomizer Function to generate "random" numbers.
	 * @return (com.ibm.rave.core.math.Random.Randomizer)  The set randomizer
	 */
	randomizer$1 : function(randomizer) {
		this.randomizerFunc = randomizer;
		return randomizer;
	},

	/**
	 * Returns a function for generating random numbers with a <a href="http://en.wikipedia.org/wiki/Normal_distribution">normal (Gaussian) distribution</a>. Uses a default deviation of 1 and a mean of 0.
	 * @return (com.ibm.rave.core.math.Random.Randomizer)  a function for generating random numbers
	 * @see #this.normal(, )
	 */
	normal$0 : function() {
		return this.normal$2(0, 1);
	},

	/**
	 * Returns a function for generating random numbers with a <a href="http://en.wikipedia.org/wiki/Normal_distribution">normal (Gaussian) distribution</a>. Uses a default deviation of 1.
	 * @param (double) mean expected value of the generated pseudorandom number
	 * @return (com.ibm.rave.core.math.Random.Randomizer)  a function for generating random numbers
	 * @see #this.normal(, )
	 */
	normal$1 : function(mean) {
		return this.normal$2(mean, 1);
	},

	/**
	 * Returns a function for generating random numbers with a <a href="http://en.wikipedia.org/wiki/Normal_distribution">normal (Gaussian) distribution</a>. The expected value of the generated pseudorandom numbers is mean, with the given standard deviation.
	 * @param (double) mean expected value of the generated pseudorandom number
	 * @param (double) deviation a standard deviation
	 * @return (com.ibm.rave.core.math.Random.Randomizer)  a function for generating random numbers
	 */
	normal$2 : function(mean, deviation) {
		return function() {
			var x, y, r;
			do {
				x = com_ibm_rave_core_math_Random.INSTANCE.randomizerFunc() * 2 - 1;
				y = com_ibm_rave_core_math_Random.INSTANCE.randomizerFunc() * 2 - 1;
				r = x * x + y * y;
			} while (r == 0 || r > 1);
			return mean + deviation * x * Math.sqrt(-2 * Math.log(r) / r);
		};
	},

	/**
	 * Returns a function for generating random numbers with a <a href="http://en.wikipedia.org/wiki/Log-normal_distribution">log-normal distribution</a>. Uses a default deviation of 1 and a mean of 0.
	 * @return (com.ibm.rave.core.math.Random.Randomizer)  a function for generating random numbers
	 * @see #this.logNormal(, )
	 */
	logNormal$0 : function() {
		return this.logNormal$2(0, 1);
	},

	/**
	 * Returns a function for generating random numbers with a <a href="http://en.wikipedia.org/wiki/Log-normal_distribution">log-normal distribution</a>. Uses a default deviation of 1.
	 * @param (double) mean expected value of the random variable’s natural logrithm
	 * @return (com.ibm.rave.core.math.Random.Randomizer)  a function for generating random numbers
	 * @see #this.logNormal(, )
	 */
	logNormal$1 : function(mean) {
		return this.logNormal$2(mean, 1);
	},

	/**
	 * Returns a function for generating random numbers with a <a href="http://en.wikipedia.org/wiki/Log-normal_distribution">log-normal distribution</a>. The expected value of the generated pseudorandom numbers is mean, with the given standard deviation.
	 * @param (double) mean expected value of the random variable’s natural logrithm
	 * @param (double) deviation a standard deviation
	 * @return (com.ibm.rave.core.math.Random.Randomizer)  a function for generating random numbers
	 */
	logNormal$2 : function(mean, deviation) {
		var random = this.normal(mean, deviation);
		return function() {
			return Math.exp(random());
		};
	},

	/**
	 * Returns a function for generating random numbers with a <a href="http://en.wikipedia.org/wiki/Bates_distribution">Bates distribution</a>.
	 * @param (int) count number of independent variables
	 * @return (com.ibm.rave.core.math.Random.Randomizer)  a function for generating random numbers
	 */
	/** @expose */ 
	bates : function(count) {
		var random = this.irwinHall(count);
		return function() {
			return random() / count;
		};
	},

	/**
	 * Returns a function for generating random numbers with an <a href="http://en.wikipedia.org/wiki/Irwin%E2%80%93Hall_distribution" >Irwin–Hall distribution</a>.
	 * @param (int) count number of independent variables
	 * @return (com.ibm.rave.core.math.Random.Randomizer)  a function for generating random numbers
	 */
	/** @expose */ 
	irwinHall : function(count) {
		return function() {
			var s = 0;
			for (var j = 0; j < count; ++j) {
				s += com_ibm_rave_core_math_Random.INSTANCE.randomizerFunc();
			}
			return s;
		};
	},

	/** @expose */ 
	randomizer : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.randomizer$0();
		}
		return this.randomizer$1(a0);
	},

	/** @expose */ 
	normal : function(a0, a1) {
		var args = arguments;
		if (args.length == 0) {
			return this.normal$0();
		}
		if (args.length == 1) {
			return this.normal$1(a0);
		}
		return this.normal$2(a0, a1);
	},

	/** @expose */ 
	logNormal : function(a0, a1) {
		var args = arguments;
		if (args.length == 0) {
			return this.logNormal$0();
		}
		if (args.length == 1) {
			return this.logNormal$1(a0);
		}
		return this.logNormal$2(a0, a1);
	}

	//constructor : function() {}
});

/** @expose */ 
com_ibm_rave_core_math_Random.INSTANCE = new com_ibm_rave_core_math_Random();

// $source: com/ibm/rave/core/arrays/Shuffle
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/math/Random (static) // Random
/**
 * Randomizes the order of the specified array using the Fisher–Yates shuffle.
 */
var com_ibm_rave_core_arrays_Shuffle = rave_externs["Shuffle"] = {

	//constructor : function() {}
};

/**
 * Randomizes the order of the specified array using the Fisher–Yates shuffle.
 * @param (Array) inputArray the array to randomize, change is done in-place.
 * @return (Array)  the randomized array
 */
com_ibm_rave_core_arrays_Shuffle.shuffle$0 = function(inputArray) {
	return com_ibm_rave_core_arrays_Shuffle.shuffle$2(inputArray, 0, inputArray.length);
};

/**
 * Randomizes the order of the specified array using the Fisher–Yates shuffle, beginning the shuffle at a specific index.
 * @param (Array) inputArray the array to randomize, change is done in-place
 * @param (int) i0 starting index for the shuffle.
 * @return (Array)  the randomized array
 */
com_ibm_rave_core_arrays_Shuffle.shuffle$1 = function(inputArray, i0) {
	return com_ibm_rave_core_arrays_Shuffle.shuffle$2(inputArray, i0, inputArray.length);
};

/**
 * Randomizes the order of the specified array using the Fisher–Yates shuffle, beginning and ending the shuffle at specific indices.
 * @param (Array) inputArray the array to randomize, change is done in-place
 * @param (int) i0 starting index for the shuffle.
 * @param (int) i1 end index for the shuffle.
 * @return (Array)  the randomized array
 */
com_ibm_rave_core_arrays_Shuffle.shuffle$2 = function(inputArray, i0, i1) {
	var m = i1 - i0;
	var i;
	var t;
	while (m != 0) {
		i = ~~(com_ibm_rave_core_math_Random.INSTANCE.randomizerFunc() * m--) | 0;
		t = inputArray[m + i0];
		inputArray[m + i0] = inputArray[i + i0];
		inputArray[i + i0] = t;
	}
	return inputArray;
};

/** @expose */ 
com_ibm_rave_core_arrays_Shuffle.shuffle = function(a0, a1, a2) {
	var args = arguments;
	if (args.length == 1) {
		return com_ibm_rave_core_arrays_Shuffle.shuffle$0(a0);
	}
	if (args.length == 2) {
		return com_ibm_rave_core_arrays_Shuffle.shuffle$1(a0, a1);
	}
	return com_ibm_rave_core_arrays_Shuffle.shuffle$2(a0, a1, a2);
};


// $source: com/ibm/rave/core/arrays/Bisector
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare anonymous, declare
//@import com/ibm/rave/core/arrays/Sort (static) // Sort
/**
 * A bisection search utility. Used to locate the insertion point in an array to maintain sorted order.
 * @param < (java.lang.Object) T > the data type for compare against data objects in the array
 */
var com_ibm_rave_core_arrays_Bisector = rave_externs["Bisector"] = com_ibm_rave_core_nativeImpl_Declare({

	/**
	 * Locate the insertion point in an array to maintain sorted order.
	 */
	/** @expose */ 
	left : null,

	/**
	 * Similar to  {@link #this.left} , but returns an insertion point which comes after (to the right of) any existing entries of the number in the array.
	 */
	/** @expose */ 
	right : null,

	/**
	 * Constructs a new bisector with the given comparator.
	 * @param (com.ibm.rave.core.util.Comparator) comparator compares two data objects
	 */
	/** @expose */ 
	constructor : function(comparator) {
		this.left = new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_arrays_Bisector.BisectorFunction], {

			bisect$2 : function(a, x, lo, hi) {
				var newLo = lo;
				var newHi = hi;
				while (newLo < newHi) {
					var mid = (newLo + newHi) >>> 1;
					if (comparator(a[mid], x) < 0) {
						newLo = mid + 1;
					} else {
						newHi = mid;
					}
				}
				return newLo;
			}

		}))();
		this.right = new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_arrays_Bisector.BisectorFunction], {

			bisect$2 : function(a, x, lo, hi) {
				var newLo = lo;
				var newHi = hi;
				while (newLo < newHi) {
					var mid = (newLo + newHi) >>> 1;
					if (comparator(a[mid], x) > 0) {
						newHi = mid;
					} else {
						newLo = mid + 1;
					}
				}
				return newLo;
			}

		}))();
	}
});

/**
 * Creates a generic bisector with the given comparator.
 * @param (com.ibm.rave.core.util.Comparator) comparator compares two data objects
 * @return (com.ibm.rave.core.arrays.Bisector)  a new bisector
 */
com_ibm_rave_core_arrays_Bisector.create$0 = function(comparator) {
	return new com_ibm_rave_core_arrays_Bisector(comparator);
};

/**
 * Creates a new bisector using  {@link this.Sort#com_ibm_rave_core_arrays_Sort.ascending}  as the comparator.
 * @param (com.ibm.rave.core.functions.DoubleValueFunction) f a value function to extract a number from a data object
 * @return (com.ibm.rave.core.arrays.Bisector)  a new bisector
 */
com_ibm_rave_core_arrays_Bisector.create$1 = function(f) {
	return new com_ibm_rave_core_arrays_Bisector(function(a, b) {
		return com_ibm_rave_core_arrays_Sort.ascending(f(a), b);
	});
};

/** @expose */ 
com_ibm_rave_core_arrays_Bisector.create = function(a0) {
	var args = arguments;
	if (args.length == 1 && typeof a0 === "function" && a0.length == 2) {
		return com_ibm_rave_core_arrays_Bisector.create$0(a0);
	}
	return com_ibm_rave_core_arrays_Bisector.create$1(a0);
};

/**
 * Function to execute a bisection search.
 * @param < (java.lang.Object) T > the data type to compare against data objects in the array
 */
com_ibm_rave_core_arrays_Bisector.BisectorFunction = rave_externs["BisectorFunction"] = com_ibm_rave_core_nativeImpl_Declare({

	_$functionClassMethod : function() {
		var _$self = function(a0, a1, a2, a3) {
			var args = arguments;
			if (args.length == 2) {
				return _$self.bisect$0(a0, a1);
			}
			if (args.length == 3) {
				return _$self.bisect$1(a0, a1, a2);
			}
			return _$self.bisect$2(a0, a1, a2, a3);
		};
		return _$self;
	},

	/**
	 * Locate the insertion point in an array to maintain sorted order.
	 * @param (Array) a the array to insert into
	 * @param (java.lang.Object) x the value to insert
	 * @return (int)  the insertion point index
	 */
	bisect$0 : function(a, x) {
		return this(a, x, 0, a.length);
	},

	/**
	 * Locate the insertion point in an array to maintain sorted order.
	 * @param (Array) a the array to insert into
	 * @param (java.lang.Object) x the value to insert
	 * @param (int) lo the low index in the array to begin at
	 * @return (int)  the insertion point index
	 */
	bisect$1 : function(a, x, lo) {
		return this(a, x, lo, a.length);
	}

	/**
	 * Locate the insertion point in an array to maintain sorted order.
	 * @param (Array) a the array to insert into
	 * @param (java.lang.Object) x the value to insert
	 * @param (int) lo the low index in the array to begin at
	 * @param (int) hi the high index in the array to stop at
	 * @return (int)  the insertion point index
	 */
	//bisect$2 : function(a, x, lo, hi) {}
});

com_ibm_rave_core_arrays_Bisector.bisector = new com_ibm_rave_core_arrays_Bisector(com_ibm_rave_core_arrays_Sort.ascending);
/**
 * Locate the insertion point in an array to maintain sorted order.
 */
/** @expose */ 
com_ibm_rave_core_arrays_Bisector.bisectLeft = com_ibm_rave_core_arrays_Bisector.bisector.left;
/**
 * Similar to  {@link #com_ibm_rave_core_arrays_Bisector.bisectLeft} , but returns an insertion point which comes after (to the right of) any existing entries of the number in the array.
 */
/** @expose */ 
com_ibm_rave_core_arrays_Bisector.bisectRight = com_ibm_rave_core_arrays_Bisector.bisector.right;
/**
 * @see #com_ibm_rave_core_arrays_Bisector.bisect
 */
/** @expose */ 
com_ibm_rave_core_arrays_Bisector.bisect = com_ibm_rave_core_arrays_Bisector.bisector.right;

// $source: com/ibm/rave/core/nativeImpl/event/Mouse
/************************************************************************
** IBM Confidential
**
** IBM Business Analytics: Rapidly Adaptive Visualization Engine
**
** (C) Copyright IBM Corp. 2014, 2015
**
** The source code for this program is not published or otherwise divested of its trade secrets, 
** irrespective of what has been deposited with the U.S. Copyright Office.
************************************************************************/

// @import com/ibm/rave/core/nativeImpl/event/EventTracker

var com_ibm_rave_core_nativeImpl_event_Mouse = (function() {
	// https://bugs.webkit.org/show_bug.cgi?id=44083
	var mouse_bug44083 = global.navigator && /WebKit/.test(global.navigator.userAgent) ? -1 : 0;
	
	return {
		
		mousePoint : function(container, e) {
			if (arguments.length == 1) {
				e = com_ibm_rave_core_nativeImpl_event_EventTracker.eventSource();
			}
			if (e.changedTouches) e = e.changedTouches[0];
			var svg = container["ownerSVGElement"];
            if (!svg && container["rave_getOwner"]) {
            	// Use the "owner" node if available - typically the canvas dom node
                svg = container["rave_getOwner"]();
            } else {
                svg = container;
            }
			if (svg["createSVGPoint"]) {
				var point = svg["createSVGPoint"]();
				if (mouse_bug44083 < 0) {
					var window = rave_window(container);
					if (window.scrollX || window.scrollY) {
						svg = rave.select("body").append("svg").style({
							position: "absolute",
							top: 0,
							left: 0,
							margin: 0,
							padding: 0,
							border: "none"
						}, "important");
						var ctm = svg[0][0]["getScreenCTM"]();
						mouse_bug44083 = !(ctm["f"] || ctm["e"]);
						svg.remove();
					}
				}
				if (mouse_bug44083) point.x = e.pageX, point.y = e.pageY;
				else point.x = e.clientX, point.y = e.clientY;
				point = point["matrixTransform"](container["getScreenCTM"]()["inverse"]());
				return [point.x, point.y];
			} else if (container["getScreenCTM"]) {
                // For canvas, need to take our screen ctm into account
                // Use 'container' which is our internal node which will have a valid screen ctm
                var point = [e.clientX, e.clientY];
                com_ibm_rave_core_transform_MatrixUtil.mapPoints(point, container.getScreenCTM().inverse())
                return point;
            }
            
			var rect = svg.getBoundingClientRect();
			return [e.clientX - rect.left - (svg.clientLeft || 0), e.clientY - rect.top - (svg.clientTop || 0)];
		}
	};
})();
// $source: com/ibm/rave/core/event/TouchUtil
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/event/Mouse (static) // mousePoint
/**
 * Utilities for obtaining coordinates of touch events relative to a container.
 */
var com_ibm_rave_core_event_TouchUtil = rave_externs["TouchUtil"] = {

	//constructor : function() {}
};

/**
 * Like  {@link #this.touch(com_ibm_rave_core_scene_SceneNode, Array, String)}  but since touches is not specified, defaults to the current event's changedTouches.
 * @param (com.ibm.rave.core.scene.SceneNode) container the container to which the resulting coordinates are relative
 * @param (String) identifier the touch identifier
 * @return (Array)  the coordinates of the touch
 */
/** @expose */ 
com_ibm_rave_core_event_TouchUtil.touchFromSource = function(container, identifier) {
	return com_ibm_rave_core_event_TouchUtil.touch(container, (rave.event).changedTouches, identifier);
};

/**
 * Returns the x and y coordinates of the touch with the specified identifier associated with the current rave.event, relative to the specified container. The container may be any scene node, such as an svg:g or svg:svg. If there is no touch with the specified identifier in touches, returns null; this can be useful for ignoring touchmove events where the only some touches have moved.
 * @param (com.ibm.rave.core.scene.SceneNode) container the container to which the resulting coordinates are relative
 * @param (Array) touches a list of all of the points of contact with a touch surface
 * @param (String) identifier the touch identifier
 * @return (Array)  the coordinates of the touch
 */
/** @expose */ 
com_ibm_rave_core_event_TouchUtil.touch = function(container, touches, identifier) {
	if (touches) {
		for (var i = 0, n = touches.length; i < n; ++i) {
			var touch = touches[i];
			if (identifier == touch.identifier) {
				return com_ibm_rave_core_nativeImpl_event_Mouse.mousePoint(container, touch);
			}
		}
	}
	return null;
};


// $source: com/ibm/rave/core/nativeImpl/event/Touches
/************************************************************************
** IBM Confidential
**
** IBM Business Analytics: Rapidly Adaptive Visualization Engine
**
** (C) Copyright IBM Corp. 2014
**
** The source code for this program is not published or otherwise divested of its trade secrets, 
** irrespective of what has been deposited with the U.S. Copyright Office.
************************************************************************/

// @import com/ibm/rave/core/nativeImpl/event/EventTracker
// @import ./Mouse

var com_ibm_rave_core_nativeImpl_event_Touches = {
	touches : function(container, touches) {
		if (arguments.length < 2) {
			touches = com_ibm_rave_core_nativeImpl_event_EventTracker.eventSource().touches;
		}
		return touches ? [].slice.call(touches).map(function(touch) {
			var point = com_ibm_rave_core_nativeImpl_event_Mouse.mousePoint(container, touch);
			point.identifier = touch.identifier;
			return point;
		}) : [];
	}
};
// $source: com/ibm/rave/core/format/FormatPrefix
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/format/Round (static) // round
//@import com/ibm/rave/core/internal/format/Precision (static) // precision
var com_ibm_rave_core_format_FormatPrefix = com_ibm_rave_core_nativeImpl_Declare({

	/**
	 * The prefix symbol, such as "M" for millions.
	 */
	/** @expose */ 
	symbol : null,

	/**
	 * The scale function, for converting numbers to the appropriate prefixed scale.
	 */
	/** @expose */ 
	scale : null,

	constructor : function(symbol, i) {
		var k = Math.pow(10, Math.abs(8 - i) * 3);
		this.scale = i > 8 ? function(d) {
			return d / k;
		} : function(d) {
			return d * k;
		};
		this.symbol = symbol;
	}
});

/**
 * Returns the SI prefix for the specified value.
 * @param (double) value the specified value
 * @param (Number) precision if an optional precision is specified, the value is rounded accordingly using  {@link this.Round#this.round(, )}  before computing the prefix
 * @return (com.ibm.rave.core.format.FormatPrefix)  SI prefix for the specified value
 */
/** @expose */ 
com_ibm_rave_core_format_FormatPrefix.formatPrefix = function(value, precision) {
	var _value = value;
	var i = 0;
	if ((_value)) {
		if (_value < 0) {
			_value *= -1;
		}
		if ((precision)) {
			_value = com_ibm_rave_core_format_Round.round(_value, com_ibm_rave_core_internal_format_Precision.precision(_value, precision));
		}
		i = 1 + Math.floor(1e-12 + Math.log(_value) / Math["LN10"]);
		i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
	}
	return com_ibm_rave_core_format_FormatPrefix.formatPrefixes[~~(8 + i / 3)];
};

com_ibm_rave_core_format_FormatPrefix.formatPrefixes = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"].map(function(currentValue, index, array) {
	return new com_ibm_rave_core_format_FormatPrefix(currentValue, index);
});

// $source: com/ibm/rave/core/arrays/Nest
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/nativeImpl/arrays/ES6Map (runtime) // create
//@import com/ibm/rave/core/arrays/Entry (runtime) // new
//@import com/ibm/rave/core/Rave (runtime) // Rave
/**
 * nest operator. The set of keys is initially empty. If the map or entries operator is invoked before any key functions are registered, the nest operator simply returns the input array.
 */
var com_ibm_rave_core_arrays_Nest = rave_externs["Nest"] = com_ibm_rave_core_nativeImpl_Declare({

	//keyFunctions : null,

	//sortKeysComparators : null,

	//sortValuesFn : null,

	//rollupFn : null,

	constructor : function() {
		this.keyFunctions = [];
		this.sortKeysComparators = [];
	},

	internalMap : function(mapType, array, depth) {
		var _depth = depth;
		if (_depth >= this.keyFunctions.length) {
			if (this.rollupFn) {
				return this.rollupFn.call(this, array);
			}
			if (this.sortValuesFn) {
				return array.sort(this.sortValuesFn);
			}
			return array;
		}
		var self = this;
		var i = -1;
		var n = array.length;
		var keyFn = this.keyFunctions[_depth++];
		var keyValue;
		var keyArray;
		var valuesByKey = com_ibm_rave_core_nativeImpl_arrays_ES6Map.create();
		var values;
		while (++i < n) {
			keyArray = array[i];
			keyValue = keyFn(keyArray);
			values = valuesByKey.get(keyValue);
			if ((values)) {
				values.push(keyArray);
			} else {
				var valueArray = [];
				valueArray.push(keyArray);
				valuesByKey.set(keyValue, valueArray);
			}
		}
		var finalDepth = _depth;
		if (mapType) {
			keyArray = mapType();
			valuesByKey.forEach(function(b, c) {
				(keyArray).set(b, self.internalMap(mapType, c, finalDepth));
				return null;
			});
		} else {
			keyArray = {};
			valuesByKey.forEach(function(b, c) {
				(keyArray)[b] = self.internalMap(mapType, c, finalDepth);
				return null;
			});
		}
		return keyArray;
	},

	internalEntries : function(map, depth) {
		if (depth >= this.keyFunctions.length) {
			return map;
		}
		var realMap = map;
		var array = [];
		var sortKey = this.sortKeysComparators.length > depth ? this.sortKeysComparators[depth] : null;
		var finalDepth = depth + 1;
		var self = this;
		realMap.forEach(function(key, keyMap) {
			var entry = new com_ibm_rave_core_arrays_Entry();
			entry.key = key;
			entry.values = self.internalEntries(keyMap, finalDepth);
			array.push(entry);
			return null;
		});
		return sortKey ? array.sort(function(obj1, obj2) {
			return sortKey(obj1.key, obj2.key);
		}) : array;
	},

	/**
	 * Applies the nest operator to the specified array, returning an array of key-values entries. Conceptually, this is similar to applying rave.entries to the associative array returned by map, but it applies to every level of the hierarchy rather than just the first (outermost) level. Each entry in the returned array corresponds to a distinct key value returned by the first key function. The entry value depends on the number of registered key functions: if there is an additional key, the value is another nested array of entries; otherwise, the value is the array of elements filtered from the input array that have the given key value.
	 * @param (Array) array the array to use
	 * @return (Array)  key-values entries
	 */
	/** @expose */ 
	entries : function(array) {
		return this.internalEntries(this.internalMap(com_ibm_rave_core_Rave.map, array, 0), 0);
	},

	/**
	 * Applies the nest operator to the specified array, returning an associative array. Each entry in the returned associative array corresponds to a distinct key value returned by the first key function. The entry value depends on the number of registered key functions: if there is an additional key, the value is another nested associative array; otherwise, the value is the array of elements filtered from the input array that have the given key value.
	 * @param (Array) array the array to use
	 * @param (com.ibm.rave.core.collections.MapFunctionClass) mapType the map creation function
	 * @return (Object)  the associative array.
	 */
	map$0 : function(array, mapType) {
		return this.internalMap(mapType, array, 0);
	},

	/**
	 * Applies the nest operator to the specified array, returning an associative array. Each entry in the returned associative array corresponds to a distinct key value returned by the first key function. The entry value depends on the number of registered key functions: if there is an additional key, the value is another nested associative array; otherwise, the value is the array of elements filtered from the input array that have the given key value.
	 * @param (Array) array the array to use
	 * @return (Object)  the associative array.
	 */
	map$1 : function(array) {
		return this.internalMap(null, array, 0);
	},

	/**
	 * Registers a new key function. The key function will be invoked for each element in the input array, and must return a string identifier that is used to assign the element to its group. Most often, the function is implemented as a simple accessor. Each time a key is registered, it is pushed onto the end of an internal keys array, and the resulting map or entries will have an additional hierarchy level.
	 * @param (com.ibm.rave.core.arrays.Nest.KeyFunction) d the key
	 * @return (com.ibm.rave.core.arrays.Nest)  this nest operator
	 */
	/** @expose */ 
	key : function(d) {
		this.keyFunctions.push(d);
		return this;
	},

	/**
	 * Specifies a rollup function to be applied on each group of leaf elements. The return value of the rollup function will replace the array of leaf values in either the associative array returned by the map operator, or the values attribute of each entry returned by the entries operator.
	 * @param (com.ibm.rave.core.arrays.Nest.RollupFunction) rFunction the rollup function
	 * @return (com.ibm.rave.core.arrays.Nest)  this nest
	 */
	/** @expose */ 
	rollup : function(rFunction) {
		this.rollupFn = rFunction;
		return this;
	},

	/**
	 * Specifies the order for the most-recently specified key. Note: only applies to entries. Map keys are unordered!
	 * @param (com.ibm.rave.core.util.Comparator) order the order function
	 * @return (com.ibm.rave.core.arrays.Nest)  this nest
	 */
	/** @expose */ 
	sortKeys : function(order) {
		this.sortKeysComparators[this.keyFunctions.length - 1] = order;
		return this;
	},

	/**
	 * Specifies the order for leaf values. Applies to both maps and entries array.
	 * @param (com.ibm.rave.core.util.Comparator) order the order function
	 * @return (com.ibm.rave.core.arrays.Nest)  this Nest
	 */
	/** @expose */ 
	sortValues : function(order) {
		this.sortValuesFn = order;
		return this;
	},

	/** @expose */ 
	map : function(a0, a1) {
		var args = arguments;
		if (args.length == 1) {
			return this.map$1(a0);
		}
		return this.map$0(a0, a1);
	}
});


// $source: com/ibm/rave/core/arrays/RaveSet
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/nativeImpl/arrays/ES6Map (runtime) // create
/**
 * The Set collection
 * @author  Bryan
 */
var com_ibm_rave_core_arrays_RaveSet = com_ibm_rave_core_nativeImpl_Declare({

	//delegate : null,

	/**
	 * private constructor
	 */
	constructor : function(list) {
		this.delegate = com_ibm_rave_core_nativeImpl_arrays_ES6Map.create();
		if (list) {
			for (var i = 0; i < list.length; ++i) {
				this.delegate.set(""+(list[i]), true);
			}
		}
	},

	/**
	 * Returns true if and only if this set has an entry for the specified value string.
	 * @param (Object) value The value to check
	 * @return (boolean)  whether the set has the value
	 */
	/** @expose */ 
	has : function(value) {
		return this.delegate.has(""+(value));
	},

	/**
	 * Adds the specified value string to this set. Returns value.
	 * @param (Object) value The value to add
	 * @return (Object) the value added
	 */
	/** @expose */ 
	add : function(value) {
		var stringvalue = ""+(value);
		return this.delegate.set(stringvalue, true) ? stringvalue : null;
	},

	/**
	 * If the set contains the specified value string, removes it and returns true.  Otherwise, this method does nothing and returns false.
	 * @param (Object) value The value to remove
	 * @return (boolean)  whether the item was removed
	 */
	/** @expose */ 
	remove : function(value) {
		return this.delegate.remove(""+(value));
	},

	/**
	 * Returns an array of the string values in this set. The order of the returned values is arbitrary.  Can be used as a convenient way of computing the unique values for a set of strings.
	 * @return (Array)  a list of the values
	 */
	/** @expose */ 
	values : function() {
		return this.delegate.keys();
	},

	/**
	 * Returns the number of values in this set.
	 * @return (int)  the number of values in this set
	 */
	/** @expose */ 
	size : function() {
		return this.delegate.size();
	},

	/**
	 * Returns true if and only if this set has zero values.
	 * @return (boolean)  whether this set is empty or not
	 */
	/** @expose */ 
	empty : function() {
		return this.delegate.empty();
	},

	/**
	 * Calls the specified function for each value in this set, passing the value as an argument.  The this context of the function is this set. Returns undefined. The iteration order is arbitrary.
	 * @param (com.ibm.rave.core.arrays.RaveSet.ForEachValueFunction) callback the function to call with each value in the set
	 */
	/** @expose */ 
	forEach : function(callback) {
		var keys = this.delegate.keys();
		for (var i = 0; i < keys.length; ++i) {
			callback.call(this, keys[i], i);
		}
	}
});

/**
 * Constructs a new set. If array is specified, adds the given array of string values to the returned set.
 * @return (com.ibm.rave.core.arrays.RaveSet)  the new Set
 */
com_ibm_rave_core_arrays_RaveSet.create$0 = function() {
	return new com_ibm_rave_core_arrays_RaveSet(null);
};

/**
 * Constructs a new set. If array is specified, adds the given array of string values to the returned set.
 * @param (Array) list the list of items to add to the set
 * @return (com.ibm.rave.core.arrays.RaveSet)  the new Set
 */
com_ibm_rave_core_arrays_RaveSet.create$1 = function(list) {
	return new com_ibm_rave_core_arrays_RaveSet(list);
};

/** @expose */ 
com_ibm_rave_core_arrays_RaveSet.create = function(a0) {
	var args = arguments;
	if (args.length == 0) {
		return com_ibm_rave_core_arrays_RaveSet.create$0();
	}
	return com_ibm_rave_core_arrays_RaveSet.create$1(a0);
};


// $source: com/ibm/rave/core/textMetrics/CanvasUtil
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/nativeImpl/textMetrics/GraphicContextFactory (runtime) // create
/**
 * A utility class for various canvas operations
 */
var com_ibm_rave_core_textMetrics_CanvasUtil = com_ibm_rave_core_nativeImpl_Declare({

	/**
	 * @param (double) width canvas width
	 * @param (double) height canvas height
	 * @return (com.ibm.rave.core.textMetrics.Canvas)  canvas element
	 */
	/** @expose */ 
	create : function(width, height) {
		return com_ibm_rave_core_nativeImpl_textMetrics_GraphicContextFactory.create(width, height);
	}

	//constructor : function() {}
});

/** @expose */ 
com_ibm_rave_core_textMetrics_CanvasUtil.INSTANCE = new com_ibm_rave_core_textMetrics_CanvasUtil();

// $source: com/ibm/rave/core/geom/QuadTree
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
/**
 * A quadtree is a two-dimensional recursive spatial subdivision. This implementation uses square partitions, dividing each square into four equally-sized squares. Each point exists in a unique node; if multiple points are in the same position, some points may be stored on internal nodes rather than leaf nodes. Quadtrees can be used to accelerate various spatial operations, such as the Barnes-Hut approximation for computing n-body forces, or collision detection.
 * @param < (java.lang.Object) T > type of quadtree node
 */
var com_ibm_rave_core_geom_QuadTree = rave_externs["QuadTree"] = com_ibm_rave_core_nativeImpl_Declare({

	//fx : null, //fy : null,

	//xVal : null, //yVal : null,

	x1 : NaN, y1 : 0, x2 : 0, y2 : 0,

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * Constructs a new quadtree for the specified array of data points, returning the root node of a new quadtree. The x- and y-coordinates of each point are determined using the current x- and y- accessor functions. To build a quadtree by adding points incrementally, the specified points array can be empty, and then points can be later added to the returned root node; in this case, you must also specify the extent of the quadtree. Each node in the quadtree has several properties: nodes - a sparse array of the four child nodes in order: top-left, top-right, bottom-left, bottom-right leaf - a boolean indicating whether this is an internal node or a leaf node point - the point associated with this node, if any (may apply to either internal or leaf nodes) x - the x-coordinate of the associated point, if any y - the y-coordinate of the associated point, if any The returned root node also defines add and visit methods.
		 * @param (Array) data Array of data points specified for the new quadtree
		 * @return (com.ibm.rave.core.geom.QuadTree.RootQTNode)  The root node of a new quadtree
		 */
		function(data) {
			var d;
			var x1_, y1_, x2_, y2_;
			var n = data.length;
			var xs, ys;
			if (!(isNaN(_$self.x1))) {
				x1_ = _$self.x1;
				y1_ = _$self.y1;
				x2_ = _$self.x2;
				y2_ = _$self.y2;
			} else {
				x2_ = y2_ = -(x1_ = y1_ = Infinity);
				xs = [];
				ys = [];
				for (var i = 0; i < n; ++i) {
					var x_ = +_$self.fx(d = data[i], i), y_ = +_$self.fy(d, i);
					if (x_ < x1_) {
						x1_ = x_;
					}
					if (y_ < y1_) {
						y1_ = y_;
					}
					if (x_ > x2_) {
						x2_ = x_;
					}
					if (y_ > y2_) {
						y2_ = y_;
					}
					xs[i] = x_;
					ys[i] = y_;
				}
			}
			var dx = x2_ - x1_, dy = y2_ - y1_;
			if (dx > dy) {
				y2_ = y1_ + dx;
			} else {
				x2_ = x1_ + dy;
			}
			var root = new com_ibm_rave_core_geom_QuadTree.RootQTNode(x1_, y1_, x2_, y2_, _$self.fx, _$self.fy);
			if (isNaN(_$self.x1)) {
				var i = -1;
				while (++i < n) {
					com_ibm_rave_core_geom_QuadTree.insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
				}
				--i;
				root.i = i;
			} else {
				for (var i = 0; i < n; ++i) {
					root.add(data[i]);
				}
			}
			return root;
		};
		return _$self;
	},

	/**
	 * If x is not specified, returns the current x-coordinate accessor
	 * @return (Object)  the current x-coordinate accessor
	 */
	x$0 : function() {
		return this.xVal;
	},

	/**
	 * If x is specified, sets the x-coordinate accessor and returns this quadtree factory For each point added to the quadtree, either during initial construction or lazily added, the x-accessor is invoked with the arguments {data, index}, where data is the current point and index is its index in the array of all points. The x-accessor must then return a numeric value indicating the x-coordinate of the given point. The x-accessor may also be defined as a constant number rather than a function, if desired.
	 * @param (double) x The x-coordinate to use
	 * @return (com.ibm.rave.core.geom.QuadTree)  the quadtree factory
	 */
	x$1 : function(x) {
		this.fx = function(data, index) {
			return x;
		};
		this.xVal = x;
		return this;
	},

	/**
	 * If x is specified, sets the x-coordinate accessor and returns this quadtree factory For each point added to the quadtree, either during initial construction or lazily added, the x-accessor is invoked with the arguments {data, index}, where data is the current point and index is its index in the array of all points. The x-accessor must then return a numeric value indicating the x-coordinate of the given point. The x-accessor may also be defined as a constant number rather than a function, if desired.
	 * @param (com.ibm.rave.core.geom.QuadTree.ValueFunction) x A new x-accessor to be used
	 * @return (com.ibm.rave.core.geom.QuadTree)  the quadtree factory
	 */
	x$2 : function(x) {
		this.fx = x;
		this.xVal = x;
		return this;
	},

	/**
	 * If y is not specified, returns the current y-coordinate accessor
	 * @return (Object)  the current y-coordinate accessor
	 */
	y$0 : function() {
		return this.yVal;
	},

	/**
	 * If y is specified, sets the y-coordinate accessor and returns this quadtree factory For each point added to the quadtree, either during initial construction or lazily added, the y-accessor is invoked with the arguments {data, index}, where data is the current point and index is its index in the array of all points. The y-accessor must then return a numeric value indicating the y-coordinate of the given point. The y-accessor may also be defined as a constant number rather than a function, if desired.
	 * @param (double) y The y-coordinate to use
	 * @return (com.ibm.rave.core.geom.QuadTree)  the quadtree factory
	 */
	y$1 : function(y) {
		this.fy = function(data, index) {
			return y;
		};
		this.yVal = y;
		return this;
	},

	/**
	 * If y is specified, sets the y-coordinate accessor and returns this quadtree factory For each point added to the quadtree, either during initial construction or lazily added, the y-accessor is invoked with the arguments {data, index}, where data is the current point and index is its index in the array of all points. The y-accessor must then return a numeric value indicating the y-coordinate of the given point. The y-accessor may also be defined as a constant number rather than a function, if desired.
	 * @param (com.ibm.rave.core.geom.QuadTree.ValueFunction) y A new y-accessor to be used
	 * @return (com.ibm.rave.core.geom.QuadTree)  the quadtree factory
	 */
	y$2 : function(y) {
		this.fy = y;
		this.yVal = y;
		return this;
	},

	/**
	 * If extent is not specified, returns the current extent, which defaults to null. When the extent is null, an extent will be computed automatically by scanning the array of input points passed to the quadtree constructor. Setting an extent is required when constructing a quadtree lazily from an initially-empty set of nodes
	 * @return (com.ibm.rave.core.geom.Point[])  an array of points using the previously setup x1, y1, x2 and y2 bounds. If x1 is not specified, null is returned
	 */
	extent$0 : function() {
		return isNaN(this.x1) ? null : [[this.x1, this.y1], [this.x2, this.y2]];
	},

	/**
	 * If extent is specified, sets the current extent and returns this quadtree factory. The extent must be specified as a two-dimensional array [​[x0, y0], [​x1, y1]​], where x0 and y0 are the lower bounds of the extent, and x1 and y1 are the upper bounds of the extent. Setting an extent is required when constructing a quadtree lazily from an initially-empty set of nodes
	 * @param (com.ibm.rave.core.geom.Point[]) extent A two-dimensional array [​[x0, y0], [​x1, y1]​], where x0 and y0 are the lower bounds of the extent, and x1 and y1 are the upper bounds of the extent
	 * @return (com.ibm.rave.core.geom.QuadTree)  quadtree factory with the current extent set
	 */
	extent$1 : function(extent) {
		if (!extent) {
			this.x1 = this.y1 = this.x2 = this.y2 = NaN;
		} else {
			this.x1 = extent[0][0];
			this.y1 = extent[0][1];
			this.x2 = extent[1][0];
			this.y2 = extent[1][1];
		}
		return this;
	},

	/**
	 * Creates a point indicating the size of the quadtree. If no size is available returns null
	 * @return (Array)  a new point indicating the size of the quadtree
	 */
	size$0 : function() {
		return isNaN(this.x1) ? null : [this.x2 - this.x1, this.y2 - this.y1];
	},

	/**
	 * Uses the data passed in, in order to calculate the size of the quadtree. If no point is given, the size will be initialized to Double.NaN
	 * @param (Array) size the point used in order to setup the quadtree's size
	 * @return (com.ibm.rave.core.geom.QuadTree)  the quadtree factory
	 */
	size$1 : function(size) {
		if (!size) {
			this.x1 = this.y1 = this.x2 = this.y2 = NaN;
		} else {
			this.x1 = this.y2 = 0;
			this.x2 = size[0];
			this.y2 = size[1];
		}
		return this;
	},

	/** @expose */ 
	x : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.x$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.x$2(a0);
		}
		return this.x$1(a0);
	},

	/** @expose */ 
	y : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.y$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.y$2(a0);
		}
		return this.y$1(a0);
	},

	/** @expose */ 
	extent : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.extent$0();
		}
		return this.extent$1(a0);
	},

	/** @expose */ 
	size : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.size$0();
		}
		return this.size$1(a0);
	}
});

/**
 * Constructs a new quadtree for the specified array of data points, returning the root node of a new quadtree. Note: only for compatibility
 * @param (Array) data data points specified in order to construct a new quadtree
 * @param (double) x1 x1 coordinate
 * @param (double) y1 y1 coordinate
 * @param (double) x2 x2 coordinate
 * @param (double) y2 y2 coordinate
 * @return (com.ibm.rave.core.geom.QuadTree.RootQTNode)  the root node of a new quadtree
 */
com_ibm_rave_core_geom_QuadTree.createQuadTree$0 = function(data, x1, y1, x2, y2) {
	var qTree = new com_ibm_rave_core_geom_QuadTree();
	qTree.fx = com_ibm_rave_core_geom_QuadTree.FX_COMP_FN();
	qTree.fy = com_ibm_rave_core_geom_QuadTree.FY_COMP_FN();
	qTree.xVal = qTree.fx;
	qTree.yVal = qTree.fy;
	qTree.x1 = x1;
	qTree.y1 = y1;
	qTree.x2 = x2;
	qTree.y2 = y2;
	return qTree(data);
};

/**
 * Constructs a new quadtree for the specified array of data points, returning the root node of a new quadtree. Note: only for compatibility
 * @param (Array) data data points specified in order to construct a new quadtree
 * @param (double) x1 x1 coordinate
 * @param (double) y1 y1 coordinate
 * @return (com.ibm.rave.core.geom.QuadTree.RootQTNode)  the root node of a new quadtree
 */
com_ibm_rave_core_geom_QuadTree.createQuadTree$1 = function(data, x1, y1) {
	return com_ibm_rave_core_geom_QuadTree.createQuadTree$0(data, 0, 0, x1, y1);
};

/**
 * Constructs a new quadtree for the specified array of data points When using this constructor for T type other than Point, setting x and y value functions for the new quad tree is mandatory
 * @param (Array) data Array of data points specified for the new quadtree
 * @return (com.ibm.rave.core.geom.QuadTree.RootQTNode)  The root node of a new quadtree
 */
com_ibm_rave_core_geom_QuadTree.createQuadTree$2 = function(data) {
	var qTree = new com_ibm_rave_core_geom_QuadTree();
	qTree.fx = com_ibm_rave_core_geom_QuadTree.FX_COMP_FN();
	qTree.fy = com_ibm_rave_core_geom_QuadTree.FY_COMP_FN();
	qTree.xVal = qTree.fx;
	qTree.yVal = qTree.fy;
	return qTree(data);
};

/**
 * Creates a new quadtree factory with the default x-accessor, y-accessor and extent. The returned function can be used to create any number of quadtrees from data with the factory’s configuration.
 * @return (com.ibm.rave.core.geom.QuadTree)  a new quadtree with default x/y accessors and extent
 */
com_ibm_rave_core_geom_QuadTree.createQuadTree$3 = function() {
	var qTree = new com_ibm_rave_core_geom_QuadTree();
	qTree.fx = com_ibm_rave_core_geom_QuadTree.FX_FN();
	qTree.fy = com_ibm_rave_core_geom_QuadTree.FY_FN();
	qTree.xVal = qTree.fx;
	qTree.yVal = qTree.fy;
	return qTree;
};

/** @expose */ 
com_ibm_rave_core_geom_QuadTree.quadtreeVisit = function(f, node, x1, y1, x2, y2) {
	var children = node.nodes;
	if (!(f(node, x1, y1, x2, y2)) && children) {
		var sx = (x1 + x2) * .5;
		var sy = (y1 + y2) * .5;
		if (children[0]) {
			com_ibm_rave_core_geom_QuadTree.quadtreeVisit(f, children[0], x1, y1, sx, sy);
		}
		if (children[1]) {
			com_ibm_rave_core_geom_QuadTree.quadtreeVisit(f, children[1], sx, y1, x2, sy);
		}
		if (children[2]) {
			com_ibm_rave_core_geom_QuadTree.quadtreeVisit(f, children[2], x1, sy, sx, y2);
		}
		if (children[3]) {
			com_ibm_rave_core_geom_QuadTree.quadtreeVisit(f, children[3], sx, sy, x2, y2);
		}
	}
};

/** @expose */ 
com_ibm_rave_core_geom_QuadTree.insert = function(n, d, x, y, x1, y1, x2, y2) {
	if (isNaN(x) || isNaN(y)) {
		return;
	}
	if (n.leaf) {
		var nx = n.x, ny = n.y;
		if (!(isNaN(nx))) {
			if ((Math.abs(nx - x) + Math.abs(ny - y)) < .01) {
				com_ibm_rave_core_geom_QuadTree.insertChild(n, d, x, y, x1, y1, x2, y2);
			} else {
				var nPoint = n.point;
				n.point = null;
				n.x = n.y = NaN;
				com_ibm_rave_core_geom_QuadTree.insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
				com_ibm_rave_core_geom_QuadTree.insertChild(n, d, x, y, x1, y1, x2, y2);
			}
		} else {
			n.x = x;
			n.y = y;
			n.point = d;
		}
	} else {
		com_ibm_rave_core_geom_QuadTree.insertChild(n, d, x, y, x1, y1, x2, y2);
	}
};

com_ibm_rave_core_geom_QuadTree.insertChild = function(n, d, x, y, x1, y1, x2, y2) {
	var _n = n;
	var _x1 = x1;
	var _y1 = y1;
	var _x2 = x2;
	var _y2 = y2;
	var xm = (_x1 + _x2) * .5;
	var ym = (_y1 + _y2) * .5;
	var right = x >= xm;
	var below = y >= ym;
	var i = below ? (right ? 3 : 2) : (right ? 1 : 0);
	_n.leaf = false;
	if (!_n.nodes[i]) {
		_n.nodes[i] = new com_ibm_rave_core_geom_QuadTree.QTNode();
	}
	_n = _n.nodes[i];
	if (right) {
		_x1 = xm;
	} else {
		_x2 = xm;
	}
	if (below) {
		_y1 = ym;
	} else {
		_y2 = ym;
	}
	com_ibm_rave_core_geom_QuadTree.insert(_n, d, x, y, _x1, _y1, _x2, _y2);
};

com_ibm_rave_core_geom_QuadTree.FX_COMP_FN = function() {
	return function(data, index) {
		return data.x;
	};
};

com_ibm_rave_core_geom_QuadTree.FY_COMP_FN = function() {
	return function(data, index) {
		return data.y;
	};
};

com_ibm_rave_core_geom_QuadTree.FX_FN = function() {
	return function(data, index) {
		return (data)[0];
	};
};

com_ibm_rave_core_geom_QuadTree.FY_FN = function() {
	return function(data, index) {
		return (data)[1];
	};
};

/** @expose */ 
com_ibm_rave_core_geom_QuadTree.createQuadTree = function(a0, a1, a2, a3, a4) {
	var args = arguments;
	if (args.length == 0) {
		return com_ibm_rave_core_geom_QuadTree.createQuadTree$3();
	}
	if (args.length == 1) {
		return com_ibm_rave_core_geom_QuadTree.createQuadTree$2(a0);
	}
	if (args.length == 3) {
		return com_ibm_rave_core_geom_QuadTree.createQuadTree$1(a0, a1, a2);
	}
	return com_ibm_rave_core_geom_QuadTree.createQuadTree$0(a0, a1, a2, a3, a4);
};

/**
 * Sets up a new object containing the quadtree node
 * @param < (java.lang.Object) T > the type of node to be used
 */
com_ibm_rave_core_geom_QuadTree.QTNode = rave_externs["QTNode"] = com_ibm_rave_core_nativeImpl_Declare({

	/**
	 * a sparse array of the four child nodes in order: top-left, top-right, bottom-left, bottom-right
	 */
	/** @expose */ 
	nodes : null,

	/**
	 * the point associated with this node, if any (may apply to either internal or leaf nodes)
	 */
	/** @expose */ 
	point : null,

	/** @expose */ 
	data : null,

	/**
	 * a boolean indicating whether this is an internal node or a leaf node
	 */
	/** @expose */ 
	leaf : true,

	/**
	 * the x-coordinate of the associated point, if any
	 */
	/** @expose */ 
	x : NaN,

	/**
	 * the y-coordinate of the associated point, if any
	 */
	/** @expose */ 
	y : NaN,

	constructor : function() {
		this.nodes = [];
	}
});

/**
 * Initial setup of a root quadtree node
 * @param < (java.lang.Object) T > type of quadtree node
 */
com_ibm_rave_core_geom_QuadTree.RootQTNode = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_geom_QuadTree.QTNode, {

	//fx : null, //fy : null,

	_x1 : 0, _y1 : 0, _x2 : 0, _y2 : 0,

	i : -1,

	constructor : function(x1, y1, x2, y2, fx, fy) {
		this._x1 = x1;
		this._y1 = y1;
		this._x2 = x2;
		this._y2 = y2;
		this.fx = fx;
		this.fy = fy;
	},

	/**
	 * Visits each node in the quadtree, invoking the specified callback with arguments {node, x1, y1, x2, y2} for each node. Nodes are traversed in pre-order. If the callback returns true for a the given node, then the children of that node are not visited; otherwise, all child nodes are visited.
	 * @param (com.ibm.rave.core.geom.QuadTree.Visitor) visitor specified callback
	 */
	/** @expose */ 
	visit : function(visitor) {
		com_ibm_rave_core_geom_QuadTree.quadtreeVisit(visitor, this, this._x1, this._y1, this._x2, this._y2);
	},

	/**
	 * Find the closest point to the specified point.
	 * @param (Array) point1 the source point
	 * @return (java.lang.Object)  the closest point
	 */
	/** @expose */ 
	find : function(point1) {
		return new com_ibm_rave_core_geom_QuadTree.Finder(point1[0], point1[1], this._x1, this._y1, this._x2, this._y2).find(this, this._x1, this._y1, this._x2, this._y2).closestPoint;
	},

	/**
	 * Adds the specified new point to the quadtree
	 * @param (java.lang.Object) d the specified new point to be added to the quadtree
	 */
	/** @expose */ 
	add : function(d) {
		com_ibm_rave_core_geom_QuadTree.insert(this, d, +this.fx(d, ++this.i), +this.fy(d, this.i), this._x1, this._y1, this._x2, this._y2);
	}
});

com_ibm_rave_core_geom_QuadTree.Finder = com_ibm_rave_core_nativeImpl_Declare({

	//closestPoint : null,

	x : 0, y : 0,

	x0 : 0, y0 : 0, x3 : 0, y3 : 0, minDistance2 : Infinity,

	constructor : function(x, y, x0, y0, x3, y3) {
		this.x = x;
		this.y = y;
		this.x0 = x0;
		this.y0 = y0;
		this.x3 = x3;
		this.y3 = y3;
	},

	find : function(node, x1, y1, x2, y2) {
		var _node = node;
		if (x1 > this.x3 || y1 > this.y3 || x2 < this.x0 || y2 < this.y0) {
			return this;
		}
		var point = _node.point;
		if (point) {
			var dx = this.x - _node.x;
			var dy = this.y - _node.y;
			var distance2 = dx * dx + dy * dy;
			if (distance2 < this.minDistance2) {
				var distance = Math.sqrt(this.minDistance2 = distance2);
				this.x0 = this.x - distance;
				this.y0 = this.y - distance;
				this.x3 = this.x + distance;
				this.y3 = this.y + distance;
				this.closestPoint = point;
			}
		}
		var children = _node.nodes;
		var xm = (x1 + x2) * .5;
		var ym = (y1 + y2) * .5;
		var right = +(this.x >= xm);
		var below = +(this.y >= ym);
		for (var i = below << 1 | right, j = i + 4; i < j; ++i) {
			if ((_node = children[i & 3])) {
				switch (i & 3) {
				case 0:
					this.find(_node, x1, y1, xm, ym);
					break;
				case 1:
					this.find(_node, xm, y1, x2, ym);
					break;
				case 2:
					this.find(_node, x1, ym, xm, y2);
					break;
				case 3:
					this.find(_node, xm, ym, x2, y2);
					break;
				}
			}
		}
		return this;
	}
});


// $source: com/ibm/rave/core/geom/Geom
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare, bind
//@import com/ibm/rave/core/geom/QuadTree (loadtime) // createQuadTree
//@import com/ibm/rave/core/geom/Polygon (runtime) // new
//@import com/ibm/rave/core/geom/Voronoi (runtime) // new
//@import com/ibm/rave/core/geom/Hull (runtime) // new
var com_ibm_rave_core_geom_Geom = com_ibm_rave_core_nativeImpl_Declare({

	/**
	 * @see this.QuadTree#this.createQuadTree()
	 */
	quadtree$0 : com_ibm_rave_core_geom_QuadTree.createQuadTree,

	/**
	 * @see  QuadTree#createQuadTree(List<PointStruct>)
	 */
	quadtree$1 : com_ibm_rave_core_geom_QuadTree.createQuadTree,

	/**
	 * @see  QuadTree#createQuadTree(List<PointStruct>, double, double, double, double)
	 */
	quadtree$2 : com_ibm_rave_core_geom_QuadTree.createQuadTree,

	/**
	 * @see  QuadTree#createQuadTree(List<PointStruct>, double, double)
	 */
	quadtree$3 : com_ibm_rave_core_geom_QuadTree.createQuadTree,

	/**
	 * Creates a polygon from the specified array of points.
	 * @param (Array) coordinates an array of points
	 * @return (com.ibm.rave.core.geom.Polygon)  the polygon
	 */
	/** @expose */ 
	polygon : function(coordinates) {
		return new com_ibm_rave_core_geom_Polygon(coordinates);
	},

	/**
	 * Create a Voronoi layout with default accessors.
	 * @return (com.ibm.rave.core.geom.Voronoi)  the Voronoi layout object
	 */
	voronoi$0 : function() {
		return new com_ibm_rave_core_geom_Voronoi();
	},

	/**
	 * Create a Voronoi layout with default accessors, and run the layout.
	 * @param (Array) data
	 * @return (Array)  an array of polygons
	 * @deprecated  use  {@link this.Geom#this.voronoi()}  instead
	 */
	voronoi$1 : function(data) {
		return new com_ibm_rave_core_geom_Voronoi()(data);
	},

	/**
	 * Create a Hull layout with default accessors
	 * @return (com.ibm.rave.core.geom.Hull)  a new Hull object
	 */
	hull$0 : function() {
		return new com_ibm_rave_core_geom_Hull();
	},

	/**
	 * Create a Hull layout with default accessors, and run the layout.
	 * @param (Array) data
	 * @return (Array)  a new Hull object
	 */
	hull$1 : function(data) {
		return new com_ibm_rave_core_geom_Hull()(data);
	},

	/**
	 * Compute the Delaunay mesh as a triangular tessellation. <p> Returns the Delaunay triangulation of the specified data array as an array of triangles. Each triangle is a three-element array containing elements from data.
	 * @param (Array) vertices array of data
	 * @return (Array)  array of triangles
	 * @deprecated  use  {@link #this.voronoi()}   {@link this.Voronoi#this.triangles(Array)} instead
	 */
	/** @expose */ 
	delaunay : function(vertices) {
		return new com_ibm_rave_core_geom_Voronoi().triangles((vertices));
	},

	/** @expose */ 
	quadtree : com_ibm_rave_core_nativeImpl_Declare.bind(function(a0, a1, a2, a3, a4) {
		var args = arguments;
		if (args.length == 0) {
			return this.quadtree$0();
		}
		if (args.length == 1) {
			return this.quadtree$1(a0);
		}
		if (args.length == 3) {
			return this.quadtree$3(a0, a1, a2);
		}
		return this.quadtree$2(a0, a1, a2, a3, a4);
	}),

	/** @expose */ 
	voronoi : com_ibm_rave_core_nativeImpl_Declare.bind(function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.voronoi$0();
		}
		return this.voronoi$1(a0);
	}),

	/** @expose */ 
	hull : com_ibm_rave_core_nativeImpl_Declare.bind(function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.hull$0();
		}
		return this.hull$1(a0);
	})

	//constructor : function() {}
});

/** @expose */ 
com_ibm_rave_core_geom_Geom.INSTANCE = new com_ibm_rave_core_geom_Geom();

// $source: com/ibm/rave/core/geom/Polygon
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/geom/PolygonUtil (runtime) // polygonIntersect
var com_ibm_rave_core_geom_Polygon = rave_externs["Polygon"] = com_ibm_rave_core_nativeImpl_Declare(Array, {

	/** @expose */ 
	constructor : function(coordinates) {
		com_ibm_rave_core_geom_Polygon.addCollection(this, coordinates);
	},

	/**
	 * Returns the signed area of this polygon. If the vertices are in counterclockwise order, the area is positive, otherwise it is negative.
	 * @return (double)  the signed area
	 */
	/** @expose */ 
	area : function() {
		var i = -1;
		var n = this.length;
		var a;
		var b = this[n - 1];
		var area = 0;
		while (++i < n) {
			a = b;
			b = this[i];
			area += a[1] * b[0] - a[0] * b[1];
		}
		return area * .5;
	},

	/**
	 * Returns a two-element array representing the centroid of this polygon.
	 * @return (Array)  the centroid
	 */
	centroid$0 : function() {
		var i = -1;
		var n = this.length;
		var x = 0;
		var y = 0;
		var a;
		var b = this[n - 1];
		var c = 0;
		var k = -1 / (6 * this.area());
		while (++i < n) {
			a = b;
			b = this[i];
			c = a[0] * b[1] - b[0] * a[1];
			x += (a[0] + b[0]) * c;
			y += (a[1] + b[1]) * c;
		}
		return [x * k, y * k];
	},

	/**
	 * Returns a two-element array representing the centroid of this polygon.
	 * @param (double) k centroid factor
	 * @return (Array)  Array representing the centroid of this polygon
	 */
	centroid$1 : function(k) {
		var i = -1;
		var n = this.length;
		var x = 0;
		var y = 0;
		var a;
		var b = this[n - 1];
		var c = 0;
		while (++i < n) {
			a = b;
			b = this[i];
			c = a[0] * b[1] - b[0] * a[1];
			x += (a[0] + b[0]) * c;
			y += (a[1] + b[1]) * c;
		}
		return [x * k, y * k];
	},

	/**
	 * Clips the subject polygon against this polygon. In other words, returns a polygon representing the intersection of this polygon and the subject polygon. Assumes the clip polygon is counterclockwise and convex.
	 * @param (Array) subject the polygon to intersect with
	 * @return (Array)  the intersection polygon
	 */
	/** @expose */ 
	clip : function(subject) {
		var _subject = subject;
		var input = [];
		var closed = com_ibm_rave_core_geom_Polygon.geom_polygonClosed(_subject);
		var i = -1;
		var n = this.length;
		if (com_ibm_rave_core_geom_Polygon.geom_polygonClosed(this)) {
			n--;
		}
		var j = 0;
		var m = 0;
		var a = this[n - 1], b, c, d;
		while (++i < n) {
			input = _subject.slice();
			_subject = [];
			b = this[i];
			m = input.length;
			if (closed) {
				m--;
			}
			c = input[m - 1];
			j = -1;
			while (++j < m) {
				d = input[j];
				if (com_ibm_rave_core_geom_Polygon.geom_polygonInside(d, a, b)) {
					if (!(com_ibm_rave_core_geom_Polygon.geom_polygonInside(c, a, b))) {
						_subject.push(com_ibm_rave_core_internal_geom_PolygonUtil.polygonIntersect(c, d, a, b));
					}
					_subject.push(d);
				} else if (com_ibm_rave_core_geom_Polygon.geom_polygonInside(c, a, b)) {
					_subject.push(com_ibm_rave_core_internal_geom_PolygonUtil.polygonIntersect(c, d, a, b));
				}
				c = d;
			}
			if (closed) {
				_subject.push(_subject[0]);
			}
			a = b;
		}
		return _subject;
	},

	/** @expose */ 
	centroid : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.centroid$0();
		}
		return this.centroid$1(a0);
	}
});

com_ibm_rave_core_geom_Polygon.addCollection = function(coordinates1, coordinates2) {
	for (var index = 0; index < coordinates2.length; ++index) {
		coordinates1.push(coordinates2[index]);
	}
};

com_ibm_rave_core_geom_Polygon.geom_polygonInside = function(p, a, b) {
	return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
};

com_ibm_rave_core_geom_Polygon.geom_polygonClosed = function(coordinates) {
	var a = coordinates[0], b = coordinates[coordinates.length - 1];
	return !((a[0] - b[0]) || ((a[1] - b[1])));
};


// $source: com/ibm/rave/core/geom/Voronoi
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/svg/SVGLine (runtime) // SVGLine
//@import com/ibm/rave/core/internal/geom/voronoi/VoronoiContext (runtime) // new
//@import com/ibm/rave/core/internal/geom/voronoi/VoronoiEdge (runtime) // new
//@import com/ibm/rave/core/internal/geom/voronoi/VoronoiIndex (runtime) // voronoi
//@import com/ibm/rave/core/internal/geom/voronoi/VoronoiCell (runtime) // VoronoiCell
//@import com/ibm/rave/core/internal/geom/voronoi/VoronoiPolygon (runtime) // new
/**
 * Voronoi layouts are particularly useful for invisible interactive regions, as demonstrated in Nate Vack’s Voronoi picking example.  See Tovi Grossman’s paper on bubble cursors for a related concept.
 */
var com_ibm_rave_core_geom_Voronoi = rave_externs["Voronoi"] = com_ibm_rave_core_nativeImpl_Declare({

	//clipExtentVal : null,

	//fx : null,

	//fy : null,

	//voronoieContext : null,

	//xVal : null,

	//yVal : null,

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * Returns an array of polygons, one for each input vertex in the specified data array. If any vertices are coincident or have NaN positions, the behavior of this method is undefined: most likely, invalid polygons will be returned! You should filter invalid vertices, and consolidate coincident vertices, before computing the tessellation.
		 * @param (Array) data 	 the data array 
		 * @return (Array)  an array of polygons
		 */
		function(data) {
			var polygons = new Array(data.length);
			var x0 = _$self.clipExtentVal[0][0], y0 = _$self.clipExtentVal[0][1], x1 = _$self.clipExtentVal[1][0], y1 = _$self.clipExtentVal[1][1];
			var cells = com_ibm_rave_core_internal_geom_voronoi_VoronoiIndex.voronoi(_$self.voronoieContext, _$self.sites(data), _$self.clipExtentVal).voronoiCells;
			cells.forEach(function(cell, index, array) {
				var edges = cell.edges;
				var site = cell.site;
				if (edges.length != 0) {
					var len = edges.length;
					var mappedArray = new com_ibm_rave_core_internal_geom_voronoi_VoronoiPolygon();
					for (var i = 0; i < len; ++i) {
						var currentValue = edges[i];
						if (currentValue) {
							var s = currentValue.start();
							mappedArray.push([s.x, s.y]);
						}
					}
					polygons[index] = mappedArray;
				} else if (site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1) {
					var newPolygon = new com_ibm_rave_core_internal_geom_voronoi_VoronoiPolygon();
					newPolygon.push([x0, y1], [x1, y1], [x1, y0], [x0, y0]);
					polygons[index] = newPolygon;
				} else {
					polygons[index] = new com_ibm_rave_core_internal_geom_voronoi_VoronoiPolygon();
				}
				var polygon = polygons[index];
				polygon.point = data[index];
				return null;
			});
			return polygons;
		};
		return _$self;
	},

	constructor : function() {
		this.clipExtentVal = com_ibm_rave_core_geom_Voronoi.DEFAULT_CLIPEXTENT;
		this.fx = com_ibm_rave_core_svg_SVGLine.DEFAULT_X_FN;
		this.fy = com_ibm_rave_core_svg_SVGLine.DEFAULT_Y_FN;
		this.voronoieContext = new com_ibm_rave_core_internal_geom_voronoi_VoronoiContext();
		this.xVal = this.fx;
		this.yVal = this.fy;
	},

	sites : function(data) {
		var self = this;
		return data.map(function(d, i, array) {
			var x = Math.round(+ (self.fx.call(this, d, i, -1)) / 1.0E-6) * 1.0E-6;
			var y = Math.round(+ (self.fy.call(this, d, i, -1)) / 1.0E-6) * 1.0E-6;
			var site = new com_ibm_rave_core_internal_geom_voronoi_VoronoiEdge.VoronoiSite(x, y);
			site.i = i;
			return site;
		});
	},

	/**
	 * Returns the Delaunay triangulation of the specified data array as an array of links.  Each link has the following attributes: <ul><li>source - the source node (an element in data).</li> <li>target - the target node (an element in data).</li></ul>
	 * @param (Array) data 	the data 
	 * @return (Array) 	array of links
	 */
	/** @expose */ 
	links : function(data) {
		var diagram = com_ibm_rave_core_internal_geom_voronoi_VoronoiIndex.voronoi(this.voronoieContext, this.sites(data), null);
		var filtered = diagram.voronoiEdges.filter(function(edge, index, array) {
			return edge.l && edge.r;
		});
		return filtered.map(function(currentValue, index, array) {
			return new com_ibm_rave_core_geom_Voronoi.Edge(data[currentValue.l.i], data[currentValue.r.i]);
		});
	},

	/**
	 * Returns the Delaunay triangulation of the specified data array as an array of triangles.  Each triangle is a three-element array containing elements from data.
	 * @param (Array) data 	the data
	 * @return (Array) 	Array or Arrays of triangles
	 */
	/** @expose */ 
	triangles : function(data) {
		var triangles = [];
		var diagram = com_ibm_rave_core_internal_geom_voronoi_VoronoiIndex.voronoi(this.voronoieContext, this.sites(data), null);
		var cells = diagram.voronoiCells;
		cells.forEach(function(cell, i, array) {
			var site = cell.site;
			var edges = cell.edges.sort(com_ibm_rave_core_internal_geom_voronoi_VoronoiCell.voronoiHalfEdgeOrder);
			var j = -1, m = edges.length;
			var e1 = edges[m - 1].edge;
			var s0, s1 = e1.l == site ? e1.r : e1.l;
			while (++j < m) {
				s0 = s1;
				e1 = edges[j].edge;
				s1 = e1.l == site ? e1.r : e1.l;
				if (i < s0.i && i < s1.i && com_ibm_rave_core_geom_Voronoi.voronoiTriangleArea(site, s0, s1) < 0) {
					triangles.push([data[i], data[s0.i], data[s1.i]]);
				}
			}
			return null;
		});
		return triangles;
	},

	/**
	 * Gets the current clip extent which defaults to null.
	 * @return (double[][]) 	the current clip extent
	 */
	clipExtent$0 : function() {
		if (this.clipExtentVal == com_ibm_rave_core_geom_Voronoi.DEFAULT_CLIPEXTENT) {
			return null;
		}
		return this.clipExtentVal;
	},

	/**
	 * Sets the clip extent of the Voronoi layout to the specified bounds and returns the layout.  The extent bounds are specified as an array [​[x0, y0], [x1, y1]​], where x0 is the left side of the extent, y0 is the top, x1 is the right and y1 is the bottom.  If extent is null, no clipping is performed.
	 * @param (double[][]) extent 	the clip extent
	 * @return (com.ibm.rave.core.geom.Voronoi) 	this Voronoi instance
	 */
	clipExtent$1 : function(extent) {
		if (!extent) {
			this.clipExtentVal = com_ibm_rave_core_geom_Voronoi.DEFAULT_CLIPEXTENT;
		} else {
			this.clipExtentVal = extent;
		}
		return this;
	},

	/**
	 * @deprecated  use  {@link this.Voronoi#this.clipExtent()}  instead
	 * @return (double[])  the size 
	 */
	size$0 : function() {
		if (this.clipExtentVal == com_ibm_rave_core_geom_Voronoi.DEFAULT_CLIPEXTENT) {
			return null;
		}
		return this.clipExtentVal[1];
	},

	/**
	 * Sets the size
	 * @deprecated  use  {@link this.Voronoi#this.clipExtent()}  instead 
	 * @param (double[]) size
	 * @return (com.ibm.rave.core.geom.Voronoi) 	this Voronoi instance
	 */
	size$1 : function(size) {
		if ((size)) {
			var newClipExtentVal = [[0, 0], size];
			this.clipExtentVal = newClipExtentVal;
		}
		return this;
	},

	/**
	 * Returns the current x-coordinate accessor Can be a double value or a function 
	 * @return (Object)  the x-coordinate accessor
	 */
	x$0 : function() {
		return this.xVal;
	},

	/**
	 * Sets the x-coordinate accessor to the passed constant.
	 * @param (double) xVal 	the x constant
	 * @return (com.ibm.rave.core.geom.Voronoi) 	this Voronoi instance
	 */
	x$1 : function(xVal) {
		this.fx = function(data, index, groupIndex) {
			return xVal;
		};
		this.xVal = xVal;
		return this;
	},

	/**
	 * Sets the x-coordinate accessor to the passed function.
	 * @param (com.ibm.rave.core.selector.ValueFunction) xVal 	the x function
	 * @return (com.ibm.rave.core.geom.Voronoi) 	this Voronoi instance
	 */
	x$2 : function(xVal) {
		this.fx = xVal;
		this.xVal = this.fx;
		return this;
	},

	/**
	 * Returns the current y-coordinate accessor  Can be a double value or a function 
	 * @return (Object)  the y-coordinate accessor 
	 */
	y$0 : function() {
		return this.yVal;
	},

	/**
	 * Sets the y-coordinate accessor to the passed constant.
	 * @param (double) yVal 	the y constant
	 * @return (com.ibm.rave.core.geom.Voronoi) 	this Voronoi instance
	 */
	y$1 : function(yVal) {
		this.fy = function(data, index, groupIndex) {
			return yVal;
		};
		this.yVal = yVal;
		return this;
	},

	/**
	 * Sets the y-coordinate accessor to the passed function.
	 * @param (com.ibm.rave.core.selector.ValueFunction) yVal 	the y function
	 * @return (com.ibm.rave.core.geom.Voronoi) 	this Voronoi instance
	 */
	y$2 : function(yVal) {
		this.fy = yVal;
		this.yVal = this.fy;
		return this;
	},

	/** @expose */ 
	clipExtent : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.clipExtent$0();
		}
		return this.clipExtent$1(a0);
	},

	/** @expose */ 
	size : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.size$0();
		}
		return this.size$1(a0);
	},

	/** @expose */ 
	x : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.x$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.x$2(a0);
		}
		return this.x$1(a0);
	},

	/** @expose */ 
	y : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.y$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.y$2(a0);
		}
		return this.y$1(a0);
	}
});

com_ibm_rave_core_geom_Voronoi.voronoiTriangleArea = function(a, b, c) {
	return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
};

/**
 * Class Represents a  Link in the Voronoi geom link has the following attributes: <ul><li>source - the source node (an element in data).</li> <li>target - the target node (an element in data).</li></ul>
 * @param < (java.lang.Object) T > 	the type of the source and target nodes
 */
com_ibm_rave_core_geom_Voronoi.Edge = rave_externs["Edge"] = com_ibm_rave_core_nativeImpl_Declare({

	/**
	 * the source
	 */
	/** @expose */ 
	source : null,

	/**
	 * the target
	 */
	/** @expose */ 
	target : null,

	/**
	 * Constructor
	 * @param (java.lang.Object) source 		the source
	 * @param (java.lang.Object) target 		the target
	 */
	/** @expose */ 
	constructor : function(source, target) {
		this.source = source;
		this.target = target;
	}
});

com_ibm_rave_core_geom_Voronoi.DEFAULT_CLIPEXTENT = [[-1e6, -1e6], [1e6, 1e6]];

// $source: com/ibm/rave/core/svg/LinePathGenerator
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/svg/SVGLine (runtime) // SVGLine
/**
 * SVG Line generator Line generator used to generate an SVG path representing the data  passed to it, using different interpolation settings  By changing the interpolation, you can also generate splines and step functions.  Also, don't be afraid to tack on additional path commands at the end.  For example, if you want to generate a closed path, append a closepath (Z) 
 */
var com_ibm_rave_core_svg_LinePathGenerator = rave_externs["LinePathGenerator"] = com_ibm_rave_core_nativeImpl_Declare({

	//definedFn : null,

	//interpolateFn : null,

	//fx : null,

	//fy : null,

	//interpolateKey : null,

	//projectionFn : null,

	tensionVal : 0.7,

	xVal : 0,

	yVal : 0,

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * Generates path data for an open piecewise linear curve, or polyline By changing the interpolation, you can also generate splines and step functions. Also, don't be afraid to tack on additional path commands at the end. For example, if you want to generate a closed path, append a closepath (Z) If the data param is empty, the returned string will be null Example usage:  <code> LinePathGenerator line = Rave.svg.line.create().x(xPointFunction).y(yPointFunction); svg.append("path") .datum(dataArray) .attr("d", line); </code>
		 * @param (Object) this the context for this function
		 * @param (Object) datum the data to use while building the path. Datum expected is java.util.List<?> consisting of Point objects or objects containing x,y coordinates accessible via fx and fy accessor functions respectively.
		 * @see ValueFunction#_$self.getValue(Object, Object, , )
		 */
		function(datum, index, groupIndex) {
			var segments = [];
			var points = [];
			var data = datum;
			var i = -1;
			var n = 0;
			var d;
			n = data.length;
			while (++i < n) {
				d = data[i];
				if (_$self.definedFn.call(_$self, d, i, -1)) {
					points.push([+ (!_$self.fx ? _$self.xVal : _$self.fx.call(this, d, i, -1)), + (!_$self.fy ? _$self.yVal : _$self.fy.call(this, d, i, -1))]);
				} else if (points.length != 0) {
					segments.push("M", _$self.interpolateFn(_$self.projectionFn.call(this, points, -1, -1), _$self.tensionVal));
					points = [];
				}
			}
			if (points.length != 0) {
				segments.push("M", _$self.interpolateFn(_$self.projectionFn.call(this, points, -1, -1), _$self.tensionVal));
			}
			return segments.length != 0 ? segments.join("") : null;
		};
		return _$self;
	},

	constructor : function(projection) {
		this.definedFn = com_ibm_rave_core_svg_SVGLine.DEFAULT_DEFINED_FN;
		this.interpolateFn = com_ibm_rave_core_svg_SVGLine.r2_svg_lineLinear;
		this.fx = com_ibm_rave_core_svg_SVGLine.DEFAULT_X_FN;
		this.fy = com_ibm_rave_core_svg_SVGLine.DEFAULT_Y_FN;
		this.interpolateKey = this.interpolateFn.key;
				/**
		 * Constructor, creates a line generator and sets the projection to use with it
		 * @param (com.ibm.rave.core.selector.ValueFunction) projection  the projection to use for example  {@link (com.ibm.rave.core.internal.util.Identity) Identity}
		 */
		{
			this.projectionFn = projection;
		}
	},

	/**
	 * Gets the x-accessor, it can be a  a function or constant.
	 * @return (Object) 	returns the x function or constant
	 */
	x$0 : function() {
		if (this.fx) {
			return this.fx;
		}
		return this.xVal;
	},

	/**
	 * Sets the x-accessor to the specified function.  This accessor is invoked for each element in the data array passed to the line generator. The default accessor assumes that each input element is a two-element array of numbers
	 * @param (com.ibm.rave.core.selector.ValueFunction) valFn   the  x-accessor
	 * @return (com.ibm.rave.core.svg.LinePathGenerator)  the line path generator
	 */
	x$1 : function(valFn) {
		this.fx = valFn;
		return this;
	},

	/**
	 * Sets the x-accessor to the constant. 
	 * @param (double) xNewVal   the constant value of x
	 * @return (com.ibm.rave.core.svg.LinePathGenerator)  the line path generator
	 */
	x$2 : function(xNewVal) {
		this.fx = null;
		this.xVal = xNewVal;
		return this;
	},

	/**
	 * Gets the y-accessor, it can be a  a function or constant.
	 * @return (Object)  returns the yfunction or constant
	 */
	y$0 : function() {
		if (this.fy) {
			return this.fy;
		}
		return this.yVal;
	},

	/**
	 * Sets the y-accessor to the specified function.  This accessor is invoked for each element in the data array passed to the line generator. The default accessor assumes that each input element is a two-element array of numbers
	 * @param (com.ibm.rave.core.selector.ValueFunction) valFn   the  y-accessor
	 * @return (com.ibm.rave.core.svg.LinePathGenerator)  the line path generator
	 */
	y$1 : function(valFn) {
		this.fy = valFn;
		return this;
	},

	/**
	 * Sets the y-accessor to the constant. 
	 * @param (double) yNewVal   the constant value of y
	 * @return (com.ibm.rave.core.svg.LinePathGenerator)  the line path generator
	 */
	y$2 : function(yNewVal) {
		this.fy = null;
		this.yVal = yNewVal;
		return this;
	},

	/**
	 * Gets  the accessor function that controls where the line is defined. default defined is a function() { return true; }
	 * @return (com.ibm.rave.core.selector.ValueFunction)  the defined function 
	 */
	defined$0 : function() {
		return this.definedFn;
	},

	/**
	 * Sets the accessor function that controls where the line is defined.  Sets the new accessor function and returns the line. The defined accessor can be used to define where the line is defined and undefined, which is typically useful in conjunction with missing data; the generated path data will automatically be broken into multiple distinct subpaths, skipping undefined data. For example, if you want to ignore y-values that are not a number (or undefined)
	 * @param (com.ibm.rave.core.selector.ValueFunction) valFn  the function to use to decide if a point is defined
	 * @return (com.ibm.rave.core.svg.LinePathGenerator)  this line path generator
	 */
	defined$1 : function(valFn) {
		this.definedFn = valFn;
		return this;
	},

	/**
	 * Returns the current tension. 
	 * @return (double)  the tension
	 */
	tension$0 : function() {
		return this.tensionVal;
	},

	/**
	 * sets the Cardinal spline or bundle interpolation tension to the specified number in the range [0, 1]. The tension only affects the Cardinal interpolation modes: cardinal, cardinal-open and cardinal-closed and Bundle interpolation. The default tension is 0.7. In some sense, this can be interpreted as the length of the tangent; 1 will yield all zero tangents, and 0 yields a Catmull-Rom spline. Note that the tension must be specified as a constant, rather than a function, as it is constant for the entirety of the line. However, it is still possible to generate multiple lines with different tensions using the same generator.
	 * @return (com.ibm.rave.core.svg.LinePathGenerator)   this line path generator
	 */
	tension$1 : function(tensionNewVal) {
		this.tensionVal = tensionNewVal;
		return this;
	},

	/**
	 * Returns the current interpolation mode. This method will return a string if the current interpolator is not custom Supported Interpolation modes are: linear - piecewise linear segments, as in a polyline. linear-closed - close the linear segments to form a polygon. step - alternate between horizontal and vertical segments, as in a step function. step-before - alternate between vertical and horizontal segments, as in a step function. step-after - alternate between horizontal and vertical segments, as in a step function. basis - a B-spline, with control point duplication on the ends. basis-open - an open B-spline; may not intersect the start or end. basis-closed - a closed B-spline, as in a loop. bundle - equivalent to basis, except the tension parameter is used to straighten the spline. cardinal - a Cardinal spline, with control point duplication on the ends. cardinal-open - an open Cardinal spline; may not intersect the start or end, but will intersect other control points. cardinal-closed - a closed Cardinal spline, as in a loop. monotone - cubic interpolation that preserves monotonicity in y. The behavior of some of these interpolation modes may be further customized by specifying a tension.
	 * @return (Object)  string represent the interpolation type or teh custominterpolation function
	 */
	interpolate$0 : function() {
		return this.interpolateKey;
	},

	/**
	 * Sets the interpolation mode to the specified string. The following named interpolation modes are supported: linear - piecewise linear segments, as in a polyline. linear-closed - close the linear segments to form a polygon. step - alternate between horizontal and vertical segments, as in a step function. step-before - alternate between vertical and horizontal segments, as in a step function. step-after - alternate between horizontal and vertical segments, as in a step function. basis - a B-spline, with control point duplication on the ends. basis-open - an open B-spline; may not intersect the start or end. basis-closed - a closed B-spline, as in a loop. bundle - equivalent to basis, except the tension parameter is used to straighten the spline. cardinal - a Cardinal spline, with control point duplication on the ends. cardinal-open - an open Cardinal spline; may not intersect the start or end, but will intersect other control points. cardinal-closed - a closed Cardinal spline, as in a loop. monotone - cubic interpolation that preserves monotonicity in y. The behavior of some of these interpolation modes may be further customized by specifying a tension.
	 * @param (String) key   the interpolation mode to use
	 * @return (com.ibm.rave.core.svg.LinePathGenerator) 	the Line Path generator
	 */
	interpolate$1 : function(key) {
		this.interpolateKey = key;
		this.interpolateFn = com_ibm_rave_core_svg_SVGLine.r2_svg_lineInterpolators.get(key);
		if (!this.interpolateFn) {
			this.interpolateFn = com_ibm_rave_core_svg_SVGLine.r2_svg_lineLinear;
			this.interpolateKey = this.interpolateFn.key;
		}
		return this;
	},

	/**
	 * Sets the interpolation mode to the specified function.  This function will be invoked to convert an array of points of the form [[x0, y0], [x1, y1]], returning an SVG path data string that will be used to display the line. The "M" at the start of the string is implied and should not be returned.
	 * @param (com.ibm.rave.core.svg.AbstractLineInterpolator) valFn  the function to call to do the interpolation
	 * @return (com.ibm.rave.core.svg.LinePathGenerator)  the Line Path generator
	 */
	interpolate$2 : function(valFn) {
		this.interpolateKey = this.interpolateFn = valFn;
		return this;
	},

	/** @expose */ 
	x : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.x$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.x$1(a0);
		}
		return this.x$2(a0);
	},

	/** @expose */ 
	y : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.y$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.y$1(a0);
		}
		return this.y$2(a0);
	},

	/** @expose */ 
	defined : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.defined$0();
		}
		return this.defined$1(a0);
	},

	/** @expose */ 
	tension : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.tension$0();
		}
		return this.tension$1(a0);
	},

	/** @expose */ 
	interpolate : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.interpolate$0();
		}
		if (args.length == 1 && (a0 == null || typeof a0 === "string")) {
			return this.interpolate$1(a0);
		}
		return this.interpolate$2(a0);
	}
});


// $source: com/ibm/rave/core/svg/AbstractLineInterpolator
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
/**
 * Base class for all line interpolators
 */
var com_ibm_rave_core_svg_AbstractLineInterpolator = rave_externs["AbstractLineInterpolator"] = com_ibm_rave_core_nativeImpl_Declare({

	//reverse : null,

	key : "",

	closed : false,

	/** @expose */ 
	constructor : function(strKey, bClosed) {
		this.key = strKey;
		this.closed = bClosed;
	},

	/**
	 * The key of this interpolator
	 */
	/** @expose */ 
	getKey : function() {
		return this.key;
	},

	/**
	 * Is this a closed interpolator or not
	 */
	/** @expose */ 
	isClosed : function() {
		return this.closed;
	},

	/**
	 * Gets the reverse Interpolator for this Interpolator
	 * @return (com.ibm.rave.core.svg.AbstractLineInterpolator)  the reverse interpolator, or NULL if none had been set
	 */
	/** @expose */ 
	getReverse : function() {
		return this.reverse;
	},

	/**
	 * Sets the reverse Interpolator for this Interpolator
	 * @param (com.ibm.rave.core.svg.AbstractLineInterpolator) reverseIntepolator The reverse interpolator
	 */
	/** @expose */ 
	setReverse : function(reverseIntepolator) {
		this.reverse = reverseIntepolator;
	}
});


// $source: com/ibm/rave/core/internal/util/TrueFunction
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
/**
 * Call back function that always return true
 */
var com_ibm_rave_core_internal_util_TrueFunction = com_ibm_rave_core_nativeImpl_Declare({

	_$functionClassMethod : function() {
		var _$self = function(data, index, groupIndex) {
			return true;
		};
		return _$self;
	}
});


// $source: com/ibm/rave/core/svg/SVGLine
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare anonymous, declare
//@import com/ibm/rave/core/svg/LinePathGenerator (static) // new
//@import com/ibm/rave/core/nativeImpl/arrays/ES6Map (runtime) // create
//@import com/ibm/rave/core/internal/util/Identity (static) // create
//@import com/ibm/rave/core/svg/AbstractLineInterpolator (static)
//@import com/ibm/rave/core/internal/util/TrueFunction (static) // new
var com_ibm_rave_core_svg_SVGLine = rave_externs["SVGLine"] = com_ibm_rave_core_nativeImpl_Declare({


});

/**
 * Factory method, that creates a Line path generator using the passed projection Constructs a new line generator with the default x- and y-accessor functions (that assume the input data is a two-element array of numbers), and linear interpolation. The returned function generates path data for an open piecewise linear curve, or polyline
 * @param (com.ibm.rave.core.selector.ValueFunction) projection
 * @return (com.ibm.rave.core.svg.LinePathGenerator)  line path generator  {@link (com.ibm.rave.core.svg.LinePathGenerator) LinePathGenerator}
 */
com_ibm_rave_core_svg_SVGLine.createLine$0 = function(projection) {
	return new com_ibm_rave_core_svg_LinePathGenerator(projection);
};

/**
 * Factory method, that creates a Line path generator using default projection (identity) Constructs a new line generator with the default x- and y-accessor functions (that assume the input data is a two-element array of numbers), and linear interpolation. The returned function generates path data for an open piecewise linear curve, or polyline
 * @return (com.ibm.rave.core.svg.LinePathGenerator)  line path generator  {@link (com.ibm.rave.core.svg.LinePathGenerator) LinePathGenerator}
 */
com_ibm_rave_core_svg_SVGLine.createLine$1 = function() {
	return new com_ibm_rave_core_svg_LinePathGenerator(com_ibm_rave_core_svg_SVGLine.DEFAULT_PROJECTION);
};

com_ibm_rave_core_svg_SVGLine.r2_svg_lineHermite = function(points, tangents) {
	if (tangents.length < 1 || (points.length != tangents.length && points.length != tangents.length + 2)) {
		return com_ibm_rave_core_svg_SVGLine.r2_svg_lineLinear(points, 0);
	}
	var quad = points.length != tangents.length;
	var path = "";
	var p0 = points[0], p = points[1], t0 = tangents[0], t = t0;
	var pi = 1;
	if (quad) {
		path+=("Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1]);
		p0 = points[1];
		pi = 2;
	}
	if (tangents.length > 1) {
		t = tangents[1];
		p = points[pi];
		pi++;
		path+=("C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1]);
		for (var i = 2; i < tangents.length; i++, pi++) {
			p = points[pi];
			t = tangents[i];
			path+=("S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1]);
		}
	}
	if (quad) {
		var lp = points[pi];
		path+=("Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1]);
	}
	return path;
};

com_ibm_rave_core_svg_SVGLine.r2_svg_lineCardinalTangents = function(points, tension) {
	var tangents = [];
	var a = (1 - tension) / 2;
	var p0, p1 = points[0], p2 = points[1];
	var i = 1;
	var n = points.length;
	while (++i < n) {
		p0 = p1;
		p1 = p2;
		p2 = points[i];
		tangents.push([a * (p2[0] - p0[0]), a * (p2[1] - p0[1])]);
	}
	return tangents;
};

com_ibm_rave_core_svg_SVGLine.r2_svg_lineDot4 = function(a, b) {
	return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
};

com_ibm_rave_core_svg_SVGLine.r2_svg_lineBasisBezier = function(path, x, y) {
	path.push("C", com_ibm_rave_core_svg_SVGLine.r2_svg_lineDot4(com_ibm_rave_core_svg_SVGLine.r2_svg_lineBasisBezier1, x), ",", com_ibm_rave_core_svg_SVGLine.r2_svg_lineDot4(com_ibm_rave_core_svg_SVGLine.r2_svg_lineBasisBezier1, y), ",", com_ibm_rave_core_svg_SVGLine.r2_svg_lineDot4(com_ibm_rave_core_svg_SVGLine.r2_svg_lineBasisBezier2, x), ",", com_ibm_rave_core_svg_SVGLine.r2_svg_lineDot4(com_ibm_rave_core_svg_SVGLine.r2_svg_lineBasisBezier2, y), ",", com_ibm_rave_core_svg_SVGLine.r2_svg_lineDot4(com_ibm_rave_core_svg_SVGLine.r2_svg_lineBasisBezier3, x), ",", com_ibm_rave_core_svg_SVGLine.r2_svg_lineDot4(com_ibm_rave_core_svg_SVGLine.r2_svg_lineBasisBezier3, y));
};

com_ibm_rave_core_svg_SVGLine.r2_svg_lineSlope = function(p0, p1) {
	return (p1[1] - p0[1]) / (p1[0] - p0[0]);
};

com_ibm_rave_core_svg_SVGLine.r2_svg_lineFiniteDifferences = function(points) {
	var i = 0, j = points.length - 1;
	var m = [];
	var p0 = points[0], p1 = points[1];
	var d = com_ibm_rave_core_svg_SVGLine.r2_svg_lineSlope(p0, p1);
	m.push(d);
	while (++i < j) {
		m.push((d + (d = com_ibm_rave_core_svg_SVGLine.r2_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2);
	}
	m.push(d);
	return m;
};

com_ibm_rave_core_svg_SVGLine.r2_svg_lineMonotoneTangents = function(points) {
	var tangents = [];
	var d, a, b, s;
	var m = com_ibm_rave_core_svg_SVGLine.r2_svg_lineFiniteDifferences(points);
	var i = -1, j = points.length - 1;
	while (++i < j) {
		d = com_ibm_rave_core_svg_SVGLine.r2_svg_lineSlope(points[i], points[i + 1]);
		if (Math.abs(d) < 1.0E-6) {
			m[i] = 0;
			m[i + 1] = 0;
		} else {
			a = m[i] / d;
			b = m[i + 1] / d;
			s = a * a + b * b;
			if (s > 9) {
				s = d * 3 / Math.sqrt(s);
				m[i] = s * a;
				m[i + 1] = s * b;
			}
		}
	}
	i = -1;
	while (++i <= j) {
		s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
		if (s != s) {
			s = 0;
		}
		var difference = m[i] * s;
		var s1 = ((s) ? s : 0);
		var s2 = ((difference) ? difference : 0);
		tangents.push([s1, s2]);
	}
	return tangents;
};

com_ibm_rave_core_svg_SVGLine.initialize_r2_svg_lineInterpolators = function() {
	var r2_svg_lineInterpolators = com_ibm_rave_core_nativeImpl_arrays_ES6Map.create();
	r2_svg_lineInterpolators.set(com_ibm_rave_core_svg_SVGLine.r2_svg_lineLinear.key, com_ibm_rave_core_svg_SVGLine.r2_svg_lineLinear);
	r2_svg_lineInterpolators.set(com_ibm_rave_core_svg_SVGLine.r2_svg_lineLinearClosed.key, com_ibm_rave_core_svg_SVGLine.r2_svg_lineLinearClosed);
	r2_svg_lineInterpolators.set(com_ibm_rave_core_svg_SVGLine.r2_svg_lineStep.key, com_ibm_rave_core_svg_SVGLine.r2_svg_lineStep);
	r2_svg_lineInterpolators.set(com_ibm_rave_core_svg_SVGLine.r2_svg_lineStepBefore.key, com_ibm_rave_core_svg_SVGLine.r2_svg_lineStepBefore);
	r2_svg_lineInterpolators.set(com_ibm_rave_core_svg_SVGLine.r2_svg_lineStepAfter.key, com_ibm_rave_core_svg_SVGLine.r2_svg_lineStepAfter);
	r2_svg_lineInterpolators.set(com_ibm_rave_core_svg_SVGLine.r2_svg_lineBasis.key, com_ibm_rave_core_svg_SVGLine.r2_svg_lineBasis);
	r2_svg_lineInterpolators.set(com_ibm_rave_core_svg_SVGLine.r2_svg_lineBasisOpen.key, com_ibm_rave_core_svg_SVGLine.r2_svg_lineBasisOpen);
	r2_svg_lineInterpolators.set(com_ibm_rave_core_svg_SVGLine.r2_svg_lineBasisClosed.key, com_ibm_rave_core_svg_SVGLine.r2_svg_lineBasisClosed);
	r2_svg_lineInterpolators.set(com_ibm_rave_core_svg_SVGLine.r2_svg_lineBundle.key, com_ibm_rave_core_svg_SVGLine.r2_svg_lineBundle);
	r2_svg_lineInterpolators.set(com_ibm_rave_core_svg_SVGLine.r2_svg_lineCardinal.key, com_ibm_rave_core_svg_SVGLine.r2_svg_lineCardinal);
	r2_svg_lineInterpolators.set(com_ibm_rave_core_svg_SVGLine.r2_svg_lineCardinalOpen.key, com_ibm_rave_core_svg_SVGLine.r2_svg_lineCardinalOpen);
	r2_svg_lineInterpolators.set(com_ibm_rave_core_svg_SVGLine.r2_svg_lineCardinalClosed.key, com_ibm_rave_core_svg_SVGLine.r2_svg_lineCardinalClosed);
	r2_svg_lineInterpolators.set(com_ibm_rave_core_svg_SVGLine.r2_svg_lineMonotone.key, com_ibm_rave_core_svg_SVGLine.r2_svg_lineMonotone);
	com_ibm_rave_core_svg_SVGLine.r2_svg_lineStepBefore.reverse = com_ibm_rave_core_svg_SVGLine.r2_svg_lineStepAfter;
	com_ibm_rave_core_svg_SVGLine.r2_svg_lineStepAfter.reverse = com_ibm_rave_core_svg_SVGLine.r2_svg_lineStepBefore;
	return r2_svg_lineInterpolators;
};

/** @expose */ 
com_ibm_rave_core_svg_SVGLine.createLine = function(a0) {
	var args = arguments;
	if (args.length == 0) {
		return com_ibm_rave_core_svg_SVGLine.createLine$1();
	}
	return com_ibm_rave_core_svg_SVGLine.createLine$0(a0);
};

/** @expose */ 
com_ibm_rave_core_svg_SVGLine.DEFAULT_X_FN = function(data, index, groupIndex) {
	return (data)[0];
};
/** @expose */ 
com_ibm_rave_core_svg_SVGLine.DEFAULT_Y_FN = function(data, index, groupIndex) {
	return (data)[1];
};
com_ibm_rave_core_svg_SVGLine.DEFAULT_PROJECTION = com_ibm_rave_core_internal_util_Identity.create();
com_ibm_rave_core_svg_SVGLine.r2_svg_lineBasisBezier1 = [0, 2 / 3, 1 / 3, 0];
com_ibm_rave_core_svg_SVGLine.r2_svg_lineBasisBezier2 = [0, 1 / 3, 2 / 3, 0];
com_ibm_rave_core_svg_SVGLine.r2_svg_lineBasisBezier3 = [0, 1 / 6, 2 / 3, 1 / 6];
com_ibm_rave_core_svg_SVGLine.r2_svg_lineStep = new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_svg_AbstractLineInterpolator], {

	_$functionClassMethod : function() {
		var _$self = function(points, tension) {
			var i = 0, n = points.length;
			var p = points[0];
			var path = [p[0], ",", p[1]];
			while (++i < n) {
				path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
			}
			if (n > 1) {
				path.push("H", p[0]);
			}
			return path.join("");
		};
		return _$self;
	}

}))("step", false);
com_ibm_rave_core_svg_SVGLine.r2_svg_lineStepBefore = new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_svg_AbstractLineInterpolator], {

	_$functionClassMethod : function() {
		var _$self = function(points, tension) {
			var i = 0, n = points.length;
			var p = points[0];
			var path = [p[0], ",", p[1]];
			while (++i < n) {
				path.push("V", (p = points[i])[1], "H", p[0]);
			}
			return path.join("");
		};
		return _$self;
	}

}))("step-before", false);
com_ibm_rave_core_svg_SVGLine.r2_svg_lineStepAfter = new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_svg_AbstractLineInterpolator], {

	_$functionClassMethod : function() {
		var _$self = function(points, tension) {
			var i = 0, n = points.length;
			var p = points[0];
			var path = [p[0], ",", p[1]];
			while (++i < n) {
				path.push("H", (p = points[i])[0], "V", p[1]);
			}
			return path.join("");
		};
		return _$self;
	}

}))("step-after", false);
com_ibm_rave_core_svg_SVGLine.r2_svg_lineCardinalOpen = new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_svg_AbstractLineInterpolator], {

	_$functionClassMethod : function() {
		var _$self = function(points, tension) {
			return points.length < 4 ? com_ibm_rave_core_svg_SVGLine.r2_svg_lineLinear(points, tension) : points[1] + com_ibm_rave_core_svg_SVGLine.r2_svg_lineHermite(points.slice(1, -1), com_ibm_rave_core_svg_SVGLine.r2_svg_lineCardinalTangents(points, tension));
		};
		return _$self;
	}

}))("cardinal-open", false);
com_ibm_rave_core_svg_SVGLine.r2_svg_lineCardinalClosed = new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_svg_AbstractLineInterpolator], {

	_$functionClassMethod : function() {
		var _$self = function(points, tension) {
			if (points.length < 3) {
				return com_ibm_rave_core_svg_SVGLine.r2_svg_lineLinear(points, tension);
			}
			var p1 = points[0];
			points.push(p1);
			var p2 = [];
			p2.push(points[points.length - 2]);
			var array = [];
			array.push(points[1]);
			p2 = p2.concat(points, array);
			var tangents = com_ibm_rave_core_svg_SVGLine.r2_svg_lineCardinalTangents(p2, tension);
			return p1 + com_ibm_rave_core_svg_SVGLine.r2_svg_lineHermite(points, tangents);
		};
		return _$self;
	}

}))("cardinal-closed", true);
com_ibm_rave_core_svg_SVGLine.r2_svg_lineCardinal = new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_svg_AbstractLineInterpolator], {

	_$functionClassMethod : function() {
		var _$self = function(points, tension) {
			return points.length < 3 ? com_ibm_rave_core_svg_SVGLine.r2_svg_lineLinear(points, tension) : points[0] + com_ibm_rave_core_svg_SVGLine.r2_svg_lineHermite(points, com_ibm_rave_core_svg_SVGLine.r2_svg_lineCardinalTangents(points, tension));
		};
		return _$self;
	}

}))("cardinal", false);
com_ibm_rave_core_svg_SVGLine.r2_svg_lineBasis = new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_svg_AbstractLineInterpolator], {

	_$functionClassMethod : function() {
		var _$self = function(points, tension) {
			if (points.length < 3) {
				return com_ibm_rave_core_svg_SVGLine.r2_svg_lineLinear(points, tension);
			}
			var i = 1, n = points.length;
			var pi = points[0];
			var x0 = pi[0], y0 = pi[1];
			var px = [x0, x0, x0, (pi = points[1])[0]];
			var py = [y0, y0, y0, pi[1]];
			var path = [x0, ",", y0, "L", com_ibm_rave_core_svg_SVGLine.r2_svg_lineDot4(com_ibm_rave_core_svg_SVGLine.r2_svg_lineBasisBezier3, px), ",", com_ibm_rave_core_svg_SVGLine.r2_svg_lineDot4(com_ibm_rave_core_svg_SVGLine.r2_svg_lineBasisBezier3, py)];
			points.push(points[n - 1]);
			while (++i <= n) {
				pi = points[i];
				px.shift();
				px.push(pi[0]);
				py.shift();
				py.push(pi[1]);
				com_ibm_rave_core_svg_SVGLine.r2_svg_lineBasisBezier(path, px, py);
			}
			points.pop();
			path.push("L", pi);
			return path.join("");
		};
		return _$self;
	}

}))("basis", false);
com_ibm_rave_core_svg_SVGLine.r2_svg_lineBasisOpen = new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_svg_AbstractLineInterpolator], {

	_$functionClassMethod : function() {
		var _$self = function(points, tension) {
			if (points.length < 4) {
				return com_ibm_rave_core_svg_SVGLine.r2_svg_lineLinear(points, 0);
			}
			var path = [];
			var i = -1, n = points.length;
			var pi;
			var px = [], py = [];
			px.push(0);
			py.push(0);
			while (++i < 3) {
				pi = points[i];
				px.push(pi[0]);
				py.push(pi[1]);
			}
			path.push(com_ibm_rave_core_svg_SVGLine.r2_svg_lineDot4(com_ibm_rave_core_svg_SVGLine.r2_svg_lineBasisBezier3, px) + "," + com_ibm_rave_core_svg_SVGLine.r2_svg_lineDot4(com_ibm_rave_core_svg_SVGLine.r2_svg_lineBasisBezier3, py));
			--i;
			while (++i < n) {
				pi = points[i];
				px.shift();
				px.push(pi[0]);
				py.shift();
				py.push(pi[1]);
				com_ibm_rave_core_svg_SVGLine.r2_svg_lineBasisBezier(path, px, py);
			}
			return path.join("");
		};
		return _$self;
	}

}))("basis-open", false);
com_ibm_rave_core_svg_SVGLine.r2_svg_lineBasisClosed = new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_svg_AbstractLineInterpolator], {

	_$functionClassMethod : function() {
		var _$self = function(points, tension) {
			if (points.length < 4) {
				return com_ibm_rave_core_svg_SVGLine.r2_svg_lineLinear(points, 0);
			}
			var i = -1, n = points.length, m = n + 4;
			var pi;
			var px = [], py = [];
			while (++i < 4) {
				pi = points[i % n];
				px.push(pi[0]);
				py.push(pi[1]);
			}
			var path = [com_ibm_rave_core_svg_SVGLine.r2_svg_lineDot4(com_ibm_rave_core_svg_SVGLine.r2_svg_lineBasisBezier3, px), ",", com_ibm_rave_core_svg_SVGLine.r2_svg_lineDot4(com_ibm_rave_core_svg_SVGLine.r2_svg_lineBasisBezier3, py)];
			--i;
			while (++i < m) {
				pi = points[i % n];
				px.shift();
				px.push(pi[0]);
				py.shift();
				py.push(pi[1]);
				com_ibm_rave_core_svg_SVGLine.r2_svg_lineBasisBezier(path, px, py);
			}
			return path.join("");
		};
		return _$self;
	}

}))("basis-closed", true);
com_ibm_rave_core_svg_SVGLine.r2_svg_lineBundle = new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_svg_AbstractLineInterpolator], {

	_$functionClassMethod : function() {
		var _$self = function(points, tension) {
			var n = points.length - 1;
			if (n != 0) {
				var p = points[0];
				var x0 = p[0], y0 = p[1];
				p = points[n];
				var dx = p[0] - x0, dy = p[1] - y0;
				var i = -1;
				var t;
				while (++i <= n) {
					p = points[i];
					t = i / n;
					p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
					p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
				}
			}
			return com_ibm_rave_core_svg_SVGLine.r2_svg_lineBasis(points, 0);
		};
		return _$self;
	}

}))("bundle", false);
/**
 * Linear interpolation; generates "L" commands.
 */
/** @expose */ 
com_ibm_rave_core_svg_SVGLine.r2_svg_lineLinear = new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_svg_AbstractLineInterpolator], {

	_$functionClassMethod : function() {
		var _$self = function(data, tension) {
			return data.join("L");
		};
		return _$self;
	}

}))("linear", false);
/**
 * Closed Linear interpolation; generates "L" commands then close it with a "Z" command.
 */
/** @expose */ 
com_ibm_rave_core_svg_SVGLine.r2_svg_lineLinearClosed = new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_svg_AbstractLineInterpolator], {

	_$functionClassMethod : function() {
		var _$self = function(data, tension) {
			return com_ibm_rave_core_svg_SVGLine.r2_svg_lineLinear(data, tension) + "Z";
		};
		return _$self;
	}

}))("linear-closed", true);
com_ibm_rave_core_svg_SVGLine.r2_svg_lineMonotone = new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_svg_AbstractLineInterpolator], {

	_$functionClassMethod : function() {
		var _$self = function(points, tension) {
			return points.length < 3 ? com_ibm_rave_core_svg_SVGLine.r2_svg_lineLinear(points, tension) : points[0] + com_ibm_rave_core_svg_SVGLine.r2_svg_lineHermite(points, com_ibm_rave_core_svg_SVGLine.r2_svg_lineMonotoneTangents(points));
		};
		return _$self;
	}

}))("monotone", false);
com_ibm_rave_core_svg_SVGLine.r2_svg_lineInterpolators = com_ibm_rave_core_svg_SVGLine.initialize_r2_svg_lineInterpolators();
com_ibm_rave_core_svg_SVGLine.DEFAULT_DEFINED_FN = new com_ibm_rave_core_internal_util_TrueFunction();

// $source: com/ibm/rave/core/internal/geom/voronoi/VoronoiContext
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
var com_ibm_rave_core_internal_geom_voronoi_VoronoiContext = com_ibm_rave_core_nativeImpl_Declare({

	//voronoiEdges : null,

	//voronoiCells : null,

	//voronoiBeaches : null,

	//voronoiBeachPool : null,

	//voronoiFirstCircle : null,

	//voronoiCircles : null,

	//voronoiCirclePool : null,

	constructor : function() {
		this.voronoiBeachPool = [];
		this.voronoiCirclePool = [];
	}
});


// $source: com/ibm/rave/core/geom/Line
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
/**
 * A class representing a lint extending form point a to point b 
 */
var com_ibm_rave_core_geom_Line = rave_externs["Line"] = com_ibm_rave_core_nativeImpl_Declare({

	//a : null,

	//b : null,

	/**
	 * @param (com.ibm.rave.core.geom.PointStruct) a point a
	 * @param (com.ibm.rave.core.geom.PointStruct) b point b
	 */
	/** @expose */ 
	constructor : function(a, b) {
		this.a = a;
		this.b = b;
	},

	/**
	 * A getter for point a
	 * @return (com.ibm.rave.core.geom.PointStruct)  the a point
	 */
	/** @expose */ 
	getA : function() {
		return this.a;
	},

	/**
	 * A setter for point a
	 * @param (com.ibm.rave.core.geom.PointStruct) a   the a point to set
	 */
	/** @expose */ 
	setA : function(a) {
		this.a = a;
	},

	/**
	 * A getter for point b
	 * @return (com.ibm.rave.core.geom.PointStruct)  the b point
	 */
	/** @expose */ 
	getB : function() {
		return this.b;
	},

	/**
	 * A setter for point b
	 * @param (com.ibm.rave.core.geom.PointStruct) b  the b to set
	 */
	/** @expose */ 
	setB : function(b) {
		this.b = b;
	}
});


// $source: com/ibm/rave/core/internal/geom/voronoi/VoronoiEdge
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/geom/Line (loadtime) // superclass
//@import com/ibm/rave/core/geom/PointStruct (loadtime) // superclass
/**
 * IBM Confidential OCO Source Materials IBM Business Analytics: Rapidly Adaptive Visualization Engine (C) Copyright IBM Corp. 2014, 2015 The source code for this program is not published or otherwise divested of its trade secrets,  irrespective of what has been deposited with the U.S. Copyright Office.
 */
var com_ibm_rave_core_internal_geom_voronoi_VoronoiEdge = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_geom_Line, {

	//l : null,

	//r : null,

	constructor : function(lSite, rSite) {
		this.l = lSite;
		this.r = rSite;
		this.a = null;
		this.b = null;
	}
});

com_ibm_rave_core_internal_geom_voronoi_VoronoiEdge.voronoiCreateEdge = function(context, lSite, rSite, va, vb) {
	var edge = new com_ibm_rave_core_internal_geom_voronoi_VoronoiEdge(lSite, rSite);
	context.voronoiEdges.push(edge);
	if ((va)) {
		com_ibm_rave_core_internal_geom_voronoi_VoronoiEdge.voronoiSetEdgeEnd(edge, lSite, rSite, va);
	}
	if ((vb)) {
		com_ibm_rave_core_internal_geom_voronoi_VoronoiEdge.voronoiSetEdgeEnd(edge, rSite, lSite, vb);
	}
	context.voronoiCells[lSite.i].edges.push(new com_ibm_rave_core_internal_geom_voronoi_VoronoiEdge.VoronoiHalfEdge(edge, lSite, rSite));
	context.voronoiCells[rSite.i].edges.push(new com_ibm_rave_core_internal_geom_voronoi_VoronoiEdge.VoronoiHalfEdge(edge, rSite, lSite));
	return edge;
};

com_ibm_rave_core_internal_geom_voronoi_VoronoiEdge.voronoiSetEdgeEnd = function(edge, lSite, rSite, vertex) {
	if (!edge.a && !edge.b) {
		edge.a = vertex;
		edge.l = lSite;
		edge.r = rSite;
	} else if (edge.l == rSite) {
		edge.b = vertex;
	} else {
		edge.a = vertex;
	}
};

com_ibm_rave_core_internal_geom_voronoi_VoronoiEdge.voronoiCreateBorderEdge = function(context, lSite, va, vb) {
	var edge = new com_ibm_rave_core_internal_geom_voronoi_VoronoiEdge(lSite, null);
	edge.a = va;
	edge.b = vb;
	context.voronoiEdges.push(edge);
	return edge;
};

com_ibm_rave_core_internal_geom_voronoi_VoronoiEdge.VoronoiSite = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_geom_PointStruct, {

	i : 0

	//constructor : function(x, y) {}
});

com_ibm_rave_core_internal_geom_voronoi_VoronoiEdge.VoronoiHalfEdge = com_ibm_rave_core_nativeImpl_Declare({

	//edge : null,

	//site : null,

	angle : 0,

	constructor : function(edge, lSite, rSite) {
		var va = edge.a, vb = edge.b;
		this.edge = edge;
		this.site = lSite;
		this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l == lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
	},

	start : function() {
		return this.edge.l == this.site ? this.edge.a : this.edge.b;
	},

	end : function() {
		return this.edge.l == this.site ? this.edge.b : this.edge.a;
	}
});


// $source: com/ibm/rave/core/internal/geom/voronoi/VoronoiRedBlackTree
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
var com_ibm_rave_core_internal_geom_voronoi_VoronoiRedBlackTree = com_ibm_rave_core_nativeImpl_Declare({

	//root : null,

	insert : function(after, node) {
		var _after = after;
		var parent, grandpa, uncle;
		if (_after) {
			node.P = _after;
			node.N = _after.N;
			if (_after.N) {
				_after.N.P = node;
			}
			_after.N = node;
			if (_after.R) {
				_after = _after.R;
				while (_after.L) {
					_after = _after.L;
				}
				_after.L = node;
			} else {
				_after.R = node;
			}
			parent = _after;
		} else if (this.root) {
			_after = com_ibm_rave_core_internal_geom_voronoi_VoronoiRedBlackTree.voronoiRedBlackFirst(this.root);
			node.P = null;
			node.N = _after;
			_after.P = _after.L = node;
			parent = _after;
		} else {
			node.P = node.N = null;
			this.root = node;
			parent = null;
		}
		node.L = node.R = null;
		node.U = parent;
		node.C = true;
		_after = node;
		while (parent && parent.C) {
			grandpa = parent.U;
			if (parent == grandpa.L) {
				uncle = grandpa.R;
				if (uncle && uncle.C) {
					parent.C = uncle.C = false;
					grandpa.C = true;
					_after = grandpa;
				} else {
					if (_after == parent.R) {
						com_ibm_rave_core_internal_geom_voronoi_VoronoiRedBlackTree.voronoiRedBlackRotateLeft(this, parent);
						_after = parent;
						parent = _after.U;
					}
					parent.C = false;
					grandpa.C = true;
					com_ibm_rave_core_internal_geom_voronoi_VoronoiRedBlackTree.voronoiRedBlackRotateRight(this, grandpa);
				}
			} else {
				uncle = grandpa.L;
				if (uncle && uncle.C) {
					parent.C = uncle.C = false;
					grandpa.C = true;
					_after = grandpa;
				} else {
					if (_after == parent.L) {
						com_ibm_rave_core_internal_geom_voronoi_VoronoiRedBlackTree.voronoiRedBlackRotateRight(this, parent);
						_after = parent;
						parent = _after.U;
					}
					parent.C = false;
					grandpa.C = true;
					com_ibm_rave_core_internal_geom_voronoi_VoronoiRedBlackTree.voronoiRedBlackRotateLeft(this, grandpa);
				}
			}
			parent = _after.U;
		}
		this.root.C = false;
	},

	remove : function(node) {
		var _node = node;
		if (_node.N) {
			_node.N.P = _node.P;
		}
		if (_node.P) {
			_node.P.N = _node.N;
		}
		_node.N = _node.P = null;
		var parent = _node.U, sibling, left = _node.L, right = _node.R, next;
		var red;
		if (!left) {
			next = right;
		} else if (!right) {
			next = left;
		} else {
			next = com_ibm_rave_core_internal_geom_voronoi_VoronoiRedBlackTree.voronoiRedBlackFirst(right);
		}
		if (parent) {
			if (parent.L == _node) {
				parent.L = next;
			} else {
				parent.R = next;
			}
		} else {
			this.root = next;
		}
		if (left && right) {
			red = next.C;
			next.C = _node.C;
			next.L = left;
			left.U = next;
			if (next != right) {
				parent = next.U;
				next.U = _node.U;
				_node = next.R;
				parent.L = _node;
				next.R = right;
				right.U = next;
			} else {
				next.U = parent;
				parent = next;
				_node = next.R;
			}
		} else {
			red = _node.C;
			_node = next;
		}
		if (_node) {
			_node.U = parent;
		}
		if (red) {
			return;
		}
		if (_node && _node.C) {
			_node.C = false;
			return;
		}
		do {
			if (_node == this.root) {
				break;
			}
			if (_node == parent.L) {
				sibling = parent.R;
				if (sibling.C) {
					sibling.C = false;
					parent.C = true;
					com_ibm_rave_core_internal_geom_voronoi_VoronoiRedBlackTree.voronoiRedBlackRotateLeft(this, parent);
					sibling = parent.R;
				}
				if ((sibling.L && sibling.L.C) || (sibling.R && sibling.R.C)) {
					if (!sibling.R || !sibling.R.C) {
						sibling.L.C = false;
						sibling.C = true;
						com_ibm_rave_core_internal_geom_voronoi_VoronoiRedBlackTree.voronoiRedBlackRotateRight(this, sibling);
						sibling = parent.R;
					}
					sibling.C = parent.C;
					parent.C = sibling.R.C = false;
					com_ibm_rave_core_internal_geom_voronoi_VoronoiRedBlackTree.voronoiRedBlackRotateLeft(this, parent);
					_node = this.root;
					break;
				}
			} else {
				sibling = parent.L;
				if (sibling.C) {
					sibling.C = false;
					parent.C = true;
					com_ibm_rave_core_internal_geom_voronoi_VoronoiRedBlackTree.voronoiRedBlackRotateRight(this, parent);
					sibling = parent.L;
				}
				if ((sibling.L && sibling.L.C) || (sibling.R && sibling.R.C)) {
					if (!sibling.L || !sibling.L.C) {
						sibling.R.C = false;
						sibling.C = true;
						com_ibm_rave_core_internal_geom_voronoi_VoronoiRedBlackTree.voronoiRedBlackRotateLeft(this, sibling);
						sibling = parent.L;
					}
					sibling.C = parent.C;
					parent.C = sibling.L.C = false;
					com_ibm_rave_core_internal_geom_voronoi_VoronoiRedBlackTree.voronoiRedBlackRotateRight(this, parent);
					_node = this.root;
					break;
				}
			}
			sibling.C = true;
			_node = parent;
			parent = parent.U;
		} while (!_node.C);
		if (_node) {
			_node.C = false;
		}
	}
});

com_ibm_rave_core_internal_geom_voronoi_VoronoiRedBlackTree.voronoiRedBlackNode = function(node) {
	node.U = null;
	node.C = false;
	node.L = null;
	node.R = null;
	node.P = null;
	node.N = null;
};

com_ibm_rave_core_internal_geom_voronoi_VoronoiRedBlackTree.voronoiRedBlackRotateLeft = function(tree, node) {
	var p = node, q = node.R, parent = p.U;
	if (parent) {
		if (parent.L == p) {
			parent.L = q;
		} else {
			parent.R = q;
		}
	} else {
		tree.root = q;
	}
	q.U = parent;
	p.U = q;
	p.R = q.L;
	if (p.R) {
		p.R.U = p;
	}
	q.L = p;
};

com_ibm_rave_core_internal_geom_voronoi_VoronoiRedBlackTree.voronoiRedBlackRotateRight = function(tree, node) {
	var p = node, q = node.L, parent = p.U;
	if (parent) {
		if (parent.L == p) {
			parent.L = q;
		} else {
			parent.R = q;
		}
	} else {
		tree.root = q;
	}
	q.U = parent;
	p.U = q;
	p.L = q.R;
	if (p.L) {
		p.L.U = p;
	}
	q.R = p;
};

com_ibm_rave_core_internal_geom_voronoi_VoronoiRedBlackTree.voronoiRedBlackFirst = function(node) {
	var retVal = node;
	while (retVal.L) {
		retVal = retVal.L;
	}
	return retVal;
};


// $source: com/ibm/rave/core/internal/geom/voronoi/VoronoiCell
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/geom/voronoi/VoronoiEdge (static) // new, voronoiCreateBorderEdge
var com_ibm_rave_core_internal_geom_voronoi_VoronoiCell = com_ibm_rave_core_nativeImpl_Declare({

	//site : null,

	//edges : null,

	constructor : function(site) {
		this.site = site;
		this.edges = [];
	},

	prepare : function() {
		var halfEdges = this.edges;
		var iHalfEdge = halfEdges.length;
		var edge;
		while (iHalfEdge-- > 0) {
			edge = halfEdges[iHalfEdge].edge;
			if (!edge.b || !edge.a) {
				halfEdges.splice(iHalfEdge, 1);
			}
		}
		halfEdges.sort(com_ibm_rave_core_internal_geom_voronoi_VoronoiCell.voronoiHalfEdgeOrder);
		return halfEdges.length;
	}
});

com_ibm_rave_core_internal_geom_voronoi_VoronoiCell.voronoiCloseCells = function(context, extent) {
	var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3;
	var cells = context.voronoiCells;
	var iCell = cells.length;
	var cell;
	var iHalfEdge;
	var halfEdges;
	var nHalfEdges;
	var start;
	var end;
	while (iCell-- > 0) {
		cell = cells[iCell];
		if (!((cell)) || !((cell.prepare()))) {
			continue;
		}
		halfEdges = cell.edges;
		nHalfEdges = halfEdges.length;
		iHalfEdge = 0;
		while (iHalfEdge < nHalfEdges) {
			end = halfEdges[iHalfEdge].end();
			x3 = end.x;
			y3 = end.y;
			start = halfEdges[++iHalfEdge % nHalfEdges].start();
			x2 = start.x;
			y2 = start.y;
			if (Math.abs(x3 - x2) > 1.0E-6 || Math.abs(y3 - y2) > 1.0E-6) {
				halfEdges.splice(iHalfEdge, 0, new com_ibm_rave_core_internal_geom_voronoi_VoronoiEdge.VoronoiHalfEdge(com_ibm_rave_core_internal_geom_voronoi_VoronoiEdge.voronoiCreateBorderEdge(context, cell.site, end, Math.abs(x3 - x0) < 1.0E-6 && y1 - y3 > 1.0E-6 ? new com_ibm_rave_core_internal_geom_voronoi_VoronoiEdge.VoronoiSite(x0, Math.abs(x2 - x0) < 1.0E-6 ? y2 : y1) : Math.abs(y3 - y1) < 1.0E-6 && x1 - x3 > 1.0E-6 ? new com_ibm_rave_core_internal_geom_voronoi_VoronoiEdge.VoronoiSite(Math.abs(y2 - y1) < 1.0E-6 ? x2 : x1, y1) : Math.abs(x3 - x1) < 1.0E-6 && y3 - y0 > 1.0E-6 ? new com_ibm_rave_core_internal_geom_voronoi_VoronoiEdge.VoronoiSite(x1, Math.abs(x2 - x1) < 1.0E-6 ? y2 : y0) : Math.abs(y3 - y0) < 1.0E-6 && x3 - x0 > 1.0E-6 ? new com_ibm_rave_core_internal_geom_voronoi_VoronoiEdge.VoronoiSite(Math.abs(y2 - y0) < 1.0E-6 ? x2 : x0, y0) : null), cell.site, null));
				++nHalfEdges;
			}
		}
	}
};

com_ibm_rave_core_internal_geom_voronoi_VoronoiCell.voronoiHalfEdgeOrder = function(a, b) {
	if (b.angle > a.angle) {
		return 1;
	} else if (b.angle < a.angle) {
		return -1;
	}
	return 0;
};

// $source: com/ibm/rave/core/internal/geom/voronoi/VoronoiCircle
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/geom/voronoi/VoronoiRedBlackTree (static) // voronoiRedBlackNode
var com_ibm_rave_core_internal_geom_voronoi_VoronoiCircle = com_ibm_rave_core_nativeImpl_Declare({

	//x : null,

	//y : null,

	//arc : null,

	//site : null,

	//circle : null,

	//cy : null,

	//P : null,

	//N : null,

	//L : null,

	//R : null,

	//U : null,

	//edge : null,

	C : false,

	constructor : function() {
		com_ibm_rave_core_internal_geom_voronoi_VoronoiRedBlackTree.voronoiRedBlackNode(this);
	}
});

com_ibm_rave_core_internal_geom_voronoi_VoronoiCircle.voronoiDetachCircle = function(context, arc) {
	var circle = arc.circle;
	if ((circle)) {
		if (!((circle.P))) {
			context.voronoiFirstCircle = circle.N;
		}
		context.voronoiCircles.remove(circle);
		context.voronoiCirclePool.push(circle);
		com_ibm_rave_core_internal_geom_voronoi_VoronoiRedBlackTree.voronoiRedBlackNode(circle);
		arc.circle = null;
	}
};

com_ibm_rave_core_internal_geom_voronoi_VoronoiCircle.voronoiAttachCircle = function(context, arc) {
	var lArc = arc.P, rArc = arc.N;
	if (!lArc || !rArc) {
		return;
	}
	var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
	if (lSite == rSite) {
		return;
	}
	var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
	var d = 2 * (ax * cy - ay * cx);
	if (d >= -1.0E-12) {
		return;
	}
	var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d;
	cy = y + by;
	var circle = context.voronoiCirclePool.pop();
	if (!((circle))) {
		circle = new com_ibm_rave_core_internal_geom_voronoi_VoronoiCircle();
	}
	circle.arc = arc;
	circle.site = cSite;
	circle.x = x + bx;
	circle.y = cy + Math.sqrt(x * x + y * y);
	circle.cy = cy;
	arc.circle = circle;
	var before, node = context.voronoiCircles.root;
	while ((node)) {
		if (circle.y < node.y || (circle.y == node.y && circle.x <= node.x)) {
			if ((node.L)) {
				node = node.L;
			} else {
				before = node.P;
				break;
			}
		} else {
			if ((node.R)) {
				node = node.R;
			} else {
				before = node;
				break;
			}
		}
	}
	context.voronoiCircles.insert(before, circle);
	if (!((before))) {
		context.voronoiFirstCircle = circle;
	}
};


// $source: com/ibm/rave/core/internal/geom/voronoi/VoronoiBeach
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/geom/voronoi/VoronoiCircle (loadtime) // voronoiDetachCircle, voronoiAttachCircle, superclass
//@import com/ibm/rave/core/internal/geom/voronoi/VoronoiRedBlackTree (static) // voronoiRedBlackNode
//@import com/ibm/rave/core/internal/geom/voronoi/VoronoiEdge (static) // new, voronoiCreateEdge, voronoiSetEdgeEnd
var com_ibm_rave_core_internal_geom_voronoi_VoronoiBeach = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_internal_geom_voronoi_VoronoiCircle, {

	constructor : function() {
		com_ibm_rave_core_internal_geom_voronoi_VoronoiRedBlackTree.voronoiRedBlackNode(this);
	}
});

com_ibm_rave_core_internal_geom_voronoi_VoronoiBeach.voronoiCreateBeach = function(context, site) {
	var beach = context.voronoiBeachPool.pop();
	if (!beach) {
		beach = new com_ibm_rave_core_internal_geom_voronoi_VoronoiBeach();
	}
	beach.site = site;
	return beach;
};

com_ibm_rave_core_internal_geom_voronoi_VoronoiBeach.voronoiDetachBeach = function(context, beach) {
	com_ibm_rave_core_internal_geom_voronoi_VoronoiCircle.voronoiDetachCircle(context, beach);
	context.voronoiBeaches.remove(beach);
	context.voronoiBeachPool.push(beach);
	com_ibm_rave_core_internal_geom_voronoi_VoronoiRedBlackTree.voronoiRedBlackNode(beach);
};

com_ibm_rave_core_internal_geom_voronoi_VoronoiBeach.voronoiRemoveBeach = function(context, beach) {
	var circle = beach.circle;
	var x = circle.x;
	var y = circle.cy;
	var vertex = new com_ibm_rave_core_internal_geom_voronoi_VoronoiEdge.VoronoiSite(x, y);
	var previous = beach.P, next = beach.N;
	var disappearing = [beach];
	com_ibm_rave_core_internal_geom_voronoi_VoronoiBeach.voronoiDetachBeach(context, beach);
	var lArc = previous;
	while (lArc.circle && Math.abs(x - lArc.circle.x) < 1.0E-6 && Math.abs(y - lArc.circle.cy) < 1.0E-6) {
		previous = lArc.P;
		disappearing.unshift(lArc);
		com_ibm_rave_core_internal_geom_voronoi_VoronoiBeach.voronoiDetachBeach(context, lArc);
		lArc = previous;
	}
	disappearing.unshift(lArc);
	com_ibm_rave_core_internal_geom_voronoi_VoronoiCircle.voronoiDetachCircle(context, lArc);
	var rArc = next;
	while (rArc.circle && Math.abs(x - rArc.circle.x) < 1.0E-6 && Math.abs(y - rArc.circle.cy) < 1.0E-6) {
		next = rArc.N;
		disappearing.push(rArc);
		com_ibm_rave_core_internal_geom_voronoi_VoronoiBeach.voronoiDetachBeach(context, rArc);
		rArc = next;
	}
	disappearing.push(rArc);
	com_ibm_rave_core_internal_geom_voronoi_VoronoiCircle.voronoiDetachCircle(context, rArc);
	var nArcs = disappearing.length;
	var iArc;
	for (iArc = 1; iArc < nArcs; ++iArc) {
		rArc = disappearing[iArc];
		lArc = disappearing[iArc - 1];
		com_ibm_rave_core_internal_geom_voronoi_VoronoiEdge.voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
	}
	lArc = disappearing[0];
	rArc = disappearing[nArcs - 1];
	rArc.edge = com_ibm_rave_core_internal_geom_voronoi_VoronoiEdge.voronoiCreateEdge(context, lArc.site, rArc.site, null, vertex);
	com_ibm_rave_core_internal_geom_voronoi_VoronoiCircle.voronoiAttachCircle(context, lArc);
	com_ibm_rave_core_internal_geom_voronoi_VoronoiCircle.voronoiAttachCircle(context, rArc);
};

com_ibm_rave_core_internal_geom_voronoi_VoronoiBeach.voronoiAddBeach = function(context, site) {
	var x = site.x, directrix = site.y;
	var lArc, rArc;
	var dxl, dxr;
	var node = context.voronoiBeaches.root;
	while (node) {
		dxl = com_ibm_rave_core_internal_geom_voronoi_VoronoiBeach.voronoiLeftBreakPoint(node, directrix) - x;
		if (dxl > 1.0E-6) {
			node = node.L;
		} else {
			dxr = x - com_ibm_rave_core_internal_geom_voronoi_VoronoiBeach.voronoiRightBreakPoint(node, directrix);
			if (dxr > 1.0E-6) {
				if (!node.R) {
					lArc = node;
					break;
				}
				node = node.R;
			} else {
				if (dxl > -1.0E-6) {
					lArc = node.P;
					rArc = node;
				} else if (dxr > -1.0E-6) {
					lArc = node;
					rArc = node.N;
				} else {
					lArc = rArc = node;
				}
				break;
			}
		}
	}
	var newArc = com_ibm_rave_core_internal_geom_voronoi_VoronoiBeach.voronoiCreateBeach(context, site);
	context.voronoiBeaches.insert(lArc, newArc);
	if (!lArc && !rArc) {
		return;
	}
	if (lArc == rArc) {
		com_ibm_rave_core_internal_geom_voronoi_VoronoiCircle.voronoiDetachCircle(context, lArc);
		rArc = com_ibm_rave_core_internal_geom_voronoi_VoronoiBeach.voronoiCreateBeach(context, lArc.site);
		context.voronoiBeaches.insert(newArc, rArc);
		newArc.edge = rArc.edge = com_ibm_rave_core_internal_geom_voronoi_VoronoiEdge.voronoiCreateEdge(context, lArc.site, newArc.site, null, null);
		com_ibm_rave_core_internal_geom_voronoi_VoronoiCircle.voronoiAttachCircle(context, lArc);
		com_ibm_rave_core_internal_geom_voronoi_VoronoiCircle.voronoiAttachCircle(context, rArc);
		return;
	}
	if (!rArc) {
		newArc.edge = com_ibm_rave_core_internal_geom_voronoi_VoronoiEdge.voronoiCreateEdge(context, lArc.site, newArc.site, null, null);
		return;
	}
	com_ibm_rave_core_internal_geom_voronoi_VoronoiCircle.voronoiDetachCircle(context, lArc);
	com_ibm_rave_core_internal_geom_voronoi_VoronoiCircle.voronoiDetachCircle(context, rArc);
	var lSite = lArc.site;
	var ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay;
	var rSite = rArc.site;
	var cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy;
	var vertex = new com_ibm_rave_core_internal_geom_voronoi_VoronoiEdge.VoronoiSite((cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay);
	com_ibm_rave_core_internal_geom_voronoi_VoronoiEdge.voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
	newArc.edge = com_ibm_rave_core_internal_geom_voronoi_VoronoiEdge.voronoiCreateEdge(context, lSite, site, null, vertex);
	rArc.edge = com_ibm_rave_core_internal_geom_voronoi_VoronoiEdge.voronoiCreateEdge(context, site, rSite, null, vertex);
	com_ibm_rave_core_internal_geom_voronoi_VoronoiCircle.voronoiAttachCircle(context, lArc);
	com_ibm_rave_core_internal_geom_voronoi_VoronoiCircle.voronoiAttachCircle(context, rArc);
};

com_ibm_rave_core_internal_geom_voronoi_VoronoiBeach.voronoiLeftBreakPoint = function(arc, directrix) {
	var site = arc.site;
	var rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
	if (!((pby2))) {
		return rfocx;
	}
	var lArc = arc.P;
	if (!lArc) {
		return -Infinity;
	}
	site = lArc.site;
	var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
	if (!((plby2))) {
		return lfocx;
	}
	var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
	if ((aby2)) {
		var sqRoot = Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2));
		return (-b + sqRoot) / aby2 + rfocx;
	}
	return (rfocx + lfocx) / 2;
};

com_ibm_rave_core_internal_geom_voronoi_VoronoiBeach.voronoiRightBreakPoint = function(arc, directrix) {
	var rArc = arc.N;
	if (rArc) {
		return com_ibm_rave_core_internal_geom_voronoi_VoronoiBeach.voronoiLeftBreakPoint(rArc, directrix);
	}
	var site = arc.site;
	return site.y == directrix ? site.x : Infinity;
};


// $source: com/ibm/rave/core/internal/geom/voronoi/VoronoiClip
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/geom/ClipLine (runtime) // create
//@import com/ibm/rave/core/internal/geom/voronoi/VoronoiEdge (static) // new
var com_ibm_rave_core_internal_geom_voronoi_VoronoiClip = com_ibm_rave_core_nativeImpl_Declare({


});

com_ibm_rave_core_internal_geom_voronoi_VoronoiClip.voronoiClipEdges = function(context, extent) {
	var edges = context.voronoiEdges;
	var clip = com_ibm_rave_core_geom_ClipLine.create(extent[0][0], extent[0][1], extent[1][0], extent[1][1]);
	var i = edges.length;
	var e;
	while (i-- > 0) {
		e = edges[i];
		if (!(com_ibm_rave_core_internal_geom_voronoi_VoronoiClip.voronoiConnectEdge(e, extent)) || !clip(e) || (Math.abs(e.a.x - e.b.x) < 1.0E-6 && Math.abs(e.a.y - e.b.y) < 1.0E-6)) {
			e.a = null;
			e.b = null;
			edges.splice(i, 1);
		}
	}
};

com_ibm_rave_core_internal_geom_voronoi_VoronoiClip.voronoiConnectEdge = function(edge, extent) {
	var vb = edge.b;
	if (vb) {
		return true;
	}
	var va = edge.a;
	var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1];
	var lSite = edge.l, rSite = edge.r;
	var lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
	if (ry == ly) {
		if (fx < x0 || fx >= x1) {
			return false;
		}
		if (lx > rx) {
			if (!va) {
				va = new com_ibm_rave_core_internal_geom_voronoi_VoronoiEdge.VoronoiSite(fx, y0);
			} else if (va.y >= y1) {
				return false;
			}
			vb = new com_ibm_rave_core_internal_geom_voronoi_VoronoiEdge.VoronoiSite(fx, y1);
		} else {
			if (!va) {
				va = new com_ibm_rave_core_internal_geom_voronoi_VoronoiEdge.VoronoiSite(fx, y1);
			} else if (va.y < y0) {
				return false;
			}
			vb = new com_ibm_rave_core_internal_geom_voronoi_VoronoiEdge.VoronoiSite(fx, y0);
		}
	} else {
		fm = (lx - rx) / (ry - ly);
		fb = fy - fm * fx;
		if (fm < -1 || fm > 1) {
			if (lx > rx) {
				if (!va) {
					va = new com_ibm_rave_core_internal_geom_voronoi_VoronoiEdge.VoronoiSite((y0 - fb) / fm, y0);
				} else if (va.y >= y1) {
					return false;
				}
				vb = new com_ibm_rave_core_internal_geom_voronoi_VoronoiEdge.VoronoiSite((y1 - fb) / fm, y1);
			} else {
				if (!va) {
					va = new com_ibm_rave_core_internal_geom_voronoi_VoronoiEdge.VoronoiSite((y1 - fb) / fm, y1);
				} else if (va.y < y0) {
					return false;
				}
				vb = new com_ibm_rave_core_internal_geom_voronoi_VoronoiEdge.VoronoiSite((y0 - fb) / fm, y0);
			}
		} else {
			if (ly < ry) {
				if (!va) {
					va = new com_ibm_rave_core_internal_geom_voronoi_VoronoiEdge.VoronoiSite(x0, fm * x0 + fb);
				} else if (va.x >= x1) {
					return false;
				}
				vb = new com_ibm_rave_core_internal_geom_voronoi_VoronoiEdge.VoronoiSite(x1, fm * x1 + fb);
			} else {
				if (!va) {
					va = new com_ibm_rave_core_internal_geom_voronoi_VoronoiEdge.VoronoiSite(x1, fm * x1 + fb);
				} else if (va.x < x0) {
					return false;
				}
				vb = new com_ibm_rave_core_internal_geom_voronoi_VoronoiEdge.VoronoiSite(x0, fm * x0 + fb);
			}
		}
	}
	edge.a = va;
	edge.b = vb;
	return true;
};


// $source: com/ibm/rave/core/internal/geom/voronoi/VoronoiIndex
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/geom/voronoi/VoronoiRedBlackTree (static) // new
//@import com/ibm/rave/core/internal/geom/voronoi/VoronoiCell (static) // new, voronoiCloseCells
//@import com/ibm/rave/core/internal/geom/voronoi/VoronoiBeach (static) // voronoiAddBeach, voronoiRemoveBeach
//@import com/ibm/rave/core/internal/geom/voronoi/VoronoiClip (static) // voronoiClipEdges
var com_ibm_rave_core_internal_geom_voronoi_VoronoiIndex = com_ibm_rave_core_nativeImpl_Declare({


});

com_ibm_rave_core_internal_geom_voronoi_VoronoiIndex.voronoi = function(context, sites, bbox) {
	var site = sites.sort(com_ibm_rave_core_internal_geom_voronoi_VoronoiIndex.voronoiVertexOrder).pop();
	var x0 = -Infinity;
	var y0 = -Infinity;
	var circle;
	context.voronoiEdges = [];
	context.voronoiCells = new Array(sites.length);
	context.voronoiBeaches = new com_ibm_rave_core_internal_geom_voronoi_VoronoiRedBlackTree();
	context.voronoiCircles = new com_ibm_rave_core_internal_geom_voronoi_VoronoiRedBlackTree();
	while (true) {
		circle = context.voronoiFirstCircle;
		if (site && (!circle || site.y < circle.y || (site.y == circle.y && site.x < circle.x))) {
			if (site.x != x0 || site.y != y0) {
				context.voronoiCells[site.i] = new com_ibm_rave_core_internal_geom_voronoi_VoronoiCell(site);
				com_ibm_rave_core_internal_geom_voronoi_VoronoiBeach.voronoiAddBeach(context, site);
				x0 = site.x;
				y0 = site.y;
			}
			site = sites.pop();
		} else if (circle) {
			com_ibm_rave_core_internal_geom_voronoi_VoronoiBeach.voronoiRemoveBeach(context, circle.arc);
		} else {
			break;
		}
	}
	if ((bbox)) {
		com_ibm_rave_core_internal_geom_voronoi_VoronoiClip.voronoiClipEdges(context, bbox);
		com_ibm_rave_core_internal_geom_voronoi_VoronoiCell.voronoiCloseCells(context, bbox);
	}
	var diagram = new com_ibm_rave_core_internal_geom_voronoi_VoronoiIndex.VoronoiDiagram(context.voronoiCells, context.voronoiEdges);
	context.voronoiBeaches = null;
	context.voronoiCircles = null;
	context.voronoiEdges = null;
	context.voronoiCells = null;
	return diagram;
};

com_ibm_rave_core_internal_geom_voronoi_VoronoiIndex.VoronoiDiagram = com_ibm_rave_core_nativeImpl_Declare({

	//voronoiEdges : null,

	//voronoiCells : null,

	constructor : function(cells, edges) {
		this.voronoiEdges = edges;
		this.voronoiCells = cells;
	}
});

com_ibm_rave_core_internal_geom_voronoi_VoronoiIndex.voronoiVertexOrder = function(a, b) {
	var dresult = (b.y - a.y);
	if (dresult == 0) {
		dresult = (b.x - a.x);
	}
	if (dresult > 0) {
		return 1;
	}
	if (dresult < 0) {
		return -1;
	}
	return 0;
};

// $source: com/ibm/rave/core/geom/ClipLine
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/geom/PointStruct (runtime) // new
/**
 * A class that creates a functor for line clipping using Liang–Barsky line clipping algorithm. In computer graphics, 'line clipping' is the process of removing lines or portions of lines outside of an area of interest.  Typically, any line or part thereof which is outside of the viewing area is removed.
 */
var com_ibm_rave_core_geom_ClipLine = rave_externs["ClipLine"] = com_ibm_rave_core_nativeImpl_Declare({


});

/**
 * Creates the line clipper functor that could be used to clip a line if it is not within the boundaries of the specified box 
 * @param (double) x0 the x ccordinate of the upper corner clipping box
 * @param (double) y0 the y ccordinate of the upper corner clipping box
 * @param (double) x1 the y ccordinate of the lower corner clipping box
 * @param (double) y1 the x ccordinate of the lower corner clipping box
 * @return (com.ibm.rave.core.geom.ClipLine.LineClipper)  return a new  {@link (com.ibm.rave.core.geom.ClipLine.LineClipper) LineClipper}  functor
 */
/** @expose */ 
com_ibm_rave_core_geom_ClipLine.create = function(x0, y0, x1, y1) {
	return function(line) {
		var a = line.a, b = line.b;
		var ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
		r = x0 - ax;
		if (!((dx)) && r > 0) {
			return null;
		}
		r /= dx;
		if (dx < 0) {
			if (r < t0) {
				return null;
			}
			if (r < t1) {
				t1 = r;
			}
		} else if (dx > 0) {
			if (r > t1) {
				return null;
			}
			if (r > t0) {
				t0 = r;
			}
		}
		r = x1 - ax;
		if (!((dx)) && r < 0) {
			return null;
		}
		r /= dx;
		if (dx < 0) {
			if (r > t1) {
				return null;
			}
			if (r > t0) {
				t0 = r;
			}
		} else if (dx > 0) {
			if (r < t0) {
				return null;
			}
			if (r < t1) {
				t1 = r;
			}
		}
		r = y0 - ay;
		if (!((dy)) && r > 0) {
			return null;
		}
		r /= dy;
		if (dy < 0) {
			if (r < t0) {
				return null;
			}
			if (r < t1) {
				t1 = r;
			}
		} else if (dy > 0) {
			if (r > t1) {
				return null;
			}
			if (r > t0) {
				t0 = r;
			}
		}
		r = y1 - ay;
		if (!((dy)) && r < 0) {
			return null;
		}
		r /= dy;
		if (dy < 0) {
			if (r > t1) {
				return null;
			}
			if (r > t0) {
				t0 = r;
			}
		} else if (dy > 0) {
			if (r < t0) {
				return null;
			}
			if (r < t1) {
				t1 = r;
			}
		}
		if (t0 > 0) {
			line.a = new com_ibm_rave_core_geom_PointStruct(ax + t0 * dx, ay + t0 * dy);
		}
		if (t1 < 1) {
			line.b = new com_ibm_rave_core_geom_PointStruct(ax + t1 * dx, ay + t1 * dy);
		}
		return line;
	};
};


// $source: com/ibm/rave/core/internal/geom/voronoi/VoronoiPolygon
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
var com_ibm_rave_core_internal_geom_voronoi_VoronoiPolygon = com_ibm_rave_core_nativeImpl_Declare(Array, {

	//point : null

	//constructor : function(elements) {}
});


// $source: com/ibm/rave/core/geom/Hull
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/math/Trigonometry (static) // cross2d
/**
 * Create a new hull layout with the default x- and y-accessors
 * @param <  T >
 */
var com_ibm_rave_core_geom_Hull = rave_externs["Hull"] = com_ibm_rave_core_nativeImpl_Declare({

	//fx : null,

	//fy : null,

	//xVal : null,

	//yVal : null,

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * Returns the convex hull for the specified vertices array, using the current x- and y-coordinate accessors. The returned convex hull is represented as an array containing a subset of the input vertices, arranged in counterclockwise order (for consistency with polygon.clip). Assumes the vertices array is greater than three in length. If vertices is of length <= 3, returns [].
		 * @param (Array) vertices The specified vertices array
		 * @return (Array)  the convex hull for the specified vertices array
		 */
		function(vertices) {
			if (!vertices || vertices.length < 3) {
				return [];
			}
			var i = 0;
			var n = vertices.length;
			var points = [];
			var flippedPoints = [];
			for (i = 0; i < n; ++i) {
				var p = new com_ibm_rave_core_geom_Hull.HullPoint();
				p.x = + (_$self.fx(vertices[i], i));
				p.y = + (_$self.fy(vertices[i], i));
				p.index = i;
				points.push(p);
			}
			points.sort(com_ibm_rave_core_geom_Hull.geom_hullOrder);
			for (i = 0; i < n; ++i) {
				var point = new com_ibm_rave_core_geom_Hull.HullPoint();
				point.x = points[i].x;
				point.y = -points[i].y;
				flippedPoints.push(point);
			}
			var upper = com_ibm_rave_core_geom_Hull.geom_hullUpper(points);
			var lower = com_ibm_rave_core_geom_Hull.geom_hullUpper(flippedPoints);
			var skipLeft = 0;
			var skipRight = 0;
			if (lower[0] == upper[0]) {
				skipLeft = 1;
			}
			if (lower[lower.length - 1] == upper[upper.length - 1]) {
				skipRight = 1;
			}
			var polygon = [];
			for (i = upper.length - 1; i >= 0; --i) {
				var upperPoint = points[upper[i]];
				polygon.push(vertices[upperPoint.index]);
			}
			for (i = skipLeft; i < lower.length - skipRight; ++i) {
				var lowerPoint = points[lower[i]];
				polygon.push(vertices[lowerPoint.index]);
			}
			return polygon;
		};
		return _$self;
	},

	constructor : function() {
		this.fx = com_ibm_rave_core_geom_Hull.FX_COMP_FN;
		this.fy = com_ibm_rave_core_geom_Hull.FY_COMP_FN;
		this.xVal = this.fx;
		this.yVal = this.fy;
	},

	/**
	 * Returns the current x-coordinate accessor function. Defaults to returning the first value in the data point.
	 * @return (Object)  the current x-coordinate accessor
	 */
	x$0 : function() {
		return this.xVal;
	},

	/**
	 * If x is specified, sets the x-coordinate accessor and returns this hull For each point added to the hull, either during initial construction or lazily added, the x-accessor is invoked with the arguments {data, index}, where data is the current point and index is its index in the array of all points. The x-accessor must then return a numeric value indicating the x-coordinate of the given point. The x-accessor may also be defined as a constant number rather than a function, if desired.
	 * @param (double) x The x-coordinate to use
	 * @return (com.ibm.rave.core.geom.Hull)  the quadtree factory
	 */
	x$1 : function(x) {
		this.fx = function(data, i) {
			if (!data) {
				return undefined;
			}
			return x;
		};
		this.xVal = x;
		return this;
	},

	/**
	 * Sets the x-coordinate accessor and returns this hull For each point added to the hull, either during initial construction or lazily added, the x-accessor is invoked with the arguments {data, index}, where data is the current point and index is its index in the array of all points. The x-accessor must then return a numeric value indicating the x-coordinate of the given point. The x-accessor may also be defined as a constant number rather than a function, if desired.
	 * @param (com.ibm.rave.core.geom.Hull.HullFunction) x A new x-accessor to be used
	 * @return (com.ibm.rave.core.geom.Hull)  the quadtree factory
	 */
	x$2 : function(x) {
		this.fx = x;
		this.xVal = x;
		return this;
	},

	/**
	 * Returns the current y-coordinate accessor. Defaults to returning the second value in the data point.
	 * @return (Object)  the current y-coordinate accessor
	 */
	y$0 : function() {
		return this.yVal;
	},

	/**
	 * If y is specified, sets the y-coordinate accessor and returns this hull For each point added to the hull, either during initial construction or lazily added, the y-accessor is invoked with the arguments {data, index}, where data is the current point and index is its index in the array of all points. The y-accessor must then return a numeric value indicating the y-coordinate of the given point. The y-accessor may also be defined as a constant number rather than a function, if desired.
	 * @param (double) y The y-coordinate to use
	 * @return (com.ibm.rave.core.geom.Hull)  the quadtree factory
	 */
	y$1 : function(y) {
		this.fy = function(data, i) {
			if (!data) {
				return undefined;
			}
			return y;
		};
		this.yVal = y;
		return this;
	},

	/**
	 * If y is specified, sets the y-coordinate accessor and returns this hull For each point added to the hull, either during initial construction or lazily added, the y-accessor is invoked with the arguments {data, index}, where data is the current point and index is its index in the array of all points. The y-accessor must then return a numeric value indicating the y-coordinate of the given point. The y-accessor may also be defined as a constant number rather than a function, if desired.
	 * @param (com.ibm.rave.core.geom.Hull.HullFunction) y A new y-accessor to be used
	 * @return (com.ibm.rave.core.geom.Hull)  the quadtree factory
	 */
	y$2 : function(y) {
		this.fy = y;
		this.yVal = y;
		return this;
	},

	/** @expose */ 
	x : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.x$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.x$2(a0);
		}
		return this.x$1(a0);
	},

	/** @expose */ 
	y : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.y$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.y$2(a0);
		}
		return this.y$1(a0);
	}
});

com_ibm_rave_core_geom_Hull.geom_hullUpper = function(points) {
	var n = points.length;
	var hull = [0, 1];
	var hs = 2;
	for (var i = 2; i < n; ++i) {
		while (hs > 1 && com_ibm_rave_core_internal_math_Trigonometry.cross2d(points[hull[hs - 2]].toDoubleArray(), points[hull[hs - 1]].toDoubleArray(), points[i].toDoubleArray()) <= 0) {
			--hs;
		}
		hull[hs++] = i;
	}
	return hull.slice(0, hs);
};

com_ibm_rave_core_geom_Hull.HullPoint = com_ibm_rave_core_nativeImpl_Declare({

	x : 0,

	y : 0,

	index : 0,

	/** @expose */ 
	toDoubleArray : function() {
		return [this.x, this.y];
	}
});

com_ibm_rave_core_geom_Hull.geom_hullOrder = function(a, b) {
	var val = ~~(a.x - b.x);
	if (val != 0) {
		return val;
	}
	return ~~(a.y - b.y);
};
com_ibm_rave_core_geom_Hull.FX_COMP_FN = function(data, i) {
	return data[0];
};
com_ibm_rave_core_geom_Hull.FY_COMP_FN = function(data, i) {
	return data[1];
};

// $source: com/ibm/rave/core/scales/AbstractScale
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
/**
 * AbstractScale A scale is a function that maps input (domain) values to output (range) values. This is a generic, common interface for all scale types (e.g.  {@link (com.ibm.rave.core.scales.LinearScale) LinearScale} ,  {@link (com.ibm.rave.core.scales.OrdinalScale) OrdinalScale} ). AbstractScale is generic to allow each concrete scale type to accept and return any value type. Each concrete scale type may expect different types and sizes of domain and range arrays. For example, {@link (com.ibm.rave.core.scales.LinearScale) LinearScale}  expects an array of 2 numbers, [min, max], as it's domain and range; however, {@link (com.ibm.rave.core.scales.OrdinalScale) OrdinalScale}  expects an arbitrary length array of any type (typically the domain will be an array of String, such as categories ["A", "B", "C", ...]).
 * @param < (java.lang.Object) C > The context type.
 * @param < (java.lang.Object) R > The return type (i.e. the value type the scale will return for a given domain value).
 */
var com_ibm_rave_core_scales_AbstractScale = rave_externs["AbstractScale"] = com_ibm_rave_core_nativeImpl_Declare({

	/**
	 * @expose  
	 */
	/** @expose */ 
	invert : null,

	/**
	 * @expose  
	 */
	/** @expose */ 
	rangeExtent : null,

	/**
	 * @expose  
	 */
	/** @expose */ 
	rangeBand : null,

	/**
	 * @expose  
	 */
	/** @expose */ 
	ticks : null,

	/**
	 * @expose  
	 */
	/** @expose */ 
	tickFormat : null,

	/**
	 * @expose  
	 */
	/** @expose */ 
	zoomTransform : null,

	/**
	 * @expose  
	 */
	/** @expose */ 
	ticksInRange : null,

	/**
	 * Create a new Scale that duplicates this Scale. Note this will typically do a shallow copy (the original and copied scale will reference the same range/domain arrays).
	 * @return (com.ibm.rave.core.scales.AbstractScale)  A duplicate AbstractScale.
	 */
	/** @expose */ 
	copy : function() {},

	/**
	 * Gets the tick format value function. if this scale does not support tick formatting then it will return null.
	 * @return (com.ibm.rave.core.scales.AbstractScale.TickFormatValueFunction)  the tick format value function if it is supported or null if it isn't 
	 */
	/** @expose */ 
	getTickFormat : function() {
		return this.tickFormat;
	},

	/**
	 * Gets the range band value function. if this scale does not support this feature then it will return null.
	 * @return (com.ibm.rave.core.scales.AbstractScale.RangeBandValueFunction)  the range band value function if it is supported or null if it isn't 
	 */
	/** @expose */ 
	getRangeBand : function() {
		return this.rangeBand;
	},

	/**
	 * Gets the range extent value function. if this scale does not support this feature then it will return null.
	 * @return (com.ibm.rave.core.scales.AbstractScale.RangeExtentValueFunction)  the range extent value function if it is supported or null if it isn't 
	 */
	/** @expose */ 
	getRangeExtent : function() {
		return this.rangeExtent;
	},

	/**
	 * Gets the ticks value function. if this scale does not support this feature then it will return null.
	 * @return (com.ibm.rave.core.scales.AbstractScale.TicksValueFunction)  the ticks value function if it is supported or null if it isn't 
	 */
	/** @expose */ 
	getTicks : function() {
		return this.ticks;
	},

	/**
	 * Gets the zoomTransform function. if this scale does not support this feature then it will return null.
	 * @return (com.ibm.rave.core.scales.AbstractScale.ZoomTransformFunction)  the zoomTransform function if it is supported or null if it isn't 
	 */
	/** @expose */ 
	getZoomTransform : function() {
		return this.zoomTransform;
	},

	/**
	 * Gets the ticksInRange function. if this scale does not support this feature then it will return null.
	 * @return (com.ibm.rave.core.scales.AbstractScale.TicksInRangeFunction)  the ticksInRange function if it is supported or null if it isn't 
	 */
	/** @expose */ 
	getTicksInRange : function() {
		return this.ticksInRange;
	},

	/**
	 * Gets the invert value function. if this scale does not support this feature then it will return null.
	 * @return (com.ibm.rave.core.scales.AbstractScale.InvertValueFunction)  the invert value function if it is supported or null if it isn't 
	 */
	/** @expose */ 
	getInvert : function() {
		return this.invert;
	},

	/** @expose */ 
	setInvert : function(invert) {
		this.invert = invert;
	},

	/** @expose */ 
	setRangeExtent : function(rangeExtent) {
		this.rangeExtent = rangeExtent;
	},

	/** @expose */ 
	setRangeBand : function(rangeBand) {
		this.rangeBand = rangeBand;
	},

	/** @expose */ 
	setTicks : function(ticks) {
		this.ticks = ticks;
	},

	/** @expose */ 
	setTickFormat : function(tickFormat) {
		this.tickFormat = tickFormat;
	},

	/** @expose */ 
	setZoomTransform : function(zoomTransform) {
		this.zoomTransform = zoomTransform;
	},

	/** @expose */ 
	setTicksInRange : function(ticksInRange) {
		this.ticksInRange = ticksInRange;
	},

	/** @expose */ 
	domain : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.domain$1();
		}
		return this.domain$0(a0);
	},

	/** @expose */ 
	range : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.range$1();
		}
		return this.range$0(a0);
	}

	/**
	 * Set the scale's input domain.
	 * @param (Array) values Array of domain values.
	 * @return (com.ibm.rave.core.scales.AbstractScale)  This scale instance.
	 */
	//domain$0 : function(values) {},

	/**
	 * Get the scale's domain.
	 * @return (Array)  Array of domain values.
	 */
	//domain$1 : function() {},

	/**
	 * Set the scale's output range.
	 * @param (Array) values Array of range values.
	 * @return (com.ibm.rave.core.scales.AbstractScale)  This scale instance.
	 */
	//range$0 : function(values) {},

	/**
	 * Get the scale's range.
	 * @return (Array)  Array of range values.
	 */
	//range$1 : function() {}
});

/**
 * Returns a 2 element array containing the first and last values in the  {@code  range}  parameter in ascending order.
 * @param (Array) range An array of values, typically a Scale object's  {@code  range} .
 * @return (Array)  min and max extent of the range, stored in an array of length2.
 */
/** @expose */ 
com_ibm_rave_core_scales_AbstractScale.scaleExtent = function(range) {
	var start = range[0];
	var stop = range[range.length - 1];
	if ((typeof start === "number" || start instanceof Number) && (typeof stop === "number" || stop instanceof Number)) {
		if ((start) > (stop)) {
			return [stop, start];
		}
	}
	return [start, stop];
};

/**
 * A utility method that return the range extent of the passed scale. It will first check if the passed scale has a range extent value function, and if so, it will invoke it and return back the results, else, it will get the scale's range, pass it to  scaleExtent method and return its results. 
 * @param (com.ibm.rave.core.scales.AbstractScale) scale the scale to get the range extent for
 * @return (Array)  the scale's range extent
 */
/** @expose */ 
com_ibm_rave_core_scales_AbstractScale.scaleRange = function(scale) {
	if (scale.rangeExtent) {
		return scale.rangeExtent();
	}
	return com_ibm_rave_core_scales_AbstractScale.scaleExtent(scale.range());
};


// $source: com/ibm/rave/core/internal/scales/Polylinear
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/Rave (runtime) // Rave
/**
 * @author  Bryan
 */
var com_ibm_rave_core_internal_scales_Polylinear = com_ibm_rave_core_nativeImpl_Declare({

	_$functionClassMethod : function() {
		var _$self = function(domain, range, uninterpolate, interpolate) {
			return new com_ibm_rave_core_internal_scales_Polylinear.PolylinearValuefunction(domain, range, uninterpolate, interpolate);
		};
		return _$self;
	}
});

com_ibm_rave_core_internal_scales_Polylinear.PolylinearValuefunction = com_ibm_rave_core_nativeImpl_Declare({

	//u : null,

	//i : null,

	//domain : null,

	//range : null,

	k : 0,

	_$functionClassMethod : function() {
		var _$self = function(x) {
			var j = com_ibm_rave_core_Rave.bisect(_$self.domain, x, 1, _$self.k) - 1;
			return _$self.i[j](+ (_$self.u[j](+ (x))));
		};
		return _$self;
	},

	constructor : function(inDomain, inRange, uninterpolate, interpolate) {
		this.u = [];
		this.i = [];
		var j = 0;
		this.domain = [];
		for (var __i_enFor0 = 0, __exp_enFor0 = inDomain, __len_enFor0 = __exp_enFor0.length;
				__i_enFor0 < __len_enFor0; ++__i_enFor0) {
			var o = __exp_enFor0[__i_enFor0];
			this.domain.push(o);
		}
		this.range = [];
		for (var __i_enFor1 = 0, __exp_enFor1 = inRange, __len_enFor1 = __exp_enFor1.length;
				__i_enFor1 < __len_enFor1; ++__i_enFor1) {
			var o = __exp_enFor1[__i_enFor1];
			this.range.push(o);
		}
		this.k = Math.min(this.domain.length, this.range.length) - 1;
		if (+ (this.domain[this.k]) < + (this.domain[0])) {
			this.domain = this.domain.slice().reverse();
			this.range = this.range.slice().reverse();
		}
		while (++j <= this.k) {
			this.u.push(uninterpolate(this.domain[j - 1], this.domain[j]));
			this.i.push(interpolate(this.range[j - 1], this.range[j]));
		}
	}
});


// $source: com/ibm/rave/core/internal/scales/Bilinear
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
/**
 * @author  Bryan
 */
var com_ibm_rave_core_internal_scales_Bilinear = com_ibm_rave_core_nativeImpl_Declare({

	_$functionClassMethod : function() {
		var _$self = function(domain, range, uninterpolate, interpolate) {
			return new com_ibm_rave_core_internal_scales_Bilinear.BilinearValuefunction(domain, range, uninterpolate, interpolate);
		};
		return _$self;
	}
});

com_ibm_rave_core_internal_scales_Bilinear.BilinearValuefunction = com_ibm_rave_core_nativeImpl_Declare({

	//u : null,

	//i : null,

	_$functionClassMethod : function() {
		var _$self = function(x) {
			return _$self.i(+ (_$self.u(+ (x))));
		};
		return _$self;
	},

	constructor : function(domain, range, uninterpolate, interpolate) {
		this.u = uninterpolate(domain[0], domain[1]);
		this.i = interpolate(range[0], range[1]);
	}
});


// $source: com/ibm/rave/core/internal/interpolate/UninterpolateClamp
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
/**
 * Creates an uninterpolator that can uninterpolate a number
 * @author  Bryan
 */
var com_ibm_rave_core_internal_interpolate_UninterpolateClamp = com_ibm_rave_core_nativeImpl_Declare({

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * Creates an uninterpolator that can uninterpolate a number
		 * @param (Object) a the start value
		 * @param (Object) b the end value
		 * @return (com.ibm.rave.core.interpolate.Interpolator)  new interpolator
		 */
		function(a, b) {
			var da = + (a);
			var db = + (b);
			var db2 = ((db - da) != 0) ? db - da : 1 / db;
			return function(x) {
				return Math.max(0, Math.min(1, (x - da) / db2));
			};
		};
		return _$self;
	}
});


// $source: com/ibm/rave/core/internal/interpolate/UninterpolateNumber
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
/**
 * Creates an uninterpolator that can uninterpolate a number
 * @author  Bryan
 */
var com_ibm_rave_core_internal_interpolate_UninterpolateNumber = com_ibm_rave_core_nativeImpl_Declare({

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * Creates an uninterpolator that can uninterpolate a number between the start and end value.
		 * @param (Object) a the start value
		 * @param (Object) b the end value
		 * @return (com.ibm.rave.core.interpolate.Interpolator)  new interpolator
		 */
		function(a, b) {
			var da = + (a);
			var db = + (b);
			var db2 = ((db - da) != 0) ? db - da : 1 / db;
			return function(x) {
				return (x - da) / db2;
			};
		};
		return _$self;
	}
});


// $source: com/ibm/rave/core/interpolate/RoundInterpolation
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
var com_ibm_rave_core_interpolate_RoundInterpolation = rave_externs["RoundInterpolation"] = com_ibm_rave_core_nativeImpl_Declare({

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * Creates an interpolator that can interpolate between the two numbers a and b; the interpolator is similar to NumberInterpolator, except it will round the resulting value to the nearest integer.
		 * @param (Object) a the start value
		 * @param (Object) b the end value
		 * @return (com.ibm.rave.core.interpolate.Interpolator)  the new interpolator
		 */
		function(a, b) {
			var da = + (a);
			var db = + (b) - da;
			return function(t) {
				return Math.round(da + db * t);
			};
		};
		return _$self;
	}
});

/** @expose */ 
com_ibm_rave_core_interpolate_RoundInterpolation.INSTANCE = new com_ibm_rave_core_interpolate_RoundInterpolation();

// $source: com/ibm/rave/core/internal/scales/NiceIdentity
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
/**
 * A default nice range that simply returns the values as-is. May be overridden for more functionality (as in TimeScale). 
 * @author  jim
 */
var com_ibm_rave_core_internal_scales_NiceIdentity = com_ibm_rave_core_nativeImpl_Declare({

	//floor : null,

	//ceil : null,

	constructor : function(inFloor, inCeil) {
		this.floor = function(x) {
			return x;
		};
		this.ceil = function(x) {
			return x;
		};
		{
			if (inFloor) {
				this.floor = inFloor;
			}
			if (inCeil) {
				this.ceil = inCeil;
			}
		}
	}

	//constructor : function() {}
});


// $source: com/ibm/rave/core/internal/scales/Nice
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/scales/NiceIdentity (static) // new
/**
 * Nicely round numbers
 * @author  Bryan
 */
var com_ibm_rave_core_internal_scales_Nice = com_ibm_rave_core_nativeImpl_Declare({


});

com_ibm_rave_core_internal_scales_Nice.scaleNice = function(domain, nice) {
	var i0 = 0.0, i1 = domain.length - 1, x0 = + (domain[i0]), x1 = + (domain[i1]), dx;
	if (x1 < x0) {
		dx = i0;
		i0 = i1;
		i1 = dx;
		dx = x0;
		x0 = x1;
		x1 = dx;
	}
	domain[i0] = nice.floor(x0);
	domain[i1] = nice.ceil(x1);
	return domain;
};

com_ibm_rave_core_internal_scales_Nice.niceStep = function(step) {
	var doubleStep = + (step);
	return doubleStep != 0.0 ? new com_ibm_rave_core_internal_scales_NiceIdentity(function(x) {
		return Math.floor(x / doubleStep) * doubleStep;
	}, function(x) {
		return Math.ceil(x / doubleStep) * doubleStep;
	}) : new com_ibm_rave_core_internal_scales_NiceIdentity();
};


// $source: com/ibm/rave/core/locale/NumberFormat
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/nativeImpl/arrays/ES6Map (runtime) // create
//@import com/ibm/rave/core/format/Round (runtime) // round
//@import com/ibm/rave/core/internal/format/Precision (runtime) // precision
//@import com/ibm/rave/core/format/FormatPrefix (runtime) // formatPrefix
var com_ibm_rave_core_locale_NumberFormat = rave_externs["NumberFormat"] = com_ibm_rave_core_nativeImpl_Declare({

	//locale_grouping : null,

	//locale_currency : null,

	//locale_decimal : null,

	//formatGroup : null,

	_$functionClassMethod : function() {
		var _$self = function(specifier) {
			var match = new RegExp(com_ibm_rave_core_locale_NumberFormat.format_re, "i").exec(specifier);
			var zcomma;
			var newType;
			var fill = match[1] != null ? match[1] : " ";
			var align = match[2] != null ? match[2] : ">";
			var sign = match[3] != null ? match[3] : "-";
			var symbol = match[4] != null ? match[4] : "";
			var zfill = match[5];
			var width = match[6];
			var comma = match[7];
			var precisionMatch = match[8];
			var type = match[9];
			var scale = 1;
			var prefix = "";
			var suffix = "";
			var integer = false;
			var exponent = true;
			var intwidth = 0;
			var precision;
			if (precisionMatch != null) {
				precision = ~~ (precisionMatch.substring(1));
			}
			if (zfill != null || fill == "0" && align == "=") {
				zfill = fill = "0";
				align = "=";
				if (comma != null) {
					var w = ~~+ (width);
					intwidth = w;
				}
			}
			if (type != null) {
				if (type == "n") {
					comma = "true";
					type = "g";
				} else if (type == "%") {
					scale = 100;
					suffix = "%";
					type = "f";
				} else if (type == "p") {
					scale = 100;
					suffix = "%";
					type = "r";
				} else if (type == "b" || type == "o" || type == "x" || type == "X") {
					if (symbol == "#") {
						prefix = "0" + type.toLowerCase();
					}
				} else if (type == "c") {
					exponent = false;
				} else if (type == "d") {
					integer = true;
					precision = 0;
				} else if (type == "s") {
					scale = -1;
					type = "r";
				}
			}
			if (symbol == ("$")) {
				prefix = _$self.locale_currency[0];
				suffix = _$self.locale_currency[1];
			}
			if (type != null && type == "r" && precision == null) {
				type = "g";
			}
			var value;
			if (precision != null) {
				value = precision;
				if (type != null && type == "g") {
					precision = Math.max(1, Math.min(21, value));
				} else if (type != null && type == "e" || type != null && type == "f") {
					precision = Math.max(0, Math.min(20, value));
				}
			}
			newType = _$self.formatTypes().get(type);
			if (!newType) {
				newType = _$self.formatTypeDefault();
			}
			if (zfill != null) {
				zcomma = comma;
			} else if (comma != null) {
				zcomma = zfill;
			} else {
				zcomma = comma;
			}
			var _suffix = suffix;
			var _exponent = exponent;
			var _integer = integer;
			var _sign = sign;
			var _prefix = prefix;
			var _zfill = zfill;
			var _comma = comma;
			var _precision = precision;
			var _scale = scale;
			var _newType = newType;
			var _zcomma = zcomma;
			var _width = width;
			var _align = align;
			var _intwidth = intwidth;
			var _fill = fill;
			var self = _$self;
			return function(data, index, groupIndex) {
				var value = + (data);
				var fullSuffix = _suffix;
				var v = value % 1;
				if (_integer && v > 0) {
					return "";
				}
				var negative;
				if (value < 0 || value == 0 && 1 / value < 0) {
					value = -value;
					negative = "-";
				} else {
					if (_sign == "-") {
						negative = "";
					} else {
						negative = _sign;
					}
				}
				if (_scale < 0) {
					var unit = com_ibm_rave_core_format_FormatPrefix.formatPrefix(value, _precision);
					value = unit.scale(value);
					fullSuffix = unit.symbol + _suffix;
				} else {
					value *= _scale;
				}
				var typeValue = _newType(value, _precision);
				var i = typeValue.lastIndexOf(".");
				var before;
				var after;
				if (i < 0) {
					var j = _exponent ? typeValue.lastIndexOf("e") : -1;
					if (j < 0) {
						before = typeValue;
						after = "";
					} else {
						before = typeValue.substring(0, j);
						after = typeValue.substring(j);
					}
				} else {
					before = typeValue.substring(0, i);
					after = self.locale_decimal + typeValue.substring(i + 1);
				}
				if (_zfill == null && _comma != null) {
					before = self.formatGroup(before, Infinity);
				}
				var length = _prefix.length + before.length + after.length + (_zcomma != null && !(_zcomma == "0") ? 0 : negative.length);
				var intwidth = _intwidth;
				if (_width != null && !(_width == "") && _intwidth == 0) {
					intwidth = parseInt(_width);
				}
				var padding;
				if (length < intwidth) {
					length = intwidth - length + 1;
					padding = new Array(length).join(_fill);
				} else {
					padding = "";
				}
				if (_zcomma != null && !(_zcomma == "0")) {
					before = self.formatGroup(padding + before, padding.length > 0 ? intwidth - after.length : Infinity);
				}
				negative += _prefix;
				var myValue = before + after;
				return (_align == "<" ? negative + myValue + padding : _align == ">" ? padding + negative + myValue : _align == "^" ? padding.substring(0, length >>= 1) + negative + myValue + padding.substring(length) : negative + (_zcomma != null && !(_zcomma == "0") ? myValue : padding + myValue)) + fullSuffix;
			};
		};
		return _$self;
	},

	/**
	 * Returns a new format function with the given string specifier. A format function takes a number as the only argument, and returns a string representing the formatted number. The format specifier is modeled after Python 3.1's built-in format specification mini-language. The general form of a specifier is: [​[fill]align][sign][symbol][0][width][,][.precision][type] The fill can be any character other than "{" or "}". The presence of a fill character is signaled by the character following it, which must be one of the align options. The align can be: ("<") Forces the field to be left-aligned within the available space. (">") Forces the field to be right-aligned within the available space. (This is the default). ("^") Forces the field to be centered within the available space. The sign can be: plus ("+") - a sign should be used for both positive and negative numbers. minus ("-") - a sign should be used only for negative numbers. (This is the default.) space (" ") - a leading space should be used on positive numbers, and a minus sign on negative numbers. The symbol can be: currency ("$") - a currency symbol should be prefixed (or suffixed) per the locale. base ("#") - for binary, octal, or hexadecimal output, prefix by "0b", "0o", or "0x", respectively. The "0" option enables zero-padding. The width defines the minimum field width. If not specified, then the width will be determined by the content. The comma (",") option enables the use of a comma for a thousands separator. The precision indicates how many digits should be displayed after the decimal point for a value formatted with types "f" and "%", or before and after the decimal point for a value formatted with types "g", "r" and "p". The available type values are: exponent ("e") - use Number.toExponential. general ("g") - use Number.toPrecision. fixed ("f") - use Number.toFixed. integer ("d") - use Number.toString, but ignore any non-integer values. rounded ("r") - round to precision significant digits, padding with zeroes  where necessary in similar fashion to fixed ("f"). If no precision is  specified, falls back to general notation. percentage ("%") - like fixed, but multiply by 100 and suffix with "%". rounded percentage ("p") - like rounded, but multiply by 100 and suffix with "%". binary ("b") - outputs the number in base 2. octal ("o") - outputs the number in base 8. hexadecimal ("x") - outputs the number in base 16, using lower-case letters for the digits above 9. hexadecimal ("X") - outputs the number in base 16, using upper-case letters for the digits above 9. character ("c") - converts the integer to the corresponding unicode character before printing. SI-prefix ("s") - like rounded, but with a unit suffixed such as "9.5M" for mega, or "1.00µ" for micro. The type "n" is also supported as shorthand for ",g" This is the entry point for number formatting. This method will take in a locale and do some basic setup in order to format a user specified number using a user specified format.
	 * @param (com.ibm.rave.core.locale.LocaleObject) locale The locale to use. If the user calls Rave.Format the default locale will be used. The default locale that is used is en-US unless the user has specified a different locale to use via Locale.setDefault();
	 * @return (void)  A value function which will allow the user to specify the type of format to use e.g] ",.2f"
	 */
	/** @expose */ 
	constructor : function(locale) {
		var locale_thousands = locale.thousands;
		this.locale_decimal = locale.decimal;
		this.locale_grouping = !locale.grouping ? [] : locale.grouping;
		this.locale_currency = locale.currency;
		var self = this;
		this.formatGroup = this.locale_grouping.length >= 0 ? 		/**
		 * an identity method which will manipulate the value coming in to be properly formatted by separating the string using locale_thousands
		 * @param (String) value the value which is to be formatted using locale_thousands as a separator
		 * @param (double) width is used to determine at which points the string should be split and a separator should be used
		 * @return (String)  A string that is separated using the locale_thousands value
		 */
		function(value, width) {
			var i = value.length;
			var t = [];
			var j = 0;
			var g = self.locale_grouping[0];
			var length = 0;
			while (i > 0 && g > 0) {
				if (length + g + 1 > width) {
					g = Math.max(1, width - length);
				}
				var zi = i;
				var zg = g;
				var z = zi -= zg;
				if (z < 0) {
					z = 0;
				}
				i -= g;
				t.push(value.substring(z, (i + ~~g)));
				if ((length += g + 1) > width) {
					break;
				}
				g = self.locale_grouping[j = (j + 1) % self.locale_grouping.length];
			}
			return t.reverse().join(locale_thousands);
		} : 		/**
		 * this method will return the value that is passed in
		 * @param (String) value the value which is to be formatted using locale_thousands as a separator
		 * @param (double) width is used to determine at which points the string should be split and a separator should be used
		 * @return (String)  the value that was passed in
		 */
		function(value, width) {
			return value;
		};
	},

	formatTypes : function() {
		var map = com_ibm_rave_core_nativeImpl_arrays_ES6Map.create();
		map.set("b", function(value, precision) {
			var v = ~~value;
			return v.toString(2);
		});
		map.set("c", function(value, precision) {
			var c = value;
			return String.fromCharCode(c);
		});
		map.set("o", function(value, precision) {
			var v = ~~value;
			return v.toString(8);
		});
		map.set("x", function(value, precision) {
			return value.toString(16);
		});
		map.set("X", function(value, precision) {
			return value.toString(16).toUpperCase();
		});
		map.set("g", function(value, precision) {
			return value.toPrecision(precision);
		});
		map.set("e", function(value, precision) {
			return precision != null ? value.toExponential(precision) : value.toExponential();
		});
		map.set("f", function(value, precision) {
			var fixed = value.toFixed(~~ (precision));
			var fixedDouble = + (fixed);
			if (((fixedDouble == Math.floor(fixedDouble)) && !(! isFinite(fixedDouble))) && ~~ (precision) <= 0) {
				var intfixed = Math.round(fixedDouble);
				return intfixed.toString();
			}
			return fixed;
		});
		map.set("r", function(value, precision) {
			var rounded = com_ibm_rave_core_format_Round.round(value, com_ibm_rave_core_internal_format_Precision.precision(value, precision));
			return rounded.toFixed(~~Math.max(0, Math.min(20, com_ibm_rave_core_internal_format_Precision.precision(rounded * (1 + 1e-15), precision))));
		});
		return map;
	},

	formatTypeDefault : function() {
		return function(xx, pp) {
			return ""+(xx);
		};
	}
});

/** @expose */ 
com_ibm_rave_core_locale_NumberFormat.format_re = "(?:([^{])?([<>=^]))?([+\\- ])?([$#])?(0)?(\\d+)?(,)?(\\.-?\\d+)?([a-z%])?";


// $source: com/ibm/rave/core/scales/OrdinalScale
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/scales/AbstractScale (loadtime) // scaleExtent, superclass
//@import com/ibm/rave/core/nativeImpl/arrays/ES6Map (runtime) // create
//@import com/ibm/rave/core/internal/scales/Ranger (static) // new
//@import com/ibm/rave/core/internal/nativeImpl/Lang (runtime) // isNumber
/**
 * A scale with a discreet input domain. This means that by default calling scale(0) will return the value in the input range that maps from this domain key -> range value. If no domain exists, then the domain will be created dynamically, adding new keys as they are called. If a domain does exist, the domain values are used as keys into the range.
 * @author  jim.
 */
var com_ibm_rave_core_scales_OrdinalScale = rave_externs["OrdinalScale"] = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_scales_AbstractScale, {

	//_domain : null,

	//_range : null,

	//ranger : null,

	//index : null,

	_rangeBand : 0,

	_viewOffset : 0,

	_viewZoom : 0,

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * Go through the domain looking for 'key' index in range.  If key doesn't exist in domain, return domain.length % range.lenth. ALSO, if the key doesn't exist, the key gets added to the domain implicitly. ie - domain([]).range(["hi","bye"])(0) == "hi" (0 % 2 == 0) domain(["test"]).range(["hi","bye"])(0) == "bye" (1 % 2 == 1) domain(["test"]).range(["hi","bye"])("test") == "hi" (key found) domain(["test", "test2"]).range(["hi","bye"])("test2") == "bye" (key found)
		 */
		function(key, _index, groupIndex) {
			return _$self.scale(key, _$self.ranger);
		};
		return _$self;
	},

	constructor : function(_domain, ranger, viewZoom, viewOffset) {
		this._domain = [];
		this._range = [];
		this.ranger = com_ibm_rave_core_scales_OrdinalScale.DEFAULT_RANGER;
		this.index = com_ibm_rave_core_nativeImpl_arrays_ES6Map.create();
		{
			this.ranger = ranger;
			this.domain(_domain);
			this._viewOffset = viewOffset;
			this._viewZoom = viewZoom;
			var self = this;
			this.rangeBand = function() {
				return self._rangeBand * self._viewZoom;
			};
			this.rangeExtent = function() {
				return com_ibm_rave_core_scales_AbstractScale.scaleExtent(self.ranger.a);
			};
			this.ticksInRange = function() {
				var ticks = [];
				var domain = self._domain;
				var extent = self.rangeExtent();
				if (com_ibm_rave_core_internal_nativeImpl_Lang.isNumber(extent[0]) && com_ibm_rave_core_internal_nativeImpl_Lang.isNumber(extent[1])) {
					var min = + (extent[0]);
					var max = + (extent[1]);
					for (var __i_enFor0 = 0, __exp_enFor0 = domain, __len_enFor0 = __exp_enFor0.length;
							__i_enFor0 < __len_enFor0; ++__i_enFor0) {
						var d = __exp_enFor0[__i_enFor0];
						var r = + (self.call(null, d, 0, 0)) + self.rangeBand() / 2;
						if (r >= min && r <= max) {
							ticks.push(d);
						}
					}
				}
				return ticks;
			};
			this.zoomTransform = function(zoom, offset) {
				self._viewOffset = offset;
				self._viewZoom = Math.max(0, zoom);
			};
		}
	},

	scale : function(key, ranger) {
		var keyString = ""+(key);
		var myindex = this.index.get(keyString);
		if (myindex == null) {
			if (ranger.t == "range") {
				this._domain.push(key);
				myindex = this.index.set(keyString, this._domain.length);
			} else {
			}
		}
		if (this._range.length == 0 || myindex == null) {
			return undefined;
		}
		myindex = (myindex - 1) % this._range.length;
		return this.transformRangeValue(this._range[myindex]);
	},

	domain$0 : function(values) {
		this._domain = [];
		this.index = com_ibm_rave_core_nativeImpl_arrays_ES6Map.create();
		var i = -1;
		var n = values.length;
		var xi;
		while (++i < n) {
			xi = ""+(values[i]);
			if (!(this.index.has(xi))) {
				this._domain.push(values[i]);
				this.index.set(xi, this._domain.length);
			}
		}
		if ("range" == this.ranger.t) {
			return this.range(this.ranger.a);
		}
		if ("rangeBands" == this.ranger.t) {
			return this.rangeBands(this.ranger.a, this.ranger.padding, this.ranger.outerPadding);
		}
		if ("rangePoints" == this.ranger.t) {
			return this.rangePoints(this.ranger.a, this.ranger.padding);
		}
		if ("rangeRoundBands" == this.ranger.t) {
			return this.rangeRoundBands(this.ranger.a, this.ranger.padding, this.ranger.outerPadding);
		}
		if ("rangeRoundPoints" == this.ranger.t) {
			return this.rangeRoundPoints(this.ranger.a, this.ranger.padding);
		}
		return this;
	},

	domain$1 : function() {
		return this._domain;
	},

	range$0 : function(values) {
		this._range = values;
		this.ranger = new com_ibm_rave_core_internal_scales_Ranger("range", values, 0, 0);
		this._rangeBand = 0;
		return this;
	},

	range$1 : function() {
		return this._range;
	},

	/** @expose */ 
	copy : function() {
		return new com_ibm_rave_core_scales_OrdinalScale(this._domain, this.ranger, this._viewZoom, this._viewOffset);
	},

	/**
	 * Sets the output range values based on the specified continuous interval. The interval is subdivided into <i>n</i> evenly spaced points, where <i>n</i> is the number of unique values in the input domain. <pre> Example: {@code rave.scale.ordinal().domain([1, 2, 3, 4]).rangePoints([0, 100], 0).range(); // returns [0, 33.333333333333336, 66.66666666666667, 100]} </pre>
	 * @param (Array) interval 2 element array containing minimum and maximum numeric values.
	 * @param (Number) padding Offset from the edge of the interval, as a multiple of the distance between points.
	 * @return (com.ibm.rave.core.scales.OrdinalScale)  This Scale.
	 */
	/** @expose */ 
	rangePoints : function(interval, padding) {
		var _padding = padding;
		if (_padding == null) {
			_padding = 0.0;
		}
		var start = + (interval[0]);
		var stop = + (interval[1]);
		var step = this._domain.length < 2 ? (start = (start + stop) / 2) : (stop - start) / (this._domain.length - 1 + _padding);
		this._range = this.steps(start + step * _padding / 2, step);
		this._rangeBand = 0.0;
		this.ranger = new com_ibm_rave_core_internal_scales_Ranger("rangePoints", interval, _padding, 0);
		return this;
	},

	/**
	 * Like rangePoints, except guarantees that the range values are integers so as to avoid antialiasing artifacts.
	 * @param (Array) interval   2 element array containing minimum and maximum numeric values.
	 * @param (Number) padding Offset from the edge of the interval, as a multiple of the distance between points.
	 * @return (com.ibm.rave.core.scales.OrdinalScale) the scale
	 */
	/** @expose */ 
	rangeRoundPoints : function(interval, padding) {
		var _padding = padding;
		if (_padding == null) {
			_padding = 0.0;
		}
		var start = + (interval[0]);
		var stop = + (interval[1]);
		var step;
		if (this._domain.length < 2) {
			start = Math.round((start + stop) / 2);
			stop = start;
			step = start;
		} else {
			step = ~~((stop - start) / (this._domain.length - 1 + _padding));
		}
		this._range = this.steps(start + Math.round(step * _padding / 2 + (stop - start - (this._domain.length - 1 + _padding) * step) / 2), step);
		this._rangeBand = 0.0;
		this.ranger = new com_ibm_rave_core_internal_scales_Ranger("rangeRoundPoints", interval, _padding, 0);
		return this;
	},

	/**
	 * Sets the output range values based on the specified continuous interval. The interval is subdivided into <i>n</i> evenly spaced <b>bands</b>, where <i>n</i> is the number of unique values in the input domain. <br/><br/> <pre> Example: {@code var o = d3.scale.ordinal().domain([1, 2, 3, 4]).rangeBands([0, 100]); o.rangeBand(); // returns 25 o.range(); // returns [0, 25, 50, 75] o.rangeExtent(); // returns [0, 100]} </pre>
	 * @param (Array) interval 2 element array containing minimum and maximum numeric values.
	 * @param (Number) padding Offset between bands, as a value in the range [0, 1] which is a multiple of the width of each band. If null, is set to 0.
	 * @param (Number) outerPadding Offset between the entire group of bands and the edge of the interval. A value 0 means there will only be padding between each band. If null, is set to padding.
	 * @return (com.ibm.rave.core.scales.OrdinalScale)  This Scale.
	 */
	/** @expose */ 
	rangeBands : function(interval, padding, outerPadding) {
		var _padding = padding;
		var _outerPadding = outerPadding;
		if (_padding == null) {
			_padding = 0.0;
		}
		if (_outerPadding == null) {
			_outerPadding = _padding;
		}
		var interval0 = + (interval[0]);
		var interval1 = + (interval[1]);
		var reverse = interval1 < interval0;
		var start = reverse ? interval1 : interval0;
		var stop = reverse ? interval0 : interval1;
		var step = (stop - start) / (this._domain.length - _padding + 2 * _outerPadding);
		this._range = this.steps(start + step * _outerPadding, step);
		if (reverse) {
			var temp;
			for (var i = 0; i < this._range.length / 2; ++i) {
				temp = this._range[i];
				var value = this._range[this._range.length - 1 - i];
				this._range[i] = value;
				this._range[this._range.length - 1 - i] = temp;
			}
		}
		this._rangeBand = step * (1 - _padding);
		this.ranger = new com_ibm_rave_core_internal_scales_Ranger("rangeBands", interval, _padding, _outerPadding);
		return this;
	},

	/**
	 * Very similar to  {@link #this.rangeBands(Array, Number, Number)} , but rounds band width and offsets to integer values.
	 * @param (Array) interval 2 element array containing minimum and maximum numeric values.
	 * @param (Number) padding Offset between bands, as a value in the range [0, 1] which is a multiple of the width of each band. If null, is set to 0.
	 * @param (Number) outerPadding Offset between the entire group of bands and the edge of the interval. A value 0 means there will only be padding between each band. If null, is set to padding.
	 * @return (com.ibm.rave.core.scales.OrdinalScale)  This Scale.
	 */
	/** @expose */ 
	rangeRoundBands : function(interval, padding, outerPadding) {
		var _padding = padding;
		var _outerPadding = outerPadding;
		if (_padding == null) {
			_padding = 0.0;
		}
		if (_outerPadding == null) {
			_outerPadding = _padding;
		}
		var interval0 = + (interval[0]);
		var interval1 = + (interval[1]);
		var reverse = interval1 < interval0;
		var start = reverse ? interval1 : interval0;
		var stop = reverse ? interval0 : interval1;
		var step = Math.floor((stop - start) / (this._domain.length - _padding + 2 * _outerPadding));
		this._range = this.steps(start + Math.round((stop - start - (this._domain.length - _padding) * step) / 2), step);
		if (reverse) {
			var temp;
			for (var i = 0; i < this._range.length / 2; ++i) {
				temp = this._range[i];
				var value = this._range[this._range.length - 1 - i];
				this._range[i] = value;
				this._range[this._range.length - 1 - i] = temp;
			}
		}
		this._rangeBand = Math.round(step * (1 - _padding));
		this.ranger = new com_ibm_rave_core_internal_scales_Ranger("rangeRoundBands", interval, _padding, _outerPadding);
		return this;
	},

	/**
	 * Calculate discrete range values (steps) for each ordinal domain value.
	 * @param (double) start The starting range value, e.g. left-most pixel position.
	 * @param (double) step The distance between each range value, e.g. pixel distance.
	 * @return (Array)  Array of range values.
	 */
	steps : function(start, step) {
		var rangeSteps = new Array(this._domain.length);
		for (var i = 0; i < this._domain.length; ++i) {
			rangeSteps[i] = start + step * i;
		}
		return rangeSteps;
	},

	/**
	 * Transform a range value by the current view transform. If the range value is not numeric, it is returned unchanged.
	 * @param (Object) r Ordinal range value.
	 * @return (Object) Range value transformed to current view space.
	 */
	transformRangeValue : function(r) {
		if (com_ibm_rave_core_internal_nativeImpl_Lang.isNumber(r) && this.zoomTransformIsModified()) {
			return (+ (r) * this._viewZoom) + this._viewOffset;
		}
		return r;
	},

	/**
	 * Returns true if the zoom scale or offset is not the identity transform (1x zoom, 0 offset), false otherwise.
	 */
	zoomTransformIsModified : function() {
		return this._viewOffset != 0.0 || this._viewZoom != 1.0;
	},

	/** @expose */ 
	domain : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.domain$1();
		}
		return this.domain$0(a0);
	},

	/** @expose */ 
	range : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.range$1();
		}
		return this.range$0(a0);
	}
});

/** @expose */ 
com_ibm_rave_core_scales_OrdinalScale.DEFAULT_RANGER = new com_ibm_rave_core_internal_scales_Ranger("range", [], 0, 0);

// $source: com/ibm/rave/core/scales/QuantizeScale
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/scales/AbstractScale (loadtime) // superclass
/**
 * Quantize scales are a variant of linear scales with a discrete rather than continuous range. The input domain is still continuous, and divided into uniform segments based on the number of values in (the cardinality of) the output range. The mapping is linear in that the output range value y can be expressed as a linear function of the input domain value x: y = mx + b. The input domain is typically a dimension of the data that you want to visualize, such as the height of students (measured in meters) in a sample population. The output range is typically a dimension of the desired output visualization, such as the height of bars (measured in pixels) in a histogram.
 */
var com_ibm_rave_core_scales_QuantizeScale = rave_externs["QuantizeScale"] = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_scales_AbstractScale, {

	//_range : null,

	kx : 0,

	i : 0,

	x0 : 0,

	x1 : 0,

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * Given a value data in the input domain, returns the corresponding value in the output range
		 * @param (Object) this the context in which this method is invoked
		 * @param (Object) data a data value, may be <code>null</code>
		 * @param (int) index the index of the current scene node
		 * @param (int) groupIndex the group index of the current scene node
		 * @return (Object)  the value in the output range for a given data
		 */
		function(data, index, groupIndex) {
			if (data===undefined || isNaN(data)) {
				return undefined;
			}
			var x = + (data);
			return _$self._range[~~Math.max(0.0, Math.min(_$self.i, Math.floor(_$self.kx * (x - _$self.x0))))];
		};
		return _$self;
	},

	/**
	 * Maintains kx and i up to date, after domain or range is set.
	 * @return (com.ibm.rave.core.scales.QuantizeScale)  this scale
	 */
	rescale : function() {
		this.kx = this._range.length / (this.x1 - this.x0);
		this.i = this._range.length - 1;
		return this;
	},

	/**
	 * Set the scale's input domain
	 * @param (Array) values  of domain values
	 * @return (com.ibm.rave.core.scales.AbstractScale)  this scale
	 */
	domain$0 : function(values) {
		this.x0 = + (values[0]);
		this.x1 = + (values[values.length - 1]);
		return this.rescale();
	},

	/**
	 * Get the scale's domain.
	 * @return (Array)  Array of domain values
	 */
	domain$1 : function() {
		var temp = [];
		temp.push(this.x0);
		temp.push(this.x1);
		return temp;
	},

	/**
	 * Get the scale's range.
	 * @return (Array)  Array of range values.
	 */
	range$1 : function() {
		return this._range;
	},

	/**
	 * Set the scale's output range.
	 * @param (Array) values  List of scale output range
	 * @return (com.ibm.rave.core.scales.AbstractScale)  this scale
	 */
	range$0 : function(values) {
		this._range = values;
		return this.rescale();
	},

	/**
	 * Returns an exact copy of this scale. Changes to this scale will not affect the returned scale, and vice versa.
	 * @return (com.ibm.rave.core.scales.AbstractScale)  a defensive copy of this scale
	 */
	/** @expose */ 
	copy : function() {
		var scale = new com_ibm_rave_core_scales_QuantizeScale();
		scale.range(this._range);
		var tempList = [];
		tempList.push(this.x0);
		tempList.push(this.x1);
		scale.domain(tempList);
		return scale;
	},

	/**
	 * Returns the extent of values in the input domain [x0, x1] for the corresponding value in the output range y, representing the inverse mapping from range to domain. This method is useful for interaction, say to determine the value in the input domain that corresponds to the pixel location under the mouse.
	 * @param (Object) givenRange  the range to which the method returns the corresponding input domain 
	 * @return (Array)  values in the input domain [x0,x1]
	 */
	/** @expose */ 
	invertExtent : function(givenRange) {
		var _givenRange = this._range.indexOf(givenRange);
		var idx = + (_givenRange);
		idx = idx < 0 ? NaN : idx / this.kx + this.x0;
		var tempList = [];
		tempList.push(idx);
		tempList.push(idx + 1 / this.kx);
		return tempList;
	},

	/** @expose */ 
	domain : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.domain$1();
		}
		return this.domain$0(a0);
	},

	/** @expose */ 
	range : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.range$1();
		}
		return this.range$0(a0);
	}
});


// $source: com/ibm/rave/core/scales/QuantileScale
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/scales/AbstractScale (loadtime) // superclass
//@import com/ibm/rave/core/arrays/Quantile (runtime) // quantile
//@import com/ibm/rave/core/Rave (runtime) // Rave
/**
 * Quantile scales map an input domain to a discrete range. Although the  input domain is continuous and the scale will accept any reasonable input  value, the input domain is specified as a discrete set of values. The number  of values in (the cardinality of) the output range determines the number of  quantiles that will be computed from the input domain. To compute the quantiles,  the input domain is sorted, and treated as a population of discrete values. The  input domain is typically a dimension of the data that you want to visualize, such  as the daily change of the stock market. The output range is typically a dimension of the  desired output visualization, such as a diverging color scale.
 */
var com_ibm_rave_core_scales_QuantileScale = rave_externs["QuantileScale"] = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_scales_AbstractScale, {

	//thresholds : null,

	//_domain : null,

	//_range : null,

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * Given a value x in the input domain, returns the corresponding value in the output range.
		 * @param (Object) this the context in which this method is invoked
		 * @param (Object) data a data value, may be <code>null</code>
		 * @param (int) index the index of the current scene node
		 * @param (int) groupIndex the group index of the current scene node
		 * @return (Object)  the value in the range mapping to the value provided in the domain
		 */
		function(data, index, groupIndex) {
			if (!(isNaN(data))) {
				return _$self.range()[com_ibm_rave_core_Rave.bisect(_$self.thresholds, data)];
			}
			return undefined;
		};
		return _$self;
	},

	constructor : function(domain, range) {
		this.thresholds = [];
		this._domain = [];
		this._range = [];
				/**
		 * Create a new  {@link (com.ibm.rave.core.scales.QuantileScale) QuantileScale}  with the provided domain and range
		 * @param (Array) domain
		 * @param (Array) range
		 */
		{
			this.domain(domain);
			this.range(range);
		}
	},

	/**
	 * Iterate using range size and override thresholds values with the result of  p-quantile of the domain using p = i/rangeSize
	 * @return (com.ibm.rave.core.scales.QuantileScale)  this
	 */
	rescale : function() {
		var i = 0;
		var rangeSize = this.range().length;
		this.thresholds = [];
		while (++i < rangeSize) {
			this.thresholds.splice(i - 1, 0, com_ibm_rave_core_arrays_Quantile.quantile(this._domain, + (i) / + (rangeSize)));
		}
		return this;
	},

	/**
	 * Sets the scales input domain
	 * @param (Array) values  the list of values for the input domain
	 * @return (com.ibm.rave.core.scales.AbstractScale)  this
	 */
	domain$0 : function(values) {
		var rave_number = function(currentValue, index, array) {
			return currentValue == null ? NaN : + (currentValue);
		};
		var rave_numeric = function(currentValue, index, array) {
			return !(isNaN(currentValue));
		};
		var ascending = function(obj1, obj2) {
			return ~~(obj1 < obj2 ? -1 : obj1 > obj2 ? 1 : obj1 >= obj2 ? 0 : NaN);
		};
		this._domain = values.map(rave_number).filter(rave_numeric).sort(ascending);
		return this.rescale();
	},

	/**
	 * Set the scale's output range.
	 * @param (Array) values  List of range values
	 * @return (com.ibm.rave.core.scales.AbstractScale)  this
	 */
	range$0 : function(values) {
		this._range = values;
		return this.rescale();
	},

	/**
	 * Get the scale's domain
	 * @return (Array)  List of domain values
	 */
	domain$1 : function() {
		return this._domain;
	},

	/**
	 * Get the scale's range
	 * @return (Array)  List of range values
	 */
	range$1 : function() {
		return this._range;
	},

	/**
	 * Returns the quantile thresholds. If the output range contains n discrete  values, the returned threshold array will contain n - 1 values. Values  less than the first element in the thresholds array, quantiles()[0], are  considered in the first quantile; greater values less than the second  threshold are in the second quantile, and so on. Internally, the thresholds  array is used with d3.bisect to find the output quantile associated with  the given input value.
	 * @return (Array)  The quantile thresholds
	 */
	/** @expose */ 
	quantiles : function() {
		return this.thresholds;
	},

	/**
	 * Returns an exact copy of this scale. Changes to this scale will not affect  the returned scale, and vice versa
	 * @return (com.ibm.rave.core.scales.AbstractScale)  defensive copy of this scale
	 */
	/** @expose */ 
	copy : function() {
		return new com_ibm_rave_core_scales_QuantileScale(this._domain, this._range);
	},

	/**
	 * Returns the extent of values in the input domain [x0, x1] for the  corresponding value in the output range y, representing the inverse  mapping from range to domain. This method is useful for interaction,  say to determine the value in the input domain that corresponds to the  pixel location under the mouse.
	 * @param (Object) y  the value in output range
	 * @return (Array)  the extent of values in the input domain corresponding to the provided output range y
	 */
	/** @expose */ 
	invertExtent : function(y) {
		var index = this._range.indexOf(y);
		var temp = [];
		if (index < 0) {
			temp.push(NaN);
			temp.push(NaN);
			return temp;
		} else {
			temp.push(index > 0 ? this.thresholds[index - 1] : this._domain[0]);
			temp.push(index < this.thresholds.length ? this.thresholds[index] : this._domain[this._domain.length - 1]);
			return temp;
		}
	},

	/** @expose */ 
	domain : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.domain$1();
		}
		return this.domain$0(a0);
	},

	/** @expose */ 
	range : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.range$1();
		}
		return this.range$0(a0);
	}
});


// $source: com/ibm/rave/core/scales/LogScale
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/scales/AbstractScale (loadtime) // scaleExtent, superclass
//@import com/ibm/rave/core/locale/NumberFormat (runtime) // new
//@import com/ibm/rave/core/locale/Locale (runtime) // Locale
//@import com/ibm/rave/core/internal/scales/Nice (runtime) // scaleNice
//@import com/ibm/rave/core/internal/scales/NiceIdentity (static) // new
/**
 * Log scales are similar to Linear scales, but have a logarithmic transform applied to the input value. The log scale domain must be either exclusively positive or exclusively negative; behaviour is undefined when a negative value is applied to a log scale with a positive domain, and vice-versa.
 */
var com_ibm_rave_core_scales_LogScale = rave_externs["LogScale"] = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_scales_AbstractScale, {

	//_linear : null,

	//_base : null,

	//_positive : null,

	//_domain : null,

	_$functionClassMethod : function() {
		var _$self = function(data, index, groupIndex) {
			return _$self._linear.call(this, _$self.log(+ (data)), index, groupIndex);
		};
		return _$self;
	},

	/** @expose */ 
	constructor : function(linear, base, positive, domain) {
		this._linear = linear;
		this._base = base;
		this._positive = positive;
		this._domain = domain;
		if (!com_ibm_rave_core_scales_LogScale.logFormat) {
			{
				if (!com_ibm_rave_core_scales_LogScale.logFormat) {
					com_ibm_rave_core_scales_LogScale.logFormat = new com_ibm_rave_core_locale_NumberFormat(com_ibm_rave_core_locale_Locale.DEFAULT_LOCALE)(".0e");
				}
			}
		}
		var self = this;
		this.ticks = function(tickArguments) {
			if (tickArguments !== null || arguments.length > 1){
				tickArguments = Array.prototype.slice.call(arguments);
			}
			{
				return self.logTicks.apply(self, tickArguments);
			}
		};
		this.tickFormat = function(tickArguments) {
			if (tickArguments !== null || arguments.length > 1){
				tickArguments = Array.prototype.slice.call(arguments);
			}
			{
				var count = tickArguments.length > 0 ? + (tickArguments[0]) : null;
				var format = tickArguments.length > 1 ? tickArguments[1] : null;
				return self.logTickFormat(count, format);
			}
		};
		this.invert = function(y) {
			return self.pow(+ (self._linear.invert(y)));
		};
	},

	domain$0 : function(values) {
		this._positive = + (values[0]) >= 0;
		this._domain = new Array(values.length);
		for (var i = 0; i < values.length; ++i) {
			this._domain[i] = + (values[i]);
		}
		var self = this;
		this._linear.domain$0(this._domain.map(function(currentValue, index, array) {
			return self.log(+ (currentValue));
		}));
		return this;
	},

	domain$1 : function() {
		return this._domain;
	},

	range$0 : function(values) {
		this._linear.range$0(values);
		return this;
	},

	range$1 : function() {
		return this._linear.range$1();
	},

	/** @expose */ 
	copy : function() {
		return new com_ibm_rave_core_scales_LogScale(this._linear.copy(), this._base, this._positive, this._domain);
	},

	/**
	 * Enable or disable clamping. With clamping enable for a quantitative scale, any scale input value outside the specified domain will produce a value that is clamped to the end of the specified range.
	 * @param (boolean) c True or False to Enable or Disable (respectively) clamping.
	 * @return (com.ibm.rave.core.scales.LogScale)  This scale.
	 */
	clamp$0 : function(c) {
		this._linear.clamp$0(c);
		return this;
	},

	/**
	 * Returns true if clamping is enabled, false otherwise.
	 * @return (boolean)  Clamp state.
	 */
	clamp$1 : function() {
		return this._linear.clamp$1();
	},

	/**
	 * Convenience method that will round the scale output values to whole numbers.
	 * @param (Array) x Output range values.
	 * @return (com.ibm.rave.core.scales.LogScale)  This scale.
	 */
	/** @expose */ 
	rangeRound : function(x) {
		this._linear.rangeRound(x);
		return this;
	},

	/**
	 * Set the interpolator.
	 * @param (com.ibm.rave.core.interpolate.InterpolatorFactory) interpolate The interpolator factory to assign to this scale
	 * @return (com.ibm.rave.core.scales.LogScale)  This scale.
	 */
	interpolate$0 : function(interpolate) {
		this._linear.interpolate$0(interpolate);
		return this;
	},

	/**
	 * @return (Object)  The interpolator assigned to this scale.
	 */
	interpolate$1 : function() {
		return this._linear.interpolate$1();
	},

	/**
	 * Extends the domain start and end values to "nice" round values. These "nice" values are primarily determined by the base power, which defaults to 10. For example, given a domain [0.20147..., 0.99667...], the "niced" domain would be [0.1, 1].
	 * @return (com.ibm.rave.core.scales.LogScale)  This scale.
	 */
	/** @expose */ 
	nice : function() {
		var self = this;
		var niced = com_ibm_rave_core_internal_scales_Nice.scaleNice(this._domain.map(function(currentValue, index, array) {
			return self.log(+ (currentValue));
		}), this._positive ? com_ibm_rave_core_scales_LogScale.logNice : com_ibm_rave_core_scales_LogScale.logNiceNegative);
		this._linear.domain(niced);
		this._domain = niced.map(function(currentValue, index, array) {
			return self.pow(+ (currentValue));
		});
		return this;
	},

	/**
	 * Set the log base value.
	 * @param (Number) b New base value.
	 * @return (com.ibm.rave.core.scales.LogScale)  This LogScale.
	 */
	base$0 : function(b) {
		this._base = b;
		return this;
	},

	/**
	 * Get the current log base value.
	 */
	base$1 : function() {
		return this._base;
	},

	log : function(x) {
		return (this._positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(this._base);
	},

	pow : function(x) {
		return this._positive ? Math.pow(this._base, x) : -Math.pow(this._base, -x);
	},

	/**
	 * Implementation of the LogScale#ticks method from D3.
	 * @param (java.lang.Object[]) tickArguments Arguments passed to the scale from Axis (in the case of log scales, no arguments are required).
	 * @return (Array)  Array of tick values.
	 */
	logTicks : function(tickArguments) {
		if (tickArguments !== null || arguments.length > 1){
			tickArguments = Array.prototype.slice.call(arguments);
		}
		{
			var extent = com_ibm_rave_core_scales_AbstractScale.scaleExtent(this._domain);
			var ticks = [];
			var u = + (extent[0]);
			var v = + (extent[1]);
			var i = Math.floor(this.log(u));
			var j = Math.ceil(this.log(v));
			var n = this._base % 1 == 0 ? this._base : 2;
			var delta = j - i;
			if (isFinite(delta)) {
				if (this._positive) {
					for (; i < j; ++i) {
						for (var k = 1.0; k < n; ++k) {
							ticks.push(this.pow(i) * k);
						}
					}
					ticks.push(this.pow(i));
				} else {
					ticks.push(this.pow(i));
					for (; i++ < j;) {
						for (var k = n - 1; k > 0; --k) {
							ticks.push(this.pow(i) * k);
						}
					}
				}
				for (i = 0.0; ticks[~~i] < u; ++i) {
				}
				for (j = (ticks.length); ticks[~~j - 1] > v; --j) {
				}
				ticks = ticks.slice(~~i, ~~j);
			}
			return (ticks);
		}
	},

	/**
	 * Implementation of the LogScale#tickFormat method from D3.
	 * @param (Number) count Number of ticks that should be displayed. Optional.
	 * @param (Object) formatter A String format specifier, or a function ( {@link  NumberFormatValueFunction} ) which will override the default format function.
	 * @return (com.ibm.rave.core.selector.ValueFunction)  A number formatter function.
	 */
	logTickFormat : function(count, formatter) {
		if (count == null && formatter == null) {
			return com_ibm_rave_core_scales_LogScale.logFormat;
		}
		var format;
		if (formatter == null) {
			format = com_ibm_rave_core_scales_LogScale.logFormat;
		} else if (typeof formatter === "function") {
			format = formatter;
		} else {
			format = new com_ibm_rave_core_locale_NumberFormat(com_ibm_rave_core_locale_Locale.DEFAULT_LOCALE)(""+(formatter));
		}
		var n = + (count);
		var k = Math.max(0.1, n / this.ticks().length);
		var e = this._positive ? 1e-12 : -1e-12;
		var f = this._positive ? com_ibm_rave_core_scales_LogScale.ceilRoundFunc : com_ibm_rave_core_scales_LogScale.floorRoundFunc;
		var self = this;
		return function(data, index, groupIndex) {
			var value = + (data);
			return value / self.pow(f(self.log(value) + e)) <= k ? format.call(this, value, index, groupIndex) : "";
		};
	},

	/** @expose */ 
	domain : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.domain$1();
		}
		return this.domain$0(a0);
	},

	/** @expose */ 
	range : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.range$1();
		}
		return this.range$0(a0);
	},

	/** @expose */ 
	clamp : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.clamp$1();
		}
		return this.clamp$0(a0);
	},

	/** @expose */ 
	interpolate : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.interpolate$1();
		}
		return this.interpolate$0(a0);
	},

	/** @expose */ 
	base : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.base$1();
		}
		return this.base$0(a0);
	}
});

/** @expose */ 
com_ibm_rave_core_scales_LogScale.DEFAULT_BASE = 10.0;
//com_ibm_rave_core_scales_LogScale.logFormat = null;
com_ibm_rave_core_scales_LogScale.logNice = new com_ibm_rave_core_internal_scales_NiceIdentity(function(x) {
	return Math.floor(x);
}, function(x) {
	return Math.ceil(x);
});
com_ibm_rave_core_scales_LogScale.logNiceNegative = new com_ibm_rave_core_internal_scales_NiceIdentity(function(x) {
	return -Math.ceil(-x);
}, function(x) {
	return -Math.floor(-x);
});
com_ibm_rave_core_scales_LogScale.ceilRoundFunc = function(v) {
	return Math.ceil(v);
};
com_ibm_rave_core_scales_LogScale.floorRoundFunc = function(v) {
	return Math.floor(v);
};

// $source: com/ibm/rave/core/locale/LocaleFormatter
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/locale/NumberFormat (runtime) // new
//@import com/ibm/rave/core/locale/TimeFormat (runtime) // new
//@import com/ibm/rave/core/globalization/BidiStringFormat (runtime) // new
var com_ibm_rave_core_locale_LocaleFormatter = rave_externs["LocaleFormatter"] = com_ibm_rave_core_nativeImpl_Declare({

	/** @expose */ 
	numberFormat : null,

	/** @expose */ 
	timeFormat : null,

	/** @expose */ 
	bidiStringFormat : null,

	/**
	 * C'tor that sets the numberformat variable
	 * @param (com.ibm.rave.core.locale.LocaleObject) locale the locale that is meant to be used while formatting numbers
	 */
	/** @expose */ 
	constructor : function(locale) {
		this.numberFormat = new com_ibm_rave_core_locale_NumberFormat(locale);
		this.timeFormat = new com_ibm_rave_core_locale_TimeFormat(locale);
		this.bidiStringFormat = new com_ibm_rave_core_globalization_BidiStringFormat(locale);
	}
});


// $source: com/ibm/rave/core/locale/TimeFormatSpecifier
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare, bind
/**
 * An abstract class which is extended by TimeFormat
 */
var com_ibm_rave_core_locale_TimeFormatSpecifier = rave_externs["TimeFormatSpecifier"] = com_ibm_rave_core_nativeImpl_Declare({

	/**
	 * Returns a new multi-resolution time format given the specified array of predicated formats. Each format is a two-element array consisting of a format specifier string (such as that passed to the rave.time.format constructor) and a predicate function. For any date that is passed to the returned time format, the first predicate function that returns true will determine how the specified date is formatted. For example, the default time format used by rave.time.scale is implemented as: var format = rave.time.format.multi([  [".%L", function(d) { return d.getMilliseconds(); }],  [":%S", function(d) { return d.getSeconds(); }], ["%I:%M", function(d) { return d.getMinutes(); }],  ["%I %p", function(d) { return d.getHours(); }],  ["%a %d", function(d) { return d.getDay() && d.getDate() != 1; }],  ["%b %d", function(d) { return d.getDate() != 1;}],  ["%B", function(d) { return d.getMonth(); }],  ["%Y", function() {return true; }]  ]); Thus, if the specified date is not a round second, the milliseconds format (".%L") is used; otherwise, if the specified date is not a round minute, the seconds format (":%S") is used, and so on The multi method is available on any rave.time.format constructor. For example, rave.time.format.utc.multi returns a multi-resolution UTC time format, and locale.timeFormat.multi returns a multi-resolution time format for the specified locale.
	 * @param (java.lang.Object[][]) formats a 2D array containing the string format as well as a predicate ValueFunction.
	 * @return (com.ibm.rave.core.selector.ValueFunction)  a new multi-resolution time format
	 */
	/** @expose */ 
	multi : com_ibm_rave_core_nativeImpl_Declare.bind(function(formats) {
		var n = formats.length;
		var i = -1;
		while (++i < n) {
			formats[i][0] = this(formats[i][0].toString());
		}
		return function(data, index, groupIndex) {
			var z = 0;
			var f = formats[z];
			var formatter = f[1];
			while (!((formatter.call(null, data, 0, 0)))) {
				f = formats[++z];
				formatter = f[1];
			}
			var firstFormatter = f[0];
			return ""+(firstFormatter.call(null, data, 0, 0));
		};
	})
});


// $source: com/ibm/rave/core/time/FormatISO
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/time/Time (runtime) // getInstance
/**
 * The full ISO 8601 UTC time format: "%Y-%m-%dT%H:%M:%S.%LZ". Where available,  this method will use Date.toISOString to format and the Date constructor  to parse strings. If you depend on strict validation of the input format according  to ISO 8601, you should construct a time format explicitly instead: iso = rave.time.format.utc("%Y-%m-%dT%H:%M:%S.%LZ");
 */
var com_ibm_rave_core_time_FormatISO = rave_externs["FormatISO"] = com_ibm_rave_core_nativeImpl_Declare({

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * Gets the result of toISOString
		 * @param (Object) date the date object to call toISOString()
		 * @return (String)  the result of toISOString()
		 */
		function(date, index, groupIndex) {
			return (date).toISOString();
		};
		return _$self;
	},

	/**
	 * @return (String)  the value of toString
	 */
	/** @expose */ 
	toString : function() {
		return com_ibm_rave_core_time_Time.getInstance().format("%Y-%m-%dT%H:%M:%S.%LZ").toString();
	},

	/**
	 * Will return an ISO formatted date. If the String passed in was incorrect, this method will return null
	 * @param (String) str the iso date to be parsed
	 * @return (com.ibm.rave.core.time.IDate)  An iso formatted date in the case that the string passed in was correct. Otherwise, returns null
	 */
	/** @expose */ 
	parse : function(str) {
		if (str == null) {
			return null;
		}
		var date = new Date(str);
		return isNaN(date) ? null : date;
	}
});


// $source: com/ibm/rave/core/time/Time
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare anonymous, declare
//@import com/ibm/rave/core/time/DateTimeScale (runtime) // new, DateTimeScale
//@import com/ibm/rave/core/locale/TimeFormat (runtime) // new
//@import com/ibm/rave/core/locale/Locale (runtime) // Locale
//@import com/ibm/rave/core/time/Day (runtime) // Day
//@import com/ibm/rave/core/time/Hour (runtime) // Hour
//@import com/ibm/rave/core/time/Month (runtime) // Month
//@import com/ibm/rave/core/time/Year (runtime) // Year
//@import com/ibm/rave/core/time/Second (runtime) // Second
//@import com/ibm/rave/core/time/Minute (runtime) // Minute
//@import com/ibm/rave/core/time/Millisecond (runtime) // Millisecond
//@import com/ibm/rave/core/time/Week (runtime) // new
//@import com/ibm/rave/core/internal/time/TimeUtil (runtime) // dayOfYear
//@import com/ibm/rave/core/time/TimeIntervalUTC (runtime) // new
/**
 * Time class from which time scales, time formats and time interval functionality may be accessed and used
 */
var com_ibm_rave_core_time_Time = com_ibm_rave_core_nativeImpl_Declare({

	/**
	 * Overrides the TimeScale methods utc() and scale() 
	 */
	/** @expose */ 
	scale : null,

	/**
	 * A helper module for parsing and formatting dates modeled after the  venerable strptime and strftime C-library standards. These functions  are also notably available in Python's time module.
	 */
	/** @expose */ 
	format : null,

	/**
	 * A day interval. Most days are 24 hours long (864e5 milliseconds); however, with Daylight Savings Time, a day may be 23 or 25 hours long.
	 */
	/** @expose */ 
	day : null,

	/**
	 * Hour time interval. 60 minutes long (36e5 milliseconds). Note that advancing time by one hour can return the same hour number, or skip an hour number, due to Daylight Savings Time.
	 */
	/** @expose */ 
	hour : null,

	/**
	 * Months (e.g., February 1, 2012 at 12:00 AM). Ranges between 28 and 31 days.
	 */
	/** @expose */ 
	month : null,

	/**
	 * Years (e.g., January 1, 2012 at 12:00 AM). Normal years are 365 days  long; leap years are 366.
	 */
	/** @expose */ 
	year : null,

	/**
	 * Seconds (e.g., 01:23:45.0000 AM). Always 1,000 milliseconds long.
	 */
	/** @expose */ 
	second : null,

	/**
	 * Minutes (e.g., 01:02:00 AM). Most browsers do not support leap  seconds, so minutes are almost always 60 seconds (6e4 milliseconds) long.
	 */
	/** @expose */ 
	minute : null,

	/**
	 * Milliseconds (e.g., 01:02:00:001)
	 */
	/** @expose */ 
	millisecond : null,

	/**
	 * Alias for rave.time.day.range. Returns the day boundaries (midnight) after  or equal to start and before stop. If step is specified, then every step'th  date will be returned, based on the day of the month. For example, a step of  2 will return the 1st, 3rd, 5th etc. of the month.
	 */
	/** @expose */ 
	days : null,

	/**
	 * Alias for rave.time.year.range. Returns the year boundaries (midnight January  1st) after or equal to start and before stop. If step is specified, then every  step'th year will be returned. For example, a step of 5 will return 2010, 2015,  2020, etc.
	 */
	/** @expose */ 
	years : null,

	/**
	 * Alias for rave.time.month.range. Returns the month boundaries  (e.g., January 01) after or equal to start and before stop. If  step is specified, then every step'th month will be returned, based  on the month of the year. For example, a step of 3 will return January,  April, July, etc.
	 */
	/** @expose */ 
	months : null,

	/**
	 * Alias for rave.time.hour.range. Returns the hour boundaries  (e.g., 01 AM) after or equal to start and before stop. If step is  specified, then every step'th hour will be returned, based on the  hour of the day. For example, a step of 3 will return 9  PM, 12 AM, 3 AM, etc.
	 */
	/** @expose */ 
	hours : null,

	/**
	 * Alias for rave.time.minute.range. Returns the minute boundaries  (e.g., 01:23 AM) after or equal to start and before stop. If step  is specified, then every step'th minute will be returned, based  on the minute of the hour. For example, a step of 15 will return  9:45 PM, 10:00 PM, 10:15 PM, etc.
	 */
	/** @expose */ 
	minutes : null,

	/**
	 * Alias for rave.time.second.range. Returns the second boundaries  (e.g., 01:23:45 AM) after or equal to start and before stop. If  step is specified, then every step'th second will be returned,  based on the second of the minute. For example, a step of  15 will return 9:01:45 PM, 9:02:00 PM, 9:02:15 PM, etc.
	 */
	/** @expose */ 
	seconds : null,

	/**
	 * Sunday-based weeks (e.g., February 5, 2012 at 12:00 AM)
	 */
	/** @expose */ 
	sunday : null,

	/**
	 * Alias for rave.time.sunday. A week is always 7 days, but ranges between 167 and 169  hours depending on Daylight Savings Time.
	 */
	/** @expose */ 
	week : null,

	/**
	 * Monday-based weeks (e.g., February 6, 2012 at 12:00 AM)
	 */
	/** @expose */ 
	monday : null,

	/**
	 * Tuesday-based weeks (e.g., February 7, 2012 at 12:00 AM)
	 */
	/** @expose */ 
	tuesday : null,

	/**
	 * Wednesday-based weeks (e.g., February 8, 2012 at 12:00 AM)
	 */
	/** @expose */ 
	wednesday : null,

	/**
	 * Thursday-based weeks (e.g., February 9, 2012 at 12:00 AM)
	 */
	/** @expose */ 
	thursday : null,

	/**
	 * Friday-based weeks (e.g., February 10, 2012 at 12:00 AM)
	 */
	/** @expose */ 
	friday : null,

	/**
	 * Saturday-based weeks (e.g., February 11, 2012 at 12:00 AM)
	 */
	/** @expose */ 
	saturday : null,

	/**
	 * Aliases for rave.time.<i>interval</i>.range etc. Returns the week boundaries  (midnight Sunday) after or equal to start and before stop. If step is specified,  then every step'th week will be returned, based on the week of the year. For  example, a step of 4 will return January 2, January 30, February 27, etc.
	 */
	/** @expose */ 
	sundays : null,

	/**
	 * Alias for sunday.range
	 */
	/** @expose */ 
	weeks : null,

	/**
	 * Alias for monday.range
	 */
	/** @expose */ 
	mondays : null,

	/**
	 * Alias for tuesday.range
	 */
	/** @expose */ 
	tuesdays : null,

	/**
	 * Alias for wednesday.range
	 */
	/** @expose */ 
	wednesdays : null,

	/**
	 * Alias for thursday.range
	 */
	/** @expose */ 
	thursdays : null,

	/**
	 * Alias for friday.range
	 */
	/** @expose */ 
	fridays : null,

	/**
	 * Alias for saturday.range
	 */
	/** @expose */ 
	saturdays : null,

	/**
	 * Returns the week number for the given date, where weeks start with  the given day. The first day of the year (January 1) is always the  0th week. weekOfYear is an alias for sundayOfYear, which is equivalent  to rave.time.format's %U directive. mondayOfYear is equivalent to  rave.time.format's %W directive. Computes the Sunday-based week number
	 */
	/** @expose */ 
	sundayOfYear : null,

	/**
	 * Alias for sundayOfYear
	 */
	/** @expose */ 
	weekOfYear : null,

	/**
	 * Computes the Monday-based week number
	 */
	/** @expose */ 
	mondayOfYear : null,

	/**
	 * Computes the Tuesday-based week number
	 */
	/** @expose */ 
	tuesdayOfYear : null,

	/**
	 * Computes the Wednesday-based week number
	 */
	/** @expose */ 
	wednesdayOfYear : null,

	/**
	 * Computes the Thursday-based week number
	 */
	/** @expose */ 
	thursdayOfYear : null,

	/**
	 * Computes the Friday-based week number
	 */
	/** @expose */ 
	fridayOfYear : null,

	/**
	 * Computes the Saturday-based week number
	 */
	/** @expose */ 
	saturdayOfYear : null,

	constructor : function() {
		this.scale = new (com_ibm_rave_core_nativeImpl_Declare({

			_$functionClassMethod : function() {
				var _$self = function() {
					return new com_ibm_rave_core_time_DateTimeScale(null, null, null, null, com_ibm_rave_core_time_DateTimeScale.localFormat, com_ibm_rave_core_time_DateTimeScale.localMethods, com_ibm_rave_core_time_DateTimeScale.localMethodsYear);
				};
				return _$self;
			},

			utc : function() {
				return new com_ibm_rave_core_time_DateTimeScale(null, null, null, null, com_ibm_rave_core_time_DateTimeScale.utcFormat, com_ibm_rave_core_time_DateTimeScale.utcMethods, com_ibm_rave_core_time_DateTimeScale.utcMethodsYear);
			}

		}))();
		this.format = new com_ibm_rave_core_locale_TimeFormat(com_ibm_rave_core_locale_Locale.DEFAULT_LOCALE);
		this.day = com_ibm_rave_core_time_Day.INSTANCE;
		this.hour = com_ibm_rave_core_time_Hour.INSTANCE;
		this.month = com_ibm_rave_core_time_Month.INSTANCE;
		this.year = com_ibm_rave_core_time_Year.INSTANCE;
		this.second = com_ibm_rave_core_time_Second.INSTANCE;
		this.minute = com_ibm_rave_core_time_Minute.INSTANCE;
		this.millisecond = com_ibm_rave_core_time_Millisecond.INSTANCE;
		this.days = new com_ibm_rave_core_time_Time.TimeRangeImpl(this.day);
		this.years = new com_ibm_rave_core_time_Time.TimeRangeImpl(this.year);
		this.months = new com_ibm_rave_core_time_Time.TimeRangeImpl(this.month);
		this.hours = new com_ibm_rave_core_time_Time.TimeRangeImpl(this.hour);
		this.minutes = new com_ibm_rave_core_time_Time.TimeRangeImpl(this.minute);
		this.seconds = new com_ibm_rave_core_time_Time.TimeRangeImpl(this.second);
		this.sunday = new com_ibm_rave_core_time_Week(0);
		this.week = this.sunday;
		this.monday = new com_ibm_rave_core_time_Week(1);
		this.tuesday = new com_ibm_rave_core_time_Week(2);
		this.wednesday = new com_ibm_rave_core_time_Week(3);
		this.thursday = new com_ibm_rave_core_time_Week(4);
		this.friday = new com_ibm_rave_core_time_Week(5);
		this.saturday = new com_ibm_rave_core_time_Week(6);
		this.sundays = new com_ibm_rave_core_time_Time.TimeRangeImpl(this.sunday);
		this.weeks = this.sundays;
		this.mondays = new com_ibm_rave_core_time_Time.TimeRangeImpl(this.monday);
		this.tuesdays = new com_ibm_rave_core_time_Time.TimeRangeImpl(this.tuesday);
		this.wednesdays = new com_ibm_rave_core_time_Time.TimeRangeImpl(this.wednesday);
		this.thursdays = new com_ibm_rave_core_time_Time.TimeRangeImpl(this.thursday);
		this.fridays = new com_ibm_rave_core_time_Time.TimeRangeImpl(this.friday);
		this.saturdays = new com_ibm_rave_core_time_Time.TimeRangeImpl(this.saturday);
		this.sundayOfYear = new com_ibm_rave_core_time_Time.WeekOfYear(0);
		this.weekOfYear = this.sundayOfYear;
		this.mondayOfYear = new com_ibm_rave_core_time_Time.WeekOfYear(1);
		this.tuesdayOfYear = new com_ibm_rave_core_time_Time.WeekOfYear(2);
		this.wednesdayOfYear = new com_ibm_rave_core_time_Time.WeekOfYear(3);
		this.thursdayOfYear = new com_ibm_rave_core_time_Time.WeekOfYear(4);
		this.fridayOfYear = new com_ibm_rave_core_time_Time.WeekOfYear(5);
		this.saturdayOfYear = new com_ibm_rave_core_time_Time.WeekOfYear(6);
	},

	/**
	 * Returns the day number for the given date. The first day of the year (January 1) is always the 0th day. Unlike the rave.time.format's %j directive, dayOfYear is 0-based rather than 1-based.
	 * @param (com.ibm.rave.core.time.IDate) date the date to get the day number from 
	 * @return (int)  The day of the year for a given date
	 */
	/** @expose */ 
	dayOfYear : function(date) {
		return com_ibm_rave_core_internal_time_TimeUtil.dayOfYear(date);
	}

	//constructor : function() {}
});

/**
 * Gets or creates and sets a new instance of Time 
 * @return (com.ibm.rave.core.time.Time)  an instance of Time. If no instance exists, a new instance of time will be created, set and returned. 
 */
/** @expose */ 
com_ibm_rave_core_time_Time.getInstance = function() {
	if (!com_ibm_rave_core_time_Time.INSTANCE) {
		{
			if (!com_ibm_rave_core_time_Time.INSTANCE) {
				com_ibm_rave_core_time_Time.INSTANCE = new com_ibm_rave_core_time_Time();
			}
		}
	}
	return com_ibm_rave_core_time_Time.INSTANCE;
};

/**
 * A helper class which overrides interval.range
 */
com_ibm_rave_core_time_Time.TimeRange = rave_externs["TimeRange"] = com_ibm_rave_core_nativeImpl_Declare({

	/** @expose */ 
	interval : null,

	/**
	 * By default utc is null. Only set in TimeRangeImpl
	 */
	/** @expose */ 
	utc : null,

	_$functionClassMethod : function() {
		var _$self = function(start, stop, step) {
			return _$self.interval.range(start, stop, step);
		};
		return _$self;
	},

	/**
	 * C'tor which sets the interval
	 * @param (com.ibm.rave.core.internal.time.ITimeInterval) interval the time interval to be set
	 */
	/** @expose */ 
	constructor : function(interval) {
		this.interval = interval;
	},

	/**
	 * @return (com.ibm.rave.core.internal.time.ITimeInterval)  the interval
	 */
	/** @expose */ 
	getInterval : function() {
		return this.interval;
	},

	/** @expose */ 
	hasRangeMethod : function() {
		return false;
	}
});

com_ibm_rave_core_time_Time.TimeRangeImpl = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_time_Time.TimeRange, {

	/** @expose */ 
	constructor : function(interval) {
		this.utc = new com_ibm_rave_core_time_Time.TimeRangeUTC(interval);
	}
});

com_ibm_rave_core_time_Time.TimeRangeUTC = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_time_Time.TimeRange, {

	/** @expose */ 
	constructor : function(interval) {
		this.interval = new com_ibm_rave_core_time_TimeIntervalUTC(interval);
	}
});

/**
 * Returns the week number for the given date, where weeks start with the given day. The first day of the year (January 1) is always the 0th week. weekOfYear is an alias for sundayOfYear, which is equivalent to time.format's %U directive. mondayOfYear is equivalent to time.format's %W directive.
 */
com_ibm_rave_core_time_Time.WeekOfYear = com_ibm_rave_core_nativeImpl_Declare({

	weekIndex : 0,

	_$functionClassMethod : function() {
		var _$self = function(date) {
			var day = com_ibm_rave_core_time_Time.getInstance().year(date).getDay();
			return Math.floor((com_ibm_rave_core_time_Time.getInstance().dayOfYear(date) + (day + (7 - _$self.weekIndex)) % 7) / 7);
		};
		return _$self;
	},

	constructor : function(index) {
		this.weekIndex = index;
	}
});

//com_ibm_rave_core_time_Time.INSTANCE = null;

// $source: com/ibm/rave/core/time/TimeIntervalUTC
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare, bind
//@import com/ibm/rave/core/time/DateUTC (runtime) // new
/**
 * A UTC version of TimeInterval. Delegates to the passed in interval,  and converts all dates into UTC time before using them.
 */
var com_ibm_rave_core_time_TimeIntervalUTC = rave_externs["TimeIntervalUTC"] = com_ibm_rave_core_nativeImpl_Declare({

	//delegate : null,

	_$functionClassMethod : function() {
		var _$self = function(start) {
			return _$self.floor(start);
		};
		return _$self;
	},

	/**
	 * Constructor which sets interval 
	 * @param (com.ibm.rave.core.time.TimeInterval) interval the time interval to set
	 */
	/** @expose */ 
	constructor : function(interval) {
		this.delegate = interval;
	},

	/** @expose */ 
	hasRangeMethod : function() {
		return true;
	},

	/** @expose */ 
	round : com_ibm_rave_core_nativeImpl_Declare.bind(function(date) {
		return this.delegate.round(new com_ibm_rave_core_time_DateUTC(date.getTime())).getDateObject();
	}),

	/** @expose */ 
	ceil : com_ibm_rave_core_nativeImpl_Declare.bind(function(date) {
		return this.delegate.ceil(new com_ibm_rave_core_time_DateUTC(date.getTime())).getDateObject();
	}),

	/** @expose */ 
	offset : com_ibm_rave_core_nativeImpl_Declare.bind(function(date, k) {
		return this.delegate.offset(new com_ibm_rave_core_time_DateUTC(date.getTime()), k).getDateObject();
	}),

	/** @expose */ 
	range : com_ibm_rave_core_nativeImpl_Declare.bind(function(t0, t1, dt) {
		return this.delegate.range(new com_ibm_rave_core_time_DateUTC(t0.getTime()), new com_ibm_rave_core_time_DateUTC(t1.getTime()), dt);
	}),

	/** @expose */ 
	floor : com_ibm_rave_core_nativeImpl_Declare.bind(function(date) {
		return this.delegate.floor(new com_ibm_rave_core_time_DateUTC(date.getTime())).getDateObject();
	}),

	/** @expose */ 
	step : com_ibm_rave_core_nativeImpl_Declare.bind(function(date, offset) {
		this.delegate.step(new com_ibm_rave_core_time_DateUTC(date.getTime()), offset);
	}),

	/** @expose */ 
	number : com_ibm_rave_core_nativeImpl_Declare.bind(function(date) {
		return this.delegate.number(new com_ibm_rave_core_time_DateUTC(date.getTime()));
	})
});


// $source: com/ibm/rave/core/time/TimeInterval
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare, bind
//@import com/ibm/rave/core/time/TimeIntervalUTC (static) // new
//@import com/ibm/rave/core/time/DateUTC (runtime) // new
/**
 * Base class for functions related to Intervals of time. Returns the specified interval. The following intervals are supported: rave.time.second rave.time.minute rave.time.hour rave.time.day rave.time.week (alias for rave.time.sunday) rave.time.sunday rave.time.monday rave.time.tuesday rave.time.wednesday rave.time.thursday rave.time.friday rave.time.saturday rave.time.month rave.time.year
 */
var com_ibm_rave_core_time_TimeInterval = rave_externs["TimeInterval"] = com_ibm_rave_core_nativeImpl_Declare({

	/**
	 * Returns a corresponding time interval in UTC rather than local time. For example, day.range(start, stop) returns local time days between start and stop, while day.utc.range(start, stop) returns UTC days between start and stop.
	 */
	/** @expose */ 
	utc : null,

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * Alias for interval.floor(date). For example, rave.time.day(new Date()) returns midnight  (12:00 AM) on the current day, in local time.
		 * @param (com.ibm.rave.core.time.IDate) start the start date 
		 * @return (com.ibm.rave.core.time.IDate)  interval.floor(date)
		 */
		function(start) {
			return _$self.floor(start);
		};
		return _$self;
	},

	constructor : function() {
		this.utc = new com_ibm_rave_core_time_TimeIntervalUTC(this);
	},

	/** @expose */ 
	hasRangeMethod : function() {
		return true;
	},

	/**
	 * Rounds up or down the specified date, returning the closest time interval to date.  For example, rave.time.day.round(new Date()) returns midnight (12:00 AM) on the  current day if it is on or before noon, and midnight of the following day if it  is after noon.
	 * @param (com.ibm.rave.core.time.IDate) date the date to round
	 * @return (com.ibm.rave.core.time.IDate)  the closest time interval to date
	 */
	/** @expose */ 
	round : com_ibm_rave_core_nativeImpl_Declare.bind(function(date) {
		var d0 = this(date), d1 = this.offset(d0, 1);
		return date.getTime() - d0.getTime() < d1.getTime() - date.getTime() ? d0 : d1;
	}),

	/**
	 * Rounds up the specified date, returning the earliest time interval after or equal to date.  For example, rave.time.day.ceil(new Date()) returns midnight (12:00 AM) on the following  day, in local time (unless you happen to run this code at exactly midnight, in which case  it returns the current time).
	 * @param (com.ibm.rave.core.time.IDate) date the date to be rounded
	 * @return (com.ibm.rave.core.time.IDate)  the earliest time interval after or equal to date
	 */
	/** @expose */ 
	ceil : com_ibm_rave_core_nativeImpl_Declare.bind(function(date) {
		var localDate = this.createDate(date, date.getTime() - 1);
		localDate = this(localDate);
		this.step(localDate, 1);
		return localDate;
	}),

	/**
	 * Creates a new date equal to date plus step intervals. If step is negative, then the  returned date will be before the specified date; if step is zero, then a copy of the  specified date is returned. This method does not round the specified date to the  interval. For example, if it is currently 5:34 PM, then rave.time.day.offset(new  Date(), 1) returns 5:34 PM tomorrow (even if Daylight Savings Time changes!).
	 * @param (com.ibm.rave.core.time.IDate) date the date to be manipulated
	 * @param (int) k the step interval
	 * @return (com.ibm.rave.core.time.IDate)  a new date equal to the date plus the step interval
	 */
	/** @expose */ 
	offset : com_ibm_rave_core_nativeImpl_Declare.bind(function(date, k) {
		var newDate = this.createDate(date, date.getTime());
		this.step(newDate, k);
		return newDate;
	}),

	/**
	 * Gets every time interval after or equal to start and before stop.  If step is specified, then every step'th interval will be returned,  based on the interval number (such as day of month for rave.time.day).  For example, a step of 2 will return the 1st, 3rd, 5th etc. of the  month with rave.time.day.
	 * @param (com.ibm.rave.core.time.IDate) start the start date
	 * @param (com.ibm.rave.core.time.IDate) stop the end date 
	 * @param (int) step   the step interval 
	 * @return (Array)  every time interval after or equal to the start and before the stop 
	 */
	/** @expose */ 
	range : com_ibm_rave_core_nativeImpl_Declare.bind(function(start, stop, step) {
		var time = this.ceil(start);
		var times = [];
		if (step > 1) {
			while (time.getTime() < stop.getTime()) {
				if (!((this.number(time) % step))) {
					times.push(new Date(time.getTime()));
				}
				this.step(time, 1);
			}
		} else {
			while (time.getTime() < stop.getTime()) {
				times.push(new Date(time.getTime()));
				this.step(time, 1);
			}
		}
		return times;
	}),

	/**
	 * Rounds down the specified date, returning the latest time interval before or equal to date. For example, rave.time.day.floor(new Date()) returns midnight (12:00 AM) on the current day, in local time.
	 */
	/** @expose */ 
	floor : function(date) {},

	/** @expose */ 
	step : function(date, offset) {},

	/** @expose */ 
	number : function(date) {},

	/**
	 * Create a new date object based on the passed in date's type, setting the new date to 'time'. This is a bit of hack to mimic d3 - it temporarily reassigns d3_date when using UTC dates.
	 * @param (com.ibm.rave.core.time.IDate) date the date to be set on the new Date object
	 * @param (long) time the time to be set on the new Date object
	 * @return (com.ibm.rave.core.time.IDate)  A new  {@link (Date) Date}  object
	 */
	/** @expose */ 
	createDate : function(date, time) {
		var newdate = (com_ibm_rave_core_nativeImpl_Object.isInstanceOf(date, com_ibm_rave_core_time_DateUTC)) ? new com_ibm_rave_core_time_DateUTC(time) : new Date(time);
		return newdate;
	}
});

com_ibm_rave_core_time_TimeInterval.utc_load_flag_unused = new com_ibm_rave_core_time_TimeIntervalUTC(null);

// $source: com/ibm/rave/core/time/Day
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/time/TimeInterval (loadtime) // superclass
//@import com/ibm/rave/core/time/DateUTC (runtime) // new
/**
 * A day interval. Most days are 24 hours long (864e5 milliseconds); however, with Daylight Savings Time, a day may be 23 or 25 hours long.
 */
var com_ibm_rave_core_time_Day = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_time_TimeInterval, {

	/** @expose */ 
	floor : function(date) {
		var day = (com_ibm_rave_core_nativeImpl_Object.isInstanceOf(date, com_ibm_rave_core_time_DateUTC)) ? new com_ibm_rave_core_time_DateUTC(Date.UTC(2000, 0, 1, 0, 0, 0, 0)) : new Date(2000, 0, 1, 0, 0, 0, 0);
		day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
		return day;
	},

	/** @expose */ 
	step : function(date, offset) {
		date.setDate(date.getDate() + offset);
	},

	/** @expose */ 
	number : function(date) {
		return date.getDate() - 1;
	}

	//constructor : function() {}
});

/**
 * Single instance of Day object.
 */
/** @expose */ 
com_ibm_rave_core_time_Day.INSTANCE = new com_ibm_rave_core_time_Day();

// $source: com/ibm/rave/core/time/DateUTC
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
/**
 * A Date class that always returns UTC values. Delegates all non-utc (local) methods to their UTC equivalent.
 */
var com_ibm_rave_core_time_DateUTC = rave_externs["DateUTC"] = com_ibm_rave_core_nativeImpl_Declare({

	//date : null,

	/**
	 * A new UTC date
	 * @param (long) time integer value representing the number of milliseconds since 1 January 1970 00:00:00 UTC
	 */
	/** @expose */ 
	constructor : function(time) {
		this.date = new Date(time);
	},

	/**
	 * Gets the day of the month in local time from 1-31
	 * @return (int)  the day of the month
	 */
	/** @expose */ 
	getDate : function() {
		return this.getUTCDate();
	},

	/**
	 * Gets the day of the week in local time from 0-6
	 * @return (int)  day of the week
	 */
	/** @expose */ 
	getDay : function() {
		return this.getUTCDay();
	},

	/**
	 * Gets the full year in numeric form (ie 1999, 2100)
	 * @return (int)  the full year
	 */
	/** @expose */ 
	getFullYear : function() {
		return this.getUTCFullYear();
	},

	/**
	 * Gets the hour between 0-23 in local time
	 * @return (int)  the hour
	 */
	/** @expose */ 
	getHours : function() {
		return this.getUTCHours();
	},

	/**
	 * Gets the milliseconds in the current minute of a date between 0-999 in local time
	 * @return (int)  the milliseconds
	 */
	/** @expose */ 
	getMilliseconds : function() {
		return this.getUTCMilliseconds();
	},

	/**
	 * Gets the minutes in the current hour of a date between 0-59 in local time
	 * @return (int)  the minutes
	 */
	/** @expose */ 
	getMinutes : function() {
		return this.getUTCMinutes();
	},

	/**
	 * Gets the current month from 0-11 in local time
	 * @return (int)  the current month
	 */
	/** @expose */ 
	getMonth : function() {
		return this.getUTCMonth();
	},

	/**
	 * Gets the number of seconds in the current minute from 0-59 in local time
	 * @return (int)  the number of seconds
	 */
	/** @expose */ 
	getSeconds : function() {
		return this.getUTCSeconds();
	},

	/**
	 * Gets the difference in minutes for the current locale. The offset is  positive for negative time zones. For instance, -5 UTC returns 300.
	 * @return (int)  the difference in minutes for the current locale
	 */
	/** @expose */ 
	getTimezoneOffset : function() {
		return 0;
	},

	/**
	 * Set the day of month using offset from start of the current month. The first  day of the month is '1' and so on. returns new time represented in milliseconds. Offsets are always relative to day 1 of the month. For instance, an offset of 0  means the last day of the previous month. -1 means the day before that, etc. Likewise, offsets greater than the number of days in the current month will  continue into the next month.
	 * @param (int) day the day of the month to set for the UTC Date
	 * @return (long)  number of seconds since 1970/1/1 in UTC time
	 */
	/** @expose */ 
	setDate : function(day) {
		return this.setUTCDate(day);
	},

	/**
	 * Set the full year of the current date
	 * @param (int) year the year of the UTC Date to create
	 * @param (int) month the month of the UTC Date to create 
	 * @param (int) day   the day of the month of the UTC Date to create
	 * @return (long)  the number of seconds since 1970/1/1 in local time
	 */
	/** @expose */ 
	setFullYear : function(year, month, day) {
		return this.setUTCFullYear(year, month, day);
	},

	/**
	 * Set the hours of the current date from 0-23
	 * @param (int) hour the hour of the UTC Date
	 * @param (int) minutes the minutes of the UTC Date
	 * @param (int) seconds the seconds of the UTC Date
	 * @param (int) milliseconds   the milliseconds of the UTC Date
	 * @return (long)  the number of seconds since 1970/1/1 in local time
	 */
	/** @expose */ 
	setHours : function(hour, minutes, seconds, milliseconds) {
		return this.setUTCHours(hour, minutes, seconds, milliseconds);
	},

	/**
	 * Set the milliseconds of the current date from 0-999
	 * @param (int) millis the number of milliseconds of the current date from 0-999
	 * @return (long)  the number of seconds since 1970/1/1 in local time
	 */
	/** @expose */ 
	setMilliseconds : function(millis) {
		return this.setUTCMilliseconds(millis);
	},

	/** @expose */ 
	setMinutes : function(minutes) {
		return this.setUTCMinutes(minutes);
	},

	/** @expose */ 
	setSeconds : function(seconds) {
		return this.setUTCSeconds(seconds);
	},

	/** @expose */ 
	getTime : function() {
		return this.date.getTime();
	},

	/** @expose */ 
	getUTCDate : function() {
		return this.date.getUTCDate();
	},

	/** @expose */ 
	getUTCDay : function() {
		return this.date.getUTCDay();
	},

	/** @expose */ 
	getUTCFullYear : function() {
		return this.date.getUTCFullYear();
	},

	/** @expose */ 
	getUTCHours : function() {
		return this.date.getUTCHours();
	},

	/** @expose */ 
	getUTCMilliseconds : function() {
		return this.date.getUTCMilliseconds();
	},

	/** @expose */ 
	getUTCMinutes : function() {
		return this.date.getUTCMinutes();
	},

	/** @expose */ 
	getUTCMonth : function() {
		return this.date.getUTCMonth();
	},

	/** @expose */ 
	getUTCSeconds : function() {
		return this.date.getUTCSeconds();
	},

	/** @expose */ 
	setMonth : function(month, day) {
		return this.setUTCMonth(month, day);
	},

	/** @expose */ 
	setTime : function(time) {
		return this.date.setTime(time);
	},

	/** @expose */ 
	setUTCDate : function(month) {
		return this.date.setUTCDate(month);
	},

	/** @expose */ 
	setUTCFullYear : function(year, month, day) {
		return this.date.setUTCFullYear(year, month, day);
	},

	/** @expose */ 
	setUTCHours : function(hour, minutes, seconds, milliseconds) {
		return this.date.setUTCHours(hour, minutes, seconds, milliseconds);
	},

	/** @expose */ 
	setUTCMilliseconds : function(millis) {
		return this.date.setUTCMilliseconds(millis);
	},

	/** @expose */ 
	setUTCMinutes : function(minutes) {
		return this.date.setUTCMinutes(minutes);
	},

	/** @expose */ 
	setUTCMonth : function(month, day) {
		return this.date.setUTCMonth(month, day);
	},

	/** @expose */ 
	setUTCSeconds : function(seconds) {
		return this.date.setUTCSeconds(seconds);
	},

	/** @expose */ 
	getDateObject : function() {
		return this.date;
	},

	/** @expose */ 
	toISOString : function() {
		return null;
	}
});


// $source: com/ibm/rave/core/locale/TimeFormat
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare anonymous, declare
//@import com/ibm/rave/core/locale/TimeFormatSpecifier (loadtime) // superclass
//@import com/ibm/rave/core/time/FormatISO (runtime) // new
//@import com/ibm/rave/core/nativeImpl/arrays/ES6Map (runtime) // create
//@import com/ibm/rave/core/time/TimeFormatter (runtime)
//@import com/ibm/rave/core/time/DateUTC (static) // new
//@import com/ibm/rave/core/time/Time (runtime) // getInstance
//@import com/ibm/rave/core/nativeImpl/format/Requote (static) // requote
/**
 * A helper module for parsing and formatting dates modeled after the venerable strptime and strftime C-library standards. These functions are also notably available in Python's time module.
 */
var com_ibm_rave_core_locale_TimeFormat = rave_externs["TimeFormat"] = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_locale_TimeFormatSpecifier, {

	/**
	 * Constructs a new UTC time formatter using the given specifier. (Equivalent to locale.timeFormat.utc for the default U.S. English locale.) The specifier may contain the same directives as the local time format. Internally, this time formatter is implemented using the UTC methods on the Date object, such as getUTCDate and setUTCDate in place of getDate and setDate. Return A formatted UTC time
	 */
	/** @expose */ 
	utc : null,

	/** @expose */ 
	iso : null,

	//timeFormats : null,

	//timeParsers : null,

	//locale : null,

	//time_periodLookup : null,

	//time_numberRe : null,

	//time_percentRe : null,

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * Constructs a new local time formatter using the given specifier. (Equivalent to locale.timeFormat for the default U.S. English locale.) The specifier string may contain the following directives. %a - abbreviated weekday name.  %A - full weekday name.  %b - abbreviated month name.  %B - full month name.  %c - date and time, as "%a %b %e %H:%M:%S %Y".  %d - zero-padded day of the month as a decimal number [01,31].  %e - space-padded day of the month as a decimal number [1,31]; equivalent to %_d.  %H - hour (24-hour clock) as a decimal number [00,23].  %I - hour (12-hour clock) as a decimal number [01,12].  %j - day of the year as a decimal number [001,366].  %m - month as a decimal number [01,12].  %M - minute as a decimal number [00,59]. %L - milliseconds as a decimal number [000, 999].  %p - either AM or PM.  %S - second as a decimal number [00,61].  %U - week number of the year (Sunday as the first day of the week) as a decimal number [00,53].  %w - weekday as a decimal number [0(Sunday),6].  %W - week number of the year (Monday as the first day of the week) as a decimal number [00,53].  %x - date, as "%m/%d/%Y". %X -time, as "%H:%M:%S".  %y - year without century as a decimal number [00,99].  %Y - year with century as a decimal number.  %Z - time zone offset, such as "-0700".  %% - a literal "%" character. For %U, all days in a new year preceding the first  Sunday are considered to be in week 0. For %W, all days in a new year preceding the first Monday are considered to be in week 0. In some implementations of strftime and strptime (as in Python), a directive may include an optional field width or precision; this feature is not yet implemented in Rave, but may be added in the future. For locale-specific date and time formatters, see locale.timeFormat. The % sign indicating a directive may be immediately followed by a padding modifier: 0 - zero-padding _ - space-padding - - disable padding If no padding modifier is specified, the default is 0 for all directives, except for %e which defaults to _).
		 */
		function(template) {
			var n = template.length;
			var self = _$self;
			return new (com_ibm_rave_core_nativeImpl_Declare({

				_$functionClassMethod : function() {
					var _$self = 					/**
					 * Formats the specified date, returning the corresponding string. The date must be a JavaScript Date object. Note that when dates are used in conjunction with quantitative scales, the dates are implicitly coerced to numbers representing the number of milliseconds since UNIX epoch. To convert between numbers and dates, you can use the following code:
					 * @param (Object) date  The Date object to be formatted.
					 * @return (String)  String representing the formatted Date
					 */
					function(date, index, groupIndex) {
						var dateObj = new Date(date);
						var string = [];
						var i = -1;
						var j = 0;
						var c;
						var p;
						var f;
						while (++i < n) {
							if (template.charCodeAt(i) == 37) {
								string.push(template.substring(j, i));
								var stringC = String.fromCharCode(template.charCodeAt(++i));
								p = com_ibm_rave_core_locale_TimeFormat.time_formatPads[c = stringC];
								if (p != null) {
									c = String.fromCharCode(template.charCodeAt(++i));
								}
								f = self.timeFormats[c];
								if (f) {
									c = f(dateObj, p == null ? (c == "e" ? " " : "0") : p);
								}
								string.push(c);
								j = i + 1;
							}
						}
						string.push(template.substring(j, i));
						return string.join("");
					};
					return _$self;
				},

				/**
				 * Overrides the toString method in order to return the template value
				 * @return (String) : the template value
				 */
				toString : function() {
					return template;
				},

				/**
				 * Parses the specified string, returning the corresponding date object. If the parsing fails, returns null. Unlike "natural language" date parsers (including JavaScript's built-in parse), this method is strict: if the specified string does not exactly match the associated format specifier, this method returns null. For example, if the associated format is the full ISO 8601 string "%Y-%m-%dT%H:%M:%SZ", then the string "2011-07-01T19:15:28Z" will be parsed correctly, but "2011-07-01T19:15:28", "2011-07-01 19:15:28" and "2011-07-01" will return null, despite being valid 8601 dates. (Note that the hard-coded "Z" here is different from %Z, the time zone offset.) If desired, you can use multiple formats to try multiple format specifiers sequentially. The %d and %e format specifiers are considered equivalent for parsing.
				 * @param (String) dateString The string to parse
				 * @return (com.ibm.rave.core.time.IDate)  A Date based on the dateString contents. If the parsing fails, null is returned.
				 */
				parse : function(dateString) {
					return com_ibm_rave_core_locale_TimeFormat.parseImpl(self, template, dateString, false);
				}

			}))();
		};
		return _$self;
	},

	constructor : function(locale) {
		this.utc = this.createUTC();
		this.iso = new com_ibm_rave_core_time_FormatISO();
		this.timeFormats = this.buildTimeFormat();
		this.timeParsers = this.buildTimeParser();
		this.time_periodLookup = com_ibm_rave_core_nativeImpl_arrays_ES6Map.create();
		this.time_numberRe = new RegExp("^\\s*\\d+", "");
		this.time_percentRe = new RegExp("^%", "");
				/**
		 * Constructs a new local time formatter using the given locale.
		 * @param (com.ibm.rave.core.locale.LocaleObject) locale  the default is intended for U.S. English, you can change the behavior of the formatters by loading a new locale as needed
		 */
		{
			this.locale = locale;
		}
	},

	/** @expose */ 
	timeParse : function(d, template, str, j) {
		var _j = j;
		var c;
		var p;
		var t;
		var i = 0;
		var n = template.length;
		var m = str.length;
		var pString;
		while (i < n) {
			if (_j >= m) {
				return -1;
			}
			c = template.charCodeAt(i++);
			if (c == 37) {
				var cc = template.charCodeAt(i++);
				t = String.fromCharCode(cc);
				if (com_ibm_rave_core_locale_TimeFormat.time_formatPads.hasOwnProperty(t)) {
					pString = String.fromCharCode(template.charCodeAt(i++));
				} else {
					pString = t;
				}
				p = this.timeParsers[pString];
				_j = p(d, str, _j);
				if (!((pString)) || (_j < 0)) {
					return -1;
				}
			} else if (c != str.charCodeAt(_j++)) {
				return -1;
			}
		}
		return _j;
	},

	setTimePeriodLookup : function() {
		for (var i = 0; i < this.locale.periods.length; ++i) {
			this.time_periodLookup.set(this.locale.periods[i].toLowerCase(), i);
		}
	},

	/**
	 * Build a UTC time format specifier. Delegates to "this" (the local, non-utc, format specifier).
	 * @return (com.ibm.rave.core.locale.TimeFormatSpecifier)  TimeFormatSpecifier which creates UTC time formatter functions.
	 */
	createUTC : function() {
		var self = this;
		return new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_locale_TimeFormatSpecifier], {

			_$functionClassMethod : function() {
				var _$self = function(template) {
					var local = self(template);
					return new (com_ibm_rave_core_nativeImpl_Declare({

						_$functionClassMethod : function() {
							var _$self = function(date, index, groupIndex) {
								return local.call(this, new com_ibm_rave_core_time_DateUTC(new Date(date).getTime()), index, groupIndex);
							};
							return _$self;
						},

						parse : function(dateString) {
							return com_ibm_rave_core_locale_TimeFormat.parseImpl(self, template, dateString, true);
						},

						toString : function() {
							return template;
						}

					}))();
				};
				return _$self;
			}

		}))();
	},

	buildTimeFormat : function() {
		var map = {};
		var self = this;
		map["a"] = new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_locale_TimeFormat.InternalTimeDateFormatter], {

			_$functionClassMethod : function() {
				var _$self = function(date, str) {
					return self.locale.shortDays[date.getDay()];
				};
				return _$self;
			}

		}))();
		map["A"] = new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_locale_TimeFormat.InternalTimeDateFormatter], {

			_$functionClassMethod : function() {
				var _$self = function(date, str) {
					return self.locale.days[date.getDay()];
				};
				return _$self;
			}

		}))();
		map["b"] = new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_locale_TimeFormat.InternalTimeDateFormatter], {

			_$functionClassMethod : function() {
				var _$self = function(date, str) {
					return self.locale.shortMonths[date.getMonth()];
				};
				return _$self;
			}

		}))();
		map["B"] = new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_locale_TimeFormat.InternalTimeDateFormatter], {

			_$functionClassMethod : function() {
				var _$self = function(date, str) {
					return self.locale.months[date.getMonth()];
				};
				return _$self;
			}

		}))();
		map["c"] = new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_locale_TimeFormat.InternalTimeDateFormatter], {

			_$functionClassMethod : function() {
				var _$self = function(date, str) {
					return self(self.locale.dateTime).call(null, date, 0, 0);
				};
				return _$self;
			},

			toString : function() {
				return self(self.locale.dateTime).toString();
			}

		}))();
		map["d"] = new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_locale_TimeFormat.InternalTimeDateFormatter], {

			_$functionClassMethod : function() {
				var _$self = function(date, str) {
					return com_ibm_rave_core_locale_TimeFormat.time_formatPad(date.getDate(), str, 2);
				};
				return _$self;
			}

		}))();
		map["e"] = new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_locale_TimeFormat.InternalTimeDateFormatter], {

			_$functionClassMethod : function() {
				var _$self = function(date, str) {
					return com_ibm_rave_core_locale_TimeFormat.time_formatPad(date.getDate(), str, 2);
				};
				return _$self;
			}

		}))();
		map["H"] = new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_locale_TimeFormat.InternalTimeDateFormatter], {

			_$functionClassMethod : function() {
				var _$self = function(date, str) {
					return com_ibm_rave_core_locale_TimeFormat.time_formatPad(date.getHours(), str, 2);
				};
				return _$self;
			}

		}))();
		map["I"] = new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_locale_TimeFormat.InternalTimeDateFormatter], {

			_$functionClassMethod : function() {
				var _$self = function(date, str) {
					if (date.getHours() % 12 > 0) {
						return com_ibm_rave_core_locale_TimeFormat.time_formatPad(date.getHours() % 12, str, 2);
					}
					return com_ibm_rave_core_locale_TimeFormat.time_formatPad(12, str, 2);
				};
				return _$self;
			}

		}))();
		map["j"] = new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_locale_TimeFormat.InternalTimeDateFormatter], {

			_$functionClassMethod : function() {
				var _$self = function(date, str) {
					return com_ibm_rave_core_locale_TimeFormat.time_formatPad(1 + com_ibm_rave_core_time_Time.getInstance().dayOfYear(date), str, 3);
				};
				return _$self;
			}

		}))();
		map["L"] = new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_locale_TimeFormat.InternalTimeDateFormatter], {

			_$functionClassMethod : function() {
				var _$self = function(date, str) {
					return com_ibm_rave_core_locale_TimeFormat.time_formatPad(date.getMilliseconds(), str, 3);
				};
				return _$self;
			}

		}))();
		map["m"] = new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_locale_TimeFormat.InternalTimeDateFormatter], {

			_$functionClassMethod : function() {
				var _$self = function(date, str) {
					return com_ibm_rave_core_locale_TimeFormat.time_formatPad(date.getMonth() + 1, str, 2);
				};
				return _$self;
			}

		}))();
		map["M"] = new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_locale_TimeFormat.InternalTimeDateFormatter], {

			_$functionClassMethod : function() {
				var _$self = function(date, str) {
					return com_ibm_rave_core_locale_TimeFormat.time_formatPad(date.getMinutes(), str, 2);
				};
				return _$self;
			}

		}))();
		map["p"] = new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_locale_TimeFormat.InternalTimeDateFormatter], {

			_$functionClassMethod : function() {
				var _$self = function(date, str) {
					var isPM = 0;
					if (date.getHours() >= 12) {
						isPM = 1;
					}
					return self.locale.periods[isPM];
				};
				return _$self;
			}

		}))();
		map["S"] = new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_locale_TimeFormat.InternalTimeDateFormatter], {

			_$functionClassMethod : function() {
				var _$self = function(date, str) {
					return com_ibm_rave_core_locale_TimeFormat.time_formatPad(date.getSeconds(), str, 2);
				};
				return _$self;
			}

		}))();
		map["U"] = new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_locale_TimeFormat.InternalTimeDateFormatter], {

			_$functionClassMethod : function() {
				var _$self = function(date, str) {
					return com_ibm_rave_core_locale_TimeFormat.time_formatPad(com_ibm_rave_core_time_Time.getInstance().sundayOfYear(date), str, 2);
				};
				return _$self;
			}

		}))();
		map["w"] = new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_locale_TimeFormat.InternalTimeDateFormatter], {

			_$functionClassMethod : function() {
				var _$self = function(date, str) {
					return ""+(date.getDay());
				};
				return _$self;
			}

		}))();
		map["W"] = new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_locale_TimeFormat.InternalTimeDateFormatter], {

			_$functionClassMethod : function() {
				var _$self = function(date, str) {
					return com_ibm_rave_core_locale_TimeFormat.time_formatPad(com_ibm_rave_core_time_Time.getInstance().mondayOfYear(date), str, 2);
				};
				return _$self;
			}

		}))();
		map["x"] = new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_locale_TimeFormat.InternalTimeDateFormatter], {

			_$functionClassMethod : function() {
				var _$self = function(date, str) {
					return self(self.locale.date).call(null, date, 0, 0);
				};
				return _$self;
			},

			toString : function() {
				return self(self.locale.date).toString();
			}

		}))();
		map["X"] = new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_locale_TimeFormat.InternalTimeDateFormatter], {

			_$functionClassMethod : function() {
				var _$self = function(date, str) {
					return self(self.locale.time).call(null, date, 0, 0);
				};
				return _$self;
			},

			toString : function() {
				return self(self.locale.time).toString();
			}

		}))();
		map["y"] = new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_locale_TimeFormat.InternalTimeDateFormatter], {

			_$functionClassMethod : function() {
				var _$self = function(date, str) {
					return com_ibm_rave_core_locale_TimeFormat.time_formatPad(date.getFullYear() % 100, str, 2);
				};
				return _$self;
			}

		}))();
		map["Y"] = new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_locale_TimeFormat.InternalTimeDateFormatter], {

			_$functionClassMethod : function() {
				var _$self = function(date, str) {
					return com_ibm_rave_core_locale_TimeFormat.time_formatPad(date.getFullYear() % 10000, str, 4);
				};
				return _$self;
			}

		}))();
		map["Z"] = new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_locale_TimeFormat.InternalTimeDateFormatter], {

			_$functionClassMethod : function() {
				var _$self = function(date, str) {
					return com_ibm_rave_core_locale_TimeFormat.time_zone(date);
				};
				return _$self;
			}

		}))();
		map["%"] = new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_locale_TimeFormat.InternalTimeDateFormatter], {

			_$functionClassMethod : function() {
				var _$self = function(date, str) {
					return "%";
				};
				return _$self;
			}

		}))();
		return map;
	},

	/**
	 * Construct time parser map.
	 */
	buildTimeParser : function() {
		var self = this;
		var map = {};
		map["a"] = function(date, str, i) {
			var time_dayAbbrevLookup = com_ibm_rave_core_locale_TimeFormat.time_formatLookup(self.locale.shortDays);
			var time_dayAbbrevRe = com_ibm_rave_core_locale_TimeFormat.time_formatRe(self.locale.shortDays);
			time_dayAbbrevRe["lastIndex"] = 0;
			var n = time_dayAbbrevRe.exec(str.substring(i));
			if (n) {
				date["w"] = time_dayAbbrevLookup.get(n[0].toLowerCase());
				return i + n[0].length;
			}
			return -1;
		};
		map["A"] = function(date, str, i) {
			var time_dayRe = com_ibm_rave_core_locale_TimeFormat.time_formatRe(self.locale.days);
			var time_dayLookup = com_ibm_rave_core_locale_TimeFormat.time_formatLookup(self.locale.days);
			time_dayRe["lastIndex"] = 0;
			var n = time_dayRe.exec(str.substring(i));
			if ((n)) {
				date["w"] = time_dayLookup.get(n[0].toLowerCase());
				return i + n[0].length;
			}
			return -1;
		};
		map["b"] = function(date, str, i) {
			var time_monthAbbrevLookup = com_ibm_rave_core_locale_TimeFormat.time_formatLookup(self.locale.shortMonths);
			var time_monthAbbrevRe = com_ibm_rave_core_locale_TimeFormat.time_formatRe(self.locale.shortMonths);
			time_monthAbbrevRe["lastIndex"] = 0;
			var n = time_monthAbbrevRe.exec(str.substring(i));
			if (n) {
				date["m"] = time_monthAbbrevLookup.get(n[0].toLowerCase());
				return i + n[0].length;
			}
			return -1;
		};
		map["B"] = function(date, str, i) {
			var time_monthLookup = com_ibm_rave_core_locale_TimeFormat.time_formatLookup(self.locale.months);
			var time_monthRe = com_ibm_rave_core_locale_TimeFormat.time_formatRe(self.locale.months);
			time_monthRe["lastIndex"] = 0;
			var n = time_monthRe.exec(str.substring(i));
			if (n) {
				date["m"] = time_monthLookup.get(n[0].toLowerCase());
				return i + n[0].length;
			}
			return -1;
		};
		map["c"] = function(date, str, i) {
			return self.timeParse(date, self.timeFormats["c"].toString(), str, i);
		};
		map["d"] = function(date, str, i) {
			self.time_numberRe["lastIndex"] = 0;
			var n = self.time_numberRe.exec(str.substring(i, i + 2));
			if ((n)) {
				date["d"] = ~~+ (n[0]);
				return i + n[0].length;
			}
			return -1;
		};
		map["e"] = function(date, str, i) {
			self.time_numberRe["lastIndex"] = 0;
			var n = self.time_numberRe.exec(str.substring(i, i + 2));
			if ((n)) {
				date["d"] = ~~+ (n[0]);
				return i + n[0].length;
			}
			return -1;
		};
		map["H"] = function(date, str, i) {
			self.time_numberRe["lastIndex"] = 0;
			var n = self.time_numberRe.exec(str.substring(i, i + 2));
			if ((n)) {
				date["H"] = ~~+ (n[0]);
				return i + n[0].length;
			}
			return -1;
		};
		map["I"] = function(date, str, i) {
			self.time_numberRe["lastIndex"] = 0;
			var n = self.time_numberRe.exec(str.substring(i, i + 2));
			if ((n)) {
				date["H"] = ~~+ (n[0]);
				return i + n[0].length;
			}
			return -1;
		};
		map["j"] = function(date, str, i) {
			self.time_numberRe["lastIndex"] = 0;
			var n = self.time_numberRe.exec(str.substring(i, i + 3));
			if ((n)) {
				date["j"] = ~~+ (n[0]);
				return i + n[0].length;
			}
			return -1;
		};
		map["L"] = function(date, str, i) {
			self.time_numberRe["lastIndex"] = 0;
			var n = self.time_numberRe.exec(str.substring(i, i + 3));
			if ((n)) {
				date["L"] = ~~+ (n[0]);
				return i + n[0].length;
			}
			return -1;
		};
		map["m"] = function(date, str, i) {
			self.time_numberRe["lastIndex"] = 0;
			var n = self.time_numberRe.exec(str.substring(i, i + 2));
			if ((n)) {
				date["m"] = ~~+ (n[0]) - 1;
				return i + n[0].length;
			}
			return -1;
		};
		map["M"] = function(date, str, i) {
			self.time_numberRe["lastIndex"] = 0;
			var n = self.time_numberRe.exec(str.substring(i, i + 2));
			if ((n)) {
				date["M"] = ~~+ (n[0]);
				return i + n[0].length;
			}
			return -1;
		};
		map["p"] = function(date, str, i) {
			var _i = i;
			self.setTimePeriodLookup();
			var n = self.time_periodLookup.get(str.substring(_i, _i += 2).toLowerCase());
			if (n == null) {
				return -1;
			}
			date["p"] = n;
			return _i;
		};
		map["S"] = function(date, str, i) {
			self.time_numberRe["lastIndex"] = 0;
			var n = self.time_numberRe.exec(str.substring(i, i + 2));
			if ((n)) {
				date["S"] = ~~+ (n[0]);
				return i + n[0].length;
			}
			return -1;
		};
		map["U"] = function(date, str, i) {
			self.time_numberRe["lastIndex"] = 0;
			var n = self.time_numberRe.exec(str.substring(i));
			if ((n)) {
				date["U"] = ~~+ (n[0]);
				return i + n[0].length;
			}
			return -1;
		};
		map["w"] = function(date, str, i) {
			self.time_numberRe["lastIndex"] = 0;
			var n = self.time_numberRe.exec(str.substring(i, i + 1));
			if ((n)) {
				date["w"] = ~~+ (n[0]);
				return i + n[0].length;
			}
			return -1;
		};
		map["W"] = function(date, str, i) {
			self.time_numberRe["lastIndex"] = 0;
			var n = self.time_numberRe.exec(str.substring(i));
			if ((n)) {
				date["W"] = ~~+ (n[0]);
				return i + n[0].length;
			}
			return -1;
		};
		map["x"] = function(date, str, i) {
			return self.timeParse(date, self.timeFormats["x"].toString(), str, i);
		};
		map["X"] = function(date, str, i) {
			return self.timeParse(date, self.timeFormats["X"].toString(), str, i);
		};
		map["y"] = function(date, str, i) {
			self.time_numberRe["lastIndex"] = 0;
			var n = self.time_numberRe.exec(str.substring(i, i + 2));
			if ((n)) {
				date["y"] = com_ibm_rave_core_locale_TimeFormat.time_expandYear(~~+ (n[0]));
				return i + n[0].length;
			}
			return -1;
		};
		map["Y"] = function(date, str, i) {
			self.time_numberRe["lastIndex"] = 0;
			var n = self.time_numberRe.exec(str.substring(i, i + 4));
			if ((n)) {
				date["y"] = ~~+ (n[0]);
				return i + n[0].length;
			}
			return -1;
		};
		map["Z"] = function(date, str, i) {
			var _str = str;
			var regExpStr = new RegExp("^[+-]\\d{4}$", "");
			if ((regExpStr.test(_str = _str.substring(i, i + 5)))) {
				date["Z"] = -~~+ (_str);
				return i + 5;
			}
			return -1;
		};
		map["%"] = function(date, str, i) {
			self.time_percentRe["lastIndex"] = 0;
			var n = self.time_percentRe.exec(str.substring(i, i + 1));
			if ((n)) {
				return i + n[0].length;
			}
			return -1;
		};
		return map;
	}
});

com_ibm_rave_core_locale_TimeFormat.parseImpl = function(owner, template, dateString, isUTC) {
	var d = {};
	d["y"] = 1900;
	d["m"] = 0;
	d["d"] = 1;
	d["H"] = 0;
	d["M"] = 0;
	d["S"] = 0;
	d["L"] = 0;
	d["Z"] = null;
	d["w"] = null;
	var i = owner.timeParse(d, template, dateString, 0);
	if (i != dateString.length) {
		return null;
	}
	if (d.hasOwnProperty("p")) {
		var dH = d["H"];
		var dP = d["p"];
		dH = dH % 12 + dP * 12;
		delete d["H"];
		d["H"] = dH;
	}
	var localZ = d["Z"] != null && !isUTC;
	var date;
	if ((localZ)) {
		date = new com_ibm_rave_core_time_DateUTC(0);
	} else {
		if (isUTC) {
			date = new com_ibm_rave_core_time_DateUTC(0);
		} else {
			date = new Date();
		}
	}
	if (d.hasOwnProperty("j")) {
		date.setFullYear(d["y"], 0, d["j"]);
	} else if (d.hasOwnProperty("w") && (d.hasOwnProperty("W") || d.hasOwnProperty("U"))) {
		date.setFullYear(d["y"], 0, 1);
		var day;
		if (d.hasOwnProperty("W")) {
			day = (d["w"] + 6) % 7 + d["W"] * 7 - (date.getDay() + 5) % 7;
		} else {
			day = d["w"] + d["U"] * 7 - (date.getDay() + 6) % 7;
		}
		date.setFullYear(d["y"], 0, day);
	} else {
		date.setFullYear(d["y"], d["m"], d["d"]);
	}
	if (d["Z"] == null) {
		date.setHours(d["H"] + (0 / 100 | 0), d["M"] + 0 % 100, d["S"], d["L"]);
	} else {
		date.setHours(d["H"] + (d["Z"] / 100 | 0), d["M"] + d["Z"] % 100, d["S"], d["L"]);
	}
	if ((localZ)) {
		return new Date(date.getTime());
	}
	if (isUTC) {
		return new Date(date.getTime());
	}
	return date;
};

com_ibm_rave_core_locale_TimeFormat.initialize_time_formatPads = function() {
	var time_formatPads = {};
	time_formatPads["-"] = "";
	time_formatPads["_"] = " ";
	time_formatPads["0"] = "0";
	return time_formatPads;
};

com_ibm_rave_core_locale_TimeFormat.time_formatPad = function(value, fill, width) {
	var sign = value < 0 ? "-" : "", string = (sign != null && !(sign.length === 0) && !(sign == "") ? -value : value) + "";
	var length = string.length;
	return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
};

com_ibm_rave_core_locale_TimeFormat.time_zone = function(date) {
	var z = date.getTimezoneOffset();
	var zs = z > 0 ? "-" : "+";
	var zh = Math.abs(z) / 60 | 0;
	var zm = Math.abs(z) % 60;
	return zs + com_ibm_rave_core_locale_TimeFormat.time_formatPad(zh, "0", 2) + com_ibm_rave_core_locale_TimeFormat.time_formatPad(zm, "0", 2);
};

com_ibm_rave_core_locale_TimeFormat.time_expandYear = function(d) {
	return d + (d > 68 ? 1900 : 2000);
};

com_ibm_rave_core_locale_TimeFormat.time_formatRe = function(names) {
	return new RegExp("^(?:" + com_ibm_rave_core_locale_TimeFormat.map(names) + ")", "i");
};

com_ibm_rave_core_locale_TimeFormat.map = function(names) {
	var maps = [];
	if ((names)) {
		for (var i = 0; i < names.length; ++i) {
			maps.push(com_ibm_rave_core_nativeImpl_format_Requote.requote(names[i]));
		}
	}
	return maps.join("|");
};

com_ibm_rave_core_locale_TimeFormat.time_formatLookup = function(names) {
	var map = com_ibm_rave_core_nativeImpl_arrays_ES6Map.create();
	if ((names)) {
		var i = -1;
		var n = names.length;
		while (++i < n) {
			map.set(names[i].toLowerCase(), i);
		}
	}
	return map;
};

com_ibm_rave_core_locale_TimeFormat.InternalTimeDateFormatter = rave_externs["InternalTimeDateFormatter"] = com_ibm_rave_core_nativeImpl_Declare({

	/** @expose */ 
	toString : function() {
		return null;
	}
});

com_ibm_rave_core_locale_TimeFormat.time_formatPads = com_ibm_rave_core_locale_TimeFormat.initialize_time_formatPads();

// $source: com/ibm/rave/core/time/Hour
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare, bind
//@import com/ibm/rave/core/time/TimeInterval (loadtime) // superclass
/**
 * Hour time interval. 60 minutes long (36e5 milliseconds). Note that advancing time by one hour can return the same hour number, or skip an hour number, due to Daylight Savings Time.
 */
var com_ibm_rave_core_time_Hour = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_time_TimeInterval, {

	/** @expose */ 
	floor : com_ibm_rave_core_nativeImpl_Declare.bind(function(date) {
		var timezone = date.getTimezoneOffset() / 60;
		return this.createDate(date, ((Math.floor(date.getTime() / 36e5 - timezone) + timezone) * 36e5));
	}),

	/** @expose */ 
	step : function(date, offset) {
		date.setTime((date.getTime() + Math.floor(offset) * 36e5));
	},

	/** @expose */ 
	number : function(date) {
		return date.getHours();
	}

	//constructor : function() {}
});

/**
 * Constructor
 */
/** @expose */ 
com_ibm_rave_core_time_Hour.INSTANCE = new com_ibm_rave_core_time_Hour();

// $source: com/ibm/rave/core/time/Month
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/time/TimeInterval (loadtime) // superclass
//@import com/ibm/rave/core/time/Day (runtime) // Day
/**
 * Month time interval.
 */
var com_ibm_rave_core_time_Month = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_time_TimeInterval, {

	/** @expose */ 
	floor : function(date) {
		var newdate = com_ibm_rave_core_time_Day.INSTANCE(date);
		newdate.setDate(1);
		return newdate;
	},

	/** @expose */ 
	step : function(date, offset) {
		date.setMonth(date.getMonth() + offset, date.getDate());
	},

	/** @expose */ 
	number : function(date) {
		return date.getMonth();
	}

	//constructor : function() {}
});

/** @expose */ 
com_ibm_rave_core_time_Month.INSTANCE = new com_ibm_rave_core_time_Month();

// $source: com/ibm/rave/core/time/Year
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/time/TimeInterval (loadtime) // superclass
//@import com/ibm/rave/core/time/Day (runtime) // Day
/**
 * Year time interval.
 */
var com_ibm_rave_core_time_Year = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_time_TimeInterval, {

	/** @expose */ 
	floor : function(date) {
		var newdate = com_ibm_rave_core_time_Day.INSTANCE(date);
		newdate.setMonth(0, 1);
		return newdate;
	},

	/** @expose */ 
	step : function(date, offset) {
		date.setFullYear(date.getFullYear() + offset, date.getMonth(), date.getDate());
	},

	/** @expose */ 
	number : function(date) {
		return date.getFullYear();
	}

	//constructor : function() {}
});

/**
 * Constructor
 */
/** @expose */ 
com_ibm_rave_core_time_Year.INSTANCE = new com_ibm_rave_core_time_Year();

// $source: com/ibm/rave/core/time/Second
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare, bind
//@import com/ibm/rave/core/time/TimeInterval (loadtime) // superclass
/**
 * Seconds (e.g., 01:23:45.0000 AM). Always 1,000 milliseconds long.
 */
var com_ibm_rave_core_time_Second = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_time_TimeInterval, {

	/** @expose */ 
	floor : com_ibm_rave_core_nativeImpl_Declare.bind(function(date) {
		return this.createDate(date, (Math.floor(date.getTime() / 1e3) * 1e3));
	}),

	/** @expose */ 
	step : function(date, offset) {
		date.setTime((date.getTime() + Math.floor(offset) * 1e3));
	},

	/** @expose */ 
	number : function(date) {
		return date.getSeconds();
	}

	/**
	 * Private Constructor
	 */
	//constructor : function() {}
});

/**
 * Instance of Second()
 */
/** @expose */ 
com_ibm_rave_core_time_Second.INSTANCE = new com_ibm_rave_core_time_Second();

// $source: com/ibm/rave/core/time/Minute
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare, bind
//@import com/ibm/rave/core/time/TimeInterval (loadtime) // superclass
/**
 * Minute time interval. Most implementations do not support leap seconds, so minutes are almost always 60 seconds (6e4 milliseconds) long.
 */
var com_ibm_rave_core_time_Minute = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_time_TimeInterval, {

	/** @expose */ 
	floor : com_ibm_rave_core_nativeImpl_Declare.bind(function(date) {
		return this.createDate(date, (Math.floor(date.getTime() / 6e4) * 6e4));
	}),

	/** @expose */ 
	step : function(date, offset) {
		date.setTime((date.getTime() + Math.floor(offset) * 6e4));
	},

	/** @expose */ 
	number : function(date) {
		return date.getMinutes();
	}

	//constructor : function() {}
});

/**
 * Constructor
 */
/** @expose */ 
com_ibm_rave_core_time_Minute.INSTANCE = new com_ibm_rave_core_time_Minute();

// $source: com/ibm/rave/core/time/Millisecond
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/time/TimeInterval (loadtime) // superclass
//@import com/ibm/rave/core/arrays/Range (runtime) // create
/**
 * A millisecond interval.
 */
var com_ibm_rave_core_time_Millisecond = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_time_TimeInterval, {

	/** @expose */ 
	floor : function(date) {
		return date;
	},

	/** @expose */ 
	step : function(date, offset) {
		date.setMilliseconds(date.getMilliseconds() + offset);
	},

	/** @expose */ 
	number : function(date) {
		return date.getMilliseconds();
	},

	/** @expose */ 
	ceil : function(date) {
		return date;
	},

	/** @expose */ 
	range : function(start, stop, step) {
		return (com_ibm_rave_core_arrays_Range.create(Math.ceil(start.getTime() / step) * step, + (stop), step));
	}

	//constructor : function() {}
});

/** @expose */ 
com_ibm_rave_core_time_Millisecond.INSTANCE = new com_ibm_rave_core_time_Millisecond();

// $source: com/ibm/rave/core/time/Week
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare, bind
//@import com/ibm/rave/core/time/TimeInterval (loadtime) // superclass
//@import com/ibm/rave/core/time/Day (runtime) // Day
//@import com/ibm/rave/core/time/Year (runtime) // Year
//@import com/ibm/rave/core/internal/time/TimeUtil (runtime) // dayOfYear
/**
 * Week time interval. Implemented for each individual day of the week class (Monday, Tuesday..)
 */
var com_ibm_rave_core_time_Week = rave_externs["Week"] = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_time_TimeInterval, {

	dayIndex : 0,

	/**
	 * Constructor which sets the day index 
	 * @param (int) index the day index
	 */
	/** @expose */ 
	constructor : function(index) {
		this.dayIndex = index;
	},

	/** @expose */ 
	floor : com_ibm_rave_core_nativeImpl_Declare.bind(function(date) {
		var newDate = com_ibm_rave_core_time_Day.INSTANCE(date);
		newDate.setDate(newDate.getDate() - (newDate.getDay() + this.dayIndex) % 7);
		return newDate;
	}),

	/** @expose */ 
	step : function(date, offset) {
		date.setDate(~~(date.getDate() + Math.floor(offset) * 7));
	},

	/** @expose */ 
	number : com_ibm_rave_core_nativeImpl_Declare.bind(function(date) {
		var day = com_ibm_rave_core_time_Year.INSTANCE(date).getDay();
		return ~~(Math.floor((com_ibm_rave_core_internal_time_TimeUtil.dayOfYear(date) + (day + this.dayIndex) % 7) / 7) - +(day != this.dayIndex));
	})
});


// $source: com/ibm/rave/core/internal/time/TimeUtil
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/time/Year (runtime) // Year
/**
 * Contains a helper method to get the day of the year for a particular date
 */
var com_ibm_rave_core_internal_time_TimeUtil = com_ibm_rave_core_nativeImpl_Declare({


});

/**
 * Helper method to get the day of year for a particular date. It's in here to avoid a circular dependency between Week and Time. 
 * @param (com.ibm.rave.core.time.IDate) date the date to get the day of the year for 
 * @return (int)  The day of the year for a given date
 */
com_ibm_rave_core_internal_time_TimeUtil.dayOfYear = function(date) {
	var year = com_ibm_rave_core_time_Year.INSTANCE(date);
	return Math.floor((date.getTime() - year.getTime() - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
};


// $source: com/ibm/rave/core/globalization/BidiStringFormat
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/globalization/BidiStringFormatter (runtime) // new
/**
 * A factory that creates a Bidi String formatter for a specific locale. 
 */
var com_ibm_rave_core_globalization_BidiStringFormat = rave_externs["BidiStringFormat"] = com_ibm_rave_core_nativeImpl_Declare({

	//locale : null,

	_$functionClassMethod : function() {
		var _$self = function(a0) {
			var args = arguments;
			if (args.length == 0) {
				return _$self.create$0();
			}
			return _$self.create$1(a0);
		};
		return _$self;
	},

	/** @expose */ 
	constructor : function(locale) {
		this.locale = locale;
	},

	create$0 : function() {
		return new com_ibm_rave_core_globalization_BidiStringFormatter();
	},

	create$1 : function(template) {
		return this();
	}
});


// $source: com/ibm/rave/core/globalization/BidiStringFormatter
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/globalization/BidiStringDirection (runtime) // parse, toString
//@import com/ibm/rave/core/internal/globalization/NumericShaperFactory (runtime) // create
//@import com/ibm/rave/core/internal/nativeImpl/globalization/BidiProcess (runtime) // determineDirection
/**
 * Internal class responsible for formatting bidi strings.
 * @author  jim
 */
var com_ibm_rave_core_globalization_BidiStringFormatter = rave_externs["BidiStringFormatter"] = com_ibm_rave_core_nativeImpl_Declare({

	//digitMappingList : null,

	dir : 4,

	numericShapingValue : "",

	defaultNumericContext : "",

	_$functionClassMethod : function() {
		var _$self = function(string, index, groupIndex) {
			var bidiString = ""+(string);
			if (_$self.numericShapingValue != null) {
				var shaper = com_ibm_rave_core_internal_globalization_NumericShaperFactory.create(_$self);
				bidiString = shaper.shape(bidiString);
			}
			var textDirection = _$self.dir;
			if (textDirection == 3) {
				textDirection = com_ibm_rave_core_internal_nativeImpl_globalization_BidiProcess.determineDirection(bidiString);
			}
			if (textDirection == 0) {
				bidiString = String.fromCharCode(8234) + bidiString + String.fromCharCode(8236);
			} else if (textDirection == 1) {
				bidiString = String.fromCharCode(8235) + bidiString + String.fromCharCode(8236);
			}
			return bidiString;
		};
		return _$self;
	},

	constructor : function() {
		this.digitMappingList = [];
				/**
		 * Internal class responsible for formatting bidi strings.
		 */
		{}
	},

	/**
	 * Sets the base text direction of this string. Base text direction refers to the order in which directional runs are laid out in a sentence. For left-to-right sentences, for example, in English, the proper base text direction is Left To Right (LTR), even if a sentence includes Arabic, Hebrew, Urdu, or Farsi words. For right-to-left sentences, for example, in Arabic or Hebrew, the proper base text direction is Right To Left (RTL), even if a sentence includes English words or numbers. Supported values are: “auto” - This implies contextual direction setting. “ltr” - Forced left to right base text direction. This is the default. “rtl” - Forced right to left base text direction. The “auto” option determines the direction contextually by using the first strong character to determine the direction. This option is useful when the text direction may not be know when setting the base text direction property. In general, if text contains letters from right to left scripts, but does not contain letters from a left to right script, the direction will be right to left, or vice versa. If the text contains characters of both types, then the first strong directional character in will determine the direction.
	 * @param (String) direction The base text direction of this string. Valid values are "auto", "ltr" or "rtl".
	 * @return (com.ibm.rave.core.globalization.BidiStringFormatter)  If a parameter is supplied, returns "this" formatter for chaining. If no parameter is supplied, returns a valid set value or "ltr" if no valid value was set.
	 */
	direction$0 : function(direction) {
		this.dir = com_ibm_rave_core_internal_globalization_BidiStringDirection.parse(direction);
		return this;
	},

	direction$1 : function() {
		return com_ibm_rave_core_internal_globalization_BidiStringDirection.toString(this.dir);
	},

	/**
	 * Sets the type of "numeric shaping" to apply to this string. Numeric shaping allows digit shapes to be presented in other forms than European shapes (0123456789), such as Arabic-Indic (٠١٢٣٤٥٦٧٨٩) or Thai (๐ ๑ ๒ ๓ ๔ ๕ ๖ ๗ ๘ ๙ ). The shaping is done from European digits to non-European digits, but not the other way around. The two types of numeric shaping supported are “national” or “contextual”. When “national” is specified, digits are shaped to the national digit types set via the digits API. For example, if the national digits are specified as ARABIC, then all European digits are shaped to ARABIC. When “contextual” is specified, digit shapes are determined from adjoining characters in the value; if the most recent character before the numerical character is left-to-right, the number is displayed as a European number. For example, if ARABIC is specified as the contextual digits, then all the European digits that are preceded by ARABIC text are shaped to ARABIC digits.
	 * @param (String) numericShapingType The type of numeric shaping to apply to this string. Valid options are "national" or "contextual"
	 * @return (com.ibm.rave.core.globalization.BidiStringFormatter)  If a parameter is supplied, returns "this" formatter for chaining. If no parameter is supplied, returns the set value.
	 */
	numericShaping$0 : function(numericShapingType) {
		this.numericShapingValue = (numericShapingType != null) ? numericShapingType.toLowerCase() : null;
		return this;
	},

	numericShaping$1 : function() {
		return this.numericShapingValue;
	},

	/**
	 * Set the default context for numerical shaping when "contextual" shaping is used. Ignored in "national" shaping. The default context is used to determine the context for numerical shaping when a string input starts with digits. This value defaults to EUROPEAN. If "national" shaping is used, this value is ignored. If defaultContext is not set, or is set to 'null' defaults to "EUROPEAN".
	 * @param (String) defaultContext A string representation of the language that will be the default for numeric contextual shaping. Valid values are: ARABIC BENGALI DEVANAGARI EASTERN_ARABIC ETHIOPIC EUROPEAN GUJARATI GURMUKHI KANNADA KHMER LAO MALAYALAM MONGOLIAN MYANMAR ORIYA TAMIL TELUGU THAI TIBETAN
	 * @return (com.ibm.rave.core.globalization.BidiStringFormatter)  If a parameter is supplied, returns "this" formatter for chaining. If no parameter is supplied, returns the set value, or null if none set.
	 */
	defaultContext$0 : function(defaultContext) {
		this.defaultNumericContext = defaultContext;
		return this;
	},

	defaultContext$1 : function() {
		return this.defaultNumericContext;
	},

	/**
	 * Defines how European digits are mapped when numerical shaping is used. All the European digits are shaped as per the specified contextual digits, based on the preceding context. For example, if ARABIC and MALAYALAM are specifed as the contextual digits then all the European digits that are preceded by ARABIC text are shaped to ARABIC and all European digits that are preceded by MALAYALAM are shaped to MALAYALAM. If both ARABIC and EASTERN_ARABIC are specifed, the digits are shaped to EASTERN_ARABIC. The default value is set via defaultContext(). If no defaultContext is specified, EUROPEAN is used. The following are valid values for the digits numeric shaping properties. Values are case sensitive. ARABIC BENGALI DEVANAGARI EASTERN_ARABIC ETHIOPIC EUROPEAN GUJARATI GURMUKHI KANNADA KHMER LAO MALAYALAM MONGOLIAN MYANMAR ORIYA TAMIL TELUGU THAI TIBETAN
	 * @param (Array) digitTypes Either a single value, or a list of alternate digit types to use to map European digits to another language.
	 * @return (com.ibm.rave.core.globalization.BidiStringFormatter)  If a parameter is supplied, returns "this" formatter for chaining. If no parameter is supplied, returns the set value.
	 */
	digitMapping$0 : function(digitTypes) {
		var array = digitTypes;
		this.digitMappingList = (array);
		return this;
	},

	digitMapping$1 : function(string) {
		this.digitMappingList = [string];
		return this;
	},

	digitMapping$2 : function() {
		if (this.digitMappingList.length == 0 && this.defaultNumericContext != null) {
			return [this.defaultNumericContext];
		}
		return this.digitMappingList;
	},

	/** @expose */ 
	direction : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.direction$1();
		}
		return this.direction$0(a0);
	},

	/** @expose */ 
	numericShaping : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.numericShaping$1();
		}
		return this.numericShaping$0(a0);
	},

	/** @expose */ 
	defaultContext : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.defaultContext$1();
		}
		return this.defaultContext$0(a0);
	},

	/** @expose */ 
	digitMapping : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.digitMapping$2();
		}
		if (args.length == 1 && (a0 == null || Object.prototype.toString.call(a0) === "[object Array]")) {
			return this.digitMapping$0(a0);
		}
		return this.digitMapping$1(a0);
	}
});


// $source: com/ibm/rave/core/internal/globalization/AbstractNumericShaper
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
var com_ibm_rave_core_internal_globalization_AbstractNumericShaper = com_ibm_rave_core_nativeImpl_Declare({

	//constructor : function() {},

	/**
	 * Return the a shaped version of a string where the numbers have been shaped based on  the type of shaping.
	 * @param (String) string
	 * @return (String)  The shaped version of the param string, based on the type of shaping.
	 */
	//shape : function(string) {}
});

com_ibm_rave_core_internal_globalization_AbstractNumericShaper.offsets = [0, 1584, 1728, 2358, 2486, 2614, 2742, 2870, 2998, 3126, 3254, 3382, 3616, 3744, 3824, 4112, 4921, 6064, 6112];

// $source: com/ibm/rave/core/internal/globalization/NationalNumericShaper
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/globalization/AbstractNumericShaper (loadtime) // offsets, superclass
var com_ibm_rave_core_internal_globalization_NationalNumericShaper = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_internal_globalization_AbstractNumericShaper, {

	nationalDigitCode : 0,

	constructor : function(nationDigitCode) {
		this.nationalDigitCode = nationDigitCode;
	},

	shape : function(text) {
		var digitCode = this.nationalDigitCode;
		if (text == null) {
			return null;
		}
		if (digitCode > com_ibm_rave_core_internal_globalization_AbstractNumericShaper.offsets.length - 1) {
			return text;
		}
		var offset = com_ibm_rave_core_internal_globalization_AbstractNumericShaper.offsets[digitCode];
		var s = "";
		var minDigit = 48;
		var maxDigit = 57;
		for (var i = 0; i < text.length; ++i) {
			var c = text.charCodeAt(i);
			if (c >= minDigit && c <= maxDigit) {
				s+=(String.fromCharCode((c + offset)));
			} else {
				s+=(String.fromCharCode(c));
			}
		}
		return s;
	}
});


// $source: com/ibm/rave/core/internal/globalization/ContextualNumericShaper
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/globalization/AbstractNumericShaper (loadtime) // offsets, superclass
var com_ibm_rave_core_internal_globalization_ContextualNumericShaper = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_internal_globalization_AbstractNumericShaper, {

	//contextualDigitCodes : null,

	startingContextCode : 0,

	constructor : function(contextualDigitCodes, startingContextCode) {
		this.contextualDigitCodes = contextualDigitCodes;
		this.startingContextCode = startingContextCode;
	},

	shape : function(text) {
		if (text == null) {
			return null;
		}
		var contextCodes = this.contextualDigitCodes;
		var contexts = 0;
		for (var i = 0; i < contextCodes.length; ++i) {
			contexts |= 1 << contextCodes[i];
		}
		var s = "";
		var offset = 0;
		var range = 0;
		if (((1 << this.startingContextCode) & contexts) != 0) {
			offset = com_ibm_rave_core_internal_globalization_AbstractNumericShaper.offsets[this.startingContextCode];
			range = this.startingContextCode;
		}
		for (var i = 0; i < text.length; ++i) {
			var c = text.charCodeAt(i);
			var minDigit = 48;
			var maxDigit = 57;
			if (c >= minDigit && c <= maxDigit) {
				s+=(String.fromCharCode((c + offset)));
			} else {
				s+=(String.fromCharCode(c));
				var newRange = com_ibm_rave_core_internal_globalization_ContextualNumericShaper.getRange(c);
				if (newRange != range) {
					if (com_ibm_rave_core_internal_globalization_ContextualNumericShaper.hasContext(c)) {
						if ((1 << newRange & contexts) != 0) {
							range = newRange;
							if (range == 1 && ((contexts & 1 << 2) != 0)) {
								range = 2;
							}
							offset = com_ibm_rave_core_internal_globalization_AbstractNumericShaper.offsets[range];
						} else if (((1 << newRange) & contexts) == 0) {
							if (newRange == 2) {
								if ((1 << 1 & contexts) != 0) {
									range = 1;
									offset = com_ibm_rave_core_internal_globalization_AbstractNumericShaper.offsets[range];
								}
							} else if (newRange == 1) {
								if ((1 << 2 & contexts) != 0) {
									range = 2;
									offset = com_ibm_rave_core_internal_globalization_AbstractNumericShaper.offsets[range];
								}
							} else {
								range = 0;
								offset = 0;
							}
						}
					}
				}
			}
		}
		return s;
	}
});

/**
 * Determine if the said character has a context.
 * @param (int) charValue - the char value
 * @return (boolean)  - true if the character has context.
 */
com_ibm_rave_core_internal_globalization_ContextualNumericShaper.hasContext = function(charValue) {
	var searchIndex = com_ibm_rave_core_internal_globalization_ContextualNumericShaper.search(com_ibm_rave_core_internal_globalization_ContextualNumericShaper.contextualCharRanges, charValue);
	return (searchIndex != -1);
};

/**
 * Get the unicode range index to which the character belongs.
 * @param (int) charValue - character
 * @return (int)  - the index of the range.
 */
com_ibm_rave_core_internal_globalization_ContextualNumericShaper.getRange = function(charValue) {
	var index = com_ibm_rave_core_internal_globalization_ContextualNumericShaper.search(com_ibm_rave_core_internal_globalization_ContextualNumericShaper.ranges, charValue);
	if (index == -1) {
		return 0;
	}
	if (index == 19) {
		return 1;
	}
	return index;
};

com_ibm_rave_core_internal_globalization_ContextualNumericShaper.search = function(pRanges, charValue) {
	var start = 0;
	var end = pRanges.length - 1;
	while (start <= end) {
		var mid = Math.floor((start + end) / 2);
		if (pRanges[mid].start <= charValue && pRanges[mid].end > charValue) {
			return mid;
		} else if (pRanges[mid].start > charValue) {
			end = mid - 1;
		} else if (pRanges[mid].end <= charValue) {
			start = mid + 1;
		}
	}
	return -1;
};

com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange = function(s, e) {
	this.start = s;
	this.end = e;
};

com_ibm_rave_core_internal_globalization_ContextualNumericShaper.EUROPEAN = 0;
com_ibm_rave_core_internal_globalization_ContextualNumericShaper.ARABIC = 1;
com_ibm_rave_core_internal_globalization_ContextualNumericShaper.EASTERN_ARABIC = 2;
com_ibm_rave_core_internal_globalization_ContextualNumericShaper.EXTENDED_ARABIC = 19;

com_ibm_rave_core_internal_globalization_ContextualNumericShaper.contextualCharRanges = [new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x41, 0x5b), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x61, 0x7b), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xaa, 0xab), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xb5, 0xb6), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xba, 0xbb), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xc0, 0xd7), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xd8, 0xf7), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xf8, 0x2b9), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x2bb, 0x2c2), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x2d0, 0x2d2), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x2e0, 0x2e5), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x2ee, 0x2ef), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x608, 0x609), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x60b, 0x60c), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x60d, 0x60e), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x61b, 0x64b), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x66d, 0x670), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x671, 0x6d6), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x6e5, 0x6e7), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x6ee, 0x6f0), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x6fa, 0x701), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x750, 0x781), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x903, 0x93a), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x93b, 0x93c), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x93d, 0x941), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x949, 0x94d), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x94e, 0x951), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x958, 0x962), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x964, 0x981), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x982, 0x9bc), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x9bd, 0x9c1), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x9c7, 0x9cd), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x9ce, 0x9e2), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x9e6, 0x9f2), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x9f4, 0x9fb), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xa03, 0xa3c), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xa3e, 0xa41), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xa59, 0xa70), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xa72, 0xa75), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xa83, 0xabc), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xabd, 0xac1), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xac9, 0xacd), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xad0, 0xae2), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xae6, 0xaf1), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xb02, 0xb3c), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xb3d, 0xb3f), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xb40, 0xb41), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xb47, 0xb4d), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xb57, 0xb62), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xb66, 0xb82), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xb83, 0xbc0), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xbc1, 0xbcd), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xbd0, 0xbf3), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xc01, 0xc3e), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xc41, 0xc46), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xc58, 0xc62), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xc66, 0xc78), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xc7f, 0xcbc), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xcbd, 0xccc), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xcd5, 0xce2), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xce6, 0xd41), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xd46, 0xd4d), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xd4e, 0xd62), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xd66, 0xd81), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xe00, 0xe31), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xe32, 0xe34), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xe40, 0xe47), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xe4f, 0xeb1), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xeb2, 0xeb4), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xebd, 0xec8), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xed0, 0xf18), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xf1a, 0xf35), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xf36, 0xf37), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xf38, 0xf39), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xf3e, 0xf71), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xf7f, 0xf80), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xf85, 0xf86), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xf88, 0xf8d), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xfbe, 0xfc6), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0xfc7, 0x102d), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x1031, 0x1032), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x1038, 0x1039), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x103b, 0x103d), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x103f, 0x1058), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x105a, 0x105e), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x1061, 0x1071), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x1075, 0x1081), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x1200, 0x135d), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x1360, 0x1381), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x1780, 0x17b7), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x17be, 0x17c6), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x17c7, 0x17c9), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x17d4, 0x17db), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x17dc, 0x17dd), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x17e0, 0x17f0), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x1810, 0x18a9), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x18aa, 0x1901)];
com_ibm_rave_core_internal_globalization_ContextualNumericShaper.ranges = [new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x0000, 0x0300), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x0600, 0x0700), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x0600, 0x0700), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x0900, 0x0980), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x0980, 0x0a00), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x0a00, 0x0a80), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x0a80, 0x0b00), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x0b00, 0x0b80), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x0b80, 0x0c00), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x0c00, 0x0c80), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x0c80, 0x0d00), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x0d00, 0x0d80), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x0e00, 0x0e80), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x0e80, 0x0f00), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x0f00, 0x1000), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x1000, 0x10a0), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x1200, 0x13a0), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x1780, 0x1800), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x1800, 0x18b0), new com_ibm_rave_core_internal_globalization_ContextualNumericShaper.CodePointRange(0x0750, 0x0780)];

// $source: com/ibm/rave/core/internal/globalization/DefaultNumericShaper
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/globalization/AbstractNumericShaper (loadtime) // superclass
var com_ibm_rave_core_internal_globalization_DefaultNumericShaper = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_internal_globalization_AbstractNumericShaper, {

	shape : function(string) {
		return string;
	}
});


// $source: com/ibm/rave/core/internal/globalization/NumericShaperFactory
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/internal/globalization/NationalNumericShaper (static) // new
//@import com/ibm/rave/core/internal/globalization/ContextualNumericShaper (static) // new
//@import com/ibm/rave/core/internal/globalization/DefaultNumericShaper (static) // new
var com_ibm_rave_core_internal_globalization_NumericShaperFactory = {


};

com_ibm_rave_core_internal_globalization_NumericShaperFactory.initialize_digitMap = function() {
	var digitMap = {};
	digitMap["ARABIC"] = 1;
	digitMap["BENGALI"] = 4;
	digitMap["DEVANAGARI"] = 3;
	digitMap["EASTERN_ARABIC"] = 2;
	digitMap["ETHIOPIC"] = 16;
	digitMap["EUROPEAN"] = 0;
	digitMap["GUJARATI"] = 6;
	digitMap["GURMUKHI"] = 5;
	digitMap["KANNADA"] = 10;
	digitMap["KHMER"] = 17;
	digitMap["LAO"] = 13;
	digitMap["MALAYALAM"] = 11;
	digitMap["MONGOLIAN"] = 18;
	digitMap["MYANMAR"] = 15;
	digitMap["ORIYA"] = 7;
	digitMap["TAMIL"] = 8;
	digitMap["TELUGU"] = 9;
	digitMap["THAI"] = 12;
	digitMap["TIBETAN"] = 14;
	return digitMap;
};

/**
 * Factory method to create a Shaper object that can shape numbers for a StringFormatter.
 * @param (com.ibm.rave.core.globalization.BidiStringFormatter) formatter - localization formatter to construct the object.
 * @return (com.ibm.rave.core.internal.globalization.AbstractNumericShaper)  - the NumericalShapingInfo object.
 */
com_ibm_rave_core_internal_globalization_NumericShaperFactory.create = function(formatter) {
	var digits = formatter.digitMapping();
	var shaping = formatter.numericShaping();
	if (digits.length > 0 && shaping != null) {
		shaping = shaping.toLowerCase();
		if (shaping.indexOf("nation") == 0) {
			return new com_ibm_rave_core_internal_globalization_NationalNumericShaper(com_ibm_rave_core_internal_globalization_NumericShaperFactory.getDigitCode(digits[0]));
		} else if (shaping.indexOf("context") == 0) {
			return new com_ibm_rave_core_internal_globalization_ContextualNumericShaper(com_ibm_rave_core_internal_globalization_NumericShaperFactory.getDigitCodes(formatter.digitMapping()), com_ibm_rave_core_internal_globalization_NumericShaperFactory.getDigitCode(formatter.defaultContext()));
		}
	}
	return new com_ibm_rave_core_internal_globalization_DefaultNumericShaper();
};

/**
 * Gets the integer code for the specified national digit. For an invalid nation digit string, EUROPEAN is returned.
 * @param (String) nationalDigits
 * @return (int)  - the digit code.
 */
com_ibm_rave_core_internal_globalization_NumericShaperFactory.getDigitCode = function(nationalDigits) {
	var digit = com_ibm_rave_core_internal_globalization_NumericShaperFactory.digitMap[nationalDigits.toUpperCase()];
	if (digit == null) {
		return com_ibm_rave_core_internal_globalization_NumericShaperFactory.digitMap["EUROPEAN"];
	}
	return digit;
};

/**
 * Returns an array of integer codes for the specified digits.
 * @param (Array) list
 * @return (int[])  Array of integer codes
 */
com_ibm_rave_core_internal_globalization_NumericShaperFactory.getDigitCodes = function(list) {
	var digits = [];
	var i = 0;
	for (var __i_enFor0 = 0, __exp_enFor0 = list, __len_enFor0 = __exp_enFor0.length;
			__i_enFor0 < __len_enFor0; ++__i_enFor0) {
		var digitStr = __exp_enFor0[__i_enFor0];
		digits[i++] = com_ibm_rave_core_internal_globalization_NumericShaperFactory.getDigitCode(digitStr);
	}
	return digits;
};

com_ibm_rave_core_internal_globalization_NumericShaperFactory.EUROPEAN = "EUROPEAN";
com_ibm_rave_core_internal_globalization_NumericShaperFactory.NATIONAL = "nation";
com_ibm_rave_core_internal_globalization_NumericShaperFactory.CONTEXTUAL = "context";

com_ibm_rave_core_internal_globalization_NumericShaperFactory.digitMap = com_ibm_rave_core_internal_globalization_NumericShaperFactory.initialize_digitMap();

// $source: com/ibm/rave/core/locale/LocaleObject
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
var com_ibm_rave_core_locale_LocaleObject = rave_externs["LocaleObject"] = com_ibm_rave_core_nativeImpl_Declare({

	/** @expose */ 
	decimal : null,

	/** @expose */ 
	thousands : null,

	/** @expose */ 
	grouping : null,

	/** @expose */ 
	currency : null,

	/** @expose */ 
	dateTime : null,

	/** @expose */ 
	date : null,

	/** @expose */ 
	time : null,

	/** @expose */ 
	periods : null,

	/** @expose */ 
	days : null,

	/** @expose */ 
	shortDays : null,

	/** @expose */ 
	months : null,

	/** @expose */ 
	shortMonths : null
});


// $source: com/ibm/rave/core/locale/enUS
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/locale/LocaleObject (loadtime) // superclass
var com_ibm_rave_core_locale_enUS = rave_externs["enUS"] = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_locale_LocaleObject, {

	/**
	 * the en-US locale. This locale is used as a default, unless the default is otherwise specified to be a different/custome locale
	 */
	/** @expose */ 
	constructor : function() {
		this.decimal = ".";
		this.thousands = ",";
		this.grouping = [3.0];
		this.currency = ["$", ""];
		this.dateTime = "%a %b %e %X %Y";
		this.date = "%m/%d/%Y";
		this.time = "%H:%M:%S";
		this.periods = ["AM", "PM"];
		this.days = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
		this.shortDays = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
		this.months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
		this.shortMonths = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
	}
});


// $source: com/ibm/rave/core/locale/Locale
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/locale/LocaleFormatter (static) // new
//@import com/ibm/rave/core/locale/enUS (static) // new
/**
 * The formatting of numbers, dates and currencies varies by language and locale. While the default is intended for U.S. English, you can change the behavior of the formatters by loading a new locale as needed.
 * @author  tina
 */
var com_ibm_rave_core_locale_Locale = com_ibm_rave_core_nativeImpl_Declare({

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * Returns a new locale given the specified definition. The locale definition must include the following properties for number formatting: decimal - the decimal place string (e.g., ".").  thousands - the group separator string (e.g., ",").  grouping - the array of group sizes (e.g., [3]), cycled as needed.  currency - the currency prefix and suffix strings (e.g., ["$", ""]). (Note that the thousands property is a slight misnomer, as the grouping definition allows groups other than thousands.) The locale definition must also include the following properties for time formatting: dateTime - the date and time (%c) format string (e.g., "%a %b %e %X %Y"). date - the date (%x) format string (e.g., "%m/%d/%Y").  time - the time (%X) format string (e.g., "%H:%M:%S").  periods - the locale’s A.M. and P.M. equivalents (e.g., ["AM", "PM"]).  days - the full names of the weekdays, starting with Sunday.  shortDays - the abbreviated names of the weekdays, starting with Sunday.  months - the full names of the months (starting with January).  shortMonths - the abbreviated names of the months (starting with January).
		 * @param (com.ibm.rave.core.locale.LocaleObject) localeObject the locale object to use
		 * @return (com.ibm.rave.core.locale.LocaleFormatter)  the LocaleFormatter object containing the new numberformat
		 */
		function(localeObject) {
			return new com_ibm_rave_core_locale_LocaleFormatter(localeObject);
		};
		return _$self;
	},

	/**
	 * Gets the locale formatter that is used by default by Time, Number and Bidi String formatting.  Currently this value is immutable and is always EN-US.
	 * @return (com.ibm.rave.core.locale.LocaleFormatter)  the default locale formatter.
	 */
	/** @expose */ 
	getDefault : function() {
		return com_ibm_rave_core_locale_Locale.formatter;
	}

	//constructor : function() {}
});

/** @expose */ 
com_ibm_rave_core_locale_Locale.getInstance = function() {
	if (!com_ibm_rave_core_locale_Locale.INSTANCE) {
		{
			if (!com_ibm_rave_core_locale_Locale.INSTANCE) {
				com_ibm_rave_core_locale_Locale.INSTANCE = new com_ibm_rave_core_locale_Locale();
			}
		}
	}
	return com_ibm_rave_core_locale_Locale.INSTANCE;
};

/**
 * Default system locale (en-us).
 */
/** @expose */ 
com_ibm_rave_core_locale_Locale.DEFAULT_LOCALE = new com_ibm_rave_core_locale_enUS();
com_ibm_rave_core_locale_Locale.formatter = new com_ibm_rave_core_locale_LocaleFormatter(com_ibm_rave_core_locale_Locale.DEFAULT_LOCALE);
//com_ibm_rave_core_locale_Locale.INSTANCE = null;

// $source: com/ibm/rave/core/scales/PowScale
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/scales/AbstractScale (loadtime) // superclass
//@import com/ibm/rave/core/scales/LinearScale (runtime) // linearTicks, linearNice, linearTickFormat
var com_ibm_rave_core_scales_PowScale = rave_externs["PowScale"] = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_scales_AbstractScale, {

	//_linear : null,

	//_exponent : null,

	//_domain : null,

	//powp : null,

	//powb : null,

	_$functionClassMethod : function() {
		var _$self = function(data, index, groupIndex) {
			return _$self._linear.call(this, _$self.powp(+ (data)), index, groupIndex);
		};
		return _$self;
	},

	/** @expose */ 
	constructor : function(linear, exponent, domain) {
		this._linear = linear;
		this._exponent = exponent;
		this._domain = domain;
		this.powp = com_ibm_rave_core_scales_PowScale.pow(this._exponent);
		this.powb = com_ibm_rave_core_scales_PowScale.pow(1 / this._exponent);
		var self = this;
		this.ticks = function(tickArguments) {
			if (tickArguments !== null || arguments.length > 1){
				tickArguments = Array.prototype.slice.call(arguments);
			}
			{
				return com_ibm_rave_core_scales_LinearScale.linearTicks.apply(com_ibm_rave_core_scales_LinearScale, [self._domain].concat(tickArguments));
			}
		};
		this.tickFormat = function(tickArguments) {
			if (tickArguments !== null || arguments.length > 1){
				tickArguments = Array.prototype.slice.call(arguments);
			}
			{
				var count = tickArguments.length > 0 ? + (tickArguments[0]) : null;
				var format = tickArguments.length > 1 ? tickArguments[1] : null;
				return com_ibm_rave_core_scales_LinearScale.linearTickFormat(self._domain, count, ((typeof format === "string" || format instanceof String)) ? format : null);
			}
		};
		this.invert = function(y) {
			return self.powb(+ (self._linear.invert(y)));
		};
	},

	domain$0 : function(values) {
		this._domain = new Array(values.length);
		for (var i = 0; i < values.length; ++i) {
			this._domain[i] = + (values[i]);
		}
		var self = this;
		this._linear.domain$0(this._domain.map(function(currentValue, index, array) {
			return self.powp(+ (currentValue));
		}));
		return this;
	},

	domain$1 : function() {
		return this._domain;
	},

	range$0 : function(values) {
		this._linear.range$0(values);
		return this;
	},

	range$1 : function() {
		return this._linear.range$1();
	},

	/** @expose */ 
	copy : function() {
		return new com_ibm_rave_core_scales_PowScale(this._linear.copy(), this._exponent, this._domain);
	},

	/**
	 * If boolean is specified, enables or disables clamping accordingly. By default, clamping is disabled, such that if a value outside the input domain is passed to the scale, the scale may return a value outside the output range through linear extrapolation. For example, with the default domain and range of [0,1], an input value of 2 will return an output value of 2. If clamping is enabled, the normalized domain parameter t is clamped to the range [0,1], such that the return value of the scale is always within the scale's output range. If boolean is not specified, returns whether or not the scale currently clamps values to within the output range.
	 * @param (boolean) c True or False to Enable or Disable (respectively) clamping.
	 * @return (com.ibm.rave.core.scales.PowScale)  This scale.
	 */
	clamp$0 : function(c) {
		this._linear.clamp$0(c);
		return this;
	},

	/**
	 * If boolean is specified, enables or disables clamping accordingly. By default, clamping is disabled, such that if a value outside the input domain is passed to the scale, the scale may return a value outside the output range through linear extrapolation. For example, with the default domain and range of [0,1], an input value of 2 will return an output value of 2. If clamping is enabled, the normalized domain parameter t is clamped to the range [0,1], such that the return value of the scale is always within the scale's output range. If boolean is not specified, returns whether or not the scale currently clamps values to within the output range.
	 * @return (boolean)  True if clamping is enabled, false otherwise.
	 */
	clamp$1 : function() {
		return this._linear.clamp$1();
	},

	/**
	 * Sets the scale's output range to the specified array of values, while also setting the scale's interpolator to Rave.interpolateRound. This is a convenience routine for when the values output by the scale should be exact integers, such as to avoid antialiasing artifacts. It is also possible to round the output values manually after the scale is applied.
	 * @param (Array) x Output range values.
	 * @return (com.ibm.rave.core.scales.PowScale)  This scale.
	 */
	/** @expose */ 
	rangeRound : function(x) {
		this._linear.rangeRound(x);
		return this;
	},

	/**
	 * If  {@code  interpolate}  is specified, sets the scale's output interpolator using the specified interpolator factory. The interpolator factory defaults to  {@link this.Rave#com_ibm_rave_core_Rave.interpolate} , and is used to map the normalized domain parameter t in [0,1] to the corresponding value in the output range. The interpolator factory will be used to construct interpolators for each adjacent pair of values from the output range. If factory is not specified, returns the scale's interpolator factory.
	 * @param (com.ibm.rave.core.interpolate.InterpolatorFactory) interpolate The interpolator factory to assign to this scale.
	 * @return (com.ibm.rave.core.scales.PowScale)  This scale.
	 */
	interpolate$0 : function(interpolate) {
		this._linear.interpolate$0(interpolate);
		return this;
	},

	/**
	 * If  {@code  interpolate}  is specified, sets the scale's output interpolator using the specified interpolator factory. The interpolator factory defaults to  {@link this.Rave#com_ibm_rave_core_Rave.interpolate} , and is used to map the normalized domain parameter t in [0,1] to the corresponding value in the output range. The interpolator factory will be used to construct interpolators for each adjacent pair of values from the output range. If factory is not specified, returns the scale's interpolator factory.
	 * @return (Object)  The interpolator assigned to this scale.
	 */
	interpolate$1 : function() {
		return this._linear.interpolate$1();
	},

	/**
	 * Extends the domain so that it starts and ends on nice round values. This method typically modifies the scale's domain, and may only extend the bounds to the nearest round value. The precision of the round value is dependent on the extent of the domain dx according to the following formula: exp(round(log(dx)) - 1). Nicing is useful if the domain is computed from data and may be irregular. For example, for a domain of [0.20147987687960267, 0.996679553296417], the nice domain is [0.2, 1]. If the domain has more than two values, nicing the domain only affects the first and last value. The optional tick count argument allows greater control over the step size used to extend the bounds, guaranteeing that the returned ticks will exactly cover the domain.
	 * @return (com.ibm.rave.core.scales.PowScale)  This scale.
	 */
	nice$0 : function() {
		return this.nice$1(10);
	},

	/**
	 * Extends the domain so that it starts and ends on nice round values. This method typically modifies the scale's domain, and may only extend the bounds to the nearest round value. The precision of the round value is dependent on the extent of the domain dx according to the following formula: exp(round(log(dx)) - 1). Nicing is useful if the domain is computed from data and may be irregular. For example, for a domain of [0.20147987687960267, 0.996679553296417], the nice domain is [0.2, 1]. If the domain has more than two values, nicing the domain only affects the first and last value. The optional tick count argument allows greater control over the step size used to extend the bounds, guaranteeing that the returned ticks will exactly cover the domain.
	 * @param (Number) m Desired number of ticks.
	 * @return (com.ibm.rave.core.scales.PowScale)  This scale.
	 */
	nice$1 : function(m) {
		return this.domain(com_ibm_rave_core_scales_LinearScale.linearNice(this._domain, m));
	},

	/**
	 * If x is specified, sets the current exponent to the given numeric value. If x is not specified, returns the current exponent. The default value is 1.
	 * @return (Number)  Exponent power assigned to this scale.
	 */
	exponent$0 : function() {
		return this._exponent;
	},

	/**
	 * If x is specified, sets the current exponent to the given numeric value. If x is not specified, returns the current exponent. The default value is 1.
	 * @param (Number) x Exponent value.
	 * @return (com.ibm.rave.core.scales.PowScale)  This scale.
	 */
	exponent$1 : function(x) {
		this._exponent = x;
		this.powp = com_ibm_rave_core_scales_PowScale.pow(this._exponent);
		this.powb = com_ibm_rave_core_scales_PowScale.pow(1 / this._exponent);
		var self = this;
		this._linear.domain(this._domain.map(function(currentValue, index, array) {
			return self.powp(+ (currentValue));
		}));
		return this;
	},

	/** @expose */ 
	domain : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.domain$1();
		}
		return this.domain$0(a0);
	},

	/** @expose */ 
	range : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.range$1();
		}
		return this.range$0(a0);
	},

	/** @expose */ 
	clamp : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.clamp$1();
		}
		return this.clamp$0(a0);
	},

	/** @expose */ 
	interpolate : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.interpolate$1();
		}
		return this.interpolate$0(a0);
	},

	/** @expose */ 
	nice : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.nice$0();
		}
		return this.nice$1(a0);
	},

	/** @expose */ 
	exponent : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.exponent$0();
		}
		return this.exponent$1(a0);
	}
});

com_ibm_rave_core_scales_PowScale.pow = function(e) {
	return function(x) {
		return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
	};
};


// $source: com/ibm/rave/core/scales/ThresholdScale
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/scales/AbstractScale (loadtime) // superclass
//@import com/ibm/rave/core/Rave (runtime) // Rave
/**
 * Threshold scales are similar to quantize scales, except they allow you to map arbitrary subsets of the  domain to discrete values in the range. The input domain is still continuous, and divided into slices based  on a set of threshold values. it is important to keep in mind that the input domain data types must be naturally ordered, for example numbers or strings, or the behavior of the scale is undefined. Also, if the number of values in the scale's domain is N, the number of values in the scale's range must be N + 1.  If there are fewer than N+1 elements in the range, the scale may return null for some inputs.  If there are more than N + 1 elements in the range, the additional values are ignored  
 */
var com_ibm_rave_core_scales_ThresholdScale = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_scales_AbstractScale, {

	//_domain : null,

	//_range : null,

	_$functionClassMethod : function() {
		var _$self = function(data, index, groupIndex) {
			return _$self.scale(data);
		};
		return _$self;
	},

	constructor : function(domain, range) {
		this._domain = [];
		this._range = [];
		{
			this._domain = domain;
			this._range = range;
		}
	},

	/**
	 * Maps a value from an input domain to an output range
	 * @param (Object) key the input domain value to map
	 * @return (Object)  the corresponding value in range, or null if none found if range has fewer elements than domains element count + 1
	 */
	/** @expose */ 
	scale : function(key) {
		var _key = key;
		if (_key == null) {
			_key = + (_key);
		}
		if (_key<=_key) {
			var i = com_ibm_rave_core_Rave.bisect(this._domain, _key);
			if (i >= 0 && i < this._range.length) {
				return this._range[i];
			}
		}
		return undefined;
	},

	domain$0 : function(values) {
		this._domain = values;
		return this;
	},

	domain$1 : function() {
		return this._domain;
	},

	range$0 : function(values) {
		this._range = values;
		return this;
	},

	range$1 : function() {
		return this._range;
	},

	/** @expose */ 
	copy : function() {
		return new com_ibm_rave_core_scales_ThresholdScale(this._domain, this._range);
	},

	/**
	 * Returns the extent of values in the input domain [x0, x1] for the corresponding value in the output range y,  representing the inverse mapping from range to domain.  This method is useful for interaction, say to determine the value in the input domain that corresponds to the pixel location under the mouse.
	 * @param (Object) y   the value in range to get the range extent for
	 * @return (Array)  an array of two objects from the domain that represent. If the value does not exist in the range, or if its index in the range values exceeds that of the domain values length (which could happen if the range values exceed in number the domain values)   then the array returned will have null entries in it. 
	 */
	/** @expose */ 
	invertExtent : function(y) {
		var i = this._range.indexOf(y);
		var first = undefined;
		var second = undefined;
		if (i > 0 && i <= this._domain.length) {
			first = this._domain[i - 1];
		}
		if (i >= 0 && i < this._domain.length) {
			second = this._domain[i];
		}
		return [first, second];
	},

	/** @expose */ 
	domain : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.domain$1();
		}
		return this.domain$0(a0);
	},

	/** @expose */ 
	range : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.range$1();
		}
		return this.range$0(a0);
	}
});

/**
 * Factory method to create a new threshold scale with default domain of [0.5] and default range of [0,1]
 * @return (com.ibm.rave.core.scales.ThresholdScale)  the newly created threshold scale
 */
/** @expose */ 
com_ibm_rave_core_scales_ThresholdScale.newThresholdScale = function() {
	var domain = [];
	domain.push(0.5);
	return new com_ibm_rave_core_scales_ThresholdScale(domain, [0, 1]);
};


// $source: com/ibm/rave/core/scales/IdentityScale
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/scales/AbstractScale (loadtime) // superclass
//@import com/ibm/rave/core/scales/LinearScale (runtime) // linearTicks, linearTickFormat
/**
 * Identity scales are a special case of linear scales where the domain and range are identical;  the scale and its invert method are both the identity function. The identity scale accepts an array of numbers as domain or range values. The array must contain two or more numbers.  If the elements in the given array are not numbers, they will be coerced to numbers;  this coercion happens similarly when the scale is called.
 */
var com_ibm_rave_core_scales_IdentityScale = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_scales_AbstractScale, {

	//_domain : null,

	_$functionClassMethod : function() {
		var _$self = function(data, index, groupIndex) {
			return _$self.scale(data);
		};
		return _$self;
	},

	constructor : function(domain) {
		this._domain = domain.map(function(currentValue, index, array) {
			return + (currentValue);
		});
		var self = this;
		this.invert = function(y) {
			return self.scale(y);
		};
		this.ticks = function(tickArguments) {
			if (tickArguments !== null || arguments.length > 1){
				tickArguments = Array.prototype.slice.call(arguments);
			}
			{
				return com_ibm_rave_core_scales_LinearScale.linearTicks.apply(com_ibm_rave_core_scales_LinearScale, [self._domain].concat(tickArguments));
			}
		};
		this.tickFormat = function(tickArguments) {
			if (tickArguments !== null || arguments.length > 1){
				tickArguments = Array.prototype.slice.call(arguments);
			}
			{
				var count = tickArguments.length > 0 ? + (tickArguments[0]) : null;
				var format = tickArguments.length > 1 ? tickArguments[1] : null;
				return com_ibm_rave_core_scales_LinearScale.linearTickFormat(self._domain, count, ((typeof format === "string" || format instanceof String)) ? format : null);
			}
		};
	},

	/**
	 * Returns the given value x
	 * @param (Object) key   the value to apply scale to it
	 * @return (Object)  the same value passed since it is an identity scale
	 */
	/** @expose */ 
	scale : function(key) {
		return + (key);
	},

	domain$0 : function(values) {
		this._domain = (values).map(function(currentValue, index, array) {
			return + (currentValue);
		});
		return this;
	},

	domain$1 : function() {
		return this._domain;
	},

	range$0 : function(values) {
		return this.domain(values);
	},

	range$1 : function() {
		return this._domain;
	},

	/** @expose */ 
	copy : function() {
		return new com_ibm_rave_core_scales_IdentityScale(this._domain);
	},

	/** @expose */ 
	domain : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.domain$1();
		}
		return this.domain$0(a0);
	},

	/** @expose */ 
	range : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.range$1();
		}
		return this.range$0(a0);
	}
});

/**
 * Constructs a new identity scale with the default domain [0, 1] and the default  range [0, 1].
 * @return (com.ibm.rave.core.scales.IdentityScale)  the newly constructed identity scale
 */
/** @expose */ 
com_ibm_rave_core_scales_IdentityScale.newIdentityScale = function() {
	return new com_ibm_rave_core_scales_IdentityScale([0, 1]);
};


// $source: com/ibm/rave/core/scales/Scales
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/scales/LinearScale (runtime) // new
//@import com/ibm/rave/core/Rave (runtime) // Rave
//@import com/ibm/rave/core/scales/OrdinalScale (runtime) // new, OrdinalScale
//@import com/ibm/rave/core/scales/QuantizeScale (runtime) // new
//@import com/ibm/rave/core/scales/QuantileScale (runtime) // new
//@import com/ibm/rave/core/scales/LogScale (runtime) // new, LogScale
//@import com/ibm/rave/core/scales/PowScale (runtime) // new
//@import com/ibm/rave/core/scales/ThresholdScale (loadtime) // newThresholdScale
//@import com/ibm/rave/core/scales/IdentityScale (loadtime) // newIdentityScale
/**
 * Collection of built-in scales.
 */
var com_ibm_rave_core_scales_Scales = com_ibm_rave_core_nativeImpl_Declare({

	/** @expose */ 
	linear : function() {
		return new com_ibm_rave_core_scales_LinearScale(null, null, null, null);
	},

	/**
	 * Constructs a new ordinal scale with a range of ten categorical colors
	 * @return (com.ibm.rave.core.scales.OrdinalScale)  Ordinal scale 
	 */
	/** @expose */ 
	category10 : function() {
		return com_ibm_rave_core_Rave.scale.ordinal().range(com_ibm_rave_core_scales_Scales.RAVE_CAT10);
	},

	/**
	 * Constructs a new ordinal scale with a range of twenty categorical colors
	 * @return (com.ibm.rave.core.scales.OrdinalScale)  Ordinal scale 
	 */
	/** @expose */ 
	category20 : function() {
		return com_ibm_rave_core_Rave.scale.ordinal().range(com_ibm_rave_core_scales_Scales.RAVE_CAT20);
	},

	/**
	 * Constructs a new ordinal scale with a range of twenty categorical colors
	 * @return (com.ibm.rave.core.scales.OrdinalScale)  Ordinal scale 
	 */
	/** @expose */ 
	category20b : function() {
		return com_ibm_rave_core_Rave.scale.ordinal().range(com_ibm_rave_core_scales_Scales.RAVE_CAT20b);
	},

	/**
	 * Constructs a new ordinal scale with a range of twenty categorical colors
	 * @return (com.ibm.rave.core.scales.OrdinalScale)  Ordinal scale 
	 */
	/** @expose */ 
	category20c : function() {
		return com_ibm_rave_core_Rave.scale.ordinal().range(com_ibm_rave_core_scales_Scales.RAVE_CAT20c);
	},

	/** @expose */ 
	ordinal : function() {
		return new com_ibm_rave_core_scales_OrdinalScale([], com_ibm_rave_core_scales_OrdinalScale.DEFAULT_RANGER, 1.0, 0.0);
	},

	/**
	 * Construct a new quantize scale with a default domain and range [0,0,1.0]
	 * @return (com.ibm.rave.core.scales.QuantizeScale)  Quantize Scale
	 */
	/** @expose */ 
	quantize : function() {
		var scale = new com_ibm_rave_core_scales_QuantizeScale();
		var tempList = [];
		tempList.push(0.0);
		tempList.push(1.0);
		scale.range(tempList);
		scale.domain(tempList);
		return scale;
	},

	/**
	 * Construct a new quantile scale with empty domain and range
	 * @return (com.ibm.rave.core.scales.QuantileScale)  Quantile Scale
	 */
	/** @expose */ 
	quantile : function() {
		return new com_ibm_rave_core_scales_QuantileScale([], []);
	},

	/** @expose */ 
	log : function() {
		return new com_ibm_rave_core_scales_LogScale(this.linear().domain([0.0, 1.0]), com_ibm_rave_core_scales_LogScale.DEFAULT_BASE, true, [1.0, 10.0]);
	},

	/** @expose */ 
	pow : function() {
		return new com_ibm_rave_core_scales_PowScale(this.linear(), 1, [0.0, 1.0]);
	},

	/**
	 * @return (com.ibm.rave.core.scales.PowScale)  A Pow scale with a power (exponent) of 1/2.
	 */
	/** @expose */ 
	sqrt : function() {
		return this.pow().exponent(0.5);
	},

	/**
	 * Constructs a new threshold scale with the default domain [.5] and the default range [0,1].  Thus, the default threshold scale is equivalent to the round function for numbers;  for example threshold(0.49) returns 0, and threshold(0.51) returns 1.
	 * @return (com.ibm.rave.core.scales.ThresholdScale)  the newly constructed threshold scale
	 */
	/** @expose */ 
	threshold : com_ibm_rave_core_scales_ThresholdScale.newThresholdScale,

	/**
	 * Constructs a new identity scale with the default domain [0, 1] and the default  range [0, 1].
	 * @return (com.ibm.rave.core.scales.IdentityScale)  the newly constructed identity scale
	 */
	/** @expose */ 
	identity : com_ibm_rave_core_scales_IdentityScale.newIdentityScale

	//constructor : function() {}
});

/** @expose */ 
com_ibm_rave_core_scales_Scales.INSTANCE = new com_ibm_rave_core_scales_Scales();
com_ibm_rave_core_scales_Scales.RAVE_CAT10 = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"];
com_ibm_rave_core_scales_Scales.RAVE_CAT20 = ["#1f77b4", "#aec7e8", "#ff7f0e", "#ffbb78", "#2ca02c", "#98df8a", "#d62728", "#ff9896", "#9467bd", "#c5b0d5", "#8c564b", "#c49c94", "#e377c2", "#f7b6d2", "#7f7f7f", "#c7c7c7", "#bcbd22", "#dbdb8d", "#17becf", "#9edae5"];
com_ibm_rave_core_scales_Scales.RAVE_CAT20b = ["#393b79", "#5254a3", "#6b6ecf", "#9c9ede", "#637939", "#8ca252", "#b5cf6b", "#cedb9c", "#8c6d31", "#bd9e39", "#e7ba52", "#e7cb94", "#843c39", "#ad494a", "#d6616b", "#e7969c", "#7b4173", "#a55194", "#ce6dbd", "#de9ed6"];
com_ibm_rave_core_scales_Scales.RAVE_CAT20c = ["#3182bd", "#6baed6", "#9ecae1", "#c6dbef", "#e6550d", "#fd8d3c", "#fdae6b", "#fdd0a2", "#31a354", "#74c476", "#a1d99b", "#c7e9c0", "#756bb1", "#9e9ac8", "#bcbddc", "#dadaeb", "#636363", "#969696", "#bdbdbd", "#d9d9d9"];

// $source: com/ibm/rave/core/layout/Layout
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/RegistryService (loadtime) // superclass
//@import com/ibm/rave/core/layout/force/Force (runtime) // new
//@import com/ibm/rave/core/layout/BundleLayout (runtime) // new
//@import com/ibm/rave/core/layout/PackLayout (runtime) // new
//@import com/ibm/rave/core/layout/chord/ChordLayout (runtime) // new
//@import com/ibm/rave/core/layout/cluster/Cluster (runtime) // new
//@import com/ibm/rave/core/layout/StackLayout (runtime) // new
//@import com/ibm/rave/core/layout/tree/Tree (runtime) // new
//@import com/ibm/rave/core/layout/treemap/Treemap (runtime) // new
//@import com/ibm/rave/core/layout/PieLayout (runtime) // new
//@import com/ibm/rave/core/layout/HistogramLayout (runtime) // new
//@import com/ibm/rave/core/layout/hierarchy/Hierarchy (runtime) // new
//@import com/ibm/rave/core/layout/PartitionLayout (runtime) // new
var com_ibm_rave_core_layout_Layout = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_RegistryService, {

	/**
	 * creates a new instance of Force
	 * @return (com.ibm.rave.core.layout.force.Force)  new instance of Force
	 */
	/** @expose */ 
	force : function() {
		return new com_ibm_rave_core_layout_force_Force();
	},

	/**
	 * creates a new instance of BundleLayout
	 * @return (com.ibm.rave.core.layout.BundleLayout)  new instance of BundleLayout
	 */
	/** @expose */ 
	bundle : function() {
		return new com_ibm_rave_core_layout_BundleLayout();
	},

	/**
	 * Creates a new pack layout with the default settings, the default sort order  is by ascending value; the default children accessor assumes each input data is an object with a children array; the default size is 1×1.
	 * @return (com.ibm.rave.core.layout.PackLayout)  new instance of Pack
	 */
	/** @expose */ 
	pack : function() {
		return new com_ibm_rave_core_layout_PackLayout();
	},

	/**
	 * creates a new instance of Chord
	 * @return (com.ibm.rave.core.layout.chord.ChordLayout)  new instance of Chord
	 */
	/** @expose */ 
	chord : function() {
		return new com_ibm_rave_core_layout_chord_ChordLayout();
	},

	/**
	 * creates a new instance of Cluster
	 * @return (com.ibm.rave.core.layout.cluster.Cluster)  new instance of Cluster
	 */
	/** @expose */ 
	cluster : function() {
		return new com_ibm_rave_core_layout_cluster_Cluster();
	},

	/**
	 * Constructs a new stack layout with the default offset (zero) and order (null). The returned layout object is both an object and a function. That is: you can call the layout like any other function, and the layout has additional methods that change its behavior. Like other classes in Rave, layouts follow the method chaining pattern where setter methods return the layout itself, allowing multiple setters to be invoked  in a concise statement.
	 * @return (com.ibm.rave.core.layout.StackLayout)   a new stack layout instance
	 */
	/** @expose */ 
	stack : function() {
		return new com_ibm_rave_core_layout_StackLayout();
	},

	/**
	 * creates a new instance of Tree
	 * @return (com.ibm.rave.core.layout.tree.Tree)  new instance of Tree
	 */
	/** @expose */ 
	tree : function() {
		return new com_ibm_rave_core_layout_tree_Tree();
	},

	/**
	 * creates a new instance of Treemap
	 * @return (com.ibm.rave.core.layout.treemap.Treemap)  new instance of Treemap
	 */
	/** @expose */ 
	treemap : function() {
		return new com_ibm_rave_core_layout_treemap_Treemap();
	},

	/**
	 * creates a new instance of Pie
	 * @return (com.ibm.rave.core.layout.PieLayout)  new instance of Pie
	 */
	/** @expose */ 
	pie : function() {
		return new com_ibm_rave_core_layout_PieLayout();
	},

	/**
	 * creates a new instance of histogram
	 * @return (com.ibm.rave.core.layout.HistogramLayout)  new instance of histogram
	 */
	/** @expose */ 
	histogram : function() {
		return new com_ibm_rave_core_layout_HistogramLayout();
	},

	/**
	 * creates a new instance of Hierarchy
	 * @return (com.ibm.rave.core.layout.hierarchy.Hierarchy)  new instance of Hierarchy
	 */
	/** @expose */ 
	hierarchy : function() {
		return new com_ibm_rave_core_layout_hierarchy_Hierarchy();
	},

	/**
	 * Creates a new instance of PartitionLayout with the default settings, the default sort order is by descending value; the default value accessor assumes each input data is an object with a numeric value attribute; the default children accessor assumes each input data is an object with a children array; the default size is 1×1
	 * @return (com.ibm.rave.core.layout.PartitionLayout)  new instance of PartitionLayout
	 */
	/** @expose */ 
	partition : function() {
		return new com_ibm_rave_core_layout_PartitionLayout();
	}

	/**
	 * singleton
	 */
	//constructor : function() {}
});

/** @expose */ 
com_ibm_rave_core_layout_Layout.INSTANCE = new com_ibm_rave_core_layout_Layout();

// $source: com/ibm/rave/core/layout/force/Force
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare anonymous, declare
//@import com/ibm/rave/core/event/Dispatcher (runtime) // create
//@import com/ibm/rave/core/geom/QuadTree (runtime) // new
//@import com/ibm/rave/core/nativeImpl/timer/Timer (runtime) // Timer
//@import com/ibm/rave/core/internal/nativeImpl/Lang (runtime) // isNumber
//@import com/ibm/rave/core/math/Random (static) // Random
//@import com/ibm/rave/core/behavior/Behavior (runtime) // Behavior
/**
 * A flexible force-directed graph layout implementation which uses a quadtree to accelerate charge interaction using the Barnes–Hut approximation. In addition to the repulsive charge force, a pseudo-gravity force keeps nodes centered in the visible area and avoids expulsion of disconnected subgraphs, while links are fixed-distance geometric constraints (and not spring forces as is common in other force-directed layouts). This layout keeps a reference to the associated nodes and links internally; thus, a given force layout instance can only be used with a single dataset.
 */
var com_ibm_rave_core_layout_force_Force = rave_externs["Force"] = com_ibm_rave_core_nativeImpl_Declare({

	//msize : null,

	//mcharge : null,

	//mdrag : null,

	//mnodes : null,

	//mlinks : null,

	//distances : null,

	//strengths : null,

	//charges : null,

	//event : null,

	//quadTree : null,

	/**
	 * Bind a behavior to nodes to allow interactive dragging, either using the mouse or touch. Use this in conjunction with the call operator on the nodes; for example, say node.call(force.drag) on initialization. The drag event sets the fixed attribute of nodes on mouseover, such that as soon as the mouse is over a node, it stops moving. Fixing on mouseover, rather than on mousedown, makes it easier to catch moving nodes. When a mousedown event is received, and on each subsequent mousemove until mouseup, the node center is set to the current mouse position. In addition, each mousemove triggers a resume of the force layout, reheating the simulation. If you want dragged nodes to remain fixed after dragging, set the fixed attribute to true on dragstart. Implementation note: the mousemove and mouseup event listeners are registered on the current window, such that when the user starts dragging a node, they can continue to drag the node even if the mouse leaves the window. Each event listener uses the "force" namespace, so as to avoid collision with other event listeners you may wish to bind to nodes or to the window. If a node is moved by the drag behavior, the subsequent click event that would be triggered by the final mouseup is captured and the default behavior prevented. If you register a click event listener, you can ignore these clicks on drag by seeing if the default behavior was prevented.
	 */
	/** @expose */ 
	drag : null,

	//dragmove : null,

	malpha : 0,

	mfriction : 0.9,

	mlinkDistance : 20,

	mlinkStrength : 1,

	mgravity : 0.1,

	chargeDistance2 : Infinity,

	theta2 : 0.64,

	constructor : function() {
		this.msize = [1, 1];
		this.mcharge = -30;
		this.mnodes = [];
		this.mlinks = [];
		this.event = com_ibm_rave_core_event_Dispatcher.create("start", "tick", "end");
		this.quadTree = new com_ibm_rave_core_geom_QuadTree().x(com_ibm_rave_core_layout_force_Force.fx).y(com_ibm_rave_core_layout_force_Force.fy);

		{
			var self = this;
			this.drag = new (com_ibm_rave_core_nativeImpl_Declare({

				_$functionClassMethod : function() {
					var _$self = function(args) {
						if (args !== null || arguments.length > 1){
							args = Array.prototype.slice.call(arguments, 0);
						}
						{
							if (!args || args.length == 0) {
								return _$self.drag();
							}
							_$self.drag(args[0]);
							return null;
						}
					};
					return _$self;
				},

				drag$0 : function() {
					self.createDrag();
					return self.mdrag;
				},

				drag$1 : function(s) {
					self.createDrag();
					s.on("mouseover.force", com_ibm_rave_core_layout_force_Force.mouseover).on("mouseout.force", com_ibm_rave_core_layout_force_Force.mouseout).call(self.mdrag);
				},

				drag : function(a0) {
					var args = arguments;
					if (args.length == 0) {
						return this.drag$0();
					}
					return this.drag$1(a0);
				}

			}))();
			this.dragmove = function(args) {
				if (args !== null || arguments.length > 1){
					args = Array.prototype.slice.call(arguments, 0);
				}
				{
					var d = args[0];
					d["px"] = (rave.event).x;
					d["py"] = (rave.event).y;
					self.resume();
					return null;
				}
			};
		}

	},

	repulse : function(node) {
		var self = this;
		return function(quad, x1, y1, x2, y2) {
			var n = node;
			var fn = quad.data;
			if (quad.point != n) {
				var k, dx = fn.cx - n["x"], dy = fn.cy - n["y"], dw = x2 - x1, dn = dx * dx + dy * dy;
				if (dw * dw / self.theta2 < dn) {
					if (dn < self.chargeDistance2) {
						k = fn.charge / dn;
						n["px"] -= dx * k;
						n["py"] -= dy * k;
					}
					return true;
				}
				if (quad.point && dn != 0 && dn < self.chargeDistance2) {
					k = fn.pointCharge / dn;
					n["px"] -= dx * k;
					n["py"] -= dy * k;
				}
			}
			return fn.charge == 0;
		};
	},

	/**
	 * Runs the force layout simulation one step. This method can be used in conjunction with start and stop to compute a static layout. For example: <code> force.start(); for (int i = 0; i < n; ++i) force.tick(); force.stop(); </code> The number of iterations depends on the graph size and complexity. The choice of initial positions can also have a dramatic impact on how quickly the graph converges on a good solution. If you do not initialize the positions manually, the force layout will initialize them randomly, resulting in somewhat unpredictable behavior.
	 * @return (boolean)  true if the simulation has ended, false otherwise. in other words, it will return true if the layout's cooling parameter decays below some threshold and the simulation will stop. This is useful if you're calling this function in a loop and wanted to know when it is no longer necessary to call it again and break out of the loop.
	 */
	/** @expose */ 
	tick : function() {
		if ((this.malpha *= .99) < .005) {
			this.malpha = 0;
			var eo = new com_ibm_rave_core_layout_force_Force.EventObject("end", 0);
			this.event[eo.type].call(eo, eo);
			return true;
		}
		var n = this.mnodes.length, m = this.mlinks.length;
		var q;
		var i;
		var ol;
		var on;
		var s;
		var t;
		var l;
		var k;
		var x;
		var y;
		for (i = 0; i < m; ++i) {
			ol = this.mlinks[i];
			s = ol["source"];
			t = ol["target"];
			x = t["x"] - s["x"];
			y = t["y"] - s["y"];
			if ((l = (x * x + y * y)) != 0) {
				l = this.malpha * this.strengths[i] * ((l = Math.sqrt(l)) - this.distances[i]) / l;
				x *= l;
				y *= l;
				t["x"] -= x * (k = s["weight"] / (t["weight"] + s["weight"]));
				t["y"] -= y * k;
				s["x"] += x * (k = 1 - k);
				s["y"] += y * k;
			}
		}
		if ((k = this.malpha * this.mgravity) != 0) {
			x = this.msize[0] / 2;
			y = this.msize[1] / 2;
			i = -1;
			if (k != 0) {
				while (++i < n) {
					on = this.mnodes[i];
					on["x"] += (x - on["x"]) * k;
					on["y"] += (y - on["y"]) * k;
				}
			}
		}
		if ((this.mcharge)) {
			com_ibm_rave_core_layout_force_Force.forceAccumulate(q = this.quadTree.size(null)(this.mnodes), this.malpha, this.charges);
			i = -1;
			while (++i < n) {
				if (!((on = this.mnodes[i])["fixed"] > 0)) {
					q.visit(this.repulse(on));
				}
			}
		}
		i = -1;
		while (++i < n) {
			on = this.mnodes[i];
			if (on["fixed"] > 0) {
				on["x"] = on["px"];
				on["y"] = on["py"];
			} else {
				on["x"] -= (on["px"] - (on["px"] = on["x"])) * this.mfriction;
				on["y"] -= (on["py"] - (on["py"] = on["y"])) * this.mfriction;
			}
		}
		var eo = new com_ibm_rave_core_layout_force_Force.EventObject("tick", this.malpha);
		this.event[eo.type].call(eo, eo);
		return false;
	},

	/**
	 * Returns the current array of nodes associated with this layout, which defaults to the empty array.
	 * @return (com.ibm.rave.core.layout.force.ForceNode[])  the current array of nodes
	 */
	nodes$0 : function() {
		return this.mnodes;
	},

	/**
	 * Sets the array of nodes associated with this layout
	 * @param (Array) nodes the array of nodes to set
	 * @return (com.ibm.rave.core.layout.force.Force)  this layout instance itself
	 */
	nodes$1 : function(nodes) {
		this.mnodes = nodes;
		return this;
	},

	/**
	 * Returns the current array of links associated with this layout, which defaults to the empty array.
	 * @return (com.ibm.rave.core.layout.force.ForceLink[])  the current array of links
	 */
	links$0 : function() {
		return this.mlinks;
	},

	/**
	 * Sets the array of links associated with this layout
	 * @param (com.ibm.rave.core.layout.force.ForceLink[]) l the array of links to set
	 * @return (com.ibm.rave.core.layout.force.Force)  this layout instance itself
	 */
	links$1 : function(l) {
		this.mlinks = l;
		return this;
	},

	/**
	 * Returns the current size dimension object, which defaults to 1×1
	 * @return (Array)  the current size
	 */
	size$0 : function() {
		return this.msize;
	},

	/**
	 * Sets the available layout size to the specified dimension object representing width and height
	 * @param (Array) s the dimension object
	 * @return (com.ibm.rave.core.layout.force.Force)  this layout instance itself
	 */
	size$1 : function(s) {
		this.msize = s;
		return this;
	},

	/**
	 * Returns the layout's current link distance, which defaults to 20 This method behaves in the same way as linkDistance getter method
	 * @return (Object)  current link distance
	 * @see #this.linkDistance()
	 */
	distance$0 : function() {
		return this.mlinkDistance;
	},

	/**
	 * Sets the target distance between linked nodes to the specified value. The value of link distance could be a number, in which case, all links are the of the same distance. Or, it could be a function which would be evaluated for each link (in order) whenever the layout starts, and the return value of this function would be used as the link distance. The function would be be passed the link and its index and the force layout as its context. This method behaves in the same way as linkDistance getter method
	 * @param (Object) d the link distance value/function to set
	 * @return (com.ibm.rave.core.layout.force.Force)  this layout instance itself
	 * @see #this.linkDistance(Object)
	 */
	distance$1 : function(d) {
		return this.linkDistance(d);
	},

	/**
	 * Returns the layout's current link distance, which defaults to 20
	 * @return (Object)  current link distance
	 */
	linkDistance$0 : function() {
		return this.mlinkDistance;
	},

	/**
	 * Sets the target distance between linked nodes to the specified value. The value of link distance could be a number, in which case, all links are the of the same distance. Or, it could be a function which would be evaluated for each link (in order) whenever the layout starts, and the return value of this function would be used as the link distance. The function would be be passed the link and its index and the force layout as its context.
	 * @param (Object) x the link distance value/function to set
	 * @return (com.ibm.rave.core.layout.force.Force)  this layout instance itself
	 */
	linkDistance$1 : function(x) {
		this.mlinkDistance = typeof x === "function" ? x : + (x);
		return this;
	},

	/**
	 * Returns the layout's current link strength (rigidity), which defaults to 1
	 * @return (Object)  returns the layout's current link strength.
	 */
	linkStrength$0 : function() {
		return this.mlinkStrength;
	},

	/**
	 * Sets the strength (rigidity) of links to the specified value in the range [0,1] The value of link strength could be a number, in which case, all links are the of the same strength. Or, it could be a function which would be evaluated for each link (in order) whenever the layout starts, and the return value of this function would be used as the link strength. The function would be be passed the link and its index and the force layout as its context.
	 * @param (Object) x the link strength value/function to set
	 * @return (com.ibm.rave.core.layout.force.Force)  this layout instance itself
	 */
	linkStrength$1 : function(x) {
		this.mlinkStrength = typeof x === "function" ? x : + (x);
		return this;
	},

	/**
	 * Returns the current friction factor that is used to approximate velocity decay. The default value is 0.9
	 * @return (double)  the current friction factor
	 */
	friction$0 : function() {
		return this.mfriction;
	},

	/**
	 * Sets the friction coefficient to the specified value which is used to approximate velocity decay. At each tick of the simulation, the particle velocity is scaled by the specified friction coefficient. Thus, a value of 1 corresponds to a frictionless environment, while a value of 0 freezes all particles in place. Values outside the range [0,1] are not recommended and may have destabilizing effects. This value could be either a number or a string that would be parsed to a number
	 * @param (Object) f the friction coefficient value to set
	 * @return (com.ibm.rave.core.layout.force.Force)  this layout instance itself
	 */
	friction$1 : function(f) {
		this.mfriction = + (f);
		return this;
	},

	/**
	 * Returns the layout's current node charge value (rigidity), which defaults to -30
	 * @return (Object)  the current charge value
	 */
	charge$0 : function() {
		return this.mcharge;
	},

	/**
	 * Sets the charge value of nodes to the specified value. The value of node charge could be a number, in which case, all nodes are of the same charge. Or, it could be a function which would be evaluated for each node (in order) whenever the layout starts, and the return value of this function would be used as the node charge value. The function would be be passed the link and its index and the force layout as its context. A negative charge value results in node repulsion, while a positive value results in node attraction. For graph layout, negative values should be used; for n-body simulation, positive values can be used. All nodes are assumed to be infinitesimal points with equal charge and mass. Setting the charge force to zero disables some computation which can noticeably improve performance if you do not need n-body forces.
	 * @param (Object) x the node charge value/function to set
	 * @return (com.ibm.rave.core.layout.force.Force)  this layout instance itself
	 */
	charge$1 : function(x) {
		this.mcharge = typeof x === "function" ? x : + (x);
		return this;
	},

	/**
	 * Returns the current maximum charge distance over which charge forces are applied. The default value is infinity
	 * @return (double)  the current maximum charge distance
	 */
	chargeDistance$0 : function() {
		return Math.sqrt(this.chargeDistance2);
	},

	/**
	 * Sets the maximum distance over which charge forces are applied. Specifying a finite charge distance improves the performance of the force layout and produces a more localized layout.
	 * @param (double) x the maximum charge distance
	 * @return (com.ibm.rave.core.layout.force.Force)  this layout instance itself
	 */
	chargeDistance$1 : function(x) {
		this.chargeDistance2 = x * x;
		return this;
	},

	/**
	 * Returns the current gravitational strength, which defaults to 0.1
	 * @return (double)  the current gravitational strength
	 */
	gravity$0 : function() {
		return this.mgravity;
	},

	/**
	 * Sets the gravitational strength to the specified value. This value could be either a number or a string that would be parsed to a number. The name of this parameter is perhaps misleading; it does not corresponding to physical gravity (which can be simulated using a positive charge parameter). Instead, gravity is implemented as a weak geometric constraint similar to a virtual spring connecting each node to the center of the layout's size. This approach has nice properties: near the center of the layout, the gravitational strength is almost zero, avoiding any local distortion of the layout; as nodes get pushed farther away from the center, the gravitational strength becomes stronger in linear proportion to the distance. Thus, gravity will always overcome repulsive charge forces at some threshold, preventing disconnected nodes from escaping the layout. Gravity can be disabled by setting the gravitational strength to zero. If you disable gravity, it is recommended that you implement some other geometric constraint to prevent nodes from escaping the layout, such as constraining them within the layout's bounds.
	 * @param (Object) g the gravitational strength to set
	 * @return (com.ibm.rave.core.layout.force.Force)  this layout instance itself
	 */
	gravity$1 : function(g) {
		this.mgravity = + (g);
		return this;
	},

	/**
	 * Returns the value of Barnes–Hut approximation criterion, which defaults to 0.8
	 * @return (double)  the current value of Barnes–Hut approximation criterion
	 */
	theta$0 : function() {
		return Math.sqrt(this.theta2);
	},

	/**
	 * Sets the value of Barnes–Hut approximation criterion. This value could be either a number or a string that would be parsed to a number. To avoid quadratic performance slowdown for large graphs, the force layout uses the Barnes–Hut approximation which takes O(n log n) per tick. For each tick, a quadtree is created to store the current node positions; then for each node, the sum charge force of all other nodes on the given node are computed. For clusters of nodes that are far away, the charge force is approximated by treating the distance cluster of nodes as a single, larger node. Theta determines the accuracy of the computation: if the ratio of the area of a quadrant in the quadtree to the distance between a node to the quadrant's center of mass is less than theta, all nodes in the given quadrant are treated as a single, larger node rather than computed individually.
	 * @param (Object) x the value of Barnes–Hut approximation criterion to set
	 * @return (com.ibm.rave.core.layout.force.Force)  this layout instance itself
	 */
	theta$1 : function(x) {
		var xx = + (x);
		this.theta2 = xx * xx;
		return this;
	},

	/**
	 * Gets the force layout's cooling parameter value. When the layout is started, the internal alpha cooling parameter is set to 0.1
	 * @return (double)  the current value of the layout's cooling parameter
	 */
	alpha$0 : function() {
		return this.malpha;
	},

	/**
	 * Sets the force layout's cooling parameter value. If value is greater than zero, this method also restarts the force layout if it is not already running, dispatching a "start" event and enabling the tick timer. If value is nonpositive, and the force layout is running, this method stops the force layout on the next tick and dispatches an "end" event.
	 * @param (double) x the cooling parameter value to set
	 * @return (com.ibm.rave.core.layout.force.Force)  this layout instance itself
	 */
	alpha$1 : function(x) {
		if (this.malpha != 0) {
			if (x > 0) {
				this.malpha = x;
			} else {
				this.malpha = 0;
			}
		} else if (x > 0) {
			this.malpha = x;
			var eo = new com_ibm_rave_core_layout_force_Force.EventObject("start", x);
			this.event[eo.type].call(eo, eo);
			var force = this;
			com_ibm_rave_core_nativeImpl_timer_Timer.INSTANCE(function(elapsed) {
				return force.tick();
			});
		}
		return this;
	},

	/**
	 * Starts the simulation; this method must be called when the layout is first created, after assigning the nodes and links. In addition, it should be called again whenever the nodes or links change. Internally, the layout uses a cooling parameter alpha which controls the layout temperature: as the physical simulation converges on a stable layout, the temperature drops, causing nodes to move more slowly. Eventually, alpha drops below a threshold and the simulation stops completely, freeing the CPU and avoiding battery drain. The layout can be reheated using resume or by restarting; this happens automatically when using the drag behavior. On start, the layout initializes various attributes on the associated nodes. The index of each node is computed by iterating over the array, starting at zero. The initial x and y coordinates, if not already set externally to a valid number, are computed by examining neighboring nodes: if a linked node already has an initial position in x or y, the corresponding coordinates are applied to the new node. This increases the stability of the graph layout when new nodes are added, rather than using the default which is to initialize the position randomly within the layout's size. The previous px and py position is set to the initial position, if not already set, giving new nodes an initial velocity of zero. Finally, the fixed boolean defaults to false. The link distances and strengths are also computed on start. In Javascript, the layout also initializes the source and target attributes on the associated links: for convenience, these attributes may be specified as a numeric index rather than a direct link, such that the nodes and links can be read-in from a JSON file or other static description that may not allow circular linking. The source and target attributes on incoming links are only replaced with the corresponding entries in nodes if these attributes are numbers; thus, these attributes on existing links are unaffected when the layout is restarted.
	 * @return (com.ibm.rave.core.layout.force.Force)  this layout instance itself
	 */
	/** @expose */ 
	start : function() {
		var i, n = this.mnodes.length, m = this.mlinks.length;
		var w = this.msize[0], h = this.msize[1];
		for (i = 0; i < n; ++i) {
			var node = this.mnodes[i];
			node["index"] = i;
			node["weight"] = 0;
		}
		for (i = 0; i < m; ++i) {
			var link = this.mlinks[i];
			var source = link["source"];
			var target = link["target"];
			if (com_ibm_rave_core_internal_nativeImpl_Lang.isNumber(source)) {
				link["source"] = this.mnodes[(source)];
			}
			if (com_ibm_rave_core_internal_nativeImpl_Lang.isNumber(target)) {
				link["target"] = this.mnodes[(target)];
			}
			++link["source"]["weight"];
			++link["target"]["weight"];
		}
		for (i = 0; i < n; ++i) {
			var node = this.mnodes[i];
			if (isNaN(node["x"])) {
				node["x"] = this.position(true, w, i);
			}
			if (isNaN(node["y"])) {
				node["y"] = this.position(false, h, i);
			}
			if (isNaN(node["px"])) {
				node["px"] = node["x"];
			}
			if (isNaN(node["py"])) {
				node["py"] = node["y"];
			}
		}
		this.distances = [];
		if (typeof this.mlinkDistance === "function") {
			for (i = 0; i < m; ++i) {
				this.distances[i] = + ((this.mlinkDistance).call(this, this.mlinks[i], i, -1));
			}
		} else {
			for (i = 0; i < m; ++i) {
				this.distances[i] = (this.mlinkDistance);
			}
		}
		this.strengths = [];
		if (typeof this.mlinkStrength === "function") {
			for (i = 0; i < m; ++i) {
				this.strengths[i] = + ((this.mlinkStrength).call(this, this.mlinks[i], i, -1));
			}
		} else {
			for (i = 0; i < m; ++i) {
				this.strengths[i] = (this.mlinkStrength);
			}
		}
		this.charges = [];
		if (typeof this.mcharge === "function") {
			for (i = 0; i < n; ++i) {
				this.charges[i] = + ((this.mcharge).call(this, this.mnodes[i], i, -1));
			}
		} else {
			for (i = 0; i < n; ++i) {
				this.charges[i] = (this.mcharge);
			}
		}
		return this.resume();
	},

	position : function(xdim, size, i) {
		return com_ibm_rave_core_math_Random.INSTANCE.randomizerFunc() * size;
	},

	/**
	 * Sets the internal alpha parameter to 0.1, and then restarts the timer. Typically, you don't need to call this method directly; it is called automatically by start. It is also called automatically by drag during a drag gesture.
	 * @return (com.ibm.rave.core.layout.force.Force)  this layout instance itself
	 */
	/** @expose */ 
	resume : function() {
		return this.alpha(0.1);
	},

	/**
	 * Terminates the simulation, setting the cooling parameter alpha to zero. This can be used to stop the simulation explicitly, for example, if you want to show animation or allow other interaction. If you do not stop the layout explicitly, it will still stop automatically after the layout's cooling parameter decays below some threshold.
	 * @return (com.ibm.rave.core.layout.force.Force)  this layout instance itself
	 */
	/** @expose */ 
	stop : function() {
		return this.alpha(0);
	},

	/**
	 * Gets the listener for the specified event type supported by force layout: "start", "tick", and "end"
	 * @param (String) type the type of event to get the listener for
	 * @return (com.ibm.rave.core.selector.RunFunction)  the listener for the specified event or null if none was registered
	 */
	on$0 : function(type) {
		return this.event.on$0(type);
	},

	/**
	 * Registers the specified listener to receive events of the specified type from the force layout. Currently, only "start", "tick", and "end" events are supported. The "tick" events are dispatched for each tick of the simulation. Listen to tick events to update the displayed positions of nodes and links. The "end" event is dispatched when the simulations internal alpha cooling parameter reaches zero. The "start" is dispatched when the simulation starts
	 * @param (String) type the type of the force event to listen for
	 * @param (com.ibm.rave.core.selector.RunFunction) listener the listener
	 * @return (com.ibm.rave.core.layout.force.Force)  this layout instance itself
	 */
	on$1 : function(type, listener) {
		this.event.on$1(type, listener);
		return this;
	},

	createDrag : function() {
		if (!this.mdrag) {
			this.mdrag = com_ibm_rave_core_behavior_Behavior.INSTANCE.drag().origin(com_ibm_rave_core_layout_force_Force.identity).on("dragstart.force", com_ibm_rave_core_layout_force_Force.dragstart).on("drag.force", this.dragmove).on("dragend.force", com_ibm_rave_core_layout_force_Force.dragend);
		}
	},

	/** @expose */ 
	nodes : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.nodes$0();
		}
		return this.nodes$1(a0);
	},

	/** @expose */ 
	links : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.links$0();
		}
		return this.links$1(a0);
	},

	/** @expose */ 
	size : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.size$0();
		}
		return this.size$1(a0);
	},

	/** @expose */ 
	distance : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.distance$0();
		}
		return this.distance$1(a0);
	},

	/** @expose */ 
	linkDistance : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.linkDistance$0();
		}
		return this.linkDistance$1(a0);
	},

	/** @expose */ 
	linkStrength : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.linkStrength$0();
		}
		return this.linkStrength$1(a0);
	},

	/** @expose */ 
	friction : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.friction$0();
		}
		return this.friction$1(a0);
	},

	/** @expose */ 
	charge : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.charge$0();
		}
		return this.charge$1(a0);
	},

	/** @expose */ 
	chargeDistance : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.chargeDistance$0();
		}
		return this.chargeDistance$1(a0);
	},

	/** @expose */ 
	gravity : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.gravity$0();
		}
		return this.gravity$1(a0);
	},

	/** @expose */ 
	theta : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.theta$0();
		}
		return this.theta$1(a0);
	},

	/** @expose */ 
	alpha : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.alpha$0();
		}
		return this.alpha$1(a0);
	},

	/** @expose */ 
	on : function(a0, a1) {
		var args = arguments;
		if (args.length == 1) {
			return this.on$0(a0);
		}
		return this.on$1(a0, a1);
	}
});

com_ibm_rave_core_layout_force_Force.forceAccumulate = function(quad, alpha, charges) {
	var cx = 0, cy = 0;
	var fn = new com_ibm_rave_core_layout_force_Force.QuadNodeData();
	quad.data = fn;
	fn.charge = 0;
	if (!quad.leaf) {
		var nodes = quad.nodes;
		var n = nodes.length;
		var i = -1;
		var c;
		while (++i < n) {
			c = nodes[i];
			if (c) {
				com_ibm_rave_core_layout_force_Force.forceAccumulate(c, alpha, charges);
				var cfn = c.data;
				fn.charge += cfn.charge;
				cx += cfn.charge * cfn.cx;
				cy += cfn.charge * cfn.cy;
			}
		}
	}
	if (quad.point) {
		var n = quad.point;
		if (!quad.leaf) {
			n["x"] += com_ibm_rave_core_math_Random.INSTANCE.randomizerFunc() - .5;
			n["y"] += com_ibm_rave_core_math_Random.INSTANCE.randomizerFunc() - .5;
		}
		var k = alpha * charges[n["index"]];
		fn.charge += fn.pointCharge = k;
		cx += k * n["x"];
		cy += k * n["y"];
	}
	fn.cx = cx / fn.charge;
	fn.cy = cy / fn.charge;
};

/**
 * The event object fired by force layout
 */
com_ibm_rave_core_layout_force_Force.EventObject = rave_externs["EventObject"] = com_ibm_rave_core_nativeImpl_Declare({

	/**
	 * The type of the event being fired, could either: "start", "tick" or "end"
	 */
	/** @expose */ 
	type : null,

	/**
	 * The current value of the cooling parameter alpha
	 */
	/** @expose */ 
	alpha : 0,

	constructor : function(type, alpha) {
		this.type = type;
		this.alpha = alpha;
	}
});

com_ibm_rave_core_layout_force_Force.QuadNodeData = com_ibm_rave_core_nativeImpl_Declare({

	cx : 0,

	cy : 0,

	charge : 0,

	pointCharge : 0
});

com_ibm_rave_core_layout_force_Force.identity = function(data, index, groupIndex) {
	var o = {};
	o["x"] = (data)["x"];
	o["y"] = (data)["y"];
	return o;
};
com_ibm_rave_core_layout_force_Force.dragstart = function(args) {
	if (args !== null || arguments.length > 1){
		args = Array.prototype.slice.call(arguments, 0);
	}
	{
		var d = args[0];
		d["fixed"] |= 2;
		return null;
	}
};
com_ibm_rave_core_layout_force_Force.dragend = function(args) {
	if (args !== null || arguments.length > 1){
		args = Array.prototype.slice.call(arguments, 0);
	}
	{
		var d = args[0];
		d["fixed"] &= ~6;
		return null;
	}
};
com_ibm_rave_core_layout_force_Force.mouseover = function(data, index, groupIndex, event) {
	var d = data;
	d["fixed"] |= 4;
	d["px"] = d["x"];
	d["py"] = d["y"];
};
com_ibm_rave_core_layout_force_Force.mouseout = function(data, index, groupIndex, event) {
	var d = data;
	d["fixed"] &= ~4;
};
com_ibm_rave_core_layout_force_Force.fx = function(node, index) {
	return node["x"];
};
com_ibm_rave_core_layout_force_Force.fy = function(node, index) {
	return node["y"];
};

// $source: com/ibm/rave/core/behavior/Behavior
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/behavior/Drag (runtime) // new
//@import com/ibm/rave/core/behavior/Zoom (runtime) // new
//@import com/ibm/rave/core/behavior/SelectionEventHandler (runtime) // new
//@import com/ibm/rave/core/behavior/FocusEventHandler (runtime) // new
var com_ibm_rave_core_behavior_Behavior = com_ibm_rave_core_nativeImpl_Declare({

	/**
	 * Constructs a new drag behavior.
	 * @return (com.ibm.rave.core.behavior.Drag)  the newly constructed Drag behavior object.
	 */
	/** @expose */ 
	drag : function() {
		return new com_ibm_rave_core_behavior_Drag();
	},

	/**
	 * Constructs a new zoom behavior.
	 * @return (com.ibm.rave.core.behavior.Zoom)  the newly constructed Zoom behavior object.
	 */
	/** @expose */ 
	zoom : function() {
		return new com_ibm_rave_core_behavior_Zoom();
	},

	/**
	 * Constructs a selection event tracker object which tracks and fires selection events.
	 * @return (com.ibm.rave.core.behavior.SelectionEventHandler)  the newly constructed selection event tracker
	 */
	/** @expose */ 
	selectionEventHandler : function() {
		return new com_ibm_rave_core_behavior_SelectionEventHandler();
	},

	/**
	 * Constructs a focus event tracker object which tracks and fires focus and blur events.
	 * @return (com.ibm.rave.core.behavior.FocusEventHandler)  the newly constructed focus event tracker
	 */
	/** @expose */ 
	focusEventHandler : function() {
		return new com_ibm_rave_core_behavior_FocusEventHandler();
	}

	//constructor : function() {}
});

/** @expose */ 
com_ibm_rave_core_behavior_Behavior.INSTANCE = new com_ibm_rave_core_behavior_Behavior();

// $source: com/ibm/rave/core/internal/event/CustomDispatcher
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/event/Dispatcher (loadtime) // superclass
/**
 * Like  {@link (com.ibm.rave.core.event.Dispatcher) Dispatcher} , but for custom events abstracting native UI events. These events have a target component (such as a brush), a target element (such as the svg:g element containing the brush) and the standard arguments 'd' (the target element's data) and 'i' (the selection index of the target element).
 */
var com_ibm_rave_core_internal_event_CustomDispatcher = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_event_Dispatcher, {

	//target : null,

	of : function(context, args) {
		if (args !== null || arguments.length > 2){
			args = Array.prototype.slice.call(arguments, 1);
		}
		{
			var self = this;
			return function(e1) {
				var list = (args).slice();
				list.push(e1);
				var e0 = e1.sourceEvent = rave.event;
				e1.target = self.target;
				rave.event = e1;
				try {
					self[e1.type].apply(context, list);
				} finally {
					rave.event = e0;
				}
			};
		}
	}

	//constructor : function() {}
});

com_ibm_rave_core_internal_event_CustomDispatcher.create$0 = function(target, types) {
	if (types !== null || arguments.length > 2){
		types = Array.prototype.slice.call(arguments, 1);
	}
	{
		var dispatch = new com_ibm_rave_core_internal_event_CustomDispatcher();
		dispatch.init.apply(dispatch, types);
		dispatch.target = target;
		return dispatch;
	}
};

com_ibm_rave_core_internal_event_CustomDispatcher.create = function(a0, a1) {
	var args = arguments;
	return com_ibm_rave_core_internal_event_CustomDispatcher.create$0.apply(this, args);
};


// $source: com/ibm/rave/core/internal/nativeImpl/event/DragSuppress
/************************************************************************
** IBM Confidential
**
** IBM Business Analytics: Rapidly Adaptive Visualization Engine
**
** (C) Copyright IBM Corp. 2014, 2015
**
** The source code for this program is not published or otherwise divested of its trade secrets, 
** irrespective of what has been deposited with the U.S. Copyright Office.
************************************************************************/
// @import com/ibm/rave/core/nativeImpl/event/EventTracker
// @import com/ibm/rave/core/internal/nativeImpl/Vendor

var com_ibm_rave_core_internal_nativeImpl_event_DragSuppress = (function() {
	var dragSelect, dragId = 0;
			
	function preventDefault() {
		rave.event.preventDefault();
	};
			
	function dragSuppress(node) {
		var name = ".dragsuppress-" + ++dragId,
			click = "click" + name,
			w = rave.select(com_ibm_rave_core_internal_nativeImpl_PlatformInitialization.getWindow(node))
				.on("touchmove" + name, preventDefault)
				.on("dragstart" + name, preventDefault)
				.on("selectstart" + name, preventDefault);
		if (dragSelect == null) {
			var docElement = rave_documentElement(node);
			dragSelect = "onselectstart" in docElement ? false : vendorSymbol(docElement.style, "userSelect");
		}
		if (dragSelect) {
			var style = rave_documentElement(node).style,
				select = style[dragSelect];
			style[dragSelect] = "none";
		}
		return function(suppressClick) {
			function off() {
				w.on(click, null);
			}
			w.on(name, null);
			if (dragSelect)
				style[dragSelect] = select;
			if (suppressClick) { // suppress the next click, but only if it’s immediate
				w.on(click, function() {
					preventDefault();
					off();
				}, true);
				setTimeout(off, 0);
			}
		};
	}

	return {
	    dragSuppress : dragSuppress
	};
})();
// $source: com/ibm/rave/core/event/BaseEvent
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
/**
 * A base class for all events which have a type and a target.
 * @param < (java.lang.Object) T > the target type
 */
var com_ibm_rave_core_event_BaseEvent = rave_externs["BaseEvent"] = com_ibm_rave_core_nativeImpl_Declare({

	/**
	 * The name of the event (case-insensitive).
	 */
	/** @expose */ 
	type : null,

	/**
	 * A reference to the event that occurred prior to this event.
	 */
	/** @expose */ 
	sourceEvent : null,

	/**
	 * A reference to the target to which the event was originally dispatched.
	 */
	/** @expose */ 
	target : null,

	/**
	 * Create a new event.
	 * @param (String) type the event type
	 */
	/** @expose */ 
	constructor : function(type) {
		this.type = type;
	}
});


// $source: com/ibm/rave/core/behavior/Drag
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/event/CustomDispatcher (runtime) // create
//@import com/ibm/rave/core/internal/nativeImpl/PlatformInitialization (runtime) // getWindow
//@import com/ibm/rave/core/internal/util/Identity (runtime) // create
//@import com/ibm/rave/core/nativeImpl/event/Mouse (runtime) // mousePoint
//@import com/ibm/rave/core/event/TouchUtil (runtime) // touchFromSource
//@import com/ibm/rave/core/Rave (runtime) // select
//@import com/ibm/rave/core/internal/nativeImpl/event/DragSuppress (runtime) // dragSuppress
//@import com/ibm/rave/core/event/BaseEvent (loadtime) // superclass
var com_ibm_rave_core_behavior_Drag = rave_externs["Drag"] = com_ibm_rave_core_nativeImpl_Declare({

	//event : null,

	//originFunc : null,

	//rave_window : null,

	//identity : null,

	//dragTouchId : null,

	//mousedowned : null,

	//touchstart : null,

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * @see RunFunction#_$self.run(Object, )
		 */
		function(args) {
			if (args !== null || arguments.length > 1){
				args = Array.prototype.slice.call(arguments, 0);
			}
			{
				if (!args || args.length == 0) {
					return _$self;
				}
				_$self.drag(args[0]);
				return null;
			}
		};
		return _$self;
	},

	constructor : function() {
		this.event = com_ibm_rave_core_internal_event_CustomDispatcher.create$0(this, "drag", "dragstart", "dragend");
		this.rave_window = function(data, index, groupIndex) {
			return com_ibm_rave_core_internal_nativeImpl_PlatformInitialization.getWindow(data);
		};
		this.identity = com_ibm_rave_core_internal_util_Identity.create();
		this.dragTouchId = function() {
			return (rave.event).changedTouches[0].identifier;
		};
		this.mousedowned = this.dragStart(null, function(node, id) {
			return com_ibm_rave_core_nativeImpl_event_Mouse.mousePoint(node);
		}, this.rave_window, "mousemove", "mouseup");
		this.touchstart = this.dragStart(this.dragTouchId, function(node, id) {
			return com_ibm_rave_core_event_TouchUtil.touchFromSource(node, id);
		}, this.identity, "touchmove", "touchend");
	},

	/**
	 * Creates event listeners to handle drag gestures on an element. Both mouse events and touch events are supported.
	 * @param (com.ibm.rave.core.selector.Selector) g
	 */
	/** @expose */ 
	drag : function(g) {
		g.on("mousedown.drag", this.mousedowned).on("touchstart.drag", this.touchstart);
	},

	dragStart : function(id, position, subject, move, end) {
		var self = this;
		return function(data, index, groupIndex, event) {
			var target = rave.event.target;
			var parent = this.rave_getParentNode();
			var dispatch = self.event.of(this, data, index, groupIndex);
			var dragged = [0];
			var dragId = id ? id() : null;
			var dragName = ".drag" + (dragId == null ? "" : "-" + dragId);
			var dragOffset;
			var dragSubject = com_ibm_rave_core_Rave.select(subject.call(this, target, index, groupIndex));
			var dragRestore = com_ibm_rave_core_internal_nativeImpl_event_DragSuppress.dragSuppress(target);
			var position0 = position(parent, dragId);
			if (self.originFunc) {
				var value = self.originFunc.call(this, data, index, groupIndex);
				dragOffset = [value["x"] - position0[0], value["y"] - position0[1]];
			} else {
				dragOffset = [0, 0];
			}
			dispatch(new com_ibm_rave_core_behavior_Drag.EventObject("dragstart", 0, 0, 0, 0));
			var moved = function(data, index, groupIndex, event) {
				var position1 = position(parent, dragId);
				if (!position1) {
					return;
				}
				var dx = position1[0] - position0[0];
				var dy = position1[1] - position0[1];
				dragged |= ~~dx | ~~dy;
				position0 = position1;
				dispatch(new com_ibm_rave_core_behavior_Drag.EventObject("drag", position1[0] + dragOffset[0], position1[1] + dragOffset[1], dx, dy));
			};
			var ended = function(data, index, groupIndex, event) {
				if (!position(parent, dragId)) {
					return;
				}
				dragSubject.on(move + dragName, null).on(end + dragName, null);
				dragRestore(dragged != 0 && rave.event.target == target);
				dispatch(new com_ibm_rave_core_behavior_Drag.EventObject("dragend", 0, 0, 0, 0));
			};
			dragSubject.on(move + dragName, moved).on(end + dragName, ended);
		};
	},

	/**
	 * If origin is specified, sets the origin accessor to the specified function. If origin is not specified, returns the current origin accessor which defaults to null. The origin accessor function is used to determine the starting position (the “origin”) of the element being dragged; this allows the drag behavior to preserve the offset between the mouse position and the starting element position during drag. If the origin accessor is null, then the element position is set to the mouse position on drag; this can cause a noticeable jump on large elements. If an origin accessor is specified, the function is called on mousedown. The function is invoked in the same manner as other operator functions, being passed the current datum d and index i, with the this context as the clicked-on DOM element. To access the current event, use the global d3.event. The origin accessor must return an object with x and y properties representing the starting coordinates of the element being dragged. Frequently the origin accessor is specified as the identity function: function(d) { return d; }. This is suitable when the datum bound to the dragged element is already an object with x and y attributes representing its current position.
	 * @return (com.ibm.rave.core.selector.ValueFunction)  the origin function
	 */
	origin$0 : function() {
		return this.originFunc;
	},

	/**
	 * If origin is specified, sets the origin accessor to the specified function. If origin is not specified, returns the current origin accessor which defaults to null. The origin accessor function is used to determine the starting position (the “origin”) of the element being dragged; this allows the drag behavior to preserve the offset between the mouse position and the starting element position during drag. If the origin accessor is null, then the element position is set to the mouse position on drag; this can cause a noticeable jump on large elements. If an origin accessor is specified, the function is called on mousedown. The function is invoked in the same manner as other operator functions, being passed the current datum d and index i, with the this context as the clicked-on DOM element. To access the current event, use the global d3.event. The origin accessor must return an object with x and y properties representing the starting coordinates of the element being dragged. Frequently the origin accessor is specified as the identity function: function(d) { return d; }. This is suitable when the datum bound to the dragged element is already an object with x and y attributes representing its current position.
	 * @param (com.ibm.rave.core.selector.ValueFunction) x The origin function
	 * @return (com.ibm.rave.core.behavior.Drag)  this isntance of Drag
	 */
	origin$1 : function(x) {
		this.originFunc = x;
		return this;
	},

	/**
	 * Registers the specified listener to receive events of the specified type from the drag behavior. If no listener is specified, returns the currently-registered listener for the specified event type. (The type may include a namespace; see dispatch.on for additional details.) The following events are supported: dragstart - when a drag gesture starts. drag - when the drag gesture moves. dragend - when the drag gesture finishes. Drag events (but not dragstart and dragend events) expose "x" and "y" properties representing the current position of the drag gesture in local coordinates. By default, this position is simply the mouse (or touch) position; however, the position can be modified by specifying an origin. The drag event also exposes "dx" and "dy" properties representing the element’s coordinates relative to its position at the beginning of the gesture, which is occasionally more convenient than specifying an explicit origin. During a drag gesture, some browser default behaviors (such as text selection) are prevented. In addition, the default behavior for a click event immediately a non-empty drag gesture is prevented, so as to allow the dragging of links. When registering your own click listener on draggable elements, you can check whether the click event was suppressed as follows: selection.on("click", function() { if (d3.event.defaultPrevented) return; // click suppressed console.log("clicked!"); }); When combining drag behaviors with other event listeners for interaction events, you may also consider stopping propagation on the source event to prevent multiple actions: drag.on("dragstart", function() { d3.event.sourceEvent.stopPropagation(); // silence other listeners });
	 * @param (String) type the specified event type
	 * @return (com.ibm.rave.core.selector.RunFunction)  the currently-registered listener for the specified event type
	 */
	on$0 : function(type) {
		return this.event.on$0(type);
	},

	/**
	 * Registers the specified listener to receive events of the specified type from the drag behavior. If no listener is specified, returns the currently-registered listener for the specified event type. (The type may include a namespace; see dispatch.on for additional details.) The following events are supported: dragstart - when a drag gesture starts. drag - when the drag gesture moves. dragend - when the drag gesture finishes. Drag events (but not dragstart and dragend events) expose "x" and "y" properties representing the current position of the drag gesture in local coordinates. By default, this position is simply the mouse (or touch) position; however, the position can be modified by specifying an origin. The drag event also exposes "dx" and "dy" properties representing the element’s coordinates relative to its position at the beginning of the gesture, which is occasionally more convenient than specifying an explicit origin. During a drag gesture, some browser default behaviors (such as text selection) are prevented. In addition, the default behavior for a click event immediately a non-empty drag gesture is prevented, so as to allow the dragging of links. When registering your own click listener on draggable elements, you can check whether the click event was suppressed as follows: selection.on("click", function() { if (d3.event.defaultPrevented) return; // click suppressed console.log("clicked!"); }); When combining drag behaviors with other event listeners for interaction events, you may also consider stopping propagation on the source event to prevent multiple actions: drag.on("dragstart", function() { d3.event.sourceEvent.stopPropagation(); // silence other listeners });
	 * @param (com.ibm.rave.core.selector.RunFunction) listener the listener to recieve events
	 * @return (com.ibm.rave.core.behavior.Drag)  this instance of Drag
	 */
	on$1 : function(type, listener) {
		this.event.on$1(type, listener);
		return this;
	},

	/** @expose */ 
	origin : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.origin$0();
		}
		return this.origin$1(a0);
	},

	/** @expose */ 
	on : function(a0, a1) {
		var args = arguments;
		if (args.length == 1) {
			return this.on$0(a0);
		}
		return this.on$1(a0, a1);
	}
});

/**
 * The drag event object class.
 */
com_ibm_rave_core_behavior_Drag.EventObject = rave_externs["EventObject"] = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_event_BaseEvent, {

	/** @expose */ 
	x : 0,

	/** @expose */ 
	y : 0,

	/** @expose */ 
	dx : 0,

	/** @expose */ 
	dy : 0,

	constructor : function(type, x, y, dx, dy) {
		this.x = x;
		this.y = y;
		this.dx = dx;
		this.dy = dy;
	}
});


// $source: com/ibm/rave/core/behavior/Zoom
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare, bind
//@import com/ibm/rave/core/internal/event/CustomDispatcher (runtime) // create
//@import com/ibm/rave/core/nativeImpl/event/Mouse (runtime) // mousePoint
//@import com/ibm/rave/core/internal/nativeImpl/event/DragSuppress (runtime) // dragSuppress
//@import com/ibm/rave/core/Rave (runtime) // selectAll, select
//@import com/ibm/rave/core/internal/nativeImpl/PlatformInitialization (runtime) // getWindow
//@import com/ibm/rave/core/internal/transitions/TransitionUtil (runtime) // interrupt
//@import com/ibm/rave/core/nativeImpl/event/Touches (runtime) // touches
//@import com/ibm/rave/core/internal/nativeImpl/transitions/InheritedTransition (runtime) // get
//@import com/ibm/rave/core/interpolate/ZoomInterpolation (runtime) // ZoomInterpolation
//@import com/ibm/rave/core/event/BaseEvent (loadtime) // superclass
/**
 * A class that implements the Zoom behavior which automatically creates event listeners to handle zooming and panning gestures on a container element. Both mouse and touch events are supported.
 */
var com_ibm_rave_core_behavior_Zoom = rave_externs["Zoom"] = com_ibm_rave_core_nativeImpl_Declare({

	//_event : null,

	//mousewheelTimer : null,

	//sx0 : null, //sx1 : null, //sy0 : null, //sy1 : null,

	//view : null,

	//translate0 : null,

	//center0 : null,

	//_center : null,

	//_size : null,

	//_scaleExtent : null,

	//mousedowned : null,

	//touchstarted : null,

	//dblclicked : null,

	//mousewheeled : null,

	touchtime : NaN,

	_duration : 250,

	zooming : 0,

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * @see RunFunction#_$self.run(Object, Object...)
		 */
		function(args) {
			if (args !== null || arguments.length > 1){
				args = Array.prototype.slice.call(arguments, 0);
			}
			{
				_$self.zoom(args[0]);
				return null;
			}
		};
		return _$self;
	},

	constructor : function() {
		this._event = com_ibm_rave_core_internal_event_CustomDispatcher.create$0(this, "zoomstart", "zoom", "zoomend");
		this.view = new com_ibm_rave_core_behavior_Zoom.View(0, 0, 1);
		this._size = [960, 500];
		this._scaleExtent = com_ibm_rave_core_behavior_Zoom.zoomInfinity;

		{
			var self = this;
			this.mousedowned = function(data, index, groupIndex, e) {
				var that = this;
				var location0 = self.location(com_ibm_rave_core_nativeImpl_event_Mouse.mousePoint(that));
				var dragRestore = com_ibm_rave_core_internal_nativeImpl_event_DragSuppress.dragSuppress(that);
				var target = rave.event.target;
				var dispatch = self._event.of(that, data, index, groupIndex);
				var dragged;
				var subject = com_ibm_rave_core_Rave.select(com_ibm_rave_core_internal_nativeImpl_PlatformInitialization.getWindow(that));
				var moved = function(data1, index1, groupIndex1, event) {
					dragged = true;
					self.translateTo(com_ibm_rave_core_nativeImpl_event_Mouse.mousePoint(that), location0);
					self.zoomed(dispatch);
				};
				var ended = function(data2, index2, groupIndex2, event) {
					subject.on("mousemove.zoom", null).on("mouseup.zoom", null);
					dragRestore(dragged && rave.event.target == target);
					self.zoomended(dispatch);
				};
				subject.on("mousemove.zoom", moved).on("mouseup.zoom", ended);
				com_ibm_rave_core_internal_transitions_TransitionUtil.interrupt(this);
				self.zoomstarted(dispatch);
			};
			this.touchstarted = function(data, index, groupIndex, e) {
				var that = this;
				var dragRestore = com_ibm_rave_core_internal_nativeImpl_event_DragSuppress.dragSuppress(that);
				var dispatch = self._event.of(that, data, index, groupIndex);
				var subject = com_ibm_rave_core_Rave.select(that);
				var zoomName = ".zoom-" + (rave.event).changedTouches[0].identifier;
				var touchmove = "touchmove" + zoomName;
				var touchend = "touchend" + zoomName;
				var targets = [];
				var locations0 = {};
				var distance0 = 0, scale0;
				var relocate = function() {
					var touches = com_ibm_rave_core_nativeImpl_event_Touches.touches(that);
					scale0 = self.view.k;
					for (var __i_enFor0 = 0, __exp_enFor0 = touches, __len_enFor0 = __exp_enFor0.length;
							__i_enFor0 < __len_enFor0; ++__i_enFor0) {
						var t = __exp_enFor0[__i_enFor0];
						if (locations0.hasOwnProperty(t["identifier"])) {
							locations0[t["identifier"]] = self.location(t);
						}
					}
					return touches;
				};
				var moved = function(data1, index1, groupIndex1, event) {
					var touches = com_ibm_rave_core_nativeImpl_event_Touches.touches(that);
					com_ibm_rave_core_internal_transitions_TransitionUtil.interrupt(this);
					var p0 = null, p1 = null;
					var l0 = null, l1 = null;
					for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
						p1 = touches[i];
						if ((l1 = locations0[p1["identifier"]])) {
							if (l0) {
								break;
							}
							p0 = p1;
							l0 = l1;
						}
					}
					if (l1) {
						var temp;
						var distance1 = (temp = p1[0] - p0[0]) * temp + (temp = p1[1] - p0[1]) * temp;
						var scale1 = 0;
						if (distance0 != 0) {
							scale1 = Math.sqrt(distance1 / distance0);
						}
						p0 = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
						l0 = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
						self.scaleTo(scale1 * scale0);
					}
					self.touchtime = NaN;
					self.translateTo(p0, l0);
					self.zoomed(dispatch);
				};
				var ended = function(data1, index1, groupIndex1, event) {
					var toucheEvent = rave.event;
					if (toucheEvent.touches.length != 0) {
						var changed = toucheEvent.changedTouches;
						for (var i = 0, n = changed.length; i < n; ++i) {
							delete locations0[changed[i].identifier];
						}
						for (var __i_enFor0 = 0, __exp_enFor0 = Object.keys(locations0), __len_enFor0 = __exp_enFor0.length;
								__i_enFor0 < __len_enFor0; ++__i_enFor0) {
							var identifier = __exp_enFor0[__i_enFor0];
							relocate();
							return;
						}
					}
					com_ibm_rave_core_Rave.selectAll(targets).on(zoomName, null);
					subject.on("mousedown.zoom", self.mousedowned).on("touchstart.zoom", self.touchstarted);
					dragRestore(false);
					self.zoomended(dispatch);
				};
				var started = function(data1, index1, groupIndex1, event) {
					var touchEvent = rave.event;
					var target = touchEvent.target;
					com_ibm_rave_core_Rave.select(target).on(touchmove, moved).on(touchend, ended);
					targets.push(target);
					var changed = touchEvent.changedTouches;
					for (var i = 0, n = changed.length; i < n; ++i) {
						locations0[changed[i].identifier] = null;
					}
					var touches = relocate();
					var now = Date.now();
					if (touches.length == 1) {
						if (now - self.touchtime < 500) {
							var p = touches[0];
							self.zoomTo(that, p, locations0[p["identifier"]], Math.floor(Math.log(self.view.k) / Math["LN2"]) + 1);
							rave.event.preventDefault();
						}
						self.touchtime = now;
					} else if (touches.length > 1) {
						var p = touches[0];
						var q = touches[1];
						var dx = p[0] - q[0];
						var dy = p[1] - q[1];
						distance0 = dx * dx + dy * dy;
					}
				};
				subject.on("mousedown.zoom", null).on("touchstart.zoom", started);
				started.call(null, null, -1, -1, null);
				self.zoomstarted(dispatch);
			};
			this.dblclicked = function(data, index, groupIndex, e) {
				var p = com_ibm_rave_core_nativeImpl_event_Mouse.mousePoint(this);
				var k = Math.log(self.view.k) / Math["LN2"];
				self.zoomTo(this, p, self.location(p), (rave.event).shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
			};
			this.mousewheeled = function(data, index, groupIndex, e) {
				var dispatch = self._event.of(this, data, index, groupIndex);
				if (self.mousewheelTimer != null) {
					clearTimeout(self.mousewheelTimer);
				} else {
					self.center0 = self._center ? self._center : com_ibm_rave_core_nativeImpl_event_Mouse.mousePoint(this);
					self.translate0 = self.location(self.center0);
					com_ibm_rave_core_internal_transitions_TransitionUtil.interrupt(this);
					self.zoomstarted(dispatch);
				}
				self.mousewheelTimer = setTimeout(function() {
					self.mousewheelTimer = null;
					self.zoomended(dispatch);
				}, 50);
				rave.event.preventDefault();
				self.scaleTo(Math.pow(2, com_ibm_rave_core_behavior_Zoom.zoomDelta() * .002) * self.view.k);
				self.translateTo(self.center0, self.translate0);
				self.zoomed(dispatch);
			};
		}

	},

	/**
	 * Applies the zoom behavior to the specified selection, registering the necessary event listeners to support panning and zooming.
	 * @param (com.ibm.rave.core.selector.Selector) g the selector to apply zoom behavior on
	 */
	/** @expose */ 
	zoom : com_ibm_rave_core_nativeImpl_Declare.bind(function(g) {
		g.on("mousedown.zoom", this.mousedowned).on("wheel" + ".zoom", this.mousewheeled).on("dblclick.zoom", this.dblclicked).on("touchstart.zoom", this.touchstarted);
	}),

	/**
	 * Triggers zoom events based on the type of the selection passed: If selection is a selection, immediately dispatches a zoom gesture to registered listeners, as the three event sequence zoomstart, zoom and zoomend. This can be useful in triggering listeners after setting the translate or scale programatically. If selection is a transition, registers the appropriate tweens so that the zoom behavior dispatches events over the course of the transition: a zoomstart event when the transition starts from the previously-set view, zoom events for each tick of the transition, and finally a zoomend event when the transition ends. Note that the transition will be interrupted if the user starts zooming before the transition ends.
	 * @param (com.ibm.rave.core.selector.Selection) g the selection to trigger events for
	 */
	/** @expose */ 
	event : com_ibm_rave_core_nativeImpl_Declare.bind(function(g) {
		var self = this;
		g.each(function(data, index, groupIndex) {
			var dispatch = self._event.of(this, data, index, groupIndex);
			var view1 = self.view;
			if (com_ibm_rave_core_internal_nativeImpl_transitions_InheritedTransition.get()) {
				com_ibm_rave_core_Rave.select(this).transition().each("start.zoom", function(args) {
					if (args !== null || arguments.length > 1){
						args = Array.prototype.slice.call(arguments, 0);
					}
					{
						var temp = this.rave_getProperty("__chart__");
						if (temp == null) {
							self.view = new com_ibm_rave_core_behavior_Zoom.View(0, 0, 1);
						} else {
							self.view = temp;
						}
						self.zoomstarted(dispatch);
						return null;
					}
				}).tween("zoom:zoom", function(data1, index1, groupIndex1) {
					var dx = self._size[0], dy = self._size[1], cx = self.center0 ? self.center0[0] : dx / 2, cy = self.center0 ? self.center0[1] : dy / 2;
					var p0 = [(cx - self.view.x) / self.view.k, (cy - self.view.y) / self.view.k, dx / self.view.k];
					var p1 = [(cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k];
					var i = com_ibm_rave_core_interpolate_ZoomInterpolation.INSTANCE(p0, p1);
					return function(t) {
						var l = i(t);
						var k = dx / l[2];
						self.view = new com_ibm_rave_core_behavior_Zoom.View(cx - l[0] * k, cy - l[1] * k, k);
						this.rave_setProperty("__chart__", self.view);
						self.zoomed(dispatch);
					};
				}).each("interrupt.zoom", function(args) {
					if (args !== null || arguments.length > 1){
						args = Array.prototype.slice.call(arguments, 0);
					}
					{
						self.zoomended(dispatch);
						return null;
					}
				}).each("end.zoom", function(args) {
					if (args !== null || arguments.length > 1){
						args = Array.prototype.slice.call(arguments, 0);
					}
					{
						self.zoomended(dispatch);
						return null;
					}
				});
			} else {
				this.rave_setProperty("__chart__", self.view);
				self.zoomstarted(dispatch);
				self.zoomed(dispatch);
				self.zoomended(dispatch);
			}
		});
	}),

	/**
	 * Returns the current translation vector, which defaults to a point of [0, 0].
	 * @return (Array)  the current translation vector
	 */
	translate$0 : function() {
		return [this.view.x, this.view.y];
	},

	/**
	 * Specifies the current zoom translation vector.
	 * @param (Array) point the zoom translation vector to set
	 * @return (com.ibm.rave.core.behavior.Zoom)  this zoom instance itself
	 */
	translate$1 : function(point) {
		this.view = new com_ibm_rave_core_behavior_Zoom.View(point[0], point[1], this.view.k);
		this.rescale();
		return this;
	},

	/**
	 * Returns the current zoom scale, which defaults to 1.
	 * @return (double)  the current zoom scale factor
	 */
	scale$0 : function() {
		return this.view.k;
	},

	/**
	 * Specifies the current zoom scale.
	 * @param (double) s the zoom scale to set
	 * @return (com.ibm.rave.core.behavior.Zoom)  this zoom instance itself
	 */
	scale$1 : function(s) {
		this.view = new com_ibm_rave_core_behavior_Zoom.View(this.view.x, this.view.y, s);
		this.rescale();
		return this;
	},

	/**
	 * Returns the current scale extent dimension object, which defaults to a minimum of 0 and maximum of Infinity.
	 * @return (Array)  scale extent dimension object
	 */
	scaleExtent$0 : function() {
		return this._scaleExtent;
	},

	/**
	 * Specifies the zoom scale's allowed range as dimension object with minimum, maximum values.
	 * @param (Array) dim the dimension object where w represent the minimum value and h represent the maximum value
	 * @return (com.ibm.rave.core.behavior.Zoom)  this zoom instance itself
	 */
	scaleExtent$1 : function(dim) {
		this._scaleExtent = !dim ? com_ibm_rave_core_behavior_Zoom.zoomInfinity : [dim[0], dim[1]];
		return this;
	},

	/**
	 * Returns the current focal point, which defaults to null. A null center indicates that mousewheel zooming should zoom in and out around the current mouse location.
	 * @return (Array)  the current focal point
	 */
	center$0 : function() {
		return this._center;
	},

	/**
	 * Sets the focal point [x, y] for mousewheel zooming.
	 * @param (Array) p the focal point to set
	 * @return (com.ibm.rave.core.behavior.Zoom)  this zoom instance itself
	 */
	center$1 : function(p) {
		this._center = p ? [p[0], p[1]] : null;
		return this;
	},

	/**
	 * The Duration of the zoom transition
	 * @return (double)  zoom transition duration
	 */
	duration$0 : function() {
		return this._duration;
	},

	/**
	 * Sets the zoom transition duration
	 * @param (double) duration the zoom transition duration value
	 * @return (com.ibm.rave.core.behavior.Zoom)  this zoom instance itself
	 */
	duration$1 : function(duration) {
		this._duration = duration;
		return this;
	},

	/**
	 * Returns the current viewport size which defaults to [960, 500]. A size is needed to support smooth zooming during transitions.
	 * @return (Array)  the current viewport size
	 */
	size$0 : function() {
		return this._size;
	},

	/**
	 * If size is specified, sets the viewport size to the specified dimensions [width, height] and returns this zoom behavior.
	 * @param (Array) p the zoom viewport size
	 * @return (com.ibm.rave.core.behavior.Zoom)  this zoom instance itself
	 */
	size$1 : function(p) {
		this._size = p ? [p[0], p[1]] : null;
		return this;
	},

	/**
	 * Returns the current x-scale, which defaults to null
	 * @return (com.ibm.rave.core.scales.AbstractScale)  the current x-scale
	 */
	x$0 : function() {
		return this.sx1;
	},

	/**
	 * Specifies an x-scale whose domain should be automatically adjusted when zooming. If the scale's domain or range is modified programmatically, this function should be called again. Setting the x-scale also resets the scale to 1 and the translate to [0, 0].
	 * @param (com.ibm.rave.core.scales.AbstractScale) z the x-scale
	 * @return (com.ibm.rave.core.behavior.Zoom)  this zoom instance itself
	 */
	x$1 : function(z) {
		this.sx1 = z;
		this.sx0 = z.copy();
		this.view = new com_ibm_rave_core_behavior_Zoom.View(0, 0, 1);
		return this;
	},

	/**
	 * Returns the current y-scale, which defaults to null.
	 * @return (com.ibm.rave.core.scales.AbstractScale)  the current y-scale
	 */
	y$0 : function() {
		return this.sy1;
	},

	/**
	 * Specifies an y-scale whose domain should be automatically adjusted when zooming. If the scale's domain or range is modified programmatically, this function should be called again. Setting the y-scale also resets the scale to 1 and the translate to [0, 0].
	 * @param (com.ibm.rave.core.scales.AbstractScale) z the y-scale
	 * @return (com.ibm.rave.core.behavior.Zoom)  this zoom instance itself
	 */
	y$1 : function(z) {
		this.sy1 = z;
		this.sy0 = z.copy();
		this.view = new com_ibm_rave_core_behavior_Zoom.View(0, 0, 1);
		return this;
	},

	location : function(p) {
		return [(p[0] - this.view.x) / this.view.k, (p[1] - this.view.y) / this.view.k];
	},

	point : function(l) {
		return [l[0] * this.view.k + this.view.x, l[1] * this.view.k + this.view.y];
	},

	scaleTo : function(s) {
		this.view.k = Math.max(this._scaleExtent[0], Math.min(this._scaleExtent[1], s));
	},

	translateTo : function(p, l) {
		var _l = this.point(l);
		this.view.x += p[0] - _l[0];
		this.view.y += p[1] - _l[1];
	},

	rescale : function() {
		if (this.sx1) {
			if (this.sx1.zoomTransform) {
				this.sx1.zoomTransform(this.view.k, this.view.x);
			} else {
				var ro = this.sx0.range();
				var r = new Array(ro.length);
				for (var i = 0, len = ro.length; i < len; ++i) {
					r[i] = this.sx0.invert(+ ((ro[i] - this.view.x) / this.view.k));
				}
				this.sx1.domain(r);
			}
		}
		if (this.sy1) {
			if (this.sy1.zoomTransform) {
				this.sy1.zoomTransform(this.view.k, this.view.y);
			} else {
				var ro = this.sy0.range();
				var r = new Array(ro.length);
				for (var i = 0, len = ro.length; i < len; ++i) {
					r[i] = this.sy0.invert(+ ((ro[i] - this.view.y) / this.view.k));
				}
				this.sy1.domain(r);
			}
		}
	},

	zoomstarted : function(dispatch) {
		if (this.zooming++ != 0) {
			dispatch(new com_ibm_rave_core_behavior_Zoom.EventObject("zoomstart", 0, null));
		}
	},

	zoomed : function(dispatch) {
		this.rescale();
		dispatch(new com_ibm_rave_core_behavior_Zoom.EventObject("zoom", this.view.k, [this.view.x, this.view.y]));
	},

	zoomended : function(dispatch) {
		if (--this.zooming == 0) {
			dispatch(new com_ibm_rave_core_behavior_Zoom.EventObject("zoomend", 0, null));
		}
		this.center0 = null;
	},

	/**
	 * Gets the listener for the specified event type supported by brush: "zoomstart", "zoom" and "zoomend"
	 * @param (String) type the type of event to get the listener for
	 * @return (com.ibm.rave.core.selector.RunFunction)  the listener for the specified event or null if none was registered
	 */
	on$0 : function(type) {
		return this._event.on$0(type);
	},

	/**
	 * Registers the specified listener to receive events of the specified type from the zoom behavior. The following types are supported: zoomstart - at the start of a zoom gesture (e.g., touchstart). zoom - when the view changes (e.g., touchmove). zoomend - at the end of the current zoom gesture (e.g., touchend). If an event listener was already registered for the same type, the existing listener is removed before the new listener is added. To register multiple listeners for the same event type, the type may be followed by an optional namespace, such as "zoom.foo" and "zoom.bar". To remove a listener, pass null as the listener. For mousewheel events, which happen discretely with no explicit start and end reported by the browser, events that occur within 50 milliseconds of each other are grouped into a single zoom gesture. When fired, the EventObject object will contain the following properties: scale - a number; the current scale. translate - a two-element array representing the current translation vector.
	 * @param (String) type the type of the brush event to listen for
	 * @param (com.ibm.rave.core.selector.RunFunction) listener the listener to register
	 * @return (com.ibm.rave.core.behavior.Zoom)  this zoom instance itself
	 */
	on$1 : function(type, listener) {
		this._event.on$1(type, listener);
		return this;
	},

	zoomTo : function(that, p, l, k) {
		that.rave_setProperty("__chart__", new com_ibm_rave_core_behavior_Zoom.View(this.view.x, this.view.y, this.view.k));
		this.scaleTo(Math.pow(2, k));
		this.translateTo(this.center0 = p, l);
		var context = com_ibm_rave_core_Rave.select(that);
		if (this._duration > 0) {
			context = context.transition().duration(this._duration);
		}
		this.event(context);
	},

	/** @expose */ 
	translate : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.translate$0();
		}
		return this.translate$1(a0);
	},

	/** @expose */ 
	scale : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.scale$0();
		}
		return this.scale$1(a0);
	},

	/** @expose */ 
	scaleExtent : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.scaleExtent$0();
		}
		return this.scaleExtent$1(a0);
	},

	/** @expose */ 
	center : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.center$0();
		}
		return this.center$1(a0);
	},

	/** @expose */ 
	duration : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.duration$0();
		}
		return this.duration$1(a0);
	},

	/** @expose */ 
	size : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.size$0();
		}
		return this.size$1(a0);
	},

	/** @expose */ 
	x : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.x$0();
		}
		return this.x$1(a0);
	},

	/** @expose */ 
	y : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.y$0();
		}
		return this.y$1(a0);
	},

	/** @expose */ 
	on : function(a0, a1) {
		var args = arguments;
		if (args.length == 1) {
			return this.on$0(a0);
		}
		return this.on$1(a0, a1);
	}
});

com_ibm_rave_core_behavior_Zoom.View = function(x, y, k) {
	this.x = x;
	this.y = y;
	this.k = k;
};

/**
 * The event object fired for zoom events: "zoomstart", "zoom", "zoomend"
 */
com_ibm_rave_core_behavior_Zoom.EventObject = rave_externs["EventObject"] = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_event_BaseEvent, {

	/**
	 * A two-element array representing the current translation vector.
	 */
	/** @expose */ 
	translate : null,

	/**
	 * The current zoom scale.
	 */
	/** @expose */ 
	scale : 0,

	constructor : function(type, scale, translate) {
		this.scale = scale;
		this.translate = translate;
	}
});

//com_ibm_rave_core_behavior_Zoom.CHART_PROP = "__chart__";
//com_ibm_rave_core_behavior_Zoom.zoomWheel = "wheel";
//com_ibm_rave_core_behavior_Zoom.mousedown = "mousedown.zoom";
//com_ibm_rave_core_behavior_Zoom.mouseup = "mouseup.zoom";
//com_ibm_rave_core_behavior_Zoom.mousemove = "mousemove.zoom";
//com_ibm_rave_core_behavior_Zoom.touchstart = "touchstart.zoom";
//com_ibm_rave_core_behavior_Zoom.dblclick = "dblclick.zoom";

com_ibm_rave_core_behavior_Zoom.zoomInfinity = [0, Infinity];
com_ibm_rave_core_behavior_Zoom.zoomDelta = function() {
	var event = rave.event;
	return -event.deltaY * (event.deltaMode != 0 ? 120 : 1);
};

// $source: com/ibm/rave/core/interpolate/ZoomInterpolation
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/math/Trigonometry (runtime) // sinh, cosh, tanh
var com_ibm_rave_core_interpolate_ZoomInterpolation = rave_externs["ZoomInterpolation"] = com_ibm_rave_core_nativeImpl_Declare({

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * Returns a smooth interpolator between the two views a and b of a two-dimensional plane, based on “Smooth and efficient zooming and panning” by Jarke J. van Wijk and Wim A.A. Nuij. Each view is defined as an array of three numbers: cx, cy and width. The first two coordinates cx, cy represent the center of the viewport; the last coordinate width represents the size of the viewport. The returned interpolator also has a duration property which encodes the recommended transition duration in milliseconds. This duration is based on the path length of the curved trajectory through x,y space. If you want to a slower or faster transition, multiply this by an arbitrary scale factor (V as described in the original paper).
		 * @param (Array) p0 the first view
		 * @param (Array) p1 the second view
		 * @return (com.ibm.rave.core.interpolate.ZoomInterpolation.ZoomInterpolator)  a zoom interpolator
		 */
		function(p0, p1) {
			var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + 4.0 * d2) / (2 * w0 * 2.0 * d1), b1 = (w1 * w1 - w0 * w0 - 4.0 * d2) / (2 * w1 * 2.0 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1), dr = r1 - r0, S = ((dr) ? dr : Math.log(w1 / w0)) / com_ibm_rave_core_interpolate_ZoomInterpolation.p;
			var interpolate = function(t) {
				var point;
				var s = t * S;
				if ((dr)) {
					var coshr0 = com_ibm_rave_core_internal_math_Trigonometry.cosh(r0), u = w0 / (2.0 * d1) * (coshr0 * com_ibm_rave_core_internal_math_Trigonometry.tanh(com_ibm_rave_core_interpolate_ZoomInterpolation.p * s + r0) - com_ibm_rave_core_internal_math_Trigonometry.sinh(r0));
					point = [ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / com_ibm_rave_core_internal_math_Trigonometry.cosh(com_ibm_rave_core_interpolate_ZoomInterpolation.p * s + r0)];
				} else {
					point = [ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(com_ibm_rave_core_interpolate_ZoomInterpolation.p * s)];
				}
				return point;
			};
			interpolate.duration = S * 1000;
			return interpolate;
		};
		return _$self;
	}
});

/** @expose */ 
com_ibm_rave_core_interpolate_ZoomInterpolation.INSTANCE = new com_ibm_rave_core_interpolate_ZoomInterpolation();
com_ibm_rave_core_interpolate_ZoomInterpolation.p = Math["SQRT2"], com_ibm_rave_core_interpolate_ZoomInterpolation.p2 = 2, com_ibm_rave_core_interpolate_ZoomInterpolation.p4 = 4;

// $source: com/ibm/rave/core/behavior/SelectionEventHandler
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/nativeImpl/event/Event (runtime) // new
/**
 * Tracks and fires selection events.
 */
var com_ibm_rave_core_behavior_SelectionEventHandler = rave_externs["SelectionEventHandler"] = com_ibm_rave_core_nativeImpl_Declare({

	//selectedNodes : null,

	constructor : function() {
		this.selectedNodes = [];
	},

	/**
	 * Get the list of selected nodes.
	 * @return (Array)  the list of selected nodes
	 */
	selected$0 : function() {
		return this.selectedNodes;
	},

	selected$1 : function(node) {
		this.selectedNodes.push(node);
	},

	selected$2 : function(nodes) {
		for (var __i_enFor0 = 0, __exp_enFor0 = nodes, __len_enFor0 = __exp_enFor0.length;
				__i_enFor0 < __len_enFor0; ++__i_enFor0) {
			var node = __exp_enFor0[__i_enFor0];
			this.selectedNodes.push(node);
		}
	},

	/**
	 * Get the last selected node.
	 * @return (com.ibm.rave.core.scene.SceneNode)  the last selected node, or <code>null</code> if no selection
	 */
	/** @expose */ 
	lastSelected : function() {
		return this.selectedNodes.length > 0 ? this.selectedNodes[this.selectedNodes.length - 1] : null;
	},

	/** @expose */ 
	isSelected : function(node) {
		return this.selectedNodes.indexOf(node) != -1;
	},

	fireSelected$0 : function(node) {
		this.fireSelected$1(node, true);
	},

	fireSelected$1 : function(node, unselectPrevious) {
		var events = [];
		var idx = -1;
		if (unselectPrevious) {
			var selectednode;
			while (this.selectedNodes.length > 0 && (selectednode = this.selectedNodes.shift())) {
				if (selectednode == node) {
					idx = 0;
				} else {
					events.push(com_ibm_rave_core_behavior_SelectionEventHandler.createEventContainer("raveunselected", selectednode, false, true));
				}
			}
		} else {
			idx = this.selectedNodes.indexOf(node);
			if (idx >= 0) {
				this.selectedNodes.splice(idx, 1);
			}
		}
		this.selectedNodes.push(node);
		events.push(com_ibm_rave_core_behavior_SelectionEventHandler.createEventContainer("raveselected", node, true, idx >= 0));
		this.fireEvents(events);
	},

	/** @expose */ 
	fireUnselectAll : function() {
		var events = [];
		for (var i = 0; i < this.selectedNodes.length; ++i) {
			events.push(com_ibm_rave_core_behavior_SelectionEventHandler.createEventContainer("raveunselected", this.selectedNodes[i], false, true));
		}
		this.selectedNodes = [];
		this.fireEvents(events);
	},

	fireSelected$2 : function(nodes) {
		this.fireSelected$3(nodes, true);
	},

	fireSelected$3 : function(nodes, unselectPrevious) {
		var events = [];
		if (unselectPrevious) {
			var selectedEvents = [];
			for (var i = 0; i < nodes.length; ++i) {
				var node = nodes[i];
				selectedEvents.push(com_ibm_rave_core_behavior_SelectionEventHandler.createEventContainer("raveselected", node, true, this.selectedNodes.indexOf(node) >= 0));
			}
			for (var i = 0; i < this.selectedNodes.length; ++i) {
				var selectednode = this.selectedNodes[i];
				if (nodes.indexOf(selectednode) >= 0) {
					this.selectedNodes.splice(i--, 1);
					events.push(com_ibm_rave_core_behavior_SelectionEventHandler.createEventContainer("raveunselected", selectednode, false, true));
					break;
				}
			}
			events = events.concat(selectedEvents);
		} else {
			for (var i = 0; i < nodes.length; ++i) {
				var node = nodes[i];
				var idx = this.selectedNodes.indexOf(node);
				events.push(com_ibm_rave_core_behavior_SelectionEventHandler.createEventContainer("raveselected", node, true, idx >= 0));
				this.selectedNodes.splice(idx, 1);
			}
			this.selectedNodes = this.selectedNodes.concat(nodes);
		}
		this.fireEvents(events);
	},

	fireUnselected$0 : function(node) {
		var idx = this.selectedNodes.indexOf(node);
		if (idx >= 0) {
			this.selectedNodes.splice(idx, 1);
			node.dispatchEvent(com_ibm_rave_core_behavior_SelectionEventHandler.createEvent("raveunselected", false, true));
		}
	},

	fireUnselected$1 : function(nodes) {
		var events = [];
		for (var i = 0; i < this.selectedNodes.length; ++i) {
			for (var j = 0; j < nodes.length; ++j) {
				var selectednode = this.selectedNodes[i];
				if (nodes[j] == selectednode) {
					this.selectedNodes.splice(i--, 1);
					events.push(com_ibm_rave_core_behavior_SelectionEventHandler.createEventContainer("raveunselected", selectednode, false, true));
					break;
				}
			}
		}
		this.fireEvents(events);
	},

	fireEvents : function(events) {
		var clone = this.selectedNodes.slice();
		for (var __i_enFor0 = 0, __exp_enFor0 = events, __len_enFor0 = __exp_enFor0.length;
				__i_enFor0 < __len_enFor0; ++__i_enFor0) {
			var e = __exp_enFor0[__i_enFor0];
			e.event.selection = clone;
			e.target.dispatchEvent(e.event);
		}
	},

	/** @expose */ 
	selected : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.selected$0();
		}
		if (args.length == 1 && (a0 == null || Object.prototype.toString.call(a0) === "[object Array]")) {
			return this.selected$2(a0);
		}
		return this.selected$1(a0);
	},

	/** @expose */ 
	fireSelected : function(a0, a1) {
		var args = arguments;
		if (args.length == 1 && (a0 == null || Object.prototype.toString.call(a0) === "[object Array]")) {
			return this.fireSelected$2(a0);
		}
		if (args.length == 1) {
			return this.fireSelected$0(a0);
		}
		if (args.length == 2 && (a0 == null || Object.prototype.toString.call(a0) === "[object Array]") && (a1 == null || typeof a1 === "boolean")) {
			return this.fireSelected$3(a0, a1);
		}
		return this.fireSelected$1(a0, a1);
	},

	/** @expose */ 
	fireUnselected : function(a0) {
		var args = arguments;
		if (args.length == 1 && (a0 == null || Object.prototype.toString.call(a0) === "[object Array]")) {
			return this.fireUnselected$1(a0);
		}
		return this.fireUnselected$0(a0);
	}
});

com_ibm_rave_core_behavior_SelectionEventHandler.createEvent = function(type, selected, previouslySelected) {
	var event = new com_ibm_rave_core_internal_nativeImpl_event_Event(type, true, false);
	event.selected = selected;
	event.previouslySelected = previouslySelected;
	return event;
};

com_ibm_rave_core_behavior_SelectionEventHandler.createEventContainer = function(type, target, selected, previouslySelected) {
	return new com_ibm_rave_core_behavior_SelectionEventHandler.EventContainer(com_ibm_rave_core_behavior_SelectionEventHandler.createEvent(type, selected, previouslySelected), target);
};

com_ibm_rave_core_behavior_SelectionEventHandler.EventContainer = function(event, target) {
	this.event = event;
	this.target = target;
};

/** @expose */ 
com_ibm_rave_core_behavior_SelectionEventHandler.SELECTED_EVENT_TYPE = "raveselected";
/** @expose */ 
com_ibm_rave_core_behavior_SelectionEventHandler.UNSELECTED_EVENT_TYPE = "raveunselected";


// $source: com/ibm/rave/core/behavior/FocusEventHandler
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/nativeImpl/event/Event (static) // new
/**
 * Tracks and fires focus and blur events.
 */
var com_ibm_rave_core_behavior_FocusEventHandler = rave_externs["FocusEventHandler"] = com_ibm_rave_core_nativeImpl_Declare({

	//focusedNode : null,

	/**
	 * Get the focused node.
	 * @return (com.ibm.rave.core.scene.SceneNode)  the focused node
	 */
	focused$0 : function() {
		return this.focusedNode;
	},

	/**
	 * Set the focused node.
	 * @param (com.ibm.rave.core.scene.SceneNode) node The node that has focus.
	 */
	focused$1 : function(node) {
		this.focusedNode = node;
	},

	/**
	 * Check if the node is the focused one.
	 * @param (com.ibm.rave.core.scene.SceneNode) node The SceneNode.
	 * @return (boolean) true if it is the focused node, false otherwise.
	 */
	/** @expose */ 
	isFocused : function(node) {
		return this.focusedNode ? this.focusedNode == node : false;
	},

	/**
	 * Fire a focus event on the provided node.  This will be preceded by a blur event on  the previously focused node, if any.
	 * @param (com.ibm.rave.core.scene.SceneNode) node The node to receive focus.
	 */
	/** @expose */ 
	fireFocus : function(node) {
		if (!(this.isFocused(node))) {
			if (this.focusedNode) {
				this.focusedNode.dispatchEvent(com_ibm_rave_core_behavior_FocusEventHandler.createEvent("raveblur"));
			}
			this.focusedNode = node;
			node.dispatchEvent(com_ibm_rave_core_behavior_FocusEventHandler.createEvent("ravefocus"));
		}
	},

	/**
	 * Fire a blur event on the provided node.
	 * @param (com.ibm.rave.core.scene.SceneNode) node The node to be blurred.
	 */
	/** @expose */ 
	fireBlur : function(node) {
		if (this.isFocused(node)) {
			this.focusedNode = null;
			node.dispatchEvent(com_ibm_rave_core_behavior_FocusEventHandler.createEvent("raveblur"));
		}
	},

	/** @expose */ 
	focused : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.focused$0();
		}
		return this.focused$1(a0);
	}
});

com_ibm_rave_core_behavior_FocusEventHandler.createEvent = function(type) {
	return new com_ibm_rave_core_internal_nativeImpl_event_Event(type, true, false);
};

/** @expose */ 
com_ibm_rave_core_behavior_FocusEventHandler.FOCUS_EVENT_TYPE = "ravefocus";
/** @expose */ 
com_ibm_rave_core_behavior_FocusEventHandler.BLUR_EVENT_TYPE = "raveblur";


// $source: com/ibm/rave/core/layout/BundleLayout
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
/**
 * Bundle layout. Currently, the bundle layout is stateless and thus only has a default configuration. The returned layout object is both an object and a function. That is: you can call the layout like any other function, and the layout has additional methods that change its behavior. 
 */
var com_ibm_rave_core_layout_BundleLayout = rave_externs["BundleLayout"] = com_ibm_rave_core_nativeImpl_Declare({

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * Evaluates the bundle layout on the specified array of links, returning the  computed path from the source to the target, through the least common ancestor. Each input link must have two attributes: source - the source node. target - the target node. Furthermore, each node must have one attribute: parent - the parent node.
		 * @param (Array) links 	the links
		 * @return (Array) 	The return value of the layout is an array of paths, where each path is represented as an array of nodes. Thus, the bundle layout does not compute the basis splines directly; instead, it returns an array of nodes which implicitly represent the control points of the spline. You can use this array in conjunction with Rave.svg.line or Rave.svg.line.radial to generate the splines themselves.
		 */
		function(links) {
			var paths = [];
			var i = -1;
			var n = links.length;
			while (++i < n) {
				paths.push(_$self.layout_bundlePath(links[i]));
			}
			return paths;
		};
		return _$self;
	},

	layout_bundleAncestors : function(node) {
		var _node = node;
		var ancestors = [];
		var parent = _node["parent"];
		while (parent) {
			ancestors.push(_node);
			_node = parent;
			parent = parent["parent"];
		}
		ancestors.push(_node);
		return ancestors;
	},

	layout_bundleLeastCommonAncestor : function(a, b) {
		if (a == b) {
			return a;
		}
		var aNodes = this.layout_bundleAncestors(a);
		var bNodes = this.layout_bundleAncestors(b);
		var aNode = aNodes.pop();
		var bNode = bNodes.pop();
		var sharedNode;
		while (aNode == bNode) {
			sharedNode = aNode;
			aNode = aNodes.pop();
			bNode = bNodes.pop();
		}
		return sharedNode;
	},

	layout_bundlePath : function(link) {
		var start = link["source"];
		var end = link["target"];
		var lca = this.layout_bundleLeastCommonAncestor(start, end);
		var points = [start];
		while (start != lca) {
			start = start["parent"];
			points.push(start);
		}
		var k = points.length;
		while (end != lca) {
			points.splice(k, 0, end);
			end = end["parent"];
		}
		return points;
	}
});


// $source: com/ibm/rave/core/layout/hierarchy/HierarchyBase
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare anonymous, declare
//@import com/ibm/rave/core/layout/hierarchy/HierarchyUtil (runtime) // visitAfter, links
/**
 * Creates a new hierarchy layout with the default settings: the default sort  order is by descending value; the default value accessor assumes each input  data is an object with a numeric value attribute; and the default children  accessor assumes each input data is an object with a children array.
 * @param < (Object) T > the type of HierarchyBase
 */
var com_ibm_rave_core_layout_hierarchy_HierarchyBase = rave_externs["HierarchyBase"] = com_ibm_rave_core_nativeImpl_Declare({

	/**
	 * Gets the children of a specified node
	 */
	//defaultChildrenFunction : null,

	/**
	 * Gets the value of a specified node
	 */
	//defaultNodeValueFunction : null,

	/**
	 * Sorts two nodes based on the value of the node
	 */
	//defaultSortFunction : null,

	/** @expose */ 
	nodeValueFunction : null,

	/** @expose */ 
	childrenFunction : null,

	/** @expose */ 
	sortFunction : null,

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * Runs the hierarchy layout, returning the array of nodes associated with the  specified root node. The input argument to the layout is the root node of the  hierarchy, and the output return value is an array representing the computed  positions of all nodes. Several attributes are populated on each node: parent - the parent node, or null for the root. children - the array of child nodes, or null for leaf nodes. value - the node value, as returned by the value accessor. depth - the depth of the node, starting at 0 for the root. In addition, most hierarchy layouts also compute x and y positions for nodes;  see the implementing class for details.
		 * @param (Object) stackNode the root node to be processed
		 * @param (int) i the index (currently unused)
		 * @return (Array)  all nodes to be drawn
		 */
		function(stackNode, i) {
			return _$self.doCreate(stackNode, i);
		};
		return _$self;
	},

	constructor : function() {
		this.defaultChildrenFunction = 		/**
		 * Gets the children of the specified node
		 * @param (Object) node node to retrieve the children from
		 * @param (int) depth the depth of the node, starting at 0 for the root
		 * @return (Array)  an array containing all the children
		 */
		function(node, depth) {
			return node["children"];
		};
		this.defaultNodeValueFunction = 		/**
		 * Gets the value of a specified node
		 * @param (Object) node node to retrieve the value from
		 * @param (int) depth the depth of the node, starting at 0 for the root
		 * @return (Object)  the value of the node
		 */
		function(node, depth) {
			return node["value"];
		};
		this.defaultSortFunction = 		/**
		 * Sorts two nodes based on the value of the node
		 * @param (Object) a the first node to compare against
		 * @param (Object) b the second node to compare against
		 * @return (int)  indicates whether node b is greater than, equal to or less than node a
		 */
		function(a, b) {
			return ~~(b["value"] - a["value"]);
		};
		this.nodeValueFunction = this.defaultNodeValueFunction;
		this.childrenFunction = this.defaultChildrenFunction;
		this.sortFunction = this.defaultSortFunction;
	},

	/** @expose */ 
	doCreate : function(stackNode, i) {
		var stack = [];
		var nodes = [];
		stackNode["depth"] = 0;
		stack.push(stackNode);
		var root;
		var child;
		var childs;
		var n;
		while ((root = stack.pop())) {
			nodes.push(root);
			if ((childs = this.childrenFunction.call(this, root, root["depth"])) && (n = childs.length) > 0) {
				while (--n >= 0) {
					stack.push(child = childs[n]);
					child["parent"] = root;
					child["depth"] = root["depth"] + 1;
				}
				if (this.nodeValueFunction) {
					root["value"] = 0.0;
				}
				root["children"] = childs;
			} else {
				if (this.nodeValueFunction) {
					var valueVal = + (this.nodeValueFunction.call(this, root, root["depth"]));
					if (valueVal != valueVal) {
						valueVal = 0;
					}
					root["value"] = valueVal;
				}
				root["children"] = undefined;
			}
		}
		if (this.sortFunction || this.nodeValueFunction) {
			var self = this;
			com_ibm_rave_core_layout_hierarchy_HierarchyUtil.visitAfter(stackNode, new (com_ibm_rave_core_nativeImpl_Declare({

				visit : function(node) {
					var childs;
					var parent;
					if (self.sortFunction && (childs = node["children"])) {
						childs.sort(self.sortFunction);
					}
					if (self.nodeValueFunction && (parent = node["parent"])) {
						parent["value"] += node["value"];
					}
				}

			}))());
		}
		return nodes;
	},

	/**
	 * If comparator is specified, sets the sort order of sibling nodes for the layout using the specified comparator function
	 * @param (com.ibm.rave.core.util.Comparator) func   the new default sort accessor to be used in place of the default  
	 * @return (com.ibm.rave.core.layout.hierarchy.HierarchyBase)  the current instance of HierarchyBase
	 */
	sort$0 : function(func) {
		this.sortFunction = func;
		return this;
	},

	/**
	 * If comparator is not specified, returns the current group sort order,  which defaults to descending order by the associated input data's  numeric value attribute The comparator function is invoked for pairs of nodes, being passed  the input data for each node. A null comparator disables sorting and  uses tree traversal order. Comparator functions may also be implemented  using rave.ascending or rave.descending
	 * @return (com.ibm.rave.core.util.Comparator)  the default sort accessor 
	 */
	sort$1 : function() {
		return this.sortFunction;
	},

	/**
	 * If accessor is specified, sets the specified children  accessor function
	 * @param (com.ibm.rave.core.layout.hierarchy.HierarchyBase.GetNodeChildren) func the children accessor function to be used in place of the default 
	 * @return (com.ibm.rave.core.layout.hierarchy.HierarchyBase)  the current instance of HierarchyBase
	 */
	children$0 : function(func) {
		this.childrenFunction = func;
		return this;
	},

	/**
	 * If accessor is not specified, returns  the current children accessor function, which by default  assumes that the input data is an object with a children array
	 * @return (com.ibm.rave.core.layout.hierarchy.HierarchyBase.GetNodeChildren)  the default children accessor function
	 */
	children$1 : function() {
		return this.childrenFunction;
	},

	/**
	 * If value is specified, sets the value accessor to the specified function
	 * @param (com.ibm.rave.core.layout.hierarchy.HierarchyBase.GetNodeValue) func the value accessor to be used in place of the default value accessor
	 * @return (com.ibm.rave.core.layout.hierarchy.HierarchyBase)  the current instance of HierarchyBase
	 */
	value$0 : function(func) {
		this.nodeValueFunction = func;
		return this;
	},

	/**
	 * If value is not specified, returns the current value accessor. The default  accessor assumes that the input data is an object with a numeric value  attribute The value accessor is invoked for each input data element, and must return  a number representing the numeric value of the node. For area-proportional  layouts such as treemaps, this value is used to set the area of each node  proportionally to the value; for other hierarchical layouts, the value has  no effect on the layout.
	 * @return (com.ibm.rave.core.layout.hierarchy.HierarchyBase.GetNodeValue)  the default value accessor function
	 */
	value$1 : function() {
		return this.nodeValueFunction;
	},

	/**
	 * Given the specified array of nodes returns an array of objects  representing the links from parent to child for each node.  Leaf nodes will not have any links. Each link is an object with  two attributes: source - the parent node (as described above). target - the child node. This method is useful for retrieving a set of link descriptions  suitable for display, often in conjunction with the diagonal shape  generator
	 * @param (Array) nodes an array of nodes for which links should be provided
	 * @return (Array)  an array of links from parent to children for each node
	 */
	/** @expose */ 
	links : function(nodes) {
		return com_ibm_rave_core_layout_hierarchy_HierarchyUtil.links(nodes);
	},

	/** @expose */ 
	sort : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.sort$1();
		}
		return this.sort$0(a0);
	},

	/** @expose */ 
	children : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.children$1();
		}
		return this.children$0(a0);
	},

	/** @expose */ 
	value : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.value$1();
		}
		return this.value$0(a0);
	}
});


// $source: com/ibm/rave/core/layout/AbstractPackLayout
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/layout/hierarchy/HierarchyBase (loadtime) // superclass
/**
 * AbstractPackLayout - generalization for layouts, which pack circle shaped nodes into an area specified by size
 */
var com_ibm_rave_core_layout_AbstractPackLayout = rave_externs["AbstractPackLayout"] = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_layout_hierarchy_HierarchyBase, {

	/**
	 * area extent value (width and height)
	 */
	/** @expose */ 
	sizeVal : null,

	/**
	 * radius value
	 */
	/** @expose */ 
	radiusVal : null,

	/**
	 * radius function value
	 */
	/** @expose */ 
	radiusFn : null,

	/**
	 * padding value
	 */
	/** @expose */ 
	paddingVal : 0,

	constructor : function() {
		this.sizeVal = [1, 1];
	},

	/**
	 * Returns the current size, which defaults to 1×1
	 * @return (double[])  return the current size
	 */
	size$0 : function() {
		return this.sizeVal;
	},

	/**
	 * Sets the available layout size to the specified two-element array of numbers representing x and y.
	 * @param (double[]) newSize 	the size of the layout
	 * @return (com.ibm.rave.core.layout.AbstractPackLayout) 	this Layout
	 */
	size$1 : function(newSize) {
		this.sizeVal = newSize;
		return this;
	},

	/**
	 * The current padding, which defaults to zero.
	 * @return (double) 	current padding
	 */
	padding$0 : function() {
		return this.paddingVal;
	},

	/**
	 * Sets the approximate padding between adjacent circles, in pixels.
	 * @param (Object) newVal    padding value
	 * @return (com.ibm.rave.core.layout.AbstractPackLayout)   this layout
	 */
	padding$1 : function(newVal) {
		this.paddingVal = + (newVal);
		return this;
	},

	/**
	 * Get the current radius function or value, which defaults to null.
	 * @return (Object)   radius, can be a vlaue or a function
	 */
	radius$0 : function() {
		if (!this.radiusFn) {
			return this.radiusVal;
		}
		return this.radiusFn;
	},

	/**
	 * Sets the radius function for computing the radius of each node.  If radius is null, as it is by default, the radius is determined automatically from the node value, scaled to fit the layout size. The radius can also be specified as a constant number for uniform circle size.
	 * @param (Object) newVal  the new radius value or function
	 * @return (com.ibm.rave.core.layout.AbstractPackLayout) 	this layout
	 */
	radius$1 : function(newVal) {
		if (typeof newVal === "function") {
			this.radiusFn = newVal;
		} else {
			this.radiusFn = null;
			this.radiusVal = newVal;
		}
		return this;
	},

	/** @expose */ 
	size : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.size$0();
		}
		return this.size$1(a0);
	},

	/** @expose */ 
	padding : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.padding$0();
		}
		return this.padding$1(a0);
	},

	/** @expose */ 
	radius : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.radius$0();
		}
		return this.radius$1(a0);
	}
});

/**
 * A default function for radius
 */
com_ibm_rave_core_layout_AbstractPackLayout.ConstantSingleValueFunction = rave_externs["ConstantSingleValueFunction"] = com_ibm_rave_core_nativeImpl_Declare({

	realdata : 0,

	_$functionClassMethod : function() {
		var _$self = function(data) {
			return _$self.realdata;
		};
		return _$self;
	},

	/** @expose */ 
	constructor : function(constantData) {
		this.realdata = + (constantData);
	}
});


// $source: com/ibm/rave/core/layout/hierarchy/HierarchyUtil
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare anonymous, declare
/**
 * A utility to help with hierarchical data traversal
 */
var com_ibm_rave_core_layout_hierarchy_HierarchyUtil = rave_externs["HierarchyUtil"] = {


};

/**
 * Re-evaluates the `value` property for the specified hierarchy.
 * @param (Object) root the root node of type T
 * @param (com.ibm.rave.core.layout.hierarchy.HierarchyBase) hierarchy hierarchical layout instance, which holds the value function
 * @return (Object)  the root node that was revalued
 */
/** @expose */ 
com_ibm_rave_core_layout_hierarchy_HierarchyUtil.revalue = function(root, hierarchy) {
	if (hierarchy.value()) {
		com_ibm_rave_core_layout_hierarchy_HierarchyUtil.visitBefore(root, new (com_ibm_rave_core_nativeImpl_Declare({

			visit : function(node) {
				if (node["children"]) {
					node["value"] = 0.0;
				}
			}

		}))());
		com_ibm_rave_core_layout_hierarchy_HierarchyUtil.visitAfter(root, new (com_ibm_rave_core_nativeImpl_Declare({

			visit : function(node) {
				var parent;
				if (!node["children"]) {
					node["value"] = + (hierarchy.value().call(hierarchy, node, node["depth"]));
				}
				if ((parent = node["parent"])) {
					parent["value"] += node["value"];
				}
			}

		}))());
	}
	return root;
};

/**
 * Pre-order traversal.
 * @param (Object) node root of the hierarchy
 * @param (com.ibm.rave.core.layout.hierarchy.HierarchyUtil.Visitor) callback a traversal handler function
 */
/** @expose */ 
com_ibm_rave_core_layout_hierarchy_HierarchyUtil.visitBefore = function(node, callback) {
	var _node = node;
	var nodes = [];
	nodes.push(_node);
	while ((_node = nodes.pop())) {
		callback.visit(_node);
		var children;
		var n = 0;
		if ((children = _node["children"]) && ((n = children.length) > 0)) {
			while (--n >= 0) {
				nodes.push(children[n]);
			}
		}
	}
};

/**
 * Post-order traversal.
 * @param (Object) node root of the hierarchy
 * @param (com.ibm.rave.core.layout.hierarchy.HierarchyUtil.Visitor) callback a traversal handler function
 */
/** @expose */ 
com_ibm_rave_core_layout_hierarchy_HierarchyUtil.visitAfter = function(node, callback) {
	var _node = node;
	var nodes = [];
	var nodes2 = [];
	nodes.push(_node);
	while ((_node = nodes.pop())) {
		nodes2.push(_node);
		var children;
		var n = 0;
		if ((children = _node["children"]) && ((n = children.length) > 0)) {
			var i = -1;
			while (++i < n) {
				nodes.push(children[i]);
			}
		}
	}
	while ((_node = nodes2.pop())) {
		callback.visit(_node);
	}
};

com_ibm_rave_core_layout_hierarchy_HierarchyUtil.links = function(nodes) {
	var num_children;
	var node;
	var links = [];
	var link;
	var num_nodes = nodes.length;
	for (var z = 0; z < num_nodes; ++z) {
		node = nodes[z];
		if (node && node["children"]) {
			num_children = node["children"].length;
			while (--num_children >= 0) {
				link = {};
				link["source"] = node;
				link["target"] = node["children"][num_children];
				links.push(link);
			}
		}
	}
	return links;
};

/**
 * Visitor which will help with traversal
 * @param < (Object) T > hierarchy node type
 */
com_ibm_rave_core_layout_hierarchy_HierarchyUtil.Visitor = rave_externs["Visitor"] = com_ibm_rave_core_nativeImpl_Declare.implement(

	//visit : function(node) {}
);


// $source: com/ibm/rave/core/layout/PackLayout
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare anonymous, declare
//@import com/ibm/rave/core/layout/AbstractPackLayout (loadtime) // new, superclass
//@import com/ibm/rave/core/layout/hierarchy/HierarchyBase (runtime)
//@import com/ibm/rave/core/layout/hierarchy/HierarchyUtil (static) // visitAfter
//@import com/ibm/rave/core/layout/XYMin_Max (runtime) // new
/**
 * PackLayout
 */
var com_ibm_rave_core_layout_PackLayout = rave_externs["PackLayout"] = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_layout_AbstractPackLayout, {

	/**
	 * An alias to this layout instance
	 */
	/** @expose */ 
	nodes : null,

	/**
	 * constructor
	 */
	/** @expose */ 
	constructor : function() {
		this.nodes = this;
		this.sort(com_ibm_rave_core_layout_PackLayout.PACK_SORT_FN);
	},

	/**
	 * Runs the pack layout, returning the array of nodes associated with the specified root node. The pack layout is part of D3's family of hierarchical layouts. These layouts follow the same basic structure: the input argument to the layout is the root node of the hierarchy, and the output return value is an array representing the computed positions of all nodes. Several attributes are populated on each node: parent - the parent node, or null for the root. children - the array of child nodes, or null for leaf nodes. value - the node value, as returned by the value accessor. depth - the depth of the node, starting at 0 for the root. x - the computed x-coordinate of the node position. y - the computed y-coordinate of the node position. r - the computed node radius.
	 * @param (Object) d  the root node
	 * @param (int) i 	index
	 * @return (Array) 	Array or positioned nodes
	 */
	doCreate$0 : function(d, i) {
		var nodes = com_ibm_rave_core_layout_hierarchy_HierarchyBase.prototype.doCreate.call(this, d, i);
		var root = nodes[0];
		var w = this.sizeVal[0];
		var h = this.sizeVal[1];
		var localR;
		if (!this.radiusFn && this.radiusVal == null) {
			localR = com_ibm_rave_core_layout_PackLayout.SQRT_FN;
		} else if (!this.radiusFn) {
			localR = new com_ibm_rave_core_layout_AbstractPackLayout.ConstantSingleValueFunction(this.radiusVal);
		} else {
			localR = this.radiusFn;
		}
		root["x"] = root["y"] = 0;
		com_ibm_rave_core_layout_hierarchy_HierarchyUtil.visitAfter(root, new (com_ibm_rave_core_nativeImpl_Declare({

			visit : function(node) {
				node["r"] = + (localR(node["value"]));
			}

		}))());
		com_ibm_rave_core_layout_hierarchy_HierarchyUtil.visitAfter(root, com_ibm_rave_core_layout_PackLayout.layout_packSiblings);
		if ((this.paddingVal)) {
			var dr = this.paddingVal * (this.radiusFn || (this.radiusVal) ? 1 : Math.max(2 * root["r"] / w, 2 * root["r"] / h)) / 2;
			com_ibm_rave_core_layout_hierarchy_HierarchyUtil.visitAfter(root, new (com_ibm_rave_core_nativeImpl_Declare({

				visit : function(node) {
					node["r"] += dr;
				}

			}))());
			com_ibm_rave_core_layout_hierarchy_HierarchyUtil.visitAfter(root, com_ibm_rave_core_layout_PackLayout.layout_packSiblings);
			com_ibm_rave_core_layout_hierarchy_HierarchyUtil.visitAfter(root, new (com_ibm_rave_core_nativeImpl_Declare({

				visit : function(node) {
					node["r"] -= dr;
				}

			}))());
		}
		this.layout_packTransform(root, w / 2, h / 2, (this.radiusFn || (this.radiusVal)) ? 1 : 1 / Math.max(2 * root["r"] / w, 2 * root["r"] / h));
		return nodes;
	},

	/** @expose */ 
	layout_packTransform : function(node, x, y, k) {
		var _x = x;
		var _y = y;
		var children = node["children"];
		node["x"] = _x += k * node["x"];
		node["y"] = _y += k * node["y"];
		node["r"] *= k;
		if (children) {
			var i = -1, n = children.length;
			while (++i < n) {
				this.layout_packTransform(children[i], _x, _y, k);
			}
		}
	},

	/** @expose */ 
	doCreate : function(a0, a1) {
		var args = arguments;
		return this.doCreate$0(a0, a1);
	}
});

com_ibm_rave_core_layout_PackLayout.d3_layout_packInsert = function(a, b) {
	var c = a["_pack_next"];
	a["_pack_next"] = b;
	b["_pack_prev"] = a;
	b["_pack_next"] = c;
	c["_pack_prev"] = b;
};

com_ibm_rave_core_layout_PackLayout.d3_layout_packSplice = function(a, b) {
	a["_pack_next"] = b;
	b["_pack_prev"] = a;
};

com_ibm_rave_core_layout_PackLayout.d3_layout_packIntersects = function(a, b) {
	var dx = b["x"] - a["x"], dy = b["y"] - a["y"], dr = a["r"] + b["r"];
	return .999 * dr * dr > dx * dx + dy * dy;
};

com_ibm_rave_core_layout_PackLayout.layout_packPlace = function(a, b, c) {
	var db = a["r"] + c["r"], dx = b["x"] - a["x"], dy = b["y"] - a["y"];
	if (db != 0 && (dx != 0 || dy != 0)) {
		var da = b["r"] + c["r"], dc = dx * dx + dy * dy;
		da *= da;
		db *= db;
		var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
		c["x"] = a["x"] + x * dx + y * dy;
		c["y"] = a["y"] + x * dy - y * dx;
	} else {
		c["x"] = a["x"] + db;
		c["y"] = a["y"];
	}
};

com_ibm_rave_core_layout_PackLayout.SQRT_FN = function(data) {
	return Math.sqrt(+ (data));
};
com_ibm_rave_core_layout_PackLayout.PACK_SORT_FN = function(a, b) {
	var val = (a["value"] - b["value"]);
	return val == 0 ? 0 : val > 0 ? 1 : -1;
};
com_ibm_rave_core_layout_PackLayout.layout_packLink = function(node, index, array) {
	node["_pack_next"] = node["_pack_prev"] = node;
	return node;
};
com_ibm_rave_core_layout_PackLayout.layout_packUnlink = function(node, index, array) {
	node["_pack_next"] = null;
	node["_pack_prev"] = null;
	return node;
};
com_ibm_rave_core_layout_PackLayout.layout_packSiblings = new (com_ibm_rave_core_nativeImpl_Declare({

	visit : function(node) {
		var nodes = node["children"];
		if (!nodes || nodes.length == 0) {
			return;
		}
		var n = nodes.length;
		var minMax = new com_ibm_rave_core_layout_XYMin_Max();
		var a, b, c, j, k = null;
		var i;
		nodes.forEach(com_ibm_rave_core_layout_PackLayout.layout_packLink);
		a = nodes[0];
		a["x"] = -a["r"];
		a["y"] = 0;
		minMax.bound(a);
		if (n > 1) {
			b = nodes[1];
			b["x"] = b["r"];
			b["y"] = 0;
			minMax.bound(b);
			if (n > 2) {
				c = nodes[2];
				com_ibm_rave_core_layout_PackLayout.layout_packPlace(a, b, c);
				minMax.bound(c);
				com_ibm_rave_core_layout_PackLayout.d3_layout_packInsert(a, c);
				a["_pack_prev"] = c;
				com_ibm_rave_core_layout_PackLayout.d3_layout_packInsert(c, b);
				b = a["_pack_next"];
				for (i = 3; i < n; ++i) {
					com_ibm_rave_core_layout_PackLayout.layout_packPlace(a, b, c = nodes[i]);
					var isect = 0, s1 = 1, s2 = 1;
					for (j = b["_pack_next"]; j != b; j = j["_pack_next"], s1++) {
						if (com_ibm_rave_core_layout_PackLayout.d3_layout_packIntersects(j, c)) {
							isect = 1;
							break;
						}
					}
					if (isect == 1) {
						for (k = a["_pack_prev"]; k != j["_pack_prev"]; k = k["_pack_prev"], s2++) {
							if (com_ibm_rave_core_layout_PackLayout.d3_layout_packIntersects(k, c)) {
								break;
							}
						}
					}
					if ((isect)) {
						if (s1 < s2 || (s1 == s2 && b["r"] < a["r"])) {
							com_ibm_rave_core_layout_PackLayout.d3_layout_packSplice(a, b = j);
						} else {
							a = k;
							com_ibm_rave_core_layout_PackLayout.d3_layout_packSplice(a, b);
						}
						i--;
					} else {
						com_ibm_rave_core_layout_PackLayout.d3_layout_packInsert(a, c);
						b = c;
						minMax.bound(c);
					}
				}
			}
		}
		var cx = (minMax.xMin + minMax.xMax) / 2, cy = (minMax.yMin + minMax.yMax) / 2, cr = 0;
		for (i = 0; i < n; ++i) {
			c = nodes[i];
			c["x"] -= cx;
			c["y"] -= cy;
			cr = Math.max(cr, c["r"] + Math.sqrt(c["x"] * c["x"] + c["y"] * c["y"]));
		}
		node["r"] = cr;
		nodes.forEach(com_ibm_rave_core_layout_PackLayout.layout_packUnlink);
	}

}))();

// $source: com/ibm/rave/core/layout/XYMin_Max
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
/**
 * A utility class used to grope for extent bounds
 */
var com_ibm_rave_core_layout_XYMin_Max = rave_externs["XYMin_Max"] = com_ibm_rave_core_nativeImpl_Declare({

	/**
	 * minimal x value
	 */
	/** @expose */ 
	xMin : 1.7976931348623157E308,

	/**
	 * maximum x value
	 */
	/** @expose */ 
	xMax : 4.9E-324,

	/**
	 * minimal y value
	 */
	/** @expose */ 
	yMin : 1.7976931348623157E308,

	/**
	 * maximum y value
	 */
	/** @expose */ 
	yMax : 4.9E-324,

	/**
	 * Adjust bounding area rectangle - extend bounds, if node falls outside of the current bounds values
	 * @param (Object) node a node with x, y coordinates and a radius set.
	 */
	/** @expose */ 
	bound : function(node) {
		this.xMin = Math.min(node["x"] - node["r"], this.xMin);
		this.xMax = Math.max(node["x"] + node["r"], this.xMax);
		this.yMin = Math.min(node["y"] - node["r"], this.yMin);
		this.yMax = Math.max(node["y"] + node["r"], this.yMax);
	}
});


// $source: com/ibm/rave/core/layout/chord/ChordLayout
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/Rave (runtime) // range
//@import com/ibm/rave/core/layout/chord/SubGroupData (runtime) // new
//@import com/ibm/rave/core/layout/chord/GroupData (runtime) // new
//@import com/ibm/rave/core/layout/chord/ChordData (runtime) // new
/**
 * Standard Chord layout. The results from this class can be used with the Chord SVG path generator to create a chord chart.
 */
var com_ibm_rave_core_layout_chord_ChordLayout = rave_externs["ChordLayout"] = com_ibm_rave_core_nativeImpl_Declare({

	//_chords : null,

	//_groups : null,

	//_matrix : null,

	//valueAccessor : null,

	//_sortGroups : null,

	//_sortSubgroups : null,

	//_sortChords : null,

	/**
	 * Retrieve the computed group angles.
	 */
	/** @expose */ 
	groups : null,

	/**
	 * Retrieve the computed chord angles
	 */
	/** @expose */ 
	chords : null,

	n : 0,

	_padding : 0,

	constructor : function() {
		this.valueAccessor = com_ibm_rave_core_layout_chord_ChordLayout.DEFAULT_ACCESSOR_FN;
		{
			var self = this;
			this.groups = function() {
				if (!self._groups) {
					self.relayout();
				}
				return self._groups;
			};
			this.chords = function() {
				if (!self._chords) {
					self.relayout();
				}
				return self._chords;
			};
		}
	},

	relayout : function() {
		var subgroups = {};
		var groupSums = [];
		var groupIndex = com_ibm_rave_core_Rave.range(this.n);
		var subgroupIndex = [];
		var k, x, x0;
		var i, j;
		this._chords = [];
		this._groups = [];
		k = 0;
		i = -1;
		while (++i < this.n) {
			x = 0;
			j = -1;
			while (++j < this.n) {
				x += this.valueAccessor(this._matrix[i][j]);
			}
			groupSums[i] = x;
			subgroupIndex[i] = com_ibm_rave_core_Rave.range(this.n);
			k += x;
		}
		if (this._sortGroups) {
			groupIndex.sort(new com_ibm_rave_core_layout_chord_ChordLayout.GroupAndSubGroupComparator(this, groupSums, false, this.valueAccessor));
		}
		if (this._sortSubgroups) {
			for (var index = 0; index < subgroupIndex.length; ++index) {
				var aToSOrt = subgroupIndex[index];
				aToSOrt.sort(new com_ibm_rave_core_layout_chord_ChordLayout.GroupAndSubGroupComparator(this, this._matrix[index], true, this.valueAccessor));
			}
		}
		k = (6.283185307179586 - this._padding * this.n) / k;
		x = 0;
		i = -1;
		while (++i < this.n) {
			x0 = x;
			j = -1;
			var di = 0;
			while (++j < this.n) {
				di = groupIndex[i];
				var dj = subgroupIndex[di][j];
				var numericV = this.valueAccessor(this._matrix[di][dj]), a0 = x, a1 = x += numericV * k;
				subgroups[di + "-" + dj] = new com_ibm_rave_core_layout_chord_SubGroupData(di, dj, a0, a1, numericV, this._matrix[di][dj]);
			}
			this._groups[di] = new com_ibm_rave_core_layout_chord_GroupData(di, x0, x, (x - x0) / k);
			x += this._padding;
		}
		i = -1;
		while (++i < this.n) {
			j = i - 1;
			while (++j < this.n) {
				var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
				if (source.value != 0 || target.value != 0) {
					var cd = new com_ibm_rave_core_layout_chord_ChordData();
					if (source.value < target.value) {
						cd.source = target;
						cd.target = source;
					} else {
						cd.source = source;
						cd.target = target;
					}
					this._chords.push(cd);
				}
			}
		}
		if (this._sortChords) {
			this.resort();
		}
	},

	/**
	 * Re-Runs the chrod sort function
	 */
	/** @expose */ 
	resort : function() {
		this._chords.sort(new com_ibm_rave_core_layout_chord_ChordLayout.ChordsComparator(this._sortChords));
	},

	/**
	 * Set the matrix data backing the layout.
	 * @param (Array) x 	the data
	 * @return (com.ibm.rave.core.layout.chord.ChordLayout) 	this chord layout
	 */
	matrix$0 : function(x) {
		this._matrix = x;
		this.n = x.length;
		this._chords = null;
		this._groups = null;
		return this;
	},

	/**
	 * Gets the matrix data backing the layout.
	 * @return (Array) 	the data
	 */
	matrix$1 : function() {
		return this._matrix;
	},

	/**
	 * Accessor to get get the current value function 
	 * @return (com.ibm.rave.core.functions.SingleValueFunction) 	the current value function
	 */
	value$0 : function() {
		return this.valueAccessor;
	},

	/**
	 * Sets the current value function, this is the function that will be called to get the value of each cell
	 * @param (com.ibm.rave.core.functions.SingleValueFunction) valueFn 	the function
	 * @return (com.ibm.rave.core.layout.chord.ChordLayout) 	this chord layout
	 */
	value$1 : function(valueFn) {
		this.valueAccessor = valueFn;
		return this;
	},

	/**
	 * Set the angular padding between chord segments.
	 * @param (double) x 	the new padding value
	 * @return (com.ibm.rave.core.layout.chord.ChordLayout) 	this layout
	 */
	padding$0 : function(x) {
		this._padding = x;
		this._chords = null;
		this._groups = null;
		return this;
	},

	/**
	 * Get the angular padding between chord segments.
	 * @return (double)  the padding
	 */
	padding$1 : function() {
		return this._padding;
	},

	/**
	 * Get the comparator function for groups.
	 * @return (com.ibm.rave.core.util.Comparator)  the comparator function
	 */
	sortGroups$0 : function() {
		return this._sortGroups;
	},

	/**
	 * Sets the comparator function for groups.
	 * @param (com.ibm.rave.core.util.Comparator) sortGroupFn 	the new comparator
	 * @return (com.ibm.rave.core.layout.chord.ChordLayout) 	this layout
	 */
	sortGroups$1 : function(sortGroupFn) {
		this._sortGroups = sortGroupFn;
		this._chords = null;
		this._groups = null;
		return this;
	},

	/**
	 * Get the comparator function for subgroups.
	 * @return (com.ibm.rave.core.util.Comparator)  the comparator function
	 */
	sortSubgroups$0 : function() {
		return this._sortSubgroups;
	},

	/**
	 * Sets the comparator function for subgroups.
	 * @param (com.ibm.rave.core.util.Comparator) sortSubGroupFn 	the new comparator
	 * @return (com.ibm.rave.core.layout.chord.ChordLayout) 	this layout
	 */
	sortSubgroups$1 : function(sortSubGroupFn) {
		this._sortSubgroups = sortSubGroupFn;
		this._chords = null;
		return this;
	},

	/**
	 * Get the comparator function for chords (z-order).
	 * @return (com.ibm.rave.core.util.Comparator) 	chords comparator
	 */
	sortChords$0 : function() {
		return this._sortChords;
	},

	/**
	 * Set the comparator function for chords (z-order).
	 * @param (com.ibm.rave.core.util.Comparator) sortChordsFn 	the new comparator functions
	 * @return (com.ibm.rave.core.layout.chord.ChordLayout)  this layout
	 */
	sortChords$1 : function(sortChordsFn) {
		this._sortChords = sortChordsFn;
		if (this._chords) {
			this.resort();
		}
		return this;
	},

	/** @expose */ 
	matrix : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.matrix$1();
		}
		return this.matrix$0(a0);
	},

	/** @expose */ 
	value : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.value$0();
		}
		return this.value$1(a0);
	},

	/** @expose */ 
	padding : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.padding$1();
		}
		return this.padding$0(a0);
	},

	/** @expose */ 
	sortGroups : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.sortGroups$0();
		}
		return this.sortGroups$1(a0);
	},

	/** @expose */ 
	sortSubgroups : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.sortSubgroups$0();
		}
		return this.sortSubgroups$1(a0);
	},

	/** @expose */ 
	sortChords : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.sortChords$0();
		}
		return this.sortChords$1(a0);
	}
});

com_ibm_rave_core_layout_chord_ChordLayout.GroupAndSubGroupComparator = com_ibm_rave_core_nativeImpl_Declare({

	//dataToSort : null,

	//chord : null,

	//valGetFn : null,

	subGroup : false,

	_$functionClassMethod : function() {
		var _$self = function(o1, o2) {
			if (!_$self.subGroup) {
				return _$self.chord._sortGroups(_$self.dataToSort[o1], _$self.dataToSort[o2]);
			}
			return _$self.chord._sortSubgroups(_$self.valGetFn(_$self.dataToSort[o1]), _$self.valGetFn(_$self.dataToSort[o2]));
		};
		return _$self;
	},

	/** @expose */ 
	constructor : function(_chord, _dataToSort, _subGroups, theValGetFn) {
		this.dataToSort = _dataToSort;
		this.chord = _chord;
		this.subGroup = _subGroups;
		this.valGetFn = theValGetFn;
	}
});

com_ibm_rave_core_layout_chord_ChordLayout.ChordsComparator = com_ibm_rave_core_nativeImpl_Declare({

	//sortGroups : null,

	_$functionClassMethod : function() {
		var _$self = function(a, b) {
			return _$self.sortGroups((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
		};
		return _$self;
	},

	/** @expose */ 
	constructor : function(_sortGroups) {
		this.sortGroups = _sortGroups;
	}
});

com_ibm_rave_core_layout_chord_ChordLayout.DEFAULT_ACCESSOR_FN = function(data) {
	return + (data);
};

// $source: com/ibm/rave/core/svg/ArcData
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
/**
 * Default data structure for arc data, arc data is used by the ARC path generator  to build an SVG path from arc information 
 */
var com_ibm_rave_core_svg_ArcData = rave_externs["ArcData"] = com_ibm_rave_core_nativeImpl_Declare({

	/** @expose */ 
	innerRadius : 0,

	/** @expose */ 
	outerRadius : 0,

	/** @expose */ 
	startAngle : 0,

	/** @expose */ 
	endAngle : 0,

	/** @expose */ 
	padAngle : 0
});


// $source: com/ibm/rave/core/layout/chord/SubGroupData
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/svg/ArcData (loadtime) // superclass
var com_ibm_rave_core_layout_chord_SubGroupData = rave_externs["SubGroupData"] = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_svg_ArcData, {

	/** @expose */ 
	datum : null,

	/** @expose */ 
	index : 0,

	/** @expose */ 
	subindex : 0,

	/** @expose */ 
	radius : 0,

	/** @expose */ 
	value : 0,

	/** @expose */ 
	constructor : function(index, subindex, startAngle, endAngle, value, datum) {
		this.index = index;
		this.subindex = subindex;
		this.startAngle = startAngle;
		this.endAngle = endAngle;
		this.datum = datum;
		this.value = value;
	}
});


// $source: com/ibm/rave/core/layout/chord/GroupData
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/svg/ArcData (loadtime) // superclass
var com_ibm_rave_core_layout_chord_GroupData = rave_externs["GroupData"] = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_svg_ArcData, {

	/** @expose */ 
	index : 0,

	/** @expose */ 
	value : 0,

	/** @expose */ 
	constructor : function(index, startAngle, endAngle, value) {
		this.index = index;
		this.startAngle = startAngle;
		this.endAngle = endAngle;
		this.value = value;
	}
});


// $source: com/ibm/rave/core/layout/chord/ChordData
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/svg/ArcData (loadtime) // superclass
var com_ibm_rave_core_layout_chord_ChordData = rave_externs["ChordData"] = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_svg_ArcData, {

	/** @expose */ 
	source : null,

	/** @expose */ 
	target : null
});


// $source: com/ibm/rave/core/layout/cluster/Cluster
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare anonymous, declare
//@import com/ibm/rave/core/layout/hierarchy/HierarchyBase (loadtime) // superclass
//@import com/ibm/rave/core/layout/tree/Tree (runtime) // treeSeparation
//@import com/ibm/rave/core/layout/hierarchy/HierarchyUtil (runtime) // visitAfter
//@import com/ibm/rave/core/Rave (runtime) // max
var com_ibm_rave_core_layout_cluster_Cluster = rave_externs["Cluster"] = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_layout_hierarchy_HierarchyBase, {

	/**
	 * default separation method to be called
	 */
	//defaultSeparationFunction : null,

	/**
	 * An alias to this layout instance
	 */
	/** @expose */ 
	nodes : null,

	//separationFunction : null,

	//_size : null,

	/**
	 * value function for max in order to get the y value for each child. this will allow us to reduce all the children's y values and return a final y value.
	 * @param  ArrayList <Node> children children of a node
	 * @return  y value of a child
	 */
	//getChildY : null,

	_nodeSize : false,

	constructor : function() {
		this.defaultSeparationFunction = function(a, b) {
			return com_ibm_rave_core_layout_tree_Tree.treeSeparation(a, b);
		};
		this.separationFunction = this.defaultSeparationFunction;
		this._size = [1.0, 1.0];
		this.getChildY = function(child, index, groupIndex) {
			return (child)["y"];
		};
				/**
		 * Implements a hierarchical layout using the cluster (or dendrogram) algorithm.
		 */
		{
			this.nodes = this;
			this.sort(null);
			this.value(null);
		}
	},

	/**
	 * helps creates a cluster diagram by setting location attributes
	 * @param (Object) d the cluster nodes
	 * @param (int) i the index
	 * @return (Array)  list of all the cluster nodes
	 */
	doCreate$0 : function(d, i) {
		var nodes = com_ibm_rave_core_layout_hierarchy_HierarchyBase.prototype.doCreate.call(this, d, i);
		var root = nodes[0], previousNode;
		var x = 0;
		var self = this;
		com_ibm_rave_core_layout_hierarchy_HierarchyUtil.visitAfter(root, new (com_ibm_rave_core_nativeImpl_Declare({

			visit : function(node) {
				var children = node["children"];
				if (children && children.length > 0) {
					node["x"] = self.clusterX(children);
					node["y"] = self.clusterY(children);
				} else {
					if (previousNode) {
						x = x + self.separationFunction(node, previousNode);
						node["x"] = x;
					} else {
						node["x"] = 0;
					}
					node["y"] = 0;
					previousNode = node;
				}
			}

		}))());
		var left = this.clusterLeft(root);
		var right = this.clusterRight(root);
		var x0 = left["x"] - this.separationFunction(left, right) / 2.0;
		var x1 = right["x"] + this.separationFunction(right, left) / 2.0;
		com_ibm_rave_core_layout_hierarchy_HierarchyUtil.visitAfter(root, new (com_ibm_rave_core_nativeImpl_Declare({

			visit : function(node) {
				if (self._nodeSize) {
					node["x"] = (node["x"] - root["x"]) * self._size[0];
					node["y"] = (root["y"] - node["y"]) * self._size[1];
				} else {
					node["x"] = (node["x"] - x0) / (x1 - x0) * self._size[0];
					node["y"] = (1 - (root["y"] > 0 ? node["y"] / root["y"] : 1)) * self._size[1];
				}
			}

		}))());
		return nodes;
	},

	/**
	 * reduce children by using the Rave.max method in order to calculate the children's y value
	 * @param (Array) children children of a node
	 * @return (double)  children's y value
	 */
	clusterY : function(children) {
		return 1.0 + (com_ibm_rave_core_Rave.max(children, this.getChildY));
	},

	/**
	 * gets the reduced value and divides it by the number of children in order to get the children's x value
	 * @param (Array) children children of a node
	 * @return (double)  children's x value
	 */
	clusterX : function(children) {
		var reduction = 0.0;
		reduction = this.reduce(children);
		return reduction / children.length;
	},

	/**
	 * gets the reduced value
	 * @param (Array) children children of a node
	 * @return (double)  children's reduction value
	 */
	reduce : function(children) {
		var reduction = 0.0;
		var previousReduction = 0.0;
		for (var __i_enFor0 = 0, __exp_enFor0 = children, __len_enFor0 = __exp_enFor0.length;
				__i_enFor0 < __len_enFor0; ++__i_enFor0) {
			var node = __exp_enFor0[__i_enFor0];
			reduction = (previousReduction + node["x"]);
			previousReduction = reduction;
		}
		return reduction;
	},

	/**
	 * Compute the left-most node for extents
	 * @param (Object) node node to compute left-most node for extents
	 * @return (Object)  left-most node
	 */
	clusterRight : function(node) {
		var children = node["children"];
		return children && children.length > 0 ? this.clusterRight(children[children.length - 1]) : node;
	},

	/**
	 * compute the right-most node for extents
	 * @param (Object) node node node to compute right-most node for extents
	 * @return (Object)  right-most node
	 */
	clusterLeft : function(node) {
		var children = node["children"];
		return children && children.length > 0 ? this.clusterLeft(children[0]) : node;
	},

	/**
	 * sets the treeSeparation method to the new method being passed in
	 * @param (com.ibm.rave.core.layout.tree.Tree.GetSeparation) func the new method to be involved when calling treeSeparation
	 * @return (com.ibm.rave.core.layout.cluster.Cluster)  cluster instance
	 */
	separation$0 : function(func) {
		this.separationFunction = func;
		return this;
	},

	/**
	 * gets the treeSeparation method
	 * @return (com.ibm.rave.core.layout.tree.Tree.GetSeparation)  treeSeparation method
	 */
	separation$1 : function() {
		return this.separationFunction;
	},

	size$0 : function() {
		return this._nodeSize ? null : this._size;
	},

	/**
	 * sets the size of the layout
	 * @param (double[]) sizes the desired height and width of the layout
	 * @return (com.ibm.rave.core.layout.cluster.Cluster)  this the cluster object
	 */
	size$1 : function(sizes) {
		this._nodeSize = (!(this._size = sizes));
		return this;
	},

	/**
	 * sets the node size
	 * @param (double[]) nodeSize the desired node size
	 * @return (com.ibm.rave.core.layout.cluster.Cluster)  this the cluster object
	 */
	nodeSize$0 : function(nodeSize) {
		this._nodeSize = (this._size = nodeSize);
		return this;
	},

	/**
	 * gets the node size
	 * @return (double[])  nodeSize
	 */
	nodeSize$1 : function() {
		return this._nodeSize ? this._size : null;
	},

	/** @expose */ 
	doCreate : function(a0, a1) {
		var args = arguments;
		return this.doCreate$0(a0, a1);
	},

	/** @expose */ 
	separation : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.separation$1();
		}
		return this.separation$0(a0);
	},

	/** @expose */ 
	size : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.size$0();
		}
		return this.size$1(a0);
	},

	/** @expose */ 
	nodeSize : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.nodeSize$1();
		}
		return this.nodeSize$0(a0);
	}
});


// $source: com/ibm/rave/core/layout/tree/Tree
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare anonymous, declare
//@import com/ibm/rave/core/layout/hierarchy/HierarchyBase (loadtime) // superclass
//@import com/ibm/rave/core/layout/hierarchy/HierarchyUtil (runtime) // visitAfter, visitBefore
/**
 * The tree layout produces tidy node-link diagrams of trees using the Reingold–Tilford “tidy” algorithm.
 */
var com_ibm_rave_core_layout_tree_Tree = rave_externs["Tree"] = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_layout_hierarchy_HierarchyBase, {

	/**
	 * default separation method to be called
	 */
	//defaultSeparationFunction : null,

	/**
	 * An alias to this layout instance
	 */
	/** @expose */ 
	nodes : null,

	//sizeNode : null,

	//firstWalk : null,

	//secondWalk : null,

	//_size : null,

	//separationFunction : null,

	_nodeSize : false,

	constructor : function() {
		this.defaultSeparationFunction = function(a, b) {
			return com_ibm_rave_core_layout_tree_Tree.treeSeparation(a, b);
		};
		this._size = [1.0, 1.0];
		this.separationFunction = this.defaultSeparationFunction;
				/**
		 * c'tor
		 */
		{
			this.nodes = this;
			var self = this;
			this.sizeNode = new (com_ibm_rave_core_nativeImpl_Declare({

				visit : function(node) {
					node["x"] *= self._size[0];
					node["y"] = node["depth"] * self._size[1];
				}

			}))();
			this.firstWalk = new (com_ibm_rave_core_nativeImpl_Declare({

				visit : function(v) {
					var children = v["children"];
					var siblings = v["parent"]["children"];
					var w = v["i"] != 0 ? siblings[v["i"] - 1] : null;
					if (children.length > 0) {
						self.treeShift(v);
						var midpoint = (children[0]["z"] + children[children.length - 1]["z"]) / 2;
						if (w) {
							v["z"] = w["z"] + self.separationFunction(v["wrappedNode"], w["wrappedNode"]);
							v["m"] = v["z"] - midpoint;
						} else {
							v["z"] = midpoint;
						}
					} else if (w) {
						v["z"] = w["z"] + self.separationFunction(v["wrappedNode"], w["wrappedNode"]);
					}
					v["parent"]["A"] = self.apportion(v, w, (v["parent"]["A"]) ? v["parent"]["A"] : siblings.length > 0 ? siblings[0] : null);
				}

			}))();
			this.secondWalk = new (com_ibm_rave_core_nativeImpl_Declare({

				visit : function(v) {
					v["wrappedNode"]["x"] = v["z"] + v["parent"]["m"];
					v["m"] += v["parent"]["m"];
				}

			}))();
			this.sort(null);
			this.value(null);
		}
	},

	createTreeNodeWrapper : function(treeNode, parent, i) {
		var node = {};
		node["wrappedNode"] = treeNode;
		node["parent"] = parent;
		node["children"] = [];
		node["A"] = null;
		node["a"] = node;
		node["z"] = 0;
		node["m"] = 0;
		node["c"] = 0;
		node["s"] = 0;
		node["t"] = null;
		node["i"] = i;
		return node;
	},

	buildChildren : function(node) {
		if (node["wrappedNode"]["children"]) {
			for (var j = 0, n = node["wrappedNode"]["children"].length; j < n; ++j) {
				var childTreeNode = node["wrappedNode"]["children"][j];
				var child = this.createTreeNodeWrapper(childTreeNode, node, j);
				node["children"].push(child);
				this.buildChildren(child);
			}
		}
	},

	wrapTree : function(root0) {
		var wrappedRoot0 = this.createTreeNodeWrapper(root0, this.createTreeNodeWrapper(null, null, -1), 0);
		this.buildChildren(wrappedRoot0);
		return wrappedRoot0;
	},

	apportion : function(v, w, ancestor) {
		var _ancestor = ancestor;
		if (w) {
			var vip = v, vop = v, vim = w, vom = vip["parent"]["children"][0];
			var sip = vip["m"], sop = vop["m"], sim = vim["m"], som = vom["m"], shift;
			vim = this.treeRight(vim);
			vip = this.treeLeft(vip);
			while (vim && vip) {
				vom = this.treeLeft(vom);
				vop = this.treeRight(vop);
				vop["a"] = v;
				shift = vim["z"] + sim - vip["z"] - sip + this.separationFunction(vim["wrappedNode"], vip["wrappedNode"]);
				if (shift > 0) {
					this.treeMove(this.treeAncestor(vim, v, _ancestor), v, shift);
					sip += shift;
					sop += shift;
				}
				sim += vim["m"];
				sip += vip["m"];
				som += vom["m"];
				sop += vop["m"];
				vim = this.treeRight(vim);
				vip = this.treeLeft(vip);
			}
			if (vim && !this.treeRight(vop)) {
				vop["t"] = vim;
				vop["m"] += sim - sop;
			}
			if (vip && !this.treeLeft(vom)) {
				vom["t"] = vip;
				vom["m"] += sip - som;
				_ancestor = v;
			}
		}
		return _ancestor;
	},

	treeLeft : function(v) {
		var children = v["children"];
		return children.length > 0 ? children[0] : v["t"];
	},

	treeRight : function(v) {
		var children = v["children"];
		var n = children.length;
		return (n > 0) ? children[n - 1] : v["t"];
	},

	treeMove : function(wm, wp, shift) {
		var change = shift / (wp["i"] - wm["i"]);
		wp["c"] -= change;
		wp["s"] += shift;
		wm["c"] += change;
		wp["z"] += shift;
		wp["m"] += shift;
	},

	treeShift : function(v) {
		var shift = 0, change = 0;
		var children = v["children"];
		var i = children.length;
		var w;
		while (--i >= 0) {
			w = children[i];
			w["z"] += shift;
			w["m"] += shift;
			shift += w["s"] + (change += w["c"]);
		}
	},

	treeAncestor : function(vim, v, ancestor) {
		return vim["a"]["parent"] == (v["parent"]) ? vim["a"] : ancestor;
	},

	/**
	 * Creates a new tree layout with the default settings: the default sort order is null; the default children accessor assumes each input data is an object with a children array; the default separation function uses one node width for siblings, and two node widths for non-siblings; the default size is 1×1.
	 * @param (Object) d the root node containing all children
	 * @param (int) i the index
	 * @return (Array)  the tree layout array representing the computed positions of all child nodes
	 */
	doCreate$0 : function(d, i) {
		var nodes = com_ibm_rave_core_layout_hierarchy_HierarchyBase.prototype.doCreate.call(this, d, i);
		var root0 = nodes[0];
		var root1 = this.wrapTree(root0);
		com_ibm_rave_core_layout_hierarchy_HierarchyUtil.visitAfter(root1, this.firstWalk);
		root1["parent"]["m"] = -root1["z"];
		com_ibm_rave_core_layout_hierarchy_HierarchyUtil.visitBefore(root1, this.secondWalk);
		if (this._nodeSize) {
			com_ibm_rave_core_layout_hierarchy_HierarchyUtil.visitBefore(root0, this.sizeNode);
		} else {
			var left = root0, right = root0, bottom = root0;
			com_ibm_rave_core_layout_hierarchy_HierarchyUtil.visitBefore(root0, new (com_ibm_rave_core_nativeImpl_Declare({

				visit : function(node) {
					if (node["x"] < left["x"]) {
						left = node;
					}
					if (node["x"] > right["x"]) {
						right = node;
					}
					if (node["depth"] > bottom["depth"]) {
						bottom = node;
					}
				}

			}))());
			var tx = this.separationFunction(left, right) / 2.0 - left["x"];
			var kx = this._size[0] / (right["x"] + this.separationFunction(right, left) / 2.0 + tx);
			var ky = this._size[1] / ((bottom["depth"] > 0) ? bottom["depth"] : 1);
			com_ibm_rave_core_layout_hierarchy_HierarchyUtil.visitBefore(root0, new (com_ibm_rave_core_nativeImpl_Declare({

				visit : function(node) {
					node["x"] = (node["x"] + tx) * kx;
					node["y"] = node["depth"] * ky;
				}

			}))());
		}
		return nodes;
	},

	/**
	 * sets the separation method to the new method being passed in it is used to compute separation between neighboring nodes
	 * @param (com.ibm.rave.core.layout.tree.Tree.GetSeparation) func the new method to be involved when calling treeSeparation
	 * @return (com.ibm.rave.core.layout.tree.Tree)  tree instance
	 */
	separation$0 : function(func) {
		this.separationFunction = func;
		return this;
	},

	/**
	 * gets the separation method
	 * @return (com.ibm.rave.core.layout.tree.Tree.GetSeparation)  separation method
	 */
	separation$1 : function() {
		return this.separationFunction;
	},

	/**
	 * sets the size of the layout
	 * @param (Array) sizes the desired height and width of the layout
	 * @return (com.ibm.rave.core.layout.tree.Tree)  this the tree object
	 */
	size$0 : function(sizes) {
		this._nodeSize = (!(this._size = sizes));
		return this;
	},

	/**
	 * gets the size of the layout The default is 1x1
	 * @return (Array)  an array representing the size of the layout
	 */
	size$1 : function() {
		return this._nodeSize ? null : this._size;
	},

	/**
	 * sets the node size
	 * @param (Array) sizes the desired node size
	 * @return (com.ibm.rave.core.layout.tree.Tree)  this the tree object
	 */
	nodeSize$0 : function(sizes) {
		this._nodeSize = ((this._size = sizes));
		return this;
	},

	/**
	 * gets the node size
	 * @return (Array)  nodeSize
	 */
	nodeSize$1 : function() {
		return (this._nodeSize) ? this._size : null;
	},

	/** @expose */ 
	doCreate : function(a0, a1) {
		var args = arguments;
		return this.doCreate$0(a0, a1);
	},

	/** @expose */ 
	separation : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.separation$1();
		}
		return this.separation$0(a0);
	},

	/** @expose */ 
	size : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.size$1();
		}
		return this.size$0(a0);
	},

	/** @expose */ 
	nodeSize : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.nodeSize$1();
		}
		return this.nodeSize$0(a0);
	}
});

/**
 * compares parent nodes
 * @param (Object) a compares node a's parent with node b
 * @param (Object) b compares node a's parent with node b
 * @return (int)  indicates whether a and b are the same or different
 */
/** @expose */ 
com_ibm_rave_core_layout_tree_Tree.treeSeparation = function(a, b) {
	return a["parent"] == b["parent"] ? 1 : 2;
};


// $source: com/ibm/rave/core/layout/StackLayout
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/nativeImpl/arrays/ES6Map (runtime) // create
//@import com/ibm/rave/core/Rave (runtime) // permute, range
//@import com/ibm/rave/core/internal/util/Identity (static) // create
//@import com/ibm/rave/core/arrays/Range (runtime) // create
var com_ibm_rave_core_layout_StackLayout = rave_externs["StackLayout"] = com_ibm_rave_core_nativeImpl_Declare({

	//valuesFn : null,

	//orderFn : null,

	//offsetFn : null,

	//outFn : null,

	//accumulatorFn : null,

	//DEFAULT_ACCUMULATOR_FUNCTION : null,

	//POSITIVES_NEGATIVES_ACCUMULATOR_FUNCTION : null,

	//r2_layout_stackAccumulators : null,

	//defaultAccumulatorFn : null,

	//positivesAndNegativesAccumulatorFn : null,

	//xFn : null,

	//yFn : null,

	accumulatedPos : 0,

	accumulatedNeg : 0,

	accumulatedVal : 0,

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * Constructs a new stack layout with the default offset (zero) and order (null). The returned layout object is both an object and a function. That is: you can call the layout like any other function, and the layout has additional methods that change its behavior. Like other classes in Rave, layouts follow the method chaining pattern where setter methods return the layout itself, allowing multiple setters to be invoked in a concise statement.
		 * @param (Object) this the context
		 * @param (Array) data the data
		 * @param (int) index the index
		 * @return (Array)  modified data
		 */
		function(data, index) {
			var objData = data;
			var n = data.length;
			if (n == 0) {
				return data;
			}
			var i = 0, j = 0;
			var self = _$self;
			var series = objData.map(function(currentValue, currentIndex, array) {
				return self.valuesFn.call(this, currentValue, currentIndex, -1);
			});
			var points = series.map(function(currentValue, notUsedindex, notUsedarray) {
				return currentValue.map(function(pointsCurrentValue, pointIndex, pointArray) {
					var xVal = (+ (self.xFn.call(self, pointsCurrentValue, pointIndex, -1)));
					var yVal = (+ (self.yFn.call(self, pointsCurrentValue, pointIndex, -1)));
					return [xVal, yVal];
				});
			});
			var orders = _$self.orderFn.call(_$self, points, index, -1);
			series = com_ibm_rave_core_Rave.permute(series, orders);
			points = com_ibm_rave_core_Rave.permute(points, orders);
			var offsets = _$self.offsetFn.call(_$self, points, index, -1);
			var m = series[0].length;
			for (j = 0; j < m; ++j) {
				var o = offsets[j];
				_$self.accumulatedVal = o;
				_$self.accumulatedPos = 0;
				_$self.accumulatedNeg = 0;
				if (_$self.accumulatedVal >= 0) {
					_$self.accumulatedPos = _$self.accumulatedVal;
				} else {
					_$self.accumulatedNeg = _$self.accumulatedVal;
				}
				_$self.outFn.call(_$self, series[0][j], o, points[0][j][1]);
				for (i = 1; i < n; ++i) {
					var lastVal = points[i - 1][j][1];
					var currentVal = points[i][j][1];
					_$self.accumulatedVal = _$self.accumulator().call(_$self, o, lastVal, currentVal);
					_$self.outFn.call(_$self, series[i][j], _$self.accumulatedVal, currentVal);
				}
			}
			return data;
		};
		return _$self;
	},

	constructor : function() {
		this.valuesFn = com_ibm_rave_core_layout_StackLayout.DEFAULT_VALUES_FUNCTION;
		this.orderFn = com_ibm_rave_core_layout_StackLayout.DEFAULT_STACKORDER_FUNCTION;
		this.offsetFn = com_ibm_rave_core_layout_StackLayout.DEFAULT_STACKOFFSETZERO;
		this.outFn = com_ibm_rave_core_layout_StackLayout.DEFAULT_OUT_FUNCTION;
		this.xFn = com_ibm_rave_core_layout_StackLayout.DEFAULT_X_FUNCTION;
		this.yFn = com_ibm_rave_core_layout_StackLayout.DEFAULT_Y_FUNCTION;
		{
			var self = this;
			this.DEFAULT_ACCUMULATOR_FUNCTION = function(offsetValue, lastValue, currentValue) {
				return self.accumulatedVal + lastValue;
			};
			this.defaultAccumulatorFn = this.DEFAULT_ACCUMULATOR_FUNCTION;
			this.POSITIVES_NEGATIVES_ACCUMULATOR_FUNCTION = function(offsetValue, lastValue, currentValue) {
				if (lastValue >= 0) {
					self.accumulatedPos += lastValue;
				} else {
					self.accumulatedNeg += lastValue;
				}
				if (currentValue >= 0) {
					return self.accumulatedPos;
				} else {
					return self.accumulatedNeg;
				}
			};
			this.positivesAndNegativesAccumulatorFn = this.POSITIVES_NEGATIVES_ACCUMULATOR_FUNCTION;
			this.r2_layout_stackAccumulators = this.initialize_r2_layout_stackAccumulators();
		}
	},

	/**
	 * gets the x-coordinate function
	 * @return (com.ibm.rave.core.selector.ValueFunction)  X function
	 */
	x$0 : function() {
		return this.xFn;
	},

	/**
	 * Specifies how to access the x-coordinate of each value's position.
	 * @param (com.ibm.rave.core.selector.ValueFunction) newXFn
	 * @return (com.ibm.rave.core.layout.StackLayout)  this layout
	 */
	x$1 : function(newXFn) {
		this.xFn = newXFn;
		return this;
	},

	/**
	 * Gets the Y-coordinate function
	 * @return (com.ibm.rave.core.selector.ValueFunction)  Y function
	 */
	y$0 : function() {
		return this.yFn;
	},

	/**
	 * Specifies how to access the Y-coordinate of each value's position.
	 * @param (com.ibm.rave.core.selector.ValueFunction) newYFn
	 * @return (com.ibm.rave.core.layout.StackLayout)  this layout
	 */
	y$1 : function(newYFn) {
		this.yFn = newYFn;
		return this;
	},

	/**
	 * Gets the Out Function
	 * @return (com.ibm.rave.core.layout.StackLayout.StackOutFunction)  the out function
	 */
	out$0 : function() {
		return this.outFn;
	},

	/**
	 * Sets the function that Specifies how to propagate the computed baseline to above layers.
	 * @param (com.ibm.rave.core.layout.StackLayout.StackOutFunction) newOutFn
	 * @return (com.ibm.rave.core.layout.StackLayout)  this layout
	 */
	out$1 : function(newOutFn) {
		this.outFn = newOutFn;
		return this;
	},

	/**
	 * Gets the values Function
	 * @return (com.ibm.rave.core.selector.ValueFunction)  stack layout value function
	 */
	values$0 : function() {
		return this.valuesFn;
	},

	/**
	 * Sets the function that Specifies how to extract values from the associated element in layers
	 * @param (com.ibm.rave.core.selector.ValueFunction) newValuesFn
	 * @return (com.ibm.rave.core.layout.StackLayout)  this layout
	 */
	values$1 : function(newValuesFn) {
		this.valuesFn = newValuesFn;
		return this;
	},

	/**
	 * Gets The stack order function
	 * @return (com.ibm.rave.core.selector.ValueFunction)  stack order function
	 */
	order$0 : function() {
		return this.orderFn;
	},

	/**
	 * Sets the function used to speficy the stack order
	 * @param (com.ibm.rave.core.selector.ValueFunction) newOrderFn
	 * @return (com.ibm.rave.core.layout.StackLayout)  this layout
	 */
	order$1 : function(newOrderFn) {
		this.orderFn = newOrderFn;
		return this;
	},

	/**
	 * Sets the stack accumulator function. An accumulator function is an algorithm that determines how cumulative values are calculated for the stack layout.  
	 * @param (com.ibm.rave.core.layout.StackLayout.AccumulatorFunction) newAccumulatorFn The new accumulator function
	 * @return (com.ibm.rave.core.layout.StackLayout)  this layout
	 */
	accumulator$0 : function(newAccumulatorFn) {
		this.accumulatorFn = newAccumulatorFn;
		return this;
	},

	/**
	 * Sets the function that serves as accumulator (the algorithm used to calculate the cumulative values) for the stack layout using the provided string.  Currently the only supported accumulator function is : "separate-positives-negatives". The accumulator for "separate-positives-negatives" sums up and stores positive values and negative values separately.
	 * @param (String) accumulator The accumulator
	 * @return (com.ibm.rave.core.layout.StackLayout)  this layout
	 */
	accumulator$1 : function(accumulator) {
		var requestedAccumulatorFn = this.r2_layout_stackAccumulators.get(accumulator);
		if (!requestedAccumulatorFn) {
			requestedAccumulatorFn = this.DEFAULT_ACCUMULATOR_FUNCTION;
		}
		this.accumulatorFn = requestedAccumulatorFn;
		return this;
	},

	/**
	 * Returns the accumulator function used for the stack layout.
	 * @return (com.ibm.rave.core.layout.StackLayout.AccumulatorFunction)  The accumulator function
	 */
	accumulator$2 : function() {
		if (!this.accumulatorFn) {
			this.accumulator$0(this.DEFAULT_ACCUMULATOR_FUNCTION);
		}
		return this.accumulatorFn;
	},

	/**
	 * Sets the stack order to use, supported types are "inside-out", "reverse" and "default"
	 * @param (String) orderType
	 * @return (com.ibm.rave.core.layout.StackLayout)  this layout
	 */
	order$2 : function(orderType) {
		var requestedOrderFn = com_ibm_rave_core_layout_StackLayout.r2_layout_stackOrders.get(orderType);
		if (!requestedOrderFn) {
			requestedOrderFn = com_ibm_rave_core_layout_StackLayout.DEFAULT_STACKORDER_FUNCTION;
		}
		this.orderFn = requestedOrderFn;
		return this;
	},

	/**
	 * Gets the stack offset algorithm
	 * @return (com.ibm.rave.core.selector.ValueFunction)  stack offset algorithm
	 */
	offset$0 : function() {
		return this.offsetFn;
	},

	/**
	 * Sets the stack order algorithm
	 * @param (com.ibm.rave.core.selector.ValueFunction) newOffsetFn
	 * @return (com.ibm.rave.core.layout.StackLayout)  this layout
	 */
	offset$1 : function(newOffsetFn) {
		this.offsetFn = newOffsetFn;
		return this;
	},

	/**
	 * Sets the stack order algorithm type, supported types are : "silhouette", "wiggle", "expand"and "zero"
	 * @param (String) offsetType
	 * @return (com.ibm.rave.core.layout.StackLayout)  this
	 */
	offset$2 : function(offsetType) {
		var requestedOffsetFn = com_ibm_rave_core_layout_StackLayout.r2_layout_stackOffsets.get(offsetType);
		if (!requestedOffsetFn) {
			requestedOffsetFn = com_ibm_rave_core_layout_StackLayout.DEFAULT_STACKOFFSETZERO;
		}
		this.offsetFn = requestedOffsetFn;
		return this;
	},

	initialize_r2_layout_stackAccumulators : function() {
		var r2_layout_stackAccumulators = com_ibm_rave_core_nativeImpl_arrays_ES6Map.create();
		r2_layout_stackAccumulators.set("separate-positives-negatives", this.POSITIVES_NEGATIVES_ACCUMULATOR_FUNCTION);
		return r2_layout_stackAccumulators;
	},

	/** @expose */ 
	x : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.x$0();
		}
		return this.x$1(a0);
	},

	/** @expose */ 
	y : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.y$0();
		}
		return this.y$1(a0);
	},

	/** @expose */ 
	out : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.out$0();
		}
		return this.out$1(a0);
	},

	/** @expose */ 
	values : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.values$0();
		}
		return this.values$1(a0);
	},

	/** @expose */ 
	order : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.order$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.order$1(a0);
		}
		return this.order$2(a0);
	},

	/** @expose */ 
	accumulator : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.accumulator$2();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.accumulator$0(a0);
		}
		return this.accumulator$1(a0);
	},

	/** @expose */ 
	offset : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.offset$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.offset$1(a0);
		}
		return this.offset$2(a0);
	}
});

com_ibm_rave_core_layout_StackLayout.initialize_r2_layout_stackOrders = function() {
	var r2_layout_stackOrders = com_ibm_rave_core_nativeImpl_arrays_ES6Map.create();
	r2_layout_stackOrders.set("inside-out", com_ibm_rave_core_layout_StackLayout.STACKORDER_INSIDED_OUT);
	r2_layout_stackOrders.set("reverse", com_ibm_rave_core_layout_StackLayout.STACKORDER_REVERSE);
	r2_layout_stackOrders.set("default", com_ibm_rave_core_layout_StackLayout.DEFAULT_STACKORDER_FUNCTION);
	return r2_layout_stackOrders;
};

com_ibm_rave_core_layout_StackLayout.initialize_r2_layout_stackOffsets = function() {
	var r2_layout_stackOffsets = com_ibm_rave_core_nativeImpl_arrays_ES6Map.create();
	r2_layout_stackOffsets.set("silhouette", com_ibm_rave_core_layout_StackLayout.STACKOFFSET_SILHOUETTE);
	r2_layout_stackOffsets.set("wiggle", com_ibm_rave_core_layout_StackLayout.STACKOFFSET_WIGGLE);
	r2_layout_stackOffsets.set("expand", com_ibm_rave_core_layout_StackLayout.STACKOFFSET_EXPAND);
	r2_layout_stackOffsets.set("zero", com_ibm_rave_core_layout_StackLayout.DEFAULT_STACKOFFSETZERO);
	return r2_layout_stackOffsets;
};

com_ibm_rave_core_layout_StackLayout.DEFAULT_VALUES_FUNCTION = com_ibm_rave_core_internal_util_Identity.create();
com_ibm_rave_core_layout_StackLayout.DEFAULT_STACKORDER_FUNCTION = function(data, index, groupIndex) {
	var aData = data;
	return (com_ibm_rave_core_arrays_Range.create(aData.length));
};
com_ibm_rave_core_layout_StackLayout.DEFAULT_STACKOFFSETZERO = function(data, index, groupIndex) {
	var j = -1;
	var child = ((data)[0]);
	var m = child.length;
	var y0 = [];
	while (++j < m) {
		y0[j] = 0;
	}
	return y0;
};
com_ibm_rave_core_layout_StackLayout.DEFAULT_OUT_FUNCTION = function(stackNode, y0, y) {
	var node = stackNode;
	node["y0"] = y0;
	node["y"] = y;
};
com_ibm_rave_core_layout_StackLayout.DEFAULT_X_FUNCTION = function(data, index, groupIndex) {
	return (data)["x"];
};
com_ibm_rave_core_layout_StackLayout.DEFAULT_Y_FUNCTION = function(data, index, groupIndex) {
	return (data)["y"];
};
com_ibm_rave_core_layout_StackLayout.r2_layout_stackMaxIndex = function(currentValue, index, array) {
	var i = 1;
	var j = 0;
	var parentArray = currentValue[0];
	var v = parentArray[1];
	var k = 0;
	var n = array.length;
	for (i = 0; i < n; ++i) {
		parentArray = currentValue[i];
		k = parentArray[1];
		if (k > v) {
			j = i;
			v = k;
		}
	}
	return j;
};
com_ibm_rave_core_layout_StackLayout.r2_layout_stackSum = function(previousValue, currentValue, index, array) {
	return previousValue + currentValue[1];
};
com_ibm_rave_core_layout_StackLayout.r2_layout_stackReduceSum = function(currentValue, index, array) {
	return currentValue.reduce(com_ibm_rave_core_layout_StackLayout.r2_layout_stackSum, 0);
};
com_ibm_rave_core_layout_StackLayout.STACKORDER_REVERSE = function(data, index, groupIndex) {
	var aData = data;
	return (com_ibm_rave_core_arrays_Range.create(aData.length)).reverse();
};
com_ibm_rave_core_layout_StackLayout.STACKORDER_INSIDED_OUT = function(data, index, groupIndex) {
	var aData = data;
	var n = aData.length;
	var i = 0;
	var j = 0;
	var max = aData.map(com_ibm_rave_core_layout_StackLayout.r2_layout_stackMaxIndex);
	var sums = aData.map(com_ibm_rave_core_layout_StackLayout.r2_layout_stackReduceSum);
	var sortedIndex = com_ibm_rave_core_Rave.range(n).sort(function(obj1, obj2) {
		return ~~(max[~~+ (obj1)] - max[~~+ (obj2)]);
	});
	var top = 0;
	var bottom = 0;
	var tops = [];
	var bottoms = [];
	for (i = 0; i < n; ++i) {
		j = ~~+ (sortedIndex[i]);
		if (top < bottom) {
			top += sums[j];
			tops.push((j));
		} else {
			bottom += sums[j];
			bottoms.push(~~((j)));
		}
	}
	return bottoms.reverse().concat(tops);
};
com_ibm_rave_core_layout_StackLayout.r2_layout_stackOrders = com_ibm_rave_core_layout_StackLayout.initialize_r2_layout_stackOrders();
com_ibm_rave_core_layout_StackLayout.STACKOFFSET_SILHOUETTE = function(data, index, groupIndex) {
	var aData = data;
	var n = aData.length;
	var m = aData[0].length;
	var sums = [];
	var max = 0;
	var i;
	var j;
	var o;
	var y0 = [];
	for (j = 0; j < m; ++j) {
		for (i = 0, o = 0; i < n; ++i) {
			o += aData[i][j][1];
		}
		if (o > max) {
			max = o;
		}
		sums.push(o);
	}
	for (j = 0; j < m; ++j) {
		y0[j] = max - sums[j] / 2;
	}
	return y0;
};
com_ibm_rave_core_layout_StackLayout.STACKOFFSET_WIGGLE = function(data, index, groupIndex) {
	var aData = data;
	var n = aData.length;
	var x = aData[0];
	var m = x.length;
	var i = 0, j = 0, k = 0;
	var s1 = 0, s2 = 0, s3 = 0, dx = 0;
	var o = 0, o0 = 0;
	var y0 = [];
	y0[0] = 0;
	for (j = 1; j < m; ++j) {
		for (i = 0, s1 = 0; i < n; ++i) {
			s1 += aData[i][j][1];
		}
		s2 = 0;
		dx = x[j][0] - x[j - 1][0];
		for (i = 0; i < n; ++i) {
			var isElement = aData[i];
			s3 = (isElement[j][1] - isElement[j - 1][1]) / (2 * dx);
			for (k = 0; k < i; ++k) {
				var ksElement = aData[k];
				s3 += (ksElement[j][1] - ksElement[j - 1][1]) / dx;
			}
			s2 += s3 * isElement[j][1];
		}
		if (s1 != 0) {
			o -= s2 / s1 * dx;
		}
		y0[j] = o;
		if (o < o0) {
			o0 = o;
		}
	}
	for (j = 0; j < m; ++j) {
		var val = y0[j];
		y0[j] = val - o0;
	}
	return y0;
};
com_ibm_rave_core_layout_StackLayout.STACKOFFSET_EXPAND = function(data, index, groupIndex) {
	var aData = data;
	var n = aData.length;
	var m = aData[0].length;
	var k = 1 / n;
	var i = 0;
	var j = 0;
	var o = 0;
	var y0 = [];
	for (j = 0; j < m; ++j) {
		for (i = 0, o = 0; i < n; ++i) {
			o += aData[i][j][1];
		}
		if (o != 0) {
			for (i = 0; i < n; ++i) {
				var ijElement = aData[i][j];
				var val = ijElement[1];
				ijElement[1] = val / o;
			}
		} else {
			for (i = 0; i < n; ++i) {
				var ijElement = aData[i][j];
				ijElement[1] = k;
			}
		}
	}
	for (j = 0; j < m; ++j) {
		y0[j] = 0;
	}
	return y0;
};
com_ibm_rave_core_layout_StackLayout.r2_layout_stackOffsets = com_ibm_rave_core_layout_StackLayout.initialize_r2_layout_stackOffsets();

// $source: com/ibm/rave/core/layout/treemap/Treemap
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/layout/hierarchy/HierarchyBase (loadtime) // superclass
//@import com/ibm/rave/core/internal/layout/treemap/TreemapRect (runtime) // new
//@import com/ibm/rave/core/layout/hierarchy/HierarchyUtil (runtime) // revalue
//@import com/ibm/rave/core/internal/layout/treemap/Row (runtime) // new
/**
 * A Layout for the treemap
 * @author  Bryan
 */
var com_ibm_rave_core_layout_treemap_Treemap = rave_externs["Treemap"] = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_layout_hierarchy_HierarchyBase, {

	/**
	 * @param  node
	 * @return  a rect from the node with no padding
	 */
	//treemapPadNull : null,

	/**
	 * @param  node
	 * @param  padding
	 * @return  the new rect with padding
	 */
	//treemapPad : null,

	/**
	 * An alias to this layout instance
	 */
	/** @expose */ 
	nodes : null,

	//_size : null,

	//_padding : null,

	//_pad : null,

	//_stickies : null,

	//_mode : null,

	//_ratio : null,

	//squarify : null,

	//stickify : null,

	_round : false,

	_sticky : false,

	constructor : function() {
		this.treemapPadNull = function(node) {
			var rect = new com_ibm_rave_core_internal_layout_treemap_TreemapRect();
			rect.x = node["x"];
			rect.y = node["y"];
			rect.dx = node["dx"];
			rect.dy = node["dy"];
			return rect;
		};
		this.treemapPad = function(node, padding) {
			var rect = new com_ibm_rave_core_internal_layout_treemap_TreemapRect();
			rect.x = node["x"] + + (padding[3]);
			rect.y = node["y"] + + (padding[0]);
			rect.dx = node["dx"] - + (padding[1]) - + (padding[3]);
			rect.dy = node["dy"] - + (padding[0]) - + (padding[2]);
			if (rect.dx < 0) {
				rect.x += rect.dx / 2;
				rect.dx = 0;
			}
			if (rect.dy < 0) {
				rect.y += rect.dy / 2;
				rect.dy = 0;
			}
			return rect;
		};
				/**
		 * Creates a new treemap layout with the default settings: the default sort order is by descending value;  the default value accessor assumes each input data is an object with a numeric value attribute;  the default children accessor assumes each input data is an object with a children array; the default size is 1×1.
		 */
		{
			this._round = true;
			this._size = [1, 1];
			this._padding = null;
			this._pad = this.treemapPadNull;
			this._sticky = false;
			this._stickies = null;
			this._mode = "squarify";
			this._ratio = 0.5 * (1 + Math.sqrt(5));
			this.nodes = this;
			var self = this;
			this.squarify = function(node, index, array) {
				var children = node["children"];
				if (children && children.length != 0) {
					var rect = self._pad(node);
					var row = new com_ibm_rave_core_internal_layout_treemap_Row();
					var remaining = children.slice();
					var child;
					var best = Infinity;
					var score = 0;
					var u = self._mode == "slice" ? rect.dx : self._mode == "dice" ? rect.dy : self._mode == "slice-dice" ? (node["depth"] & 1) ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy);
					var n;
					self.scale(remaining, rect.dx * rect.dy / node["value"]);
					row.area = 0;
					while ((n = remaining.length) > 0) {
						row.push(child = remaining[n - 1]);
						row.area += child["area"];
						if (!(self._mode == "squarify") || (score = self.worst(row, u)) <= best) {
							remaining.pop();
							best = score;
						} else {
							row.area -= row.pop()["area"];
							self.position(row, u, rect, false);
							u = Math.min(rect.dx, rect.dy);
							row = new com_ibm_rave_core_internal_layout_treemap_Row();
							best = Infinity;
						}
					}
					if (row.length != 0) {
						self.position(row, u, rect, true);
						row = new com_ibm_rave_core_internal_layout_treemap_Row();
					}
					children.forEach(self.squarify);
				}
				return null;
			};
			this.stickify = function(node, index, array) {
				var children = node["children"];
				if (children && children.length != 0) {
					var rect = self._pad(node);
					var remaining = children.slice();
					var child;
					var row = new com_ibm_rave_core_internal_layout_treemap_Row();
					self.scale(remaining, rect.dx * rect.dy / node["value"]);
					row.area = 0;
					while ((child = remaining.pop())) {
						row.push(child);
						row.area += child["area"];
						if (child["z"] != null) {
							self.position(row, child["z"] ? rect.dx : rect.dy, rect, remaining.length == 0);
							row = new com_ibm_rave_core_internal_layout_treemap_Row();
						}
					}
					children.forEach(self.stickify);
				}
				return null;
			};
		}
	},

	/**
	 * Compute the area for each child based on value & scale
	 * @param (Array) children
	 * @param (double) k
	 */
	scale : function(children, k) {
		var i = -1;
		var n = children.length;
		var child;
		var area;
		while (++i < n) {
			area = (child = children[i])["value"] * (k < 0 ? 0 : k);
			child["area"] = isNaN(area) || area <= 0 ? 0 : area;
		}
	},

	/**
	 * Computes the score for the specified row, as the worst aspect ratio
	 * @param (com.ibm.rave.core.internal.layout.treemap.Row) row
	 * @param (double) u
	 * @return (double)  the score for the specified row
	 */
	worst : function(row, u) {
		var _u = u;
		var s = row.area;
		var r;
		var rmax = 0;
		var rmin = Infinity;
		var i = -1;
		var n = row.length;
		while (++i < n) {
			if ((r = row[i]["area"]) == 0) {
				continue;
			}
			if (r < rmin) {
				rmin = r;
			}
			if (r > rmax) {
				rmax = r;
			}
		}
		s *= s;
		_u *= _u;
		return s != 0 ? Math.max((_u * rmax * this._ratio) / s, s / (_u * rmin * this._ratio)) : Infinity;
	},

	/**
	 * Positions the specified row of nodes. modifies "rect"
	 * @param (com.ibm.rave.core.internal.layout.treemap.Row) row
	 * @param (double) u
	 * @param (com.ibm.rave.core.internal.layout.treemap.TreemapRect) rect
	 * @param (boolean) flush
	 */
	position : function(row, u, rect, flush) {
		var i = -1;
		var n = row.length;
		var x = rect.x;
		var y = rect.y;
		var v = u != 0 ? this.roundFunction(row.area / u) : 0;
		if (u == rect.dx) {
			var o = null;
			if (flush || v > rect.dy) {
				v = rect.dy;
			}
			while (++i < n) {
				o = row[i];
				o["x"] = x;
				o["y"] = y;
				o["dy"] = v;
				x += o["dx"] = Math.min(rect.x + rect.dx - x, v != 0 ? this.roundFunction(o["area"] / v) : 0);
			}
			if (o) {
				o["z"] = true;
				o["dx"] += rect.x + rect.dx - x;
				rect.y += v;
				rect.dy -= v;
			}
		} else {
			var o = null;
			if (flush || v > rect.dx) {
				v = rect.dx;
			}
			while (++i < n) {
				o = row[i];
				o["x"] = x;
				o["y"] = y;
				o["dx"] = v;
				y += o["dy"] = Math.min(rect.y + rect.dy - y, v != 0 ? this.roundFunction(o["area"] / v) : 0);
			}
			if (o) {
				o["z"] = false;
				o["dy"] += rect.y + rect.dy - y;
				rect.x += v;
				rect.dx -= v;
			}
		}
	},

	/**
	 * Runs the treemap layout, returning the array of nodes associated with the specified root node.  The treemap layout is part of D3's family of hierarchical layouts. These layouts follow the same basic structure:  the input argument to the layout is the root node of the hierarchy, and the output return value is an array representing the computed positions of all nodes. Several attributes are populated on each node: parent - the parent node, or null for the root. children - the array of child nodes, or null for leaf nodes. value - the node value, as returned by the value accessor. depth - the depth of the node, starting at 0 for the root. x - the minimum x-coordinate of the node position. y - the minimum y-coordinate of the node position. dx - the x-extent of the node position. dy - the y-extent of the node position. Note that this will modify the nodes that you pass in! Although the layout has a size in x and y, this represents an arbitrary coordinate system; for example, you can treat x as a radius and y as an angle to produce a radial rather than Cartesian layout. In Cartesian orientation, x, y, dx and dy correspond to the "x", "y", "width" and "height" attributes of the SVG rect element.
	 * @param  rootNode The root node of the treemap * @param i the index (currently unused)
	 * @return (Array)  an array of all the nodes in the treemap
	 */
	doCreate$0 : function(d, i) {
		var nodes = (this._stickies) ? this._stickies : com_ibm_rave_core_layout_hierarchy_HierarchyBase.prototype.doCreate.call(this, d, i);
		var root = nodes[0];
		root["x"] = 0;
		root["y"] = 0;
		root["dx"] = this._size[0];
		root["dy"] = this._size[1];
		if (this._stickies) {
			com_ibm_rave_core_layout_hierarchy_HierarchyUtil.revalue(root, this);
		}
		this.scale([root], root["dx"] * root["dy"] / root["value"]);
		(this._stickies ? this.stickify : this.squarify)(root, 0, [root]);
		if (this._sticky) {
			this._stickies = nodes;
		}
		return nodes;
	},

	/**
	 * If size is specified, sets the available layout size to the specified two-element  array of numbers representing x and y. If size is not specified, returns the current size,  which defaults to 1×1.
	 * @return (Array)  the size array as a list with two values
	 */
	size$0 : function() {
		return this._size;
	},

	/**
	 * If size is specified, sets the available layout size to the specified two-element  array of numbers representing x and y. If size is not specified, returns the current size,  which defaults to 1×1.
	 * @param (Array) size the size to set as a list with two values
	 * @return (com.ibm.rave.core.layout.treemap.Treemap)  this instance of the treemap
	 */
	size$1 : function(size) {
		this._size = size;
		return this;
	},

	/**
	 * Get or set the padding for each treemap cell, in pixels. The padding determines the amount of extra space to  reserve between the parent and its children; this space can be used to indicate the hierarchy through enclosure,  or to reserve space for parent labels. If no padding is used, then the leaves of the tree will completely fill the layout's size. If padding is specified, sets the new padding and returns the treemap layout;  if padding is not specified, returns the current padding. The padding may be specified several ways: A null value disables padding; null is equivalent to zero. A number indicates uniform padding, in pixels, on all four sides. An array of numbers indicates the top, right, bottom and left padding values. The padding may also be specified as a function which returns one of the three above values.  This function is evaluated for each internal (non-leaf) node, and can be used to compute padding dynamically.
	 * @return (Object)  the padding
	 */
	padding$0 : function() {
		return this._padding;
	},

	/**
	 * Get or set the padding for each treemap cell, in pixels. The padding determines the amount of extra space to  reserve between the parent and its children; this space can be used to indicate the hierarchy through enclosure,  or to reserve space for parent labels. If no padding is used, then the leaves of the tree will completely fill the layout's size. If padding is specified, sets the new padding and returns the treemap layout;  if padding is not specified, returns the current padding. The padding may be specified several ways: A null value disables padding; null is equivalent to zero. A number indicates uniform padding, in pixels, on all four sides. An array of numbers indicates the top, right, bottom and left padding values. The padding may also be specified as a function which returns one of the three above values.  This function is evaluated for each internal (non-leaf) node, and can be used to compute padding dynamically.
	 * @param (double) padding a single value to be added to all four sides of the treemap
	 * @return (com.ibm.rave.core.layout.treemap.Treemap)  this instance of the treemap
	 */
	padding$1 : function(padding) {
		var paddingArray = [];
		paddingArray.push(padding);
		return this.padding$2(paddingArray);
	},

	/**
	 * Get or set the padding for each treemap cell, in pixels. The padding determines the amount of extra space to  reserve between the parent and its children; this space can be used to indicate the hierarchy through enclosure,  or to reserve space for parent labels. If no padding is used, then the leaves of the tree will completely fill the layout's size. If padding is specified, sets the new padding and returns the treemap layout;  if padding is not specified, returns the current padding. The padding may be specified several ways: A null value disables padding; null is equivalent to zero. A number indicates uniform padding, in pixels, on all four sides. An array of numbers indicates the top, right, bottom and left padding values. The padding may also be specified as a function which returns one of the three above values.  This function is evaluated for each internal (non-leaf) node, and can be used to compute padding dynamically.
	 * @param (Array) padding a list of doubles which must contain four values, one for each side
	 * @return (com.ibm.rave.core.layout.treemap.Treemap)  this instance of the treemap
	 */
	padding$2 : function(padding) {
		var self = this;
		var padConstant = function(node) {
			return self.treemapPad(node, padding.length == 1 ? [padding[0], padding[0], padding[0], padding[0]] : padding);
		};
		this._padding = padding;
		this._pad = this._padding == null || padding.length == 0 ? this.treemapPadNull : padConstant;
		return this;
	},

	/**
	 * Get or set the padding for each treemap cell, in pixels. The padding determines the amount of extra space to  reserve between the parent and its children; this space can be used to indicate the hierarchy through enclosure,  or to reserve space for parent labels. If no padding is used, then the leaves of the tree will completely fill the layout's size. If padding is specified, sets the new padding and returns the treemap layout;  if padding is not specified, returns the current padding. The padding may be specified several ways: A null value disables padding; null is equivalent to zero. A number indicates uniform padding, in pixels, on all four sides. An array of numbers indicates the top, right, bottom and left padding values. The padding may also be specified as a function which returns one of the three above values.  This function is evaluated for each internal (non-leaf) node, and can be used to compute padding dynamically.
	 * @param (com.ibm.rave.core.functions.TwoParamValueFunction) padding a function which must return a single value of a list of four values
	 * @return (com.ibm.rave.core.layout.treemap.Treemap)  this instance of the treemap
	 */
	padding$3 : function(padding) {
		var self = this;
		var padFunction = function(node) {
			var pObject = padding(node, node["depth"]);
			var p = null;
			if ((typeof pObject === "number" || pObject instanceof Number)) {
				p = [+ (pObject), + (pObject), + (pObject), + (pObject)];
			} else if ((typeof pObject === "array" || pObject instanceof Array)) {
				var pList = pObject;
				p = [];
				for (var __i_enFor0 = 0, __exp_enFor0 = pList, __len_enFor0 = __exp_enFor0.length;
						__i_enFor0 < __len_enFor0; ++__i_enFor0) {
					var o = __exp_enFor0[__i_enFor0];
					p.push(o);
				}
			}
			return !p ? self.treemapPadNull(node) : self.treemapPad(node, p);
		};
		this._padding = padding;
		this._pad = this._padding == null ? this.treemapPadNull : padFunction;
		return this;
	},

	/**
	 * If round is specified, sets whether or not the treemap layout will round to exact pixel boundaries.  This can be nice to avoid antialiasing artifacts in SVG.  If round is not specified, returns whether the treemap will be rounded.
	 * @return (boolean)  round
	 */
	round$0 : function() {
		return this._round;
	},

	/**
	 * If round is specified, sets whether or not the treemap layout will round to exact pixel boundaries.  This can be nice to avoid antialiasing artifacts in SVG.  If round is not specified, returns whether the treemap will be rounded.
	 * @param (boolean) round boolean to indicate whether the treemap should round
	 * @return (com.ibm.rave.core.layout.treemap.Treemap)  this instance of the treemap
	 */
	round$1 : function(round) {
		this._round = round;
		return this;
	},

	/**
	 * The rounding function
	 * @param (Number) value the value to round
	 * @return (double)  the rounded value
	 */
	roundFunction : function(value) {
		if (this._round) {
			return Math.round(value);
		}
		return value;
	},

	/**
	 * If sticky is specified, sets whether or not the treemap layout is "sticky":  a sticky treemap layout will preserve the relative arrangement of nodes across transitions.  The allocation of nodes into squarified horizontal and vertical rows is persisted across updates by  storing a z attribute on the last element in each row; this allows nodes to be resized smoothly,  without shuffling or occlusion that would impede perception of changing values. Note, however,  that this results in a suboptimal layout for one of the two states. If sticky is not specified,  returns whether the treemap layout is sticky. Implementation note: sticky treemaps cache the array of nodes internally;  therefore, it is not possible to reuse the same layout instance on multiple datasets.  To reset the cached state when switching datasets with a sticky layout, call sticky(true) again.  Since version 1.25.0, hierarchy layouts no longer copy the input data by default on each invocation,  so it may be possible to eliminate caching and make the layout fully stateless.
	 * @return (boolean)  sticky
	 */
	sticky$0 : function() {
		return this._sticky;
	},

	/**
	 * If sticky is specified, sets whether or not the treemap layout is "sticky":  a sticky treemap layout will preserve the relative arrangement of nodes across transitions.  The allocation of nodes into squarified horizontal and vertical rows is persisted across updates by  storing a z attribute on the last element in each row; this allows nodes to be resized smoothly,  without shuffling or occlusion that would impede perception of changing values. Note, however,  that this results in a suboptimal layout for one of the two states. If sticky is not specified,  returns whether the treemap layout is sticky. Implementation note: sticky treemaps cache the array of nodes internally;  therefore, it is not possible to reuse the same layout instance on multiple datasets.  To reset the cached state when switching datasets with a sticky layout, call sticky(true) again.  Since version 1.25.0, hierarchy layouts no longer copy the input data by default on each invocation,  so it may be possible to eliminate caching and make the layout fully stateless.
	 * @param (boolean) sticky a boolean to indicates whether to keep the nodes in this instance
	 * @return (com.ibm.rave.core.layout.treemap.Treemap)  this instance of the treemap
	 */
	sticky$1 : function(sticky) {
		this._sticky = sticky;
		this._stickies = null;
		return this;
	},

	/**
	 * If ratio is specified, sets the layout ratio. If ratio is not specified,  returns the current layout ratio, which defaults to .5 * (1 + Math.sqrt(5))
	 * @return (double)  the ratio
	 */
	ratio$0 : function() {
		return this._ratio;
	},

	/**
	 * If ratio is specified, sets the layout ratio. If ratio is not specified,  returns the current layout ratio, which defaults to .5 * (1 + Math.sqrt(5))
	 * @param (double) ratio the value used to compute the score for the specified row
	 * @return (com.ibm.rave.core.layout.treemap.Treemap)  this instance of the treemap
	 */
	ratio$1 : function(ratio) {
		this._ratio = ratio;
		return this;
	},

	/**
	 * If mode is specified, sets the layout algorithm. If mode is not specified, returns the current layout algorithm,  which defaults to "squarify". The following modes are supported: squarify - rectangular subdivision; squareness controlled via the target ratio. slice - horizontal subdivision. dice - vertical subdivision. slice-dice - alternating between horizontal and vertical subdivision.
	 * @return (String)  the mode
	 */
	mode$0 : function() {
		return this._mode;
	},

	/**
	 * If mode is specified, sets the layout algorithm. If mode is not specified, returns the current layout algorithm,  which defaults to "squarify". The following modes are supported: squarify - rectangular subdivision; squareness controlled via the target ratio. slice - horizontal subdivision. dice - vertical subdivision. slice-dice - alternating between horizontal and vertical subdivision.
	 * @param (String) mode the mode to use to organize the treemap layout
	 * @return (com.ibm.rave.core.layout.treemap.Treemap)  this instance of the treemap
	 */
	mode$1 : function(mode) {
		this._mode = mode + "";
		return this;
	},

	/** @expose */ 
	doCreate : function(a0, a1) {
		var args = arguments;
		return this.doCreate$0(a0, a1);
	},

	/** @expose */ 
	size : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.size$0();
		}
		return this.size$1(a0);
	},

	/** @expose */ 
	padding : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.padding$0();
		}
		if (args.length == 1 && (a0 == null || Object.prototype.toString.call(a0) === "[object Array]")) {
			return this.padding$2(a0);
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.padding$3(a0);
		}
		return this.padding$1(a0);
	},

	/** @expose */ 
	round : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.round$0();
		}
		return this.round$1(a0);
	},

	/** @expose */ 
	sticky : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.sticky$0();
		}
		return this.sticky$1(a0);
	},

	/** @expose */ 
	ratio : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.ratio$0();
		}
		return this.ratio$1(a0);
	},

	/** @expose */ 
	mode : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.mode$0();
		}
		return this.mode$1(a0);
	}
});


// $source: com/ibm/rave/core/internal/layout/treemap/TreemapRect
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
var com_ibm_rave_core_internal_layout_treemap_TreemapRect = com_ibm_rave_core_nativeImpl_Declare({

	x : 0, dx : 0, y : 0, dy : 0,

	constructor : function() {
		this.x = 0;
		this.y = 0;
		this.dx = 0;
		this.dy = 0;
	}
});


// $source: com/ibm/rave/core/internal/layout/treemap/Row
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
/**
 * A treemap row... it's just an Array with an area... clearly
 * @author  Bryan
 */
var com_ibm_rave_core_internal_layout_treemap_Row = com_ibm_rave_core_nativeImpl_Declare(Array, {

	area : 0
});


// $source: com/ibm/rave/core/layout/PieLayout
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/Rave (runtime) // sum
//@import com/ibm/rave/core/arrays/Range (runtime) // create
//@import com/ibm/rave/core/layout/SliceData (runtime) // new
var com_ibm_rave_core_layout_PieLayout = rave_externs["PieLayout"] = com_ibm_rave_core_nativeImpl_Declare({

	//_value : null,

	//_sort : null,

	//_endAngle : null,

	_startAngle : 0,

	_padAngle : 0,

	sortDefined : false,

	_$functionClassMethod : function() {
		var _$self = function(a0, a1) {
			var args = arguments;
			if (args.length == 1) {
				return _$self.pie$0(a0);
			}
			return _$self.pie$1(a0, a1);
		};
		return _$self;
	},

	constructor : function() {
		this._value = com_ibm_rave_core_layout_PieLayout.VALUE;
		this._endAngle = 6.283185307179586;
	},

	/**
	 * Calculates the arc data on the specified array of values.  An optional index may be specified, which is passed along to the start and end angle functions.
	 * @param (Array) info Data used to construct arc data
	 * @return (com.ibm.rave.core.layout.SliceData[])  sliceData Slice data used to construct the arcs
	 */
	pie$0 : function(info) {
		return this(info, -1);
	},

	/**
	 * Calculates the arc data on the specified array of values.  An optional index may be specified, which is passed along to the start and end angle functions.
	 * @param (Array) data Data used to construct arc data
	 * @return (com.ibm.rave.core.layout.SliceData[])  sliceData Slice data used to construct the arcs
	 */
	pie$1 : function(data, index) {
		var values;
		var self = this;
		var n = data.length;
		values = data.map(function(currentValue, i, array) {
			return + (self._value.call(self, currentValue, i, -1));
		});
		var a = + ((typeof this._startAngle === "function") ? (this._startAngle).call(this, data, index, -1) : this._startAngle);
		var da = + ((typeof this._endAngle === "function") ? (this._endAngle).call(this, data, index, -1) : this._endAngle) - a;
		var p = Math.min(Math.abs(da) / n, + ((typeof this._padAngle === "function") ? (this._padAngle).call(this, data, index, -1) : this._padAngle));
		var pa = p * (da < 0 ? -1 : 1);
		var k = (da - n * pa) / (com_ibm_rave_core_Rave.sum(values));
		var indexArr = com_ibm_rave_core_arrays_Range.create(data.length);
		if (!this.sortDefined) {
			indexArr.sort(function(i, j) {
				return (values[~~ (j)] - values[~~ (i)]);
			});
		} else if (this.sortDefined && this._sort) {
			indexArr.sort(function(i, j) {
				return self._sort(data[~~ (i)], data[~~ (j)]);
			});
		}
		var arcs = [];
		for (var __i_enFor0 = 0, __exp_enFor0 = indexArr, __len_enFor0 = __exp_enFor0.length;
				__i_enFor0 < __len_enFor0; ++__i_enFor0) {
			var j = __exp_enFor0[__i_enFor0];
			var sd = new com_ibm_rave_core_layout_SliceData();
			var v = sd.value = values[~~ (j)];
			sd.data = data[~~ (j)];
			sd.startAngle = a;
			sd.endAngle = a += v * k + pa;
			sd.innerRadius = 0;
			sd.outerRadius = 0;
			sd.padAngle = p;
			arcs[~~ (j)] = sd;
		}
		return arcs;
	},

	/**
	 * sets the start angle value function, function that will be called by the arc class to get the value on start angle
	 * @param (com.ibm.rave.core.selector.ValueFunction) startAngleFn the start angle function
	 * @return (com.ibm.rave.core.layout.PieLayout)  this
	 */
	startAngle$0 : function(startAngleFn) {
		this._startAngle = startAngleFn;
		return this;
	},

	/**
	 * sets the start angle value 
	 * @param (Object) value   the start angle value
	 * @return (com.ibm.rave.core.layout.PieLayout) 	this
	 */
	startAngle$1 : function(value) {
		this._startAngle = value;
		return this;
	},

	/**
	 * gets the start angle value function
	 * @return (Object) 	the value function
	 */
	startAngle$2 : function() {
		return this._startAngle;
	},

	/**
	 * sets the end angle value function, function that will be called by the arc class to get the value on end angle
	 * @param (com.ibm.rave.core.selector.ValueFunction) endAngleFn the end angle function
	 * @return (com.ibm.rave.core.layout.PieLayout)  this
	 */
	endAngle$0 : function(endAngleFn) {
		this._endAngle = endAngleFn;
		return this;
	},

	/**
	 * sets the end angle value
	 * @param (Object) value the end angle value
	 * @return (com.ibm.rave.core.layout.PieLayout)  this
	 */
	endAngle$1 : function(value) {
		this._endAngle = value;
		return this;
	},

	/**
	 * gets the end angle value function
	 * @return (Object)  the value function
	 */
	endAngle$2 : function() {
		return this._endAngle;
	},

	/**
	 * sets the function for computing data values, function that will be called by the PieLayout class to get the data values
	 * @param (com.ibm.rave.core.selector.ValueFunction) valueFn The function for computing data values
	 * @return (com.ibm.rave.core.layout.PieLayout)  this
	 */
	value$0 : function(valueFn) {
		this._value = valueFn;
		return this;
	},

	/**
	 * gets the data value function
	 * @return (com.ibm.rave.core.selector.ValueFunction)  the value function
	 */
	value$1 : function() {
		return this._value;
	},

	/**
	 * sets the pad Angle value function, function that will be called by the arc class to get the value on pad Angle
	 * @param (com.ibm.rave.core.selector.ValueFunction) padAngleFn the padAngle function
	 * @return (com.ibm.rave.core.layout.PieLayout)  this
	 */
	padAngle$0 : function(padAngleFn) {
		this._padAngle = padAngleFn;
		return this;
	},

	/**
	 * sets the pad Angle value 
	 * @param (Object) value   the pad Angle value
	 * @return (com.ibm.rave.core.layout.PieLayout) 	this
	 */
	padAngle$1 : function(value) {
		this._padAngle = value;
		return this;
	},

	/**
	 * gets the pad Angle value function
	 * @return (Object) 	the value function
	 */
	padAngle$2 : function() {
		return this._padAngle;
	},

	/**
	 * sets the comparator for sorting
	 * @param (com.ibm.rave.core.util.Comparator) sortFn the sort comparator
	 * @return (com.ibm.rave.core.layout.PieLayout)  this
	 */
	sort$0 : function(sortFn) {
		this.sortDefined = true;
		this._sort = sortFn;
		return this;
	},

	/**
	 * gets the sort comparator
	 * @return (com.ibm.rave.core.util.Comparator)  the value function
	 */
	sort$1 : function() {
		return this._sort;
	},

	/** @expose */ 
	startAngle : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.startAngle$2();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.startAngle$0(a0);
		}
		return this.startAngle$1(a0);
	},

	/** @expose */ 
	endAngle : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.endAngle$2();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.endAngle$0(a0);
		}
		return this.endAngle$1(a0);
	},

	/** @expose */ 
	value : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.value$1();
		}
		return this.value$0(a0);
	},

	/** @expose */ 
	padAngle : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.padAngle$2();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.padAngle$0(a0);
		}
		return this.padAngle$1(a0);
	},

	/** @expose */ 
	sort : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.sort$1();
		}
		return this.sort$0(a0);
	}
});

/**
 * Default value function for value calculation.
 */
com_ibm_rave_core_layout_PieLayout.VALUE = function(data, index, groupIndex) {
	return + (data);
};

// $source: com/ibm/rave/core/layout/SliceData
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/svg/ArcData (loadtime) // superclass
var com_ibm_rave_core_layout_SliceData = rave_externs["SliceData"] = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_svg_ArcData, {

	/** @expose */ 
	value : null,

	/** @expose */ 
	data : null
});


// $source: com/ibm/rave/core/layout/HistogramLayout
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/arrays/Bisector (runtime) // Bisector
//@import com/ibm/rave/core/arrays/MinMax (runtime) // min, max
/**
 * Histogram layout shows the distribution of data by grouping discrete data points into bins
 */
var com_ibm_rave_core_layout_HistogramLayout = rave_externs["HistogramLayout"] = com_ibm_rave_core_nativeImpl_Declare({

	//valuerFn : null,

	//ranger : null,

	//binner : null,

	freqencyVal : true,

	_$functionClassMethod : function() {
		var _$self = function(a0, a1) {
			var args = arguments;
			if (args.length == 1) {
				return _$self.histogram$0(a0);
			}
			return _$self.histogram$1(a0, a1);
		};
		return _$self;
	},

	constructor : function() {
		this.valuerFn = com_ibm_rave_core_layout_HistogramLayout.DEFAULT_VALUER_FN;
		this.ranger = com_ibm_rave_core_layout_HistogramLayout.RANGER_DEFAULT_FN;
		this.binner = com_ibm_rave_core_layout_HistogramLayout.DEFAULT_BINNER_FN;
	},

	/**
	 * Evaluates the histogram function on the specified array of values.  An optional index may be specified, which is passed along to the range and bin function.
	 * @param (Array) data The data to be processed
	 * @return (Array) An array of arrays, off the data split into it's proper bins,  each element in the outer array represents a bin, each bin contains the associated elements from the input values
	 */
	histogram$0 : function(data) {
		return this(data, 0);
	},

	/**
	 * Evaluates the histogram function on the specified array of values.  An optional index may be specified, which is passed along to the range and bin function. 
	 * @param (Array) data The data to be processed
	 * @param (int) index The index that is passed along to the range and bin functions
	 * @return (Array) An array of arrays, off the data split into it's proper bins,  each element in the outer array represents a bin, each bin contains the associated elements from the input values
	 */
	histogram$1 : function(data, index) {
		var bins = [];
		var values = data.map(this.valuerFn);
		var range = this.ranger.call(this, values, index, -1);
		var thresholds = this.binner.call(this, range, values, index);
		var bin;
		var i = -1;
		var n = values.length, m = thresholds.length - 1;
		var k = this.freqencyVal ? 1 : 1 / n, x;
		while (++i < m) {
			bin = [];
			bins[i] = bin;
			bin["dx"] = + (thresholds[i + 1]) - (bin["x"] = + (thresholds[i]));
			bin["y"] = 0;
		}
		if (m > 0) {
			i = -1;
			while (++i < n) {
				x = values[i];
				if (x >= + (range[0]) && x <= + (range[1])) {
					bin = bins[com_ibm_rave_core_arrays_Bisector.bisect(thresholds, (x), 1, m) - 1];
					bin["y"] += k;
					bin.push(data[i]);
				}
			}
		}
		return bins;
	},

	layout_histogramRange : function(values) {
		return [com_ibm_rave_core_arrays_MinMax.min(values), com_ibm_rave_core_arrays_MinMax.max(values)];
	},

	/**
	 * Determines if the histogram's `y` value is a count (frequency) or a probability (density). The default value is true.
	 * @return (boolean) Whether the calculation is using frequency or density
	 */
	frequency$0 : function() {
		return this.freqencyVal;
	},

	/**
	 * Specifies whether the histogram's `y` value is a count (frequency) or a probability (density). The default value is true.
	 * @param (java.lang.Boolean) x The value to set frequency to.
	 * @return (com.ibm.rave.core.layout.HistogramLayout) this
	 */
	frequency$1 : function(x) {
		this.freqencyVal = (x);
		return this;
	},

	/**
	 * Specifies how to bin values in the histogram. The argument `x` may be specified as a number, in which case the range of values will be split uniformly into the given number of bins. Or, `x` may be an array of threshold values, defining the bins; the specified array must contain the rightmost (upper) value, thus specifying n + 1 values for n bins. Or, `x` may be a function which is evaluated, being passed the range, the array of values, and the current index `i`, returning an array of thresholds. The default bin function will divide the values into uniform bins using Sturges' formula.
	 * @return (com.ibm.rave.core.layout.HistogramLayout.HistogramBinSturges)  binner
	 */
	bins$0 : function() {
		return this.binner;
	},

	/**
	 * Specifies how to bin values in the histogram. The argument `x` is a number, in which case the range of values will be split uniformly into the given number of bins. 
	 * @param (Number) x the range of values will be split uniformly into the given number of bins
	 * @return (com.ibm.rave.core.layout.HistogramLayout) 	this layout
	 */
	bins$1 : function(x) {
		this.binner = function(range, values, index) {
			return com_ibm_rave_core_layout_HistogramLayout.layout_histogramBinFixed(range, x);
		};
		return this;
	},

	/**
	 * Specifies how to bin values in the histogram. The argument `x` may be an array of threshold values, defining the bins; the specified array must contain the rightmost (upper) value, thus specifying n + 1 values for n bins. Or, `x` may be a function which is evaluated, being passed the range, the array of values, and the current index `i`, returning an array of thresholds. The default bin function will divide the values into uniform bins using Sturges' formula.
	 * @param (Object) x An array of threshold values, or a function to call back 
	 * @return (com.ibm.rave.core.layout.HistogramLayout) 	this layout
	 */
	bins$2 : function(x) {
		if (typeof x === "function") {
			this.binner = x;
		} else {
			this.binner = function(range, values, index) {
				return x;
			};
		}
		return this;
	},

	/**
	 * Gets the range of the histogram. The default range is the extent (minimum and maximum) of the values.
	 * @return (com.ibm.rave.core.selector.ValueFunction) 	the ranger function
	 */
	range$0 : function() {
		return this.ranger;
	},

	/**
	 * Specifies the range of the histogram. Values outside the specified range will be ignored. The argument `x` is  a two-element array representing the minimum and maximum value of the range.  The default range is the extent (minimum and maximum) of the values.
	 * @param (Array) range 		the range
	 * @return (com.ibm.rave.core.layout.HistogramLayout) 	this layout
	 */
	range$1 : function(range) {
		this.ranger = function(data, index, groupIndex) {
			return range;
		};
		return this;
	},

	/**
	 * Specifies the range of the histogram. Values outside the specified range will be ignored. The argument `x` is a  function that returns the range  given the array of values and the current index `i`.  The default range is the extent (minimum and maximum) of the values.
	 * @param (com.ibm.rave.core.selector.ValueFunction) fn 		the range function
	 * @return (com.ibm.rave.core.layout.HistogramLayout) 	this layout
	 */
	range$2 : function(fn) {
		this.ranger = fn;
		return this;
	},

	/**
	 * Return the function used to extract a value from the associated data. The default value function is `Number`, which is equivalent to the identity function.
	 * @return (com.ibm.rave.core.collections.ArrayEx.ArrayValueFunction)  teh vlaue function
	 */
	value$0 : function() {
		return this.valuerFn;
	},

	/**
	 * Specifies how to extract a value from the associated data. The default value function is `Number`, which is equivalent to the identity function.
	 * @param (com.ibm.rave.core.collections.ArrayEx.ArrayValueFunction) x 	the value function
	 * @return (com.ibm.rave.core.layout.HistogramLayout) 	this layout
	 */
	value$1 : function(x) {
		this.valuerFn = x;
		return this;
	},

	/** @expose */ 
	frequency : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.frequency$0();
		}
		return this.frequency$1(a0);
	},

	/** @expose */ 
	bins : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.bins$0();
		}
		if (args.length == 1 && (a0 == null || typeof a0 === "number")) {
			return this.bins$1(a0);
		}
		return this.bins$2(a0);
	},

	/** @expose */ 
	range : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.range$0();
		}
		if (args.length == 1 && (a0 == null || Object.prototype.toString.call(a0) === "[object Array]")) {
			return this.range$1(a0);
		}
		return this.range$2(a0);
	},

	/** @expose */ 
	value : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.value$0();
		}
		return this.value$1(a0);
	}
});

com_ibm_rave_core_layout_HistogramLayout.layout_histogramBinFixed = function(range, n) {
	var x = -1;
	var b = + (range[0]);
	var m = (+ (range[1]) - b) / n;
	var f = [];
	while (++x <= n) {
		f[x] = m * x + b;
	}
	return f;
};

com_ibm_rave_core_layout_HistogramLayout.LN2 = Math.log(2);
com_ibm_rave_core_layout_HistogramLayout.RANGER_DEFAULT_FN = function(values, index, groupIndex) {
	return [com_ibm_rave_core_arrays_MinMax.min(values), com_ibm_rave_core_arrays_MinMax.max(values)];
};
com_ibm_rave_core_layout_HistogramLayout.DEFAULT_VALUER_FN = function(currentValue, index, array) {
	return + (currentValue);
};
com_ibm_rave_core_layout_HistogramLayout.DEFAULT_BINNER_FN = function(range, values, index) {
	return com_ibm_rave_core_layout_HistogramLayout.layout_histogramBinFixed(range, Math.ceil(Math.log(((values)).length) / com_ibm_rave_core_layout_HistogramLayout.LN2 + 1));
};

// $source: com/ibm/rave/core/layout/hierarchy/Hierarchy
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/layout/hierarchy/HierarchyBase (loadtime) // superclass
//@import com/ibm/rave/core/layout/hierarchy/HierarchyUtil (runtime) // revalue
/**
 * The hierarchy layout is an abstract layout that is not used directly, but instead  allows code sharing between multiple hierarchical layouts. For an implementation,  see one of: Cluster - cluster entities into a dendrogram. Pack - produce a hierarchical layout using recursive circle-packing. Partition - recursively partition a node tree into a sunburst or icicle. Tree - position a tree of nodes tidily. Treemap - use recursive spatial subdivision to display a tree of nodes. Although not a hierarchy layout, the bundle layout is also designed to work in  conjunction with hierarchies
 * @param < (Object) T > the type of HierarchyBase
 */
var com_ibm_rave_core_layout_hierarchy_Hierarchy = rave_externs["Hierarchy"] = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_layout_hierarchy_HierarchyBase, {

	/**
	 * c'tor
	 */
	/** @expose */ 
	constructor : function() {},

	/**
	 * Re-evaluates the `value` property for the specified hierarchy.
	 * @param (Object) root the root node of type T 
	 * @return (Object)  the root node that was revalued
	 */
	/** @expose */ 
	revalue : function(root) {
		return com_ibm_rave_core_layout_hierarchy_HierarchyUtil.revalue(root, this);
	}
});


// $source: com/ibm/rave/core/layout/PartitionLayout
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/layout/hierarchy/HierarchyBase (loadtime) // superclass
/**
 * Produces adjacency diagrams: a space-filling variant of a node-link tree diagram.  Rather than drawing a link between parent and child in the hierarchy, nodes are drawn as solid areas (either arcs or rectangles), and their placement relative to other nodes reveals their position in the hierarchy. The size of the nodes encodes a quantitative dimension that would be difficult to show in a node-link diagram
 */
var com_ibm_rave_core_layout_PartitionLayout = rave_externs["PartitionLayout"] = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_layout_hierarchy_HierarchyBase, {

	//sizeVal : null,

	/**
	 * An alias to this layout instance
	 */
	/** @expose */ 
	nodes : null,

	constructor : function() {
		this.sizeVal = [1, 1];
		{
			this.nodes = this;
		}
	},

	position : function(node, x, dx, dy) {
		var children = node["children"];
		node["x"] = x;
		node["y"] = node["depth"] * dy;
		node["dx"] = dx;
		node["dy"] = dy;
		var n = 0;
		var localdx = dx;
		var localx = x;
		if (children && children.length > 0) {
			n = children.length;
			var i = -1;
			var c;
			var d = 0;
			localdx = (node["value"]) ? localdx / node["value"] : 0;
			while (++i < n) {
				c = children[i];
				d = c["value"] * localdx;
				this.position(c, localx, d, dy);
				localx += d;
			}
		}
	},

	depth : function(node) {
		var children = node["children"];
		var d = 0;
		if (children && children.length > 0) {
			var n = children.length;
			var i = -1;
			while (++i < n) {
				d = Math.max(d, this.depth(children[i]));
			}
		}
		return 1 + d;
	},

	/**
	 * Returns the current size, which defaults to 1×1
	 * @return (double[])  return the current size
	 */
	size$0 : function() {
		return this.sizeVal;
	},

	/**
	 * Sets the available layout size to the specified two-element array of numbers representing x and y.
	 * @param (double[]) newSize 	the size of the layout
	 * @return (com.ibm.rave.core.layout.PartitionLayout) 	this Layout
	 */
	size$1 : function(newSize) {
		this.sizeVal = newSize;
		return this;
	},

	/**
	 * Runs the partition layout, returning the array of nodes associated with the specified root node. The partition layout is part of Rave's family of hierarchical layouts. These layouts follow the same basic structure: the input argument to the layout is the root node of the hierarchy, and the output return value is an array representing the computed positions of all nodes. Several attributes are populated on each node: parent - the parent node, or null for the root. children - the array of child nodes, or null for leaf nodes. value - the node value, as returned by the value accessor. depth - the depth of the node, starting at 0 for the root. x - the minimum x-coordinate of the node position. y - the minimum y-coordinate of the node position. dx - the x-extent of the node position. dy - the y-extent of the node position. Although the layout has a size in x and y, this represents an arbitrary coordinate system;  for example, you can treat x as a radius and y as an angle to produce a radial rather than Cartesian layout. In Cartesian orientation, x, y, dx and dy correspond to the "x", "y",  "width" and "height" attributes of the SVG rect element. In radial orientation, they can be used to compute the innerRadius, startAngle, outerRadius and endAngle of an arc generator. The Cartesian orientation may be called an icicle tree, while the radial orientation is called a sunburst.
	 * @param (Object) d the root node
	 * @param (int) i 	 the node index
	 * @return (Array)  list of all the cluster nodes
	 */
	doCreate$0 : function(d, i) {
		var nodes = com_ibm_rave_core_layout_hierarchy_HierarchyBase.prototype.doCreate.call(this, d, i);
		this.position(nodes[0], 0, this.sizeVal[0], this.sizeVal[1] / this.depth(nodes[0]));
		return nodes;
	},

	/** @expose */ 
	size : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.size$0();
		}
		return this.size$1(a0);
	},

	/** @expose */ 
	doCreate : function(a0, a1) {
		var args = arguments;
		return this.doCreate$0(a0, a1);
	}
});


// $source: com/ibm/rave/core/capabilities/Capabilities
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/RegistryService (loadtime) // superclass
/**
 * The Capabilities class is used to register the services and factories attached to rave e.g. An example of a service would be something like layouts where the functionality is extensible and  new layouts could be registered to the layouts object. An example of a factory would be something like statistics where the functionality is not extensible and it provides a a finite, discrete set of functionality that is optional to the core layer, and can be loaded on demand USAGE: Registration: Rave.capabilities.extension("id", instance); Fetching extension: Rave.capabilities.extension("id");
 */
var com_ibm_rave_core_capabilities_Capabilities = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_RegistryService, {

	/**
	 * singleton
	 */
	//constructor : function() {}
});

/** @expose */ 
com_ibm_rave_core_capabilities_Capabilities.INSTANCE = new com_ibm_rave_core_capabilities_Capabilities();

// $source: com/ibm/rave/core/svg/LinePathGeneratorFactory
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/svg/LineRadial (runtime) // createLine
//@import com/ibm/rave/core/internal/util/Identity (runtime) // create
//@import com/ibm/rave/core/svg/SVGLine (runtime) // createLine
/**
 * Line Path Generator Factory
 */
var com_ibm_rave_core_svg_LinePathGeneratorFactory = rave_externs["LinePathGeneratorFactory"] = com_ibm_rave_core_nativeImpl_Declare({

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * Creates a Line Path generator using the Identity projection Constructs a new line generator with the default x- and y-accessor functions (that assume the input data is a two-element array of numbers), and linear interpolation. The returned function generates path data for an open piecewise linear curve, or polyline By changing the interpolation, you can also generate splines and step functions. Also, don't be afraid to tack on additional path commands at the end. For example, if you want to generate a closed path, append a closepath (Z)
		 * @return (com.ibm.rave.core.svg.LinePathGenerator)  line path generator {@link (com.ibm.rave.core.svg.LinePathGenerator) LinePathGenerator}
		 */
		function() {
			var identity = com_ibm_rave_core_internal_util_Identity.create();
			return com_ibm_rave_core_svg_SVGLine.createLine(identity);
		};
		return _$self;
	},

	/**
	 * Constructs a new radial line generator with the default radius- and angle-accessor functions (that assume the input data is a two-element array of numbers), and linear interpolation. The returned generator generates path data for an open piecewise linear curve, or polyline, as with the Cartesian line generator.
	 * @return (com.ibm.rave.core.svg.LineRadial.RadialLinePathGenerator)  svg path generator
	 */
	/** @expose */ 
	radial : function() {
		return com_ibm_rave_core_svg_LineRadial.createLine();
	}
});


// $source: com/ibm/rave/core/svg/LineRadial
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/svg/LinePathGenerator (loadtime) // superclass
/**
 * Constructs a new radial line generator with the default radius- and  angle-accessor functions (that assume the input data is a two-element  array of numbers), and linear interpolation.  The returned function generates path data for an open piecewise linear  curve, or polyline, as with the Cartesian line generator.
 */
var com_ibm_rave_core_svg_LineRadial = rave_externs["LineRadial"] = com_ibm_rave_core_nativeImpl_Declare({


});

/**
 * Constructs a new radial line generator with the default radius- and angle-accessor functions (that assume the input data is a two-element array of numbers), and linear interpolation. The returned generator generates path data for an open piecewise linear curve, or polyline, as with the Cartesian line generator.
 * @return (com.ibm.rave.core.svg.LineRadial.RadialLinePathGenerator)  a radial line path generator  {@link (com.ibm.rave.core.svg.LinePathGenerator) LinePathGenerator}
 */
/** @expose */ 
com_ibm_rave_core_svg_LineRadial.createLine = function() {
	return new com_ibm_rave_core_svg_LineRadial.RadialLinePathGenerator(com_ibm_rave_core_svg_LineRadial.r2_svg_lineRadial);
};

/**
 * Radial Line path generator
 */
com_ibm_rave_core_svg_LineRadial.RadialLinePathGenerator = rave_externs["RadialLinePathGenerator"] = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_svg_LinePathGenerator, {

	/**
	 * Constructor constructs a Radial Line path generator
	 * @param (com.ibm.rave.core.selector.ValueFunction) projection the projection to set on this line generator
	 */
	/** @expose */ 
	constructor : function(projection) {
	},

	/**
	 * Gets the radius-accessor, it can be a function or constant.
	 * @return (Object)  the radius-accessor 
	 */
	radius$0 : com_ibm_rave_core_svg_LinePathGenerator.prototype.x$0,

	/**
	 * Sets the radius-accessor to the specified function.  This accessor is invoked for each element in the data array passed to the line generator. The default accessor assumes that each input element is a two-element array of numbers
	 * @param (com.ibm.rave.core.selector.ValueFunction) valFn the  radius-accessor
	 * @return (com.ibm.rave.core.svg.LineRadial.RadialLinePathGenerator)  the line path generator
	 */
	radius$1 : com_ibm_rave_core_svg_LinePathGenerator.prototype.x$1,

	/**
	 * Sets the radius-accessor to the constant. 
	 * @param (double) xNewVal the constant value of radius
	 * @return (com.ibm.rave.core.svg.LineRadial.RadialLinePathGenerator)  the line path generator
	 */
	radius$2 : com_ibm_rave_core_svg_LinePathGenerator.prototype.x$2,

	/**
	 * gets the angle-accessor, it can be a  a function or constant.
	 * @return (Object)  the angle-accessor
	 */
	angle$0 : com_ibm_rave_core_svg_LinePathGenerator.prototype.y$0,

	/**
	 * Sets the angle-accessor to the specified function.  This accessor is invoked for each element in the data array passed to the line generator. The default accessor assumes that each input element is a two-element array of numbers
	 * @param (com.ibm.rave.core.selector.ValueFunction) valFn The  angle-accessor
	 * @return (com.ibm.rave.core.svg.LineRadial.RadialLinePathGenerator)  the line path generator
	 */
	angle$1 : com_ibm_rave_core_svg_LinePathGenerator.prototype.y$1,

	/**
	 * Sets the anglr-accessor to the constant. 
	 * @param (double) yNewVal The constant value of angle
	 * @return (com.ibm.rave.core.svg.LineRadial.RadialLinePathGenerator)  the line path generator
	 */
	angle$2 : com_ibm_rave_core_svg_LinePathGenerator.prototype.y$2,

	/** @expose */ 
	radius : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.radius$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.radius$1(a0);
		}
		return this.radius$2(a0);
	},

	/** @expose */ 
	angle : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.angle$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.angle$1(a0);
		}
		return this.angle$2(a0);
	}
});

delete com_ibm_rave_core_svg_LineRadial.RadialLinePathGenerator.prototype.x;
delete com_ibm_rave_core_svg_LineRadial.RadialLinePathGenerator.prototype.x$0;
delete com_ibm_rave_core_svg_LineRadial.RadialLinePathGenerator.prototype.x$1;
delete com_ibm_rave_core_svg_LineRadial.RadialLinePathGenerator.prototype.x$2;
delete com_ibm_rave_core_svg_LineRadial.RadialLinePathGenerator.prototype.y;
delete com_ibm_rave_core_svg_LineRadial.RadialLinePathGenerator.prototype.y$0;
delete com_ibm_rave_core_svg_LineRadial.RadialLinePathGenerator.prototype.y$1;
delete com_ibm_rave_core_svg_LineRadial.RadialLinePathGenerator.prototype.y$2;
/**
 * Creates the projection to set on this generator
 */
/** @expose */ 
com_ibm_rave_core_svg_LineRadial.r2_svg_lineRadial = function(data, index, groupIndex) {
	var point;
	var points = data;
	var i = -1, n = points.length;
	var r, a;
	while (++i < n) {
		point = points[i];
		r = point[0];
		a = point[1] - 1.5707963267948966;
		point[0] = r * Math.cos(a);
		point[1] = r * Math.sin(a);
	}
	return points;
};

// $source: com/ibm/rave/core/svg/AreaPathGeneratorFactory
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/svg/RadialAreaPathGenerator (runtime) // createRadialAreaGenerator
//@import com/ibm/rave/core/internal/util/Identity (runtime) // create
//@import com/ibm/rave/core/svg/AreaPathGenerator (runtime) // new
/**
 * Area Path Generator Factory
 */
var com_ibm_rave_core_svg_AreaPathGeneratorFactory = rave_externs["AreaPathGeneratorFactory"] = com_ibm_rave_core_nativeImpl_Declare({

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * Constructs a new area generator with the default x-, y0- and y1-accessor functions (that assume the input data is a two-element array of numbers; see below for details), and linear interpolation. The returned function generates path data for a closed piecewise linear curve, or polygon.
		 * @return (com.ibm.rave.core.svg.AreaPathGenerator)  area path generator {@link (com.ibm.rave.core.svg.AreaPathGenerator) AreaPathGenerator}
		 */
		function() {
			var identity = com_ibm_rave_core_internal_util_Identity.create();
			return new com_ibm_rave_core_svg_AreaPathGenerator(identity);
		};
		return _$self;
	},

	/**
	 * Constructs a new radial area generator with the default radius- and angle-accessor functions (that assume the input data is a two-element array of numbers), and linear interpolation.
	 * @return (com.ibm.rave.core.svg.RadialAreaPathGenerator)  svg path generator
	 */
	/** @expose */ 
	radial : function() {
		return com_ibm_rave_core_svg_RadialAreaPathGenerator.createRadialAreaGenerator();
	}
});


// $source: com/ibm/rave/core/svg/AreaPathGenerator
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/svg/SVGLine (runtime) // SVGLine
/**
 * Constructs a new area generator with the default x-, y0- and y1-accessor functions (that assume the input data is a two-element array of numbers; see below for details), and linear interpolation. ThisGenerator generates path data for a closed piecewise linear curve, or polygon. Conceptually, the polygon is formed using two lines: the top line is formed using the x- and y1-accessor functions, and proceeds from left-to-right; the bottom line is added to this line, using the x- and y0-accessor functions, and proceeds from right-to-left. By setting the transform attribute to rotate the path element by 90 degrees, you can also generate vertical areas. By changing the interpolation, you can also generate splines and step functions. The area generator is designed to work in conjunction with the {@link (com.ibm.rave.core.svg.LinePathGenerator) LinePathGenerator} . For example, when producing an area chart, you might use an area generator with a fill style, and a line generator with a stroke style to emphasize the top edge of the area. Since the area generator is only used to set the d attribute, you can control the appearance of the area using standard SVG styles and attributes, such as fill. To create streamgraphs (stacked area charts), use the stack layout. This layout sets the y0 attribute for each value in a series, which can be used from the y0- and y1-accessors. Note that each series must have the same number of values per series, and each value must have the same x-coordinate; if you have missing data or inconsistent x-coordinates per series, you must resample and interpolate your data before computing the stacked layout.
 */
var com_ibm_rave_core_svg_AreaPathGenerator = rave_externs["AreaPathGenerator"] = com_ibm_rave_core_nativeImpl_Declare({

	//fx0 : null,

	//fx1 : null,

	//fy0 : null,

	//fy1 : null,

	//definedFn : null,

	//interpolateFn : null,

	//interpolateKey : null,

	//interpolateReverseFn : null,

	//projectionFn : null,

	x0Val : 0,

	y0Val : 0,

	x1Val : 0,

	y1Val : 0,

	tensionVal : 0.7,

	L : "L",

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * Returns the path data string for the specified array of data elements, or null if the path is empty.
		 * @param (Object) this The context for this function
		 * @param (Array) data The data to use while generating the area
		 * @return (String)  the svg path string
		 */
		function(data) {
			var segments = [];
			var points0 = [];
			var points1 = [];
			var i = -1;
			var n = data.length;
			var d;
			n = data.length;
			var xa, ya;
			var localFx1;
			if (_$self.fx0 && _$self.fx0 == _$self.fx1) {
				localFx1 = function(data, index, groupIndex) {
					return xa;
				};
			} else {
				localFx1 = _$self.fx1;
			}
			var localFy1;
			if (_$self.fy0 && _$self.fy0 == _$self.fy1) {
				localFy1 = function(data, index, groupIndex) {
					return ya;
				};
			} else {
				localFy1 = _$self.fy1;
			}
			while (++i < n) {
				d = data[i];
				if (_$self.definedFn.call(this, d, i, -1)) {
					xa = + (!_$self.fx0 ? _$self.x0Val : _$self.fx0.call(this, d, i, -1));
					ya = + (!_$self.fy0 ? _$self.y0Val : _$self.fy0.call(this, d, i, -1));
					points0.push([xa, ya]);
					points1.push([+ (!localFx1 ? _$self.x1Val : localFx1.call(this, d, i, -1)), + (!localFy1 ? _$self.y1Val : localFy1.call(this, d, i, -1))]);
				} else if (points0.length > 0) {
					segments.push("M", _$self.interpolateFn(_$self.projectionFn.call(this, points1, -1, -1), _$self.tensionVal), _$self.L, _$self.interpolateReverseFn(_$self.projectionFn.call(this, points0.reverse(), -1, -1), _$self.tensionVal), "Z");
					points0 = [];
					points1 = [];
				}
			}
			if (points0.length > 0) {
				segments.push("M", _$self.interpolateFn(_$self.projectionFn.call(this, points1, -1, -1), _$self.tensionVal), _$self.L, _$self.interpolateReverseFn(_$self.projectionFn.call(this, points0.reverse(), -1, -1), _$self.tensionVal), "Z");
			}
			return segments.length > 0 ? segments.join("") : null;
		};
		return _$self;
	},

	constructor : function(projection) {
		this.fx0 = com_ibm_rave_core_svg_SVGLine.DEFAULT_X_FN;
		this.fx1 = com_ibm_rave_core_svg_SVGLine.DEFAULT_X_FN;
		this.fy1 = com_ibm_rave_core_svg_SVGLine.DEFAULT_Y_FN;
		this.definedFn = com_ibm_rave_core_svg_SVGLine.DEFAULT_DEFINED_FN;
		this.interpolateFn = com_ibm_rave_core_svg_SVGLine.r2_svg_lineLinear;
		this.interpolateKey = this.interpolateFn.key;
		this.interpolateReverseFn = this.interpolateFn;
				/**
		 * Constructor creates am AreaPathGenerator and sets the projection on it to be, the passed projection
		 * @param (com.ibm.rave.core.selector.ValueFunction) projection The projection to use while generating the area
		 */
		{
			this.projectionFn = projection;
		}
	},

	/**
	 * Returns the current x1-accessor. this can be ValueFunction of a Number
	 * @return (Object)  x1-accessor
	 */
	x$0 : function() {
		if (this.fx1) {
			return this.fx1;
		}
		return this.x1Val;
	},

	/**
	 * Sets the x-accessor to the specified constant. This accessor is invoked for each element in the data array passed to the area generator. The default accessor assumes that each input element is a two-element array of numbers:
	 * @param (double) xVal The constant to use
	 * @return (com.ibm.rave.core.svg.AreaPathGenerator)  this path generator
	 */
	x$1 : function(xVal) {
		this.fx0 = this.fx1 = null;
		this.x0Val = this.x1Val = xVal;
		return this;
	},

	/**
	 * Sets the x-accessor to the specified function. This accessor is invoked for each element in the data array passed to the area generator. The default accessor assumes that each input element is a two-element array of numbers:
	 * @param (com.ibm.rave.core.selector.ValueFunction) valFn The constant to use
	 * @return (com.ibm.rave.core.svg.AreaPathGenerator)  this path generator
	 */
	x$2 : function(valFn) {
		this.fx0 = this.fx1 = valFn;
		return this;
	},

	/**
	 * Returns the current x0-accessor. this can be ValueFunction of a Number
	 * @return (Object)  x0-accessor
	 */
	x0$0 : function() {
		if (this.fx0) {
			return this.fx0;
		}
		return this.x0Val;
	},

	/**
	 * Sets the x0-accessor to the specified constant. This accessor is invoked for each element in the data array passed to the area generator. The default accessor assumes that each input element is a two-element array of numbers:
	 * @param (double) xVal The constant to use
	 * @return (com.ibm.rave.core.svg.AreaPathGenerator)  this path generator
	 */
	x0$1 : function(xVal) {
		this.fx0 = null;
		this.x0Val = xVal;
		return this;
	},

	/**
	 * Sets the x0-accessor to the specified function. This accessor is invoked for each element in the data array passed to the area generator. The default accessor assumes that each input element is a two-element array of numbers:
	 * @param (com.ibm.rave.core.selector.ValueFunction) valFn The constant to use
	 * @return (com.ibm.rave.core.svg.AreaPathGenerator)  this path generator
	 */
	x0$2 : function(valFn) {
		this.fx0 = valFn;
		return this;
	},

	/**
	 * Returns the current x1-accessor. this can be ValueFunction of a Number
	 * @return (Object)  x1-accessor
	 */
	x1$0 : function() {
		if (this.fx1) {
			return this.fx1;
		}
		return this.x1Val;
	},

	/**
	 * Sets the x1-accessor to the specified constant. This accessor is invoked for each element in the data array passed to the area generator. The default accessor assumes that each input element is a two-element array of numbers:
	 * @param (double) xVal The constant to use
	 * @return (com.ibm.rave.core.svg.AreaPathGenerator)  this path generator
	 */
	x1$1 : function(xVal) {
		this.fx1 = null;
		this.x1Val = xVal;
		return this;
	},

	/**
	 * Sets the x1-accessor to the specified function. This accessor is invoked for each element in the data array passed to the area generator. The default accessor assumes that each input element is a two-element array of numbers:
	 * @param (com.ibm.rave.core.selector.ValueFunction) valFn The constant to use
	 * @return (com.ibm.rave.core.svg.AreaPathGenerator)  this path generator
	 */
	x1$2 : function(valFn) {
		this.fx1 = valFn;
		return this;
	},

	/**
	 * Returns the current y1-accessor. this can be ValueFunction of a Number
	 * @return (Object)  y1-accessor
	 */
	y$0 : function() {
		if (this.fy1) {
			return this.fy1;
		}
		return this.y1Val;
	},

	/**
	 * Sets the y-accessor to the specified constant. This accessor is invoked for each element in the data array passed to the area generator. The default accessor assumes that each input element is a two-element array of numbers:
	 * @param (double) yVal The constant to use
	 * @return (com.ibm.rave.core.svg.AreaPathGenerator)  this path generator
	 */
	y$1 : function(yVal) {
		this.fy0 = this.fy1 = null;
		this.y0Val = this.y1Val = yVal;
		return this;
	},

	/**
	 * Sets the y-accessor to the specified function. This accessor is invoked for each element in the data array passed to the area generator. The default accessor assumes that each input element is a two-element array of numbers:
	 * @param (com.ibm.rave.core.selector.ValueFunction) valFn The constant to use
	 * @return (com.ibm.rave.core.svg.AreaPathGenerator)  this path generator
	 */
	y$2 : function(valFn) {
		this.fy0 = this.fy1 = valFn;
		return this;
	},

	/**
	 * Returns the current y0-accessor. this can be ValueFunction of a Number
	 * @return (Object)  y0-accessor
	 */
	y0$0 : function() {
		if (this.fy0) {
			return this.fy0;
		}
		return this.y0Val;
	},

	/**
	 * Sets the y0-accessor to the specified constant. This accessor is invoked for each element in the data array passed to the area generator. The default accessor assumes that each input element is a two-element array of numbers:
	 * @param (double) yVal The constant to use
	 * @return (com.ibm.rave.core.svg.AreaPathGenerator)  this path generator
	 */
	y0$1 : function(yVal) {
		this.fy0 = null;
		this.y0Val = yVal;
		return this;
	},

	/**
	 * Sets the y0-accessor to the specified function. This accessor is invoked for each element in the data array passed to the area generator. The default accessor assumes that each input element is a two-element array of numbers:
	 * @param (com.ibm.rave.core.selector.ValueFunction) valFn The constant to use
	 * @return (com.ibm.rave.core.svg.AreaPathGenerator)  this path generator
	 */
	y0$2 : function(valFn) {
		this.fy0 = valFn;
		return this;
	},

	/**
	 * Returns the current y1-accessor. this can be ValueFunction of a Number
	 * @return (Object)  y1-accessor
	 */
	y1$0 : function() {
		if (this.fy1) {
			return this.fy1;
		}
		return this.y1Val;
	},

	/**
	 * Sets the y1-accessor to the specified constant. This accessor is invoked for each element in the data array passed to the area generator. The default accessor assumes that each input element is a two-element array of numbers:
	 * @param (double) yVal The constant to use
	 * @return (com.ibm.rave.core.svg.AreaPathGenerator)  this path generator
	 */
	y1$1 : function(yVal) {
		this.fy1 = null;
		this.y1Val = yVal;
		return this;
	},

	/**
	 * Sets the y1-accessor to the specified function. This accessor is invoked for each element in the data array passed to the area generator. The default accessor assumes that each input element is a two-element array of numbers:
	 * @param (com.ibm.rave.core.selector.ValueFunction) valFn The constant to use
	 * @return (com.ibm.rave.core.svg.AreaPathGenerator)  this path generator
	 */
	y1$2 : function(valFn) {
		this.fy1 = valFn;
		return this;
	},

	/**
	 * Gets the accessor function that controls where the area is defined. default defined is a function() { return true; }
	 * @return (com.ibm.rave.core.selector.ValueFunction)  the defined function
	 */
	defined$0 : function() {
		return this.definedFn;
	},

	/**
	 * Sets the accessor function that controls where the area is defined. Sets the new accessor function and returns the area generator. The defined accessor can be used to define where the area is defined and undefined, which is typically useful in conjunction with missing data; the generated path data will automatically be broken into multiple distinct subpaths, skipping undefined data. For example, if you want to ignore y-values that are not a number (or undefined)
	 * @param (com.ibm.rave.core.selector.ValueFunction) valFn the function to use to decide if a point is defined
	 * @return (com.ibm.rave.core.svg.AreaPathGenerator)  this Area path generator
	 */
	defined$1 : function(valFn) {
		this.definedFn = valFn;
		return this;
	},

	/**
	 * Returns the current tension.
	 * @return (double)  the tension
	 */
	tension$0 : function() {
		return this.tensionVal;
	},

	/**
	 * sets the Cardinal spline or bundle interpolation tension to the specified number in the range [0, 1]. The tension only affects the Cardinal interpolation modes: cardinal, cardinal-open and cardinal-closed and Bundle interpolation. The default tension is 0.7. In some sense, this can be interpreted as the length of the tangent; 1 will yield all zero tangents, and 0 yields a Catmull-Rom spline. Note that the tension must be specified as a constant, rather than a function, as it is constant for the entirety of the line. However, it is still possible to generate multiple lines with different tensions using the same generator.
	 * @return (com.ibm.rave.core.svg.AreaPathGenerator)  this Area path generator
	 */
	tension$1 : function(tensionNewVal) {
		this.tensionVal = tensionNewVal;
		return this;
	},

	interpolate$0 : function() {
		return this.interpolateKey;
	},

	/**
	 * Sets the interpolation mode to the specified string. The following named interpolation modes are supported: linear - piecewise linear segments, as in a polyline. linear-closed - close the linear segments to form a polygon. step - alternate between horizontal and vertical segments, as in a step function. step-before - alternate between vertical and horizontal segments, as in a step function. step-after - alternate between horizontal and vertical segments, as in a step function. basis - a B-spline, with control point duplication on the ends. basis-open - an open B-spline; may not intersect the start or end. basis-closed - a closed B-spline, as in a loop. bundle - equivalent to basis, except the tension parameter is used to straighten the spline. cardinal - a Cardinal spline, with control point duplication on the ends. cardinal-open - an open Cardinal spline; may not intersect the start or end, but will intersect other control points. cardinal-closed - a closed Cardinal spline, as in a loop. monotone - cubic interpolation that preserves monotonicity in y. The behavior of some of these interpolation modes may be further customized by specifying a tension.
	 * @param (String) key the interpolation mode to use
	 * @return (com.ibm.rave.core.svg.AreaPathGenerator)  the Area Path generator
	 */
	interpolate$1 : function(key) {
		this.interpolateKey = key;
		this.interpolateFn = com_ibm_rave_core_svg_SVGLine.r2_svg_lineInterpolators.get(key);
		if (!this.interpolateFn) {
			this.interpolateFn = com_ibm_rave_core_svg_SVGLine.r2_svg_lineLinear;
			this.interpolateKey = this.interpolateFn.key;
		}
		this.interpolateReverseFn = this.interpolateFn.reverse ? this.interpolateFn.reverse : this.interpolateFn;
		this.L = this.interpolateFn.closed ? "M" : "L";
		return this;
	},

	/**
	 * Sets the interpolation mode to the specified function. This function will be invoked to convert an array of points of the form [​[x0, y0], [x1, y1], …], returning an SVG path data string that will be used to display the line. The "M" at the start of the string is implied and should not be returned.
	 * @param (com.ibm.rave.core.svg.AbstractLineInterpolator) valFn the function to call to do the interpolation
	 * @return (com.ibm.rave.core.svg.AreaPathGenerator)  the Line Path generator
	 */
	interpolate$2 : function(valFn) {
		this.interpolateKey = this.interpolateFn = valFn;
		this.interpolateReverseFn = this.interpolateFn.reverse ? this.interpolateFn.reverse : this.interpolateFn;
		this.L = this.interpolateFn.closed ? "M" : "L";
		return this;
	},

	/** @expose */ 
	x : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.x$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.x$2(a0);
		}
		return this.x$1(a0);
	},

	/** @expose */ 
	x0 : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.x0$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.x0$2(a0);
		}
		return this.x0$1(a0);
	},

	/** @expose */ 
	x1 : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.x1$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.x1$2(a0);
		}
		return this.x1$1(a0);
	},

	/** @expose */ 
	y : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.y$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.y$2(a0);
		}
		return this.y$1(a0);
	},

	/** @expose */ 
	y0 : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.y0$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.y0$2(a0);
		}
		return this.y0$1(a0);
	},

	/** @expose */ 
	y1 : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.y1$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.y1$2(a0);
		}
		return this.y1$1(a0);
	},

	/** @expose */ 
	defined : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.defined$0();
		}
		return this.defined$1(a0);
	},

	/** @expose */ 
	tension : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.tension$0();
		}
		return this.tension$1(a0);
	},

	/** @expose */ 
	interpolate : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.interpolate$0();
		}
		if (args.length == 1 && (a0 == null || typeof a0 === "string")) {
			return this.interpolate$1(a0);
		}
		return this.interpolate$2(a0);
	}
});


// $source: com/ibm/rave/core/svg/RadialAreaPathGenerator
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/svg/AreaPathGenerator (loadtime) // superclass
//@import com/ibm/rave/core/svg/LineRadial (static) // LineRadial
/**
 * A Radial Area path generator
 */
var com_ibm_rave_core_svg_RadialAreaPathGenerator = rave_externs["RadialAreaPathGenerator"] = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_svg_AreaPathGenerator, {

	/**
	 * Returns the current radius-accessor. this can be ValueFunction of a Number
	 * @return (Object)  radius-accessor
	 */
	radius$0 : com_ibm_rave_core_svg_AreaPathGenerator.prototype.x$0,

	/**
	 * Sets the radius-accessor to the specified constant.  This accessor is invoked for each element in the data array passed to the area generator. The default accessor assumes that each input element is a two-element array of numbers:
	 * @param (double) rVal 	The constant to use
	 * @return (com.ibm.rave.core.svg.AreaPathGenerator) 	this path generator
	 */
	radius$1 : com_ibm_rave_core_svg_AreaPathGenerator.prototype.x$1,

	/**
	 * Sets the radius-accessor to the specified function.  This accessor is invoked for each element in the data array passed to the area generator. The default accessor assumes that each input element is a two-element array of numbers:
	 * @param (com.ibm.rave.core.selector.ValueFunction) valFn 	The constant to use
	 * @return (com.ibm.rave.core.svg.AreaPathGenerator) 	this path generator
	 */
	radius$2 : com_ibm_rave_core_svg_AreaPathGenerator.prototype.x$2,

	/**
	 * Returns the current innerRadius-accessor. this can be ValueFunction of a Number
	 * @return (Object)  innerRadius-accessor
	 */
	innerRadius$0 : com_ibm_rave_core_svg_AreaPathGenerator.prototype.x0$0,

	/**
	 * Sets the innerRadius-accessor to the specified constant.  This accessor is invoked for each element in the data array passed to the area generator. The default accessor assumes that each input element is a two-element array of numbers:
	 * @param (double) xVal 	The constant to use
	 * @return (com.ibm.rave.core.svg.RadialAreaPathGenerator) 	this path generator
	 */
	innerRadius$1 : com_ibm_rave_core_svg_AreaPathGenerator.prototype.x0$1,

	/**
	 * Sets the innerRadius-accessor to the specified function.  This accessor is invoked for each element in the data array passed to the area generator. The default accessor assumes that each input element is a two-element array of numbers:
	 * @param (com.ibm.rave.core.selector.ValueFunction) valFn 	The constant to use
	 * @return (com.ibm.rave.core.svg.RadialAreaPathGenerator) 	this path generator
	 */
	innerRadius$2 : com_ibm_rave_core_svg_AreaPathGenerator.prototype.x0$2,

	/**
	 * Returns the current outerRadius-accessor. this can be ValueFunction of a Number
	 * @return (Object)  outerRadius-accessor
	 */
	outerRadius$0 : com_ibm_rave_core_svg_AreaPathGenerator.prototype.x1$0,

	/**
	 * Sets the outerRadius-accessor to the specified constant.  This accessor is invoked for each element in the data array passed to the area generator. The default accessor assumes that each input element is a two-element array of numbers:
	 * @param (double) xVal 	The constant to use
	 * @return (com.ibm.rave.core.svg.RadialAreaPathGenerator) 	this path generator
	 */
	outerRadius$1 : com_ibm_rave_core_svg_AreaPathGenerator.prototype.x1$1,

	/**
	 * Sets the outerRadius-accessor to the specified function.  This accessor is invoked for each element in the data array passed to the area generator. The default accessor assumes that each input element is a two-element array of numbers:
	 * @param (com.ibm.rave.core.selector.ValueFunction) valFn 	The constant to use
	 * @return (com.ibm.rave.core.svg.RadialAreaPathGenerator) 	this path generator
	 */
	outerRadius$2 : com_ibm_rave_core_svg_AreaPathGenerator.prototype.x1$2,

	/**
	 * Returns the current angle-accessor. this can be ValueFunction of a Number
	 * @return (Object)  angle-accessor
	 */
	angle$0 : com_ibm_rave_core_svg_AreaPathGenerator.prototype.y$0,

	/**
	 * Sets the angle-accessor to the specified constant.  This accessor is invoked for each element in the data array passed to the area generator. The default accessor assumes that each input element is a two-element array of numbers:
	 * @param (double) yVal 	The constant to use
	 * @return (com.ibm.rave.core.svg.RadialAreaPathGenerator) 	this path generator
	 */
	angle$1 : com_ibm_rave_core_svg_AreaPathGenerator.prototype.y$1,

	/**
	 * Sets the angle-accessor to the specified function.  This accessor is invoked for each element in the data array passed to the area generator. The default accessor assumes that each input element is a two-element array of numbers:
	 * @param (com.ibm.rave.core.selector.ValueFunction) valFn 	The constant to use
	 * @return (com.ibm.rave.core.svg.RadialAreaPathGenerator) 	this path generator
	 */
	angle$2 : com_ibm_rave_core_svg_AreaPathGenerator.prototype.y$2,

	/**
	 * Returns the current startAngle-accessor. this can be ValueFunction of a Number
	 * @return (Object)  startAngle-accessor
	 */
	startAngle$0 : com_ibm_rave_core_svg_AreaPathGenerator.prototype.y0$0,

	/**
	 * Sets the startAngle-accessor to the specified constant.  This accessor is invoked for each element in the data array passed to the area generator. The default accessor assumes that each input element is a two-element array of numbers:
	 * @param (double) yVal 	The constant to use
	 * @return (com.ibm.rave.core.svg.RadialAreaPathGenerator) 	this path generator
	 */
	startAngle$1 : com_ibm_rave_core_svg_AreaPathGenerator.prototype.y0$1,

	/**
	 * Sets the startAngle-accessor to the specified function.  This accessor is invoked for each element in the data array passed to the area generator. The default accessor assumes that each input element is a two-element array of numbers:
	 * @param (com.ibm.rave.core.selector.ValueFunction) valFn 	The constant to use
	 * @return (com.ibm.rave.core.svg.RadialAreaPathGenerator) 	this path generator
	 */
	startAngle$2 : com_ibm_rave_core_svg_AreaPathGenerator.prototype.y0$2,

	/**
	 * Returns the current endAngle-accessor. this can be ValueFunction of a Number
	 * @return (Object)  endAngle-accessor
	 */
	endAngle$0 : com_ibm_rave_core_svg_AreaPathGenerator.prototype.y1$0,

	/**
	 * Sets the endAngle-accessor to the specified constant.  This accessor is invoked for each element in the data array passed to the area generator. The default accessor assumes that each input element is a two-element array of numbers:
	 * @param (double) yVal 	The constant to use
	 * @return (com.ibm.rave.core.svg.RadialAreaPathGenerator) 	this path generator
	 */
	endAngle$1 : com_ibm_rave_core_svg_AreaPathGenerator.prototype.y1$1,

	/**
	 * Sets the endAngle-accessor to the specified function.  This accessor is invoked for each element in the data array passed to the area generator. The default accessor assumes that each input element is a two-element array of numbers:
	 * @param (com.ibm.rave.core.selector.ValueFunction) valFn 	The constant to use
	 * @return (com.ibm.rave.core.svg.RadialAreaPathGenerator) 	this path generator
	 */
	endAngle$2 : com_ibm_rave_core_svg_AreaPathGenerator.prototype.y1$2,

	/**
	 * Constructor constructs a Radial Area path generator
	 * @param (com.ibm.rave.core.selector.ValueFunction) projection the projection to set on this area generator
	 */
	/** @expose */ 
	constructor : function(projection) {
	},

	/** @expose */ 
	radius : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.radius$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.radius$2(a0);
		}
		return this.radius$1(a0);
	},

	/** @expose */ 
	innerRadius : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.innerRadius$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.innerRadius$2(a0);
		}
		return this.innerRadius$1(a0);
	},

	/** @expose */ 
	outerRadius : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.outerRadius$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.outerRadius$2(a0);
		}
		return this.outerRadius$1(a0);
	},

	/** @expose */ 
	angle : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.angle$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.angle$2(a0);
		}
		return this.angle$1(a0);
	},

	/** @expose */ 
	startAngle : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.startAngle$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.startAngle$2(a0);
		}
		return this.startAngle$1(a0);
	},

	/** @expose */ 
	endAngle : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.endAngle$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.endAngle$2(a0);
		}
		return this.endAngle$1(a0);
	}
});

/**
 * Creates a Radial Area Path generator
 * @return (com.ibm.rave.core.svg.RadialAreaPathGenerator)  a new RadialAreaPathGenerator
 */
com_ibm_rave_core_svg_RadialAreaPathGenerator.createRadialAreaGenerator = function() {
	return new com_ibm_rave_core_svg_RadialAreaPathGenerator(com_ibm_rave_core_svg_LineRadial.r2_svg_lineRadial);
};

delete com_ibm_rave_core_svg_RadialAreaPathGenerator.prototype.x;
delete com_ibm_rave_core_svg_RadialAreaPathGenerator.prototype.x$0;
delete com_ibm_rave_core_svg_RadialAreaPathGenerator.prototype.x$1;
delete com_ibm_rave_core_svg_RadialAreaPathGenerator.prototype.x$2;
delete com_ibm_rave_core_svg_RadialAreaPathGenerator.prototype.x0;
delete com_ibm_rave_core_svg_RadialAreaPathGenerator.prototype.x0$0;
delete com_ibm_rave_core_svg_RadialAreaPathGenerator.prototype.x0$1;
delete com_ibm_rave_core_svg_RadialAreaPathGenerator.prototype.x0$2;
delete com_ibm_rave_core_svg_RadialAreaPathGenerator.prototype.x1;
delete com_ibm_rave_core_svg_RadialAreaPathGenerator.prototype.x1$0;
delete com_ibm_rave_core_svg_RadialAreaPathGenerator.prototype.x1$1;
delete com_ibm_rave_core_svg_RadialAreaPathGenerator.prototype.x1$2;
delete com_ibm_rave_core_svg_RadialAreaPathGenerator.prototype.y;
delete com_ibm_rave_core_svg_RadialAreaPathGenerator.prototype.y$0;
delete com_ibm_rave_core_svg_RadialAreaPathGenerator.prototype.y$1;
delete com_ibm_rave_core_svg_RadialAreaPathGenerator.prototype.y$2;
delete com_ibm_rave_core_svg_RadialAreaPathGenerator.prototype.y0;
delete com_ibm_rave_core_svg_RadialAreaPathGenerator.prototype.y0$0;
delete com_ibm_rave_core_svg_RadialAreaPathGenerator.prototype.y0$1;
delete com_ibm_rave_core_svg_RadialAreaPathGenerator.prototype.y0$2;
delete com_ibm_rave_core_svg_RadialAreaPathGenerator.prototype.y1;
delete com_ibm_rave_core_svg_RadialAreaPathGenerator.prototype.y1$0;
delete com_ibm_rave_core_svg_RadialAreaPathGenerator.prototype.y1$1;
delete com_ibm_rave_core_svg_RadialAreaPathGenerator.prototype.y1$2;

// $source: com/ibm/rave/core/svg/DiagonalPathGeneratorFactory
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/svg/RadialDiagonalPathGenerator (runtime) // createRadialAreaGenerator
//@import com/ibm/rave/core/svg/DiagonalPathGenerator (runtime) // new, DiagonalPathGenerator
var com_ibm_rave_core_svg_DiagonalPathGeneratorFactory = rave_externs["DiagonalPathGeneratorFactory"] = com_ibm_rave_core_nativeImpl_Declare({

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * Factory method, Constructs a new diagonal generator with the default accessor functions (that assume the input data is an object with named attributes matching the accessors). The returned Generator generates the path data for a cubic Bézier connecting the source and target points; the tangents are specified to produce smooth fan-in and fan-out when connecting nodes 
		 * @return (com.ibm.rave.core.svg.DiagonalPathGenerator)  area path generator {@link (com.ibm.rave.core.svg.DiagonalPathGenerator) DiagonalPathGenerator}
		 */
		function() {
			return new com_ibm_rave_core_svg_DiagonalPathGenerator(com_ibm_rave_core_svg_DiagonalPathGenerator.r2_svg_diagonalProjection);
		};
		return _$self;
	},

	/**
	 * Constructs a new Radial Diagonal  generator with the default 
	 * @return (com.ibm.rave.core.svg.RadialDiagonalPathGenerator) 	svg path generator
	 */
	/** @expose */ 
	radial : function() {
		return com_ibm_rave_core_svg_RadialDiagonalPathGenerator.createRadialAreaGenerator();
	}
});


// $source: com/ibm/rave/core/svg/DiagonalPathGenerator
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
/**
 * Constructs a new diagonal generator with the default accessor functions (that assume the input data is an object with named attributes matching the accessors). The returned Generator generates the path data for a cubic Bézier connecting the source and target points; the tangents are specified to produce smooth fan-in and fan-out when connecting nodes 
 */
var com_ibm_rave_core_svg_DiagonalPathGenerator = rave_externs["DiagonalPathGenerator"] = com_ibm_rave_core_nativeImpl_Declare({

	//projectionFn : null,

	//sourceFn : null,

	//targetFn : null,

	//sourceVal : null,

	//targetVal : null,

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * Constructs a new diagonal generator with the default accessor functions (that assume the input data is an object with named attributes matching the accessors). The returned Generator generates the path data for a cubic Bézier connecting the source and target points; the tangents are specified to produce smooth fan-in and fan-out when connecting nodes 
		 * @param (Object) this   the context of this function
		 * @param (Object) data 	the data to use to get source and target, optional param		
		 * @param (int) index 	the index of the data, optional param 
		 * @return (String)  SVG string representing the path
		 */
		function(data, index) {
			var p0 = _$self.sourceFn ? _$self.sourceFn.call(this, data, index, -1) : _$self.sourceVal;
			var p3 = _$self.targetFn ? _$self.targetFn.call(this, data, index, -1) : _$self.targetVal;
			var m = (p0["y"] + p3["y"]) / 2;
			var ap1 = {};
			ap1["x"] = p0["x"];
			ap1["y"] = m;
			var ap2 = {};
			ap2["x"] = p3["x"];
			ap2["y"] = m;
			var array = [p0, ap1, ap2, p3];
			var pointArray = array.map(_$self.projectionFn);
			return "M" + pointArray[0] + "C" + pointArray[1] + " " + pointArray[2] + " " + pointArray[3];
		};
		return _$self;
	},

	constructor : function(projection) {
		this.sourceFn = com_ibm_rave_core_svg_DiagonalPathGenerator.DEFAULT_SOURCE_FN;
		this.targetFn = com_ibm_rave_core_svg_DiagonalPathGenerator.DEFAULT_TARGET_FN;
				/**
		 * Constructor creates a DiagonalPathGenerator and sets the projection on it to be the passed projection
		 * @param (com.ibm.rave.core.collections.ArrayEx.ArrayValueFunction) projection 		The projection to use while generating the path
		 */
		{
			this.projectionFn = projection;
		}
	},

	/**
	 * Gets the source function or constant 
	 * @return (Object) 	the source function or constant
	 */
	source$0 : function() {
		if (this.sourceFn) {
			return this.sourceFn;
		}
		return this.sourceVal;
	},

	/**
	 * Sets the source function 
	 * @param (com.ibm.rave.core.selector.ValueFunction) valFn   function to use to get the source form the data 
	 * @return (com.ibm.rave.core.svg.DiagonalPathGenerator) 	this generator
	 */
	source$1 : function(valFn) {
		this.sourceFn = valFn;
		return this;
	},

	/**
	 * Sets the Source value for this generator
	 * @param (Object) val 	the source value
	 * @return (com.ibm.rave.core.svg.DiagonalPathGenerator) 	this generator
	 */
	source$2 : function(val) {
		this.sourceFn = null;
		this.sourceVal = val;
		return this;
	},

	/**
	 * Gets the target functions of value
	 * @return (Object) 	the target function or value
	 */
	target$0 : function() {
		if (this.targetFn) {
			return this.targetFn;
		}
		return this.targetVal;
	},

	/**
	 * Sets the function to use to get the target from the data
	 * @param (com.ibm.rave.core.selector.ValueFunction) valFn 	the target function
	 * @return (com.ibm.rave.core.svg.DiagonalPathGenerator) 	this generator
	 */
	target$1 : function(valFn) {
		this.targetFn = valFn;
		return this;
	},

	/**
	 * Sets The target value 
	 * @param (Object) val 	the target value
	 * @return (com.ibm.rave.core.svg.DiagonalPathGenerator) 	this generator
	 */
	target$2 : function(val) {
		this.targetFn = null;
		this.targetVal = val;
		return this;
	},

	/**
	 * Gets the current projection function on this Generator
	 * @return (com.ibm.rave.core.collections.ArrayEx.ArrayValueFunction) 	the projection function
	 */
	projection$0 : function() {
		return this.projectionFn;
	},

	/**
	 * Sets the  projection to use by this generator
	 * @param (com.ibm.rave.core.collections.ArrayEx.ArrayValueFunction) projection  the projection
	 * @return (com.ibm.rave.core.svg.DiagonalPathGenerator)  this generator
	 */
	projection$1 : function(projection) {
		this.projectionFn = projection;
		return this;
	},

	/** @expose */ 
	source : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.source$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.source$1(a0);
		}
		return this.source$2(a0);
	},

	/** @expose */ 
	target : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.target$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.target$1(a0);
		}
		return this.target$2(a0);
	},

	/** @expose */ 
	projection : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.projection$0();
		}
		return this.projection$1(a0);
	}
});

com_ibm_rave_core_svg_DiagonalPathGenerator.DEFAULT_SOURCE_FN = function(data, index, groupIndex) {
	return (data)["source"];
};
com_ibm_rave_core_svg_DiagonalPathGenerator.DEFAULT_TARGET_FN = function(data, index, groupIndex) {
	return (data)["target"];
};
/**
 * Creates the projection to set on this generator
 */
/** @expose */ 
com_ibm_rave_core_svg_DiagonalPathGenerator.r2_svg_diagonalProjection = function(currentValue, index, array) {
	var input = currentValue;
	return [input["x"], input["y"]];
};

// $source: com/ibm/rave/core/svg/RadialDiagonalPathGenerator
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/svg/DiagonalPathGenerator (loadtime) // superclass
/**
 * Constructor creates a RadialDiagonalPathGenerator
 */
var com_ibm_rave_core_svg_RadialDiagonalPathGenerator = rave_externs["RadialDiagonalPathGenerator"] = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_svg_DiagonalPathGenerator, {

	/**
	 * Constructor creates a RadialDiagonalPathGenerator and sets the projection on it to be r2_svg_diagonalProjection
	 */
	/** @expose */ 
	constructor : function() {
	},

	/** @expose */ 
	projection$1 : function(projectionVal) {
		com_ibm_rave_core_svg_DiagonalPathGenerator.prototype.projection$1.call(this, new com_ibm_rave_core_svg_RadialDiagonalPathGenerator.DiagonalRadialProjection(projectionVal));
		return this;
	}
});

/**
 * Creates a Radial Diagonal Path generator
 * @return (com.ibm.rave.core.svg.RadialDiagonalPathGenerator)  a new RadialDiagonalPathGenerator
 */
com_ibm_rave_core_svg_RadialDiagonalPathGenerator.createRadialAreaGenerator = function() {
	return new com_ibm_rave_core_svg_RadialDiagonalPathGenerator();
};

com_ibm_rave_core_svg_RadialDiagonalPathGenerator.DiagonalRadialProjection = com_ibm_rave_core_nativeImpl_Declare({

	//innerProjectionFn : null,

	_$functionClassMethod : function() {
		var _$self = function(currentValue, index, array) {
			var p = _$self.innerProjectionFn(currentValue, index, array);
			var r = p[0];
			var a = p[1] - 1.5707963267948966;
			return [r * Math.cos(a), r * Math.sin(a)];
		};
		return _$self;
	},

	constructor : function(projectionVal) {
		this.innerProjectionFn = projectionVal;
	}
});


// $source: com/ibm/rave/core/internal/svg/symbol/CrossSymbolCreator
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
/**
 * Symbol creator for a Cross shape
 */
var com_ibm_rave_core_internal_svg_symbol_CrossSymbolCreator = com_ibm_rave_core_nativeImpl_Declare({

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * create a cross symbol using the passed size
		 * @param (double) size   size of the shape in square pixels
		 * @return (String)  SVG path string for the shape
		 */
		function(size) {
			var r = Math.sqrt(size / 5) / 2;
			var r3 = r * 3;
			var s1 = "M" + -r3 + "," + -r + "H" + -r + "V" + -r3 + "H" + r + "V" + -r;
			var s2 = "H" + r3 + "V" + r + "H" + r + "V" + r3 + "H" + -r + "V" + r + "H" + -r3 + "Z";
			return s1 + s2;
		};
		return _$self;
	}
});


// $source: com/ibm/rave/core/internal/svg/symbol/DiamondSymbolCreator
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/svg/symbol/SymbolCreatorsConstants (runtime) // SymbolCreatorsConstants
/**
 * Symbol creator for a Diamond shape
 */
var com_ibm_rave_core_internal_svg_symbol_DiamondSymbolCreator = com_ibm_rave_core_nativeImpl_Declare({

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * create a Diamond symbol using the passed size
		 * @param (double) size  size of the shape in square pixels
		 * @return (String)  SVG path string for the shape
		 */
		function(size) {
			var ry = Math.sqrt(size / (2 * com_ibm_rave_core_internal_svg_symbol_SymbolCreatorsConstants.r2_svg_symbolTan30)), rx = ry * com_ibm_rave_core_internal_svg_symbol_SymbolCreatorsConstants.r2_svg_symbolTan30;
			return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
		};
		return _$self;
	}
});


// $source: com/ibm/rave/core/internal/svg/symbol/SquareSymbolCreator
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
/**
 * Symbol creator for a Square shape
 */
var com_ibm_rave_core_internal_svg_symbol_SquareSymbolCreator = com_ibm_rave_core_nativeImpl_Declare({

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * create a Square symbol using the passed size
		 * @param (double) size  size of the shape in square pixels
		 * @return (String)  SVG path string for the shape
		 */
		function(size) {
			var r = Math.sqrt(size) / 2;
			return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
		};
		return _$self;
	}
});


// $source: com/ibm/rave/core/internal/svg/symbol/TriangleDownSymbolCreator
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/svg/symbol/SymbolCreatorsConstants (runtime) // SymbolCreatorsConstants
/**
 * Symbol creator for a TriangleDown shape
 */
var com_ibm_rave_core_internal_svg_symbol_TriangleDownSymbolCreator = com_ibm_rave_core_nativeImpl_Declare({

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * create a TriangleDown symbol using the passed size
		 * @param (double) size   size of the shape in square pixels
		 * @return (String)  SVG path string for the shape
		 */
		function(size) {
			var rx = Math.sqrt(size / com_ibm_rave_core_internal_svg_symbol_SymbolCreatorsConstants.r2_svg_symbolSqrt3), ry = rx * com_ibm_rave_core_internal_svg_symbol_SymbolCreatorsConstants.r2_svg_symbolSqrt3 / 2;
			return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
		};
		return _$self;
	}
});


// $source: com/ibm/rave/core/internal/svg/symbol/TriangleUpSymbolCreator
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/svg/symbol/SymbolCreatorsConstants (runtime) // SymbolCreatorsConstants
/**
 * Symbol creator for a TriangleUp shape
 */
var com_ibm_rave_core_internal_svg_symbol_TriangleUpSymbolCreator = com_ibm_rave_core_nativeImpl_Declare({

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * create a TriangleUp symbol using the passed size
		 * @param (double) size  size of the shape in square pixels
		 * @return (String)  SVG path string for the shape
		 */
		function(size) {
			var rx = Math.sqrt(size / com_ibm_rave_core_internal_svg_symbol_SymbolCreatorsConstants.r2_svg_symbolSqrt3), ry = rx * com_ibm_rave_core_internal_svg_symbol_SymbolCreatorsConstants.r2_svg_symbolSqrt3 / 2;
			return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
		};
		return _$self;
	}
});


// $source: com/ibm/rave/core/internal/svg/symbol/CircleSymbolCreator
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
/**
 * Symbol creator for a circle shape
 */
var com_ibm_rave_core_internal_svg_symbol_CircleSymbolCreator = com_ibm_rave_core_nativeImpl_Declare({

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * create a circle symbol using the passed size
		 * @param (double) size   size of the shape in square pixels
		 * @return (String)  SVG path string for the shape
		 */
		function(size) {
			var r = Math.sqrt(size / 3.141592653589793);
			return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + (-r) + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
		};
		return _$self;
	}
});


// $source: com/ibm/rave/core/svg/Symbol
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/nativeImpl/arrays/ES6Map (runtime) // create
//@import com/ibm/rave/core/internal/svg/symbol/CrossSymbolCreator (static) // new
//@import com/ibm/rave/core/internal/svg/symbol/DiamondSymbolCreator (static) // new
//@import com/ibm/rave/core/internal/svg/symbol/SquareSymbolCreator (static) // new
//@import com/ibm/rave/core/internal/svg/symbol/TriangleDownSymbolCreator (static) // new
//@import com/ibm/rave/core/internal/svg/symbol/TriangleUpSymbolCreator (static) // new
//@import com/ibm/rave/core/internal/svg/symbol/CircleSymbolCreator (static) // new
/**
 * Constructs a new symbol generator with the default type- and size-accessor functions (that make no assumptions about input data, and produce a circle sized 64 square pixels; see below for details).  While the default accessors generate static symbols, it is common to set one or more of the accessors using a function, such as setting the size proportional to a dimension of data for a scatterplot.
 */
var com_ibm_rave_core_svg_Symbol = rave_externs["Symbol"] = com_ibm_rave_core_nativeImpl_Declare({

	//type_fn : null,

	//size_fn : null,

	_$functionClassMethod : function() {
		var _$self = function(data, index, groupIndex) {
			var type = _$self.type_fn.call(this, data, index, groupIndex);
			var creator = com_ibm_rave_core_svg_Symbol.r2_svg_symbols.get(type);
			if (!creator) {
				creator = com_ibm_rave_core_svg_Symbol.r2_svg_symbolCircle;
			}
			return creator(_$self.size_fn.call(this, data, index, groupIndex));
		};
		return _$self;
	},

	constructor : function() {
		this.type_fn = com_ibm_rave_core_svg_Symbol.TYPE_FN;
		this.size_fn = com_ibm_rave_core_svg_Symbol.SIZE_FN;
	},

	/**
	 * returns accessor for the symbol type
	 * @return (com.ibm.rave.core.selector.ValueFunction) 	the symbol type accessor 
	 */
	type$0 : function() {
		return this.type_fn;
	},

	/**
	 * sets the accessor for the  symbol type
	 * @param (com.ibm.rave.core.selector.ValueFunction) valueFn  , symbol type accessor
	 * @return (com.ibm.rave.core.svg.Symbol)  the Symbol
	 */
	type$1 : function(valueFn) {
		this.type_fn = valueFn;
		return this;
	},

	/**
	 * sets the symbol type
	 * @param (String) value  the symbol type
	 * @return (com.ibm.rave.core.svg.Symbol)  the Symbol
	 */
	type$2 : function(value) {
		this.type_fn = function(data, index, groupIndex) {
			return value;
		};
		return this;
	},

	/**
	 * returns accessor for the symbol size, size is in square pixels
	 * @return (com.ibm.rave.core.selector.ValueFunction) 	the symbol size accessor 
	 */
	size$0 : function() {
		return this.size_fn;
	},

	/**
	 * sets the accessor for the  symbol size, size is expected to provided in square pixels
	 * @param (com.ibm.rave.core.selector.ValueFunction) valueFn  , symbol size accessor
	 * @return (com.ibm.rave.core.svg.Symbol)  the symbol
	 */
	size$1 : function(valueFn) {
		this.size_fn = valueFn;
		return this;
	},

	/**
	 * sets the symbol size, size is expected to provided in square pixels
	 * @param (double) value  the symbol size
	 * @return (com.ibm.rave.core.svg.Symbol)  the Symbol
	 */
	size$2 : function(value) {
		this.size_fn = function(data, index, groupIndex) {
			return value;
		};
		return this;
	},

	/** @expose */ 
	type : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.type$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.type$1(a0);
		}
		return this.type$2(a0);
	},

	/** @expose */ 
	size : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.size$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.size$1(a0);
		}
		return this.size$2(a0);
	}
});

com_ibm_rave_core_svg_Symbol.createSymbols = function() {
	var map = com_ibm_rave_core_nativeImpl_arrays_ES6Map.create();
	map.set("circle", com_ibm_rave_core_svg_Symbol.r2_svg_symbolCircle);
	map.set("cross", new com_ibm_rave_core_internal_svg_symbol_CrossSymbolCreator());
	map.set("diamond", new com_ibm_rave_core_internal_svg_symbol_DiamondSymbolCreator());
	map.set("square", new com_ibm_rave_core_internal_svg_symbol_SquareSymbolCreator());
	map.set("triangle-down", new com_ibm_rave_core_internal_svg_symbol_TriangleDownSymbolCreator());
	map.set("triangle-up", new com_ibm_rave_core_internal_svg_symbol_TriangleUpSymbolCreator());
	return map;
};

/**
 * Register a symbol creator using an id. If the same id is already in use, registration will fail. Once you register as symbol creator it will be available for all other symbols created afterwards and not only this instance
 * @param (String) id extension id
 * @param (com.ibm.rave.core.svg.SymbolCreator) symbolCreator extended symbolCreator which is an svg path generator provided by id
 * @return (boolean)  true, if the registration was successful, false otherwise
 */
com_ibm_rave_core_svg_Symbol.register = function(id, symbolCreator) {
	if (com_ibm_rave_core_svg_Symbol.r2_svg_symbols.get(id)) {
		return false;
	}
	com_ibm_rave_core_svg_Symbol.r2_svg_symbols.set(id, symbolCreator);
	return true;
};

com_ibm_rave_core_svg_Symbol.DEFAULT_SIZE = 64;

com_ibm_rave_core_svg_Symbol.r2_svg_symbols = com_ibm_rave_core_svg_Symbol.createSymbols();
com_ibm_rave_core_svg_Symbol.r2_svg_symbolCircle = new com_ibm_rave_core_internal_svg_symbol_CircleSymbolCreator();
com_ibm_rave_core_svg_Symbol.r2_svg_symbolTypes = com_ibm_rave_core_svg_Symbol.r2_svg_symbols.keys();
com_ibm_rave_core_svg_Symbol.SIZE_FN = function(data, index, groupIndex) {
	return com_ibm_rave_core_svg_Symbol.DEFAULT_SIZE;
};
com_ibm_rave_core_svg_Symbol.TYPE_FN = function(data, index, groupIndex) {
	return "circle";
};

// $source: com/ibm/rave/core/svg/SVG
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/svg/LinePathGeneratorFactory (runtime) // new
//@import com/ibm/rave/core/svg/AreaPathGeneratorFactory (runtime) // new
//@import com/ibm/rave/core/svg/DiagonalPathGeneratorFactory (runtime) // new
//@import com/ibm/rave/core/svg/Symbol (loadtime) // new, register, Symbol
//@import com/ibm/rave/core/svg/Arc (runtime) // new
//@import com/ibm/rave/core/svg/Chord (runtime) // new
//@import com/ibm/rave/core/svg/Axis (runtime) // new
//@import com/ibm/rave/core/svg/Brush (runtime) // newBrush
/**
 * A Factory class for the SVG path generators.
 */
var com_ibm_rave_core_svg_SVG = com_ibm_rave_core_nativeImpl_Declare({

	/**
	 * Factory method, that creates a Line path generator   using the Identity projection Constructs a new line generator with the default x- and y-accessor functions (that assume the input data is a two-element array of numbers), and linear interpolation.  The returned function generates path data for an open piecewise linear curve, or polyline By changing the interpolation, you can also generate splines and step functions.  Also, don't be afraid to tack on additional path commands at the end.  For example, if you want to generate a closed path, append a closepath (Z)  Returns a line path generator factory method  {@link (com.ibm.rave.core.svg.LinePathGeneratorFactory) LinePathGeneratorFactory}
	 */
	/** @expose */ 
	line : null,

	/**
	 * Factory method, that creates an Area Path Generator   using the Identity projection Constructs a new Area Path Generator with the default x- and y-accessors functions (that assume the input data is a two-element array of numbers), and linear interpolation.  The returned function generates path data for a closed piecewise linear curve, or polygon. Returns a  line path generator factory method  {@link (com.ibm.rave.core.svg.AreaPathGenerator) AreaPathGenerator}
	 */
	/** @expose */ 
	area : null,

	/**
	 * Factory method, Constructs a new diagonal generator with the default accessor functions (that assume the input data is an object with named attributes matching the accessors). The returned Generator generates the path data for a cubic Bézier connecting the source and target points; the tangents are specified to produce smooth fan-in and fan-out when connecting nodes   Returns a Diagonal path generator factory method  {@link (com.ibm.rave.core.svg.DiagonalPathGenerator) DiagonalPathGenerator}
	 */
	/** @expose */ 
	diagonal : null,

	/**
	 * List of all supported Symbol Types
	 */
	/** @expose */ 
	symbolTypes : null,

	constructor : function() {
		this.line = new com_ibm_rave_core_svg_LinePathGeneratorFactory();
		this.area = new com_ibm_rave_core_svg_AreaPathGeneratorFactory();
		this.diagonal = new com_ibm_rave_core_svg_DiagonalPathGeneratorFactory();
		this.symbolTypes = com_ibm_rave_core_svg_Symbol.r2_svg_symbolTypes;
	},

	/**
	 * Factory method, that creates an Arc path generator.
	 * @return (com.ibm.rave.core.svg.Arc)  arc path generator  {@link (com.ibm.rave.core.svg.Arc) Arc}
	 */
	/** @expose */ 
	arc : function() {
		return new com_ibm_rave_core_svg_Arc();
	},

	/**
	 * Factory method, that creates a chord path generator.
	 * @return (com.ibm.rave.core.svg.Chord)  chord path generator  {@link (com.ibm.rave.core.svg.Chord) Chord}
	 */
	/** @expose */ 
	chord : function() {
		return new com_ibm_rave_core_svg_Chord();
	},

	/**
	 * Factory method, that creates an axis shape generator.
	 * @return (com.ibm.rave.core.svg.Axis)  axis shape generator  {@link (com.ibm.rave.core.svg.Axis) Axis}
	 */
	/** @expose */ 
	axis : function() {
		return new com_ibm_rave_core_svg_Axis();
	},

	/**
	 * Factory method, that creates a Symbol path generator.
	 * @return (com.ibm.rave.core.svg.Symbol)  symbol path generator  {@link (com.ibm.rave.core.svg.Symbol) Symbol}
	 */
	/** @expose */ 
	symbol : function() {
		return new com_ibm_rave_core_svg_Symbol();
	},

	/**
	 * Constructs a new brush with no default x- and y-scale, and an empty extent
	 * @return (com.ibm.rave.core.svg.Brush)  the newly constructed brush control
	 */
	/** @expose */ 
	brush : function() {
		return com_ibm_rave_core_svg_Brush.newBrush();
	},

	/**
	 * Register a symbol creator using an id. If the same id is already in use, registration will fail. Once you register as symbol creator it will be available to use via Symbol. In Javascript for example, registering a symbol creator would look like the following: <pre class="javascript"> rave.svg.symbolCreator("circle-line", function(area){ //A symbol creator for a circle with a horizontal line across it //First, create a circle svg path var circleStr = lib.svg.symbol().type("circle").size(area *.6)(); //Now, calculate width and height of a horizontal rectangle representing a line var w = Math.sqrt(area / 2.0); var h = w / 6.0; //Then, build the line's svg path string var hRectStr =  "M" + -w + "," + -h + "H" + w + "V" + h + "H" + -w + "Z"; //Finally, concatenate both to create the path of the composite shape and return it return circleStr.substring(0, circleStr.length - 1) + hRectStr; }); </pre>
	 * @param (String) id extension id
	 * @param (com.ibm.rave.core.svg.SymbolCreator) symbolCreator extended symbolCreator which is an svg path generator provided by id
	 * @return (boolean)  true, if the registration was successful, false otherwise
	 * @see SymbolCreator
	 * @see Symbol
	 */
	/** @expose */ 
	symbolCreator : com_ibm_rave_core_svg_Symbol.register

	//constructor : function() {}
});

/** @expose */ 
com_ibm_rave_core_svg_SVG.getInstance = function() {
	if (!com_ibm_rave_core_svg_SVG.INSTANCE) {
		{
			if (!com_ibm_rave_core_svg_SVG.INSTANCE) {
				com_ibm_rave_core_svg_SVG.INSTANCE = new com_ibm_rave_core_svg_SVG();
			}
		}
	}
	return com_ibm_rave_core_svg_SVG.INSTANCE;
};

//com_ibm_rave_core_svg_SVG.INSTANCE = null;

// $source: com/ibm/rave/core/svg/Arc
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/math/Trigonometry (runtime) // asin
//@import com/ibm/rave/core/internal/geom/PolygonUtil (runtime) // polygonIntersect
/**
 * Arc is an SVG path generator helper class it generates an SVG path string representing an ARC using the values set on the generator parameters to control the path generator are: Inner radius : the inner radius of the curve  {@link #this.innerRadius()}  Outer radius : the outer radius of the curve  {@link #this.outerRadius()}  Start angle : the starting angle of the curve {@link #this.startAngle()}  End angle : the end angle of the curve {@link #this.endAngle()}
 */
var com_ibm_rave_core_svg_Arc = rave_externs["Arc"] = com_ibm_rave_core_nativeImpl_Declare({

	//_innerRadius : null,

	//_cornerRadius : null,

	//_outerRadius : null,

	//_startAngle : null,

	//_endAngle : null,

	//_arcPadAngle : null,

	//_padRadius : null,

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * Get a computed value for the given data and index.
		 * @param (Object) this the context in which this method is invoked
		 * @param (Object) data a data value, may be <code>null</code>
		 * @param (int) index the index of the current scene node
		 * @param (int) groupIndex the group index of the current scene node
		 * @return (String)  a computed value
		 */
		function(data, index, groupIndex) {
			var l0 = 0;
			var l1 = 0;
			var r0 = Math.max(0, + (_$self._innerRadius.call(this, data, index, groupIndex)));
			var r1 = Math.max(0, + (_$self._outerRadius.call(this, data, index, groupIndex)));
			var a0 = _$self._startAngle.call(this, data, index, groupIndex) - (1.5707963267948966);
			var a1 = _$self._endAngle.call(this, data, index, groupIndex) - (1.5707963267948966);
			var da = Math.abs(a1 - a0);
			var cw = a0 > a1 ? 0 : 1;
			if (r1 < r0) {
				var rc = r1;
				r1 = r0;
				r0 = rc;
			}
			if (da >= 6.283184307179586) {
				return com_ibm_rave_core_svg_Arc.circleSegment(r1, cw) + (r0 != 0 && r0 != 0 ? com_ibm_rave_core_svg_Arc.circleSegment(r0, 1 - cw) : "") + "Z";
			}
			var rc, cr, rp, p0 = 0, p1 = 0, ap, x0, y0, x2, y2, x1 = NaN, y1 = NaN, x3 = NaN, y3 = NaN;
			var path = "";
			ap = + (_$self._arcPadAngle.call(this, data, index, groupIndex));
			if ((ap)) {
				ap = ap / 2;
				rp = + ((_$self._padRadius == com_ibm_rave_core_svg_Arc.PAD_RADIUS ? Math.sqrt(r0 * r0 + r1 * r1) : + (_$self._padRadius.call(this, data, index, groupIndex))));
				if (r1 != 0) {
					p1 = com_ibm_rave_core_internal_math_Trigonometry.asin(rp / r1 * Math.sin(ap));
				}
				if (r0 != 0) {
					p0 = com_ibm_rave_core_internal_math_Trigonometry.asin(rp / r0 * Math.sin(ap));
				}
			} else {
				ap = 0.0;
			}
			if ((r1)) {
				x0 = r1 * Math.cos(a0 + p1);
				y0 = r1 * Math.sin(a0 + p1);
				x1 = r1 * Math.cos(a1 - p1);
				y1 = r1 * Math.sin(a1 - p1);
				l1 = Math.abs(a1 - a0 - 2 * p1) <= 3.141592653589793 ? 0 : 1;
				if ((p1 != 0.0 && (com_ibm_rave_core_svg_Arc.arcSweep(x0, y0, x1, y1)) == (cw ^ l1))) {
					var h1 = (a0 + a1) / 2;
					x0 = r1 * Math.cos(h1);
					y0 = r1 * Math.sin(h1);
					x1 = y1 = NaN;
				}
			} else {
				x0 = y0 = 0.0;
			}
			if ((r0)) {
				x2 = r0 * Math.cos(a1 - p0);
				y2 = r0 * Math.sin(a1 - p0);
				x3 = r0 * Math.cos(a0 + p0);
				y3 = r0 * Math.sin(a0 + p0);
				l0 = Math.abs(a0 - a1 + 2 * p0) <= 3.141592653589793 ? 0 : 1;
				if ((p0) && ((com_ibm_rave_core_svg_Arc.arcSweep(x2, y2, x3, y3)) == ((1 - cw) ^ l0))) {
					var h0 = (a0 + a1) / 2;
					x2 = r0 * Math.cos(h0);
					y2 = r0 * Math.sin(h0);
					x3 = y3 = NaN;
				}
			} else {
				x2 = y2 = 0.0;
			}
			if ((rc = Math.min(Math.abs(r1 - r0) / 2, + (_$self._cornerRadius.call(this, data, index, groupIndex)))) > 1e-3) {
				cr = (r0 < r1) ^ (cw) ? 0 : 1;
				var oc = isNaN(x3) ? [x2, y2] : isNaN(x1) ? [x0, y0] : com_ibm_rave_core_internal_geom_PolygonUtil.polygonIntersect([x0, y0], [x3, y3], [x1, y1], [x2, y2]);
				var ax = x0 - oc[0];
				var ay = y0 - oc[1];
				var bx = x1 - oc[0];
				var by = y1 - oc[1];
				var kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2);
				var lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
				var rc1 = Math.min(rc, (r1 - lc) / (kc + 1));
				var t12 = com_ibm_rave_core_svg_Arc.svg_arcCornerTangents([x1, y1], [x2, y2], r1, rc1, cw);
				var t30 = com_ibm_rave_core_svg_Arc.svg_arcCornerTangents(isNaN(x3) ? [x2, y2] : [x3, y3], [x0, y0], r1, rc1, cw);
				if (rc == rc1) {
					path = path + "M" + t30[0] + "A" + rc1 + "," + rc1 + " 0 0," + cr + " ";
					path = path + t30[1] + "A" + r1 + "," + r1 + " 0 " + ((1 - cw) ^ com_ibm_rave_core_svg_Arc.arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1])) + "," + cw + " " + t12[1] + "A" + rc1 + "," + rc1 + " 0 0," + cr + " " + t12[0];
				} else {
					path = path + "M" + t30[0] + "A" + rc1 + "," + rc1 + " 0 1," + cr + " " + t12[0];
				}
				if (!(isNaN(x3))) {
					var rc0 = Math.min(rc, (r0 - lc) / (kc - 1));
					var t21 = com_ibm_rave_core_svg_Arc.svg_arcCornerTangents([x2, y2], isNaN(x1) ? [x0, y0] : [x1, y1], r0, -rc0, cw);
					var t03 = com_ibm_rave_core_svg_Arc.svg_arcCornerTangents([x0, y0], [x3, y3], r0, -rc0, cw);
					if (rc == rc0) {
						path = path + "L" + t21[0] + "A" + rc0 + "," + rc0 + " 0 0," + cr + " ";
						path = path + t21[1] + "A" + r0 + "," + r0 + " 0 " + (cw ^ com_ibm_rave_core_svg_Arc.arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1])) + "," + (1 - cw) + " " + t03[1] + "A" + rc0 + "," + rc0 + " 0 0," + cr + " " + t03[0];
					} else {
						path = path + "L" + t21[0] + "A" + rc0 + "," + rc0 + " 0 0," + cr + " " + t03[0];
					}
				} else {
					path = path + "L" + x2 + "," + y2;
				}
			} else {
				path = path + "M" + x0 + "," + y0;
				if (!(isNaN(x1))) {
					path = path + "A" + r1 + "," + r1 + " 0 " + l1 + "," + cw + " " + x1 + "," + y1;
				}
				path = path + "L" + x2 + "," + y2;
				if (!(isNaN(x3))) {
					path = path + "A" + r0 + "," + r0 + " 0 " + l0 + "," + (1 - cw) + " " + x3 + "," + y3;
				}
			}
			path = path + "Z";
			return path;
		};
		return _$self;
	},

	constructor : function() {
		this._innerRadius = com_ibm_rave_core_svg_Arc.INNER_RADIUS;
		this._cornerRadius = com_ibm_rave_core_svg_Arc.CORNER_RADIUS;
		this._outerRadius = com_ibm_rave_core_svg_Arc.OUTER_RADIUS;
		this._startAngle = com_ibm_rave_core_svg_Arc.START_ANGLE;
		this._endAngle = com_ibm_rave_core_svg_Arc.END_ANGLE;
		this._arcPadAngle = com_ibm_rave_core_svg_Arc.PAD_ANGLE;
		this._padRadius = com_ibm_rave_core_svg_Arc.PAD_RADIUS;
	},

	/**
	 * sets the inner radius value function, function that will be called by the arc class to get the value on inner radius
	 * @param (com.ibm.rave.core.selector.ValueFunction) innerRadiusFn the inner radius function
	 * @return (com.ibm.rave.core.svg.Arc)  this
	 */
	innerRadius$0 : function(innerRadiusFn) {
		this._innerRadius = innerRadiusFn;
		return this;
	},

	/**
	 * sets the inner radius value
	 * @param (double) value the inner radius value
	 * @return (com.ibm.rave.core.svg.Arc)  this
	 */
	innerRadius$1 : function(value) {
		this._innerRadius = function(data, index, groupIndex) {
			return value;
		};
		return this;
	},

	/**
	 * gets the inner radius value function
	 * @return (com.ibm.rave.core.selector.ValueFunction)  the value function
	 */
	innerRadius$2 : function() {
		return this._innerRadius;
	},

	/**
	 * sets the outer radius value function, function that will be called by the arc class to get the value on outer radius
	 * @param (com.ibm.rave.core.selector.ValueFunction) outerRadiusFn the outer radius function
	 * @return (com.ibm.rave.core.svg.Arc)  this
	 */
	outerRadius$0 : function(outerRadiusFn) {
		this._outerRadius = outerRadiusFn;
		return this;
	},

	/**
	 * sets the outer radius value
	 * @param (double) value the outer radius value
	 * @return (com.ibm.rave.core.svg.Arc)  this
	 */
	outerRadius$1 : function(value) {
		this._outerRadius = function(data, index, groupIndex) {
			return value;
		};
		return this;
	},

	/**
	 * gets the outer radius value function
	 * @return (com.ibm.rave.core.selector.ValueFunction)  the value function
	 */
	outerRadius$2 : function() {
		return this._outerRadius;
	},

	/**
	 * sets the start angle value function, function that will be called by the arc class to get the value on start angle
	 * @param (com.ibm.rave.core.selector.ValueFunction) startAngleFn the start angle function
	 * @return (com.ibm.rave.core.svg.Arc)  this
	 */
	startAngle$0 : function(startAngleFn) {
		this._startAngle = startAngleFn;
		return this;
	},

	/**
	 * sets the start angle value
	 * @param (double) value the start angle value
	 * @return (com.ibm.rave.core.svg.Arc)  this
	 */
	startAngle$1 : function(value) {
		this._startAngle = function(data, index, groupIndex) {
			return value;
		};
		return this;
	},

	/**
	 * gets the start angle value function
	 * @return (com.ibm.rave.core.selector.ValueFunction)  the value function
	 */
	startAngle$2 : function() {
		return this._startAngle;
	},

	/**
	 * sets the end angle value function, function that will be called by the arc class to get the value on end angle
	 * @param (com.ibm.rave.core.selector.ValueFunction) endAngleFn the end angle function
	 * @return (com.ibm.rave.core.svg.Arc)  this
	 */
	endAngle$0 : function(endAngleFn) {
		this._endAngle = endAngleFn;
		return this;
	},

	/**
	 * sets the end angle value
	 * @param (double) value the end angle value
	 * @return (com.ibm.rave.core.svg.Arc)  this
	 */
	endAngle$1 : function(value) {
		this._endAngle = function(data, index, groupIndex) {
			return value;
		};
		return this;
	},

	/**
	 * gets the end angle value function
	 * @return (com.ibm.rave.core.selector.ValueFunction)  the value function
	 */
	endAngle$2 : function() {
		return this._endAngle;
	},

	/**
	 * sets the arc pad angle value function, function that will be called by the arc class to get the value on end angle
	 * @param (com.ibm.rave.core.selector.ValueFunction) padAngleFn the pad angle function
	 * @return (com.ibm.rave.core.svg.Arc)  this
	 */
	padAngle$0 : function(padAngleFn) {
		this._arcPadAngle = padAngleFn;
		return this;
	},

	/**
	 * sets the arc pad angle value
	 * @param (double) value the pad angle value
	 * @return (com.ibm.rave.core.svg.Arc)  this
	 */
	padAngle$1 : function(value) {
		this._arcPadAngle = function(data, index, groupIndex) {
			return value;
		};
		return this;
	},

	/**
	 * gets the arc pad angle value function
	 * @return (com.ibm.rave.core.selector.ValueFunction)  the value function
	 */
	padAngle$2 : function() {
		return this._arcPadAngle;
	},

	/**
	 * sets the corner radius value function, function that will be called by the arc class to get the value on corner radius
	 * @param (com.ibm.rave.core.selector.ValueFunction) cornerRadiusFn the end angle function
	 * @return (com.ibm.rave.core.svg.Arc)  this
	 */
	cornerRadius$0 : function(cornerRadiusFn) {
		this._cornerRadius = cornerRadiusFn;
		return this;
	},

	/**
	 * sets the corner radius value
	 * @param (double) value the corner radius value
	 * @return (com.ibm.rave.core.svg.Arc)  this
	 */
	cornerRadius$1 : function(value) {
		this._cornerRadius = function(data, index, groupIndex) {
			return value;
		};
		return this;
	},

	/**
	 * gets the corner radius value function
	 * @return (com.ibm.rave.core.selector.ValueFunction)  the value function
	 */
	cornerRadius$2 : function() {
		return this._cornerRadius;
	},

	/**
	 * sets the pad radius value function, function that will be called by the arc class to get the value on pad radius
	 * @param (com.ibm.rave.core.selector.ValueFunction) padRadiusFn the pad radius function
	 * @return (com.ibm.rave.core.svg.Arc)  this
	 */
	padRadius$0 : function(padRadiusFn) {
		this._padRadius = padRadiusFn;
		return this;
	},

	/**
	 * sets the pad radius value
	 * @param (double) value the pad radius value
	 * @return (com.ibm.rave.core.svg.Arc)  this
	 */
	padRadius$1 : function(value) {
		this._padRadius = function(data, index, groupIndex) {
			return value;
		};
		return this;
	},

	/**
	 * gets the pad radius value function
	 * @return (com.ibm.rave.core.selector.ValueFunction)  the value function
	 */
	padRadius$2 : function() {
		return this._padRadius;
	},

	/**
	 * Calculates the centroid of the arc that would be generated from a specified input. The centroid is defined as the midpoint in polar coordinates of the inner and outer radius, and the start and end angle.
	 * @param (Object) data The input used to calculate the centroids
	 * @param (int) index The current index
	 * @param (int) groupIndex The current group index
	 * @return (double[])  The centroid of the arc
	 */
	/** @expose */ 
	centroid : function(data, index, groupIndex) {
		var r = (this._innerRadius.call(this, data, index, groupIndex) + this._outerRadius.call(this, data, index, groupIndex)) / 2, a = (this._startAngle.call(this, data, index, groupIndex) + this._endAngle.call(this, data, index, groupIndex)) / 2 - (1.5707963267948966);
		return [Math.cos(a) * r, Math.sin(a) * r];
	},

	/** @expose */ 
	innerRadius : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.innerRadius$2();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.innerRadius$0(a0);
		}
		return this.innerRadius$1(a0);
	},

	/** @expose */ 
	outerRadius : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.outerRadius$2();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.outerRadius$0(a0);
		}
		return this.outerRadius$1(a0);
	},

	/** @expose */ 
	startAngle : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.startAngle$2();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.startAngle$0(a0);
		}
		return this.startAngle$1(a0);
	},

	/** @expose */ 
	endAngle : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.endAngle$2();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.endAngle$0(a0);
		}
		return this.endAngle$1(a0);
	},

	/** @expose */ 
	padAngle : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.padAngle$2();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.padAngle$0(a0);
		}
		return this.padAngle$1(a0);
	},

	/** @expose */ 
	cornerRadius : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.cornerRadius$2();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.cornerRadius$0(a0);
		}
		return this.cornerRadius$1(a0);
	},

	/** @expose */ 
	padRadius : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.padRadius$2();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.padRadius$0(a0);
		}
		return this.padRadius$1(a0);
	}
});

com_ibm_rave_core_svg_Arc.circleSegment = function(r1, cw) {
	return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
};

com_ibm_rave_core_svg_Arc.arcSweep = function(x0, y0, x1, y1) {
	return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
};

com_ibm_rave_core_svg_Arc.svg_arcCornerTangents = function(p0, p1, r1, rc, cw) {
	var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw != null ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(r * r * d2 - D * D), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;
	if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) {
		cx0 = cx1;
		cy0 = cy1;
	}
	return [[cx0 - ox, cy0 - oy], [cx0 * r1 / r, cy0 * r1 / r]];
};

com_ibm_rave_core_svg_Arc.INNER_RADIUS = function(data, index, groupIndex) {
	return (data).innerRadius;
};
com_ibm_rave_core_svg_Arc.OUTER_RADIUS = function(data, index, groupIndex) {
	return (data).outerRadius;
};
com_ibm_rave_core_svg_Arc.START_ANGLE = function(data, index, groupIndex) {
	return (data).startAngle;
};
com_ibm_rave_core_svg_Arc.END_ANGLE = function(data, index, groupIndex) {
	return (data).endAngle;
};
com_ibm_rave_core_svg_Arc.CORNER_RADIUS = function(data, index, groupIndex) {
	return 0.0;
};
com_ibm_rave_core_svg_Arc.PAD_ANGLE = function(data, index, groupIndex) {
	if (data == null) {
		return null;
	}
	return (data).padAngle;
};
com_ibm_rave_core_svg_Arc.PAD_RADIUS = function(data, index, groupIndex) {
	return "auto";
};
com_ibm_rave_core_svg_Arc.svg_arcMax = 6.283185307179586 - 1.0E-6;

// $source: com/ibm/rave/core/svg/Chord
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/svg/Arc (runtime) // Arc
/**
 * Chord svg path generator. This class generates a path representing a chord. It depends on results generated by {@link ChordLayout}  and uses the  {@link (com.ibm.rave.core.svg.Arc) Arc}  svg path generator.
 */
var com_ibm_rave_core_svg_Chord = rave_externs["Chord"] = com_ibm_rave_core_nativeImpl_Declare({

	//_source : null,

	//_target : null,

	//_radius : null,

	//_startAngle : null,

	//_endAngle : null,

	_$functionClassMethod : function() {
		var _$self = function(data, index, groupIndex) {
			var s = _$self.subgroup(this, _$self._source, data, index, groupIndex), t = _$self.subgroup(this, _$self._target, data, index, groupIndex);
			return "M" + (s.p0) + _$self.arc(s.r, s.p1, s.a1 - s.a0) + (_$self.equals(s, t) ? _$self.curve(s.r, s.p1, s.r, s.p0) : _$self.curve(s.r, s.p1, t.r, t.p0) + _$self.arc(t.r, t.p1, t.a1 - t.a0) + _$self.curve(t.r, t.p1, s.r, s.p0)) + "Z";
		};
		return _$self;
	},

	constructor : function() {
		this._source = com_ibm_rave_core_svg_Chord.SOURCE;
		this._target = com_ibm_rave_core_svg_Chord.TARGET;
		this._radius = com_ibm_rave_core_svg_Chord.RAIDUS;
		this._startAngle = com_ibm_rave_core_svg_Arc.START_ANGLE;
		this._endAngle = com_ibm_rave_core_svg_Arc.END_ANGLE;
	},

	subgroup : function(context, f, d, i, groupIndex) {
		var subgroup = f.call(context, d, i, groupIndex);
		var r = this._radius.call(context, subgroup, i, groupIndex);
		var a0 = this._startAngle.call(context, subgroup, i, groupIndex) - 1.5707963267948966;
		var a1 = this._endAngle.call(context, subgroup, i, groupIndex) - 1.5707963267948966;
		return new com_ibm_rave_core_svg_Chord.SubGroup(r, a0, a1, [r * Math.cos(a0), r * Math.sin(a0)], [r * Math.cos(a1), r * Math.sin(a1)]);
	},

	equals : function(a, b) {
		return a.a0 == b.a0 && a.a1 == b.a1;
	},

	arc : function(r, p, a) {
		return "A" + r + "," + r + " 0 " + +(a > 3.141592653589793) + ",1 " + (p);
	},

	curve : function(r0, p0, r1, p1) {
		return "Q 0,0 " + (p1);
	},

	/**
	 * sets the end angle value function, function that will be called by the chord class to get the value on end angle
	 * @param (com.ibm.rave.core.selector.ValueFunction) endAngleFn the end angle function
	 * @return (com.ibm.rave.core.svg.Chord)  this
	 */
	endAngle$0 : function(endAngleFn) {
		this._endAngle = endAngleFn;
		return this;
	},

	/**
	 * sets the end angle value
	 * @param (double) value the end angle value
	 * @return (com.ibm.rave.core.svg.Chord)  this
	 */
	endAngle$1 : function(value) {
		this._endAngle = function(data, index, groupIndex) {
			return value;
		};
		return this;
	},

	/**
	 * gets the end angle value function
	 * @return (com.ibm.rave.core.selector.ValueFunction)  the value function
	 */
	endAngle$2 : function() {
		return this._endAngle;
	},

	/**
	 * sets the start angle value function, function that will be called by the chord class to get the value on start angle
	 * @param (com.ibm.rave.core.selector.ValueFunction) startAngleFn the start angle function
	 * @return (com.ibm.rave.core.svg.Chord)  this
	 */
	startAngle$0 : function(startAngleFn) {
		this._startAngle = startAngleFn;
		return this;
	},

	/**
	 * sets the start angle value
	 * @param (double) value the start angle value
	 * @return (com.ibm.rave.core.svg.Chord)  this
	 */
	startAngle$1 : function(value) {
		this._startAngle = function(data, index, groupIndex) {
			return value;
		};
		return this;
	},

	/**
	 * gets the start angle value function
	 * @return (com.ibm.rave.core.selector.ValueFunction)  the value function
	 */
	startAngle$2 : function() {
		return this._startAngle;
	},

	/**
	 * sets the source value function, function that will be called by the chord class to get the value on source
	 * @param (com.ibm.rave.core.selector.ValueFunction) sourceFn the source angle function
	 * @return (com.ibm.rave.core.svg.Chord)  this
	 */
	source$0 : function(sourceFn) {
		this._source = sourceFn;
		return this;
	},

	/**
	 * sets the source value
	 * @param (com.ibm.rave.core.layout.chord.SubGroupData) sourceValue the source value
	 * @return (com.ibm.rave.core.svg.Chord)  this
	 */
	source$1 : function(sourceValue) {
		this._source = function(data, index, groupIndex) {
			return sourceValue;
		};
		return this;
	},

	/**
	 * gets the source value function
	 * @return (com.ibm.rave.core.selector.ValueFunction)  the source function
	 */
	source$2 : function() {
		return this._source;
	},

	/**
	 * sets the target value function, function that will be called by the chord class to get the value on target
	 * @param (com.ibm.rave.core.selector.ValueFunction) targetFn the start angle function
	 * @return (com.ibm.rave.core.svg.Chord)  this
	 */
	target$0 : function(targetFn) {
		this._target = targetFn;
		return this;
	},

	/**
	 * sets the target value
	 * @param (com.ibm.rave.core.layout.chord.SubGroupData) value the target value
	 * @return (com.ibm.rave.core.svg.Chord)  this
	 */
	target$1 : function(value) {
		this._target = function(data, index, groupIndex) {
			return value;
		};
		return this;
	},

	/**
	 * gets the target value function
	 * @return (com.ibm.rave.core.selector.ValueFunction)  the value function
	 */
	target$2 : function() {
		return this._target;
	},

	/**
	 * sets the radius value function, function that will be called by the chord class to get the value of radius
	 * @param (com.ibm.rave.core.selector.ValueFunction) radiusFn the radius function
	 * @return (com.ibm.rave.core.svg.Chord)  this
	 */
	radius$0 : function(radiusFn) {
		this._radius = radiusFn;
		return this;
	},

	/**
	 * sets the radius value
	 * @param (double) value the radius value
	 * @return (com.ibm.rave.core.svg.Chord)  this
	 */
	radius$1 : function(value) {
		this._radius = function(data, index, groupIndex) {
			return value;
		};
		return this;
	},

	/**
	 * gets the radius value function
	 * @return (com.ibm.rave.core.selector.ValueFunction)  the value function
	 */
	radius$2 : function() {
		return this._radius;
	},

	/** @expose */ 
	endAngle : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.endAngle$2();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.endAngle$0(a0);
		}
		return this.endAngle$1(a0);
	},

	/** @expose */ 
	startAngle : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.startAngle$2();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.startAngle$0(a0);
		}
		return this.startAngle$1(a0);
	},

	/** @expose */ 
	source : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.source$2();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.source$0(a0);
		}
		return this.source$1(a0);
	},

	/** @expose */ 
	target : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.target$2();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.target$0(a0);
		}
		return this.target$1(a0);
	},

	/** @expose */ 
	radius : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.radius$2();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.radius$0(a0);
		}
		return this.radius$1(a0);
	}
});

com_ibm_rave_core_svg_Chord.SubGroup = function(r, a0, a1, p0, p1) {
	this.r = r;
	this.a0 = a0;
	this.a1 = a1;
	this.p0 = p0;
	this.p1 = p1;
};

com_ibm_rave_core_svg_Chord.SOURCE = function(data, index, groupIndex) {
	return (data).source;
};
com_ibm_rave_core_svg_Chord.TARGET = function(data, index, groupIndex) {
	return (data).target;
};
com_ibm_rave_core_svg_Chord.RAIDUS = function(data, index, groupIndex) {
	return (data).radius;
};

// $source: com/ibm/rave/core/svg/Axis
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/scales/Scales (runtime) // Scales
//@import com/ibm/rave/core/selector/Selector (runtime) // new
//@import com/ibm/rave/core/transition/Transition (runtime) // newTransition
//@import com/ibm/rave/core/scales/AbstractScale (loadtime) // scaleRange, superclass
//@import com/ibm/rave/core/internal/util/Identity (static) // create
/**
 * An axis is a visual representation of a scale. The Axis class will generate a reference line, ticks and labels automatically for a given scale (see  {@link (com.ibm.rave.core.scales.AbstractScale) AbstractScale} ).
 */
var com_ibm_rave_core_svg_Axis = rave_externs["Axis"] = com_ibm_rave_core_nativeImpl_Declare({

	//_scale : null,

	//_orient : null,

	//_tickArguments : null,

	_tickValues : null,

	//_tickFormat : null,

	//_tickHandler : null,

	_innerTickSize : 6.0,

	_outerTickSize : 6.0,

	_tickPadding : 3.0,

	_$functionClassMethod : function() {
		var _$self = function(args) {
			if (args !== null || arguments.length > 1){
				args = Array.prototype.slice.call(arguments, 0);
			}
			{
				_$self.axis(args[0]);
				return null;
			}
		};
		return _$self;
	},

	constructor : function() {
		this._scale = com_ibm_rave_core_scales_Scales.INSTANCE.linear();
		this._orient = "bottom";
		this._tickArguments = [10.0];
	},

	/** @expose */ 
	axis : function(g) {
		var self = this;
		g.each(function(data, index, groupIndex) {
			var groupSelector = new com_ibm_rave_core_selector_Selector().init(this);
			var __chart__ = this.rave_getProperty("__chart__");
			var scale0 = __chart__ != null ? __chart__ : self._scale;
			var scale1 = self._scale.copy();
			this.rave_setProperty("__chart__", scale1);
			var ticks = self._tickValues;
			if (!ticks) {
				if (scale1.ticksInRange) {
					ticks = scale1.ticksInRange();
				} else if (scale1.ticks) {
					ticks = scale1.ticks.apply(scale1.ticks, self._tickArguments);
				} else {
					ticks = scale1.domain();
				}
			}
			var tickFormat = self._tickFormat;
			if (tickFormat == null) {
				if (scale1.tickFormat) {
					tickFormat = scale1.tickFormat.apply(scale1.tickFormat, self._tickArguments);
				} else {
					tickFormat = com_ibm_rave_core_svg_Axis._identity;
				}
			}
			var tick = groupSelector.selectAll(".tick").data(ticks, scale1);
			var tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", 1.0E-6);
			var tickExit = com_ibm_rave_core_transition_Transition.newTransition(tick.exit()).style("opacity", 1.0E-6).remove();
			var tickUpdate = com_ibm_rave_core_transition_Transition.newTransition(tick.order()).style("opacity", 1);
			var tickSpacing = Math.max(self._innerTickSize, 0) + self._tickPadding;
			var tickTransformFunction;
			var range = com_ibm_rave_core_scales_AbstractScale.scaleRange(scale1);
			var path = groupSelector.selectAll(".domain").data([0.0]);
			path.enter().append("path").attr("class", "domain");
			var pathUpdate = com_ibm_rave_core_transition_Transition.newTransition(path);
			tickEnter.append("line");
			tickEnter.append("text");
			var lineEnter = tickEnter.select("line");
			var lineUpdate = tickUpdate.select("line");
			var text = tick.select("text");
			if (typeof tickFormat === "function") {
				text.text(tickFormat);
			} else {
				text.text(tickFormat);
			}
			var textEnter = tickEnter.select("text");
			var textUpdate = tickUpdate.select("text");
			var sign = "top" == self._orient || "left" == self._orient ? -1 : 1;
			var x1, x2, y1, y2;
			if ("bottom" == self._orient || "top" == self._orient) {
				tickTransformFunction = com_ibm_rave_core_svg_Axis.HORIZONTAL_TRANSFORM;
				x1 = "x";
				y1 = "y";
				x2 = "x2";
				y2 = "y2";
				text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
				pathUpdate.attr("d", "M" + range[0] + "," + (sign * self._outerTickSize) + "V" + "0" + "H" + range[1] + "V" + (sign * self._outerTickSize));
			} else {
				tickTransformFunction = com_ibm_rave_core_svg_Axis.VERTICAL_TRANSFORM;
				x1 = "y";
				y1 = "x";
				x2 = "y2";
				y2 = "x2";
				text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
				pathUpdate.attr("d", "M" + (sign * self._outerTickSize) + "," + range[0] + "H" + "0" + "V" + range[1] + "H" + (sign * self._outerTickSize));
			}
			lineEnter.attr(y2, sign * self._innerTickSize);
			textEnter.attr(y1, sign * tickSpacing);
			lineUpdate.attr(x2, 0).attr(y2, sign * self._innerTickSize);
			textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
			if (scale1.rangeBand) {
				var dx = scale1.rangeBand() / 2;
				scale0 = scale1 = new com_ibm_rave_core_svg_Axis.DeltaScale(scale1, dx);
			} else if (scale0.rangeBand) {
				scale0 = scale1;
			} else {
				tickTransformFunction(tickExit, scale1, scale0);
			}
			tickTransformFunction(tickEnter, scale0, scale1);
			tickTransformFunction(tickUpdate, scale1, scale1);
			var __tickHandler__ = this.rave_getProperty("__tickHandler__");
			this.rave_setProperty("__tickHandler__", self._tickHandler);
			if (__tickHandler__ != null && typeof __tickHandler__ === "function") {
				var tickHandler = __tickHandler__;
				tickHandler.reset(tick);
			}
			if (self._tickHandler) {
				if (tickUpdate.isTransition()) {
					(tickUpdate).tween("__axisLabelDrop__", function(data, index, groupIndex) {
						return function(t) {
							if (self._tickHandler) {
								self._tickHandler.call(this, com_ibm_rave_core_transition_Transition.newTransition(tick), self._orient);
							}
						};
					});
				} else {
					self._tickHandler.call(this, tick, self._orient);
				}
			}
		});
	},

	/**
	 * Set the scale this axis should represent.
	 * @param (com.ibm.rave.core.scales.AbstractScale) scale The scale object to assign to this axis (e.g. LinearScale, OrdinalScale).
	 * @return (com.ibm.rave.core.svg.Axis)  this Axis instance.
	 */
	scale$0 : function(scale) {
		this._scale = scale;
		return this;
	},

	/**
	 * Get the scale assigned to this axis.
	 * @return (com.ibm.rave.core.scales.AbstractScale)  Scale ValueFunction.
	 */
	scale$1 : function() {
		return this._scale;
	},

	/**
	 * Set the axis orientation. Can be one of: <ul> <li>bottom</li> <li>top</li> <li>left</li> <li>right</li> </ul>
	 * @param (String) orientation The orientation to assign to this axis.
	 * @return (com.ibm.rave.core.svg.Axis)  this Axis instance.
	 */
	orient$0 : function(orientation) {
		if ("bottom" == orientation || "top" == orientation || "left" == orientation || "right" == orientation) {
			this._orient = orientation;
		} else {
			this._orient = "bottom";
		}
		return this;
	},

	/**
	 * Get the current orientation.
	 * @return (String)  Orientation String.
	 */
	orient$1 : function() {
		return this._orient;
	},

	/**
	 * Set the tick generation arguments. These arguments will be passed along to the  {@link #this.ticks()}  method. For example, an axis with a linear scale can generate a given number of ticks (approximately) by: <pre> Axis axis = Rave.svg.axis(); axis.scale(Rave.scale.linear()); axis.ticks(20); // Generate &tilde;20 ticks. </pre>
	 * @param (java.lang.Object[]) tickArguments Argument list to control tick generation. See the {@code  ticks}  method of the respective scale assigned to this Axis (note the default scale is a  {@link (com.ibm.rave.core.scales.LinearScale) LinearScale} ).
	 * @return (com.ibm.rave.core.svg.Axis)  This Axis.
	 */
	ticks$0 : function(tickArguments) {
		if (tickArguments !== null || arguments.length > 1){
			tickArguments = Array.prototype.slice.call(arguments);
		}
		{
			this._tickArguments = tickArguments;
			return this;
		}
	},

	/**
	 * Get the currently assigned tick arguments. Default is [10].
	 * @return (java.lang.Object[])  Array of tick argument values.
	 */
	ticks$1 : function() {
		return this._tickArguments;
	},

	/**
	 * Manually specify array of tick values which will override the default tick generation behaviour. A new tick will be generated for each value in the array.
	 * @param (Array) values Array of tick values.
	 * @return (com.ibm.rave.core.svg.Axis)  This Axis.
	 */
	tickValues$0 : function(values) {
		this._tickValues = values;
		return this;
	},

	/**
	 * Get the currently assigned tick values.
	 * @return (Array)  Array of tick values, or null if none have been assigned (see {@link #this.tickValues(Array)} ).
	 */
	tickValues$1 : function() {
		return this._tickValues;
	},

	/**
	 * Specify tick label formatting.
	 * @param (Object) format
	 * @return (com.ibm.rave.core.svg.Axis)  this Axis instance.
	 */
	tickFormat$0 : function(format) {
		this._tickFormat = format;
		return this;
	},

	/**
	 * Specify tick label formatting.
	 * @param (com.ibm.rave.core.selector.ValueFunction) valueFunction "anonymous" function class, when executed, returns the formatted tick value.
	 * @return (com.ibm.rave.core.svg.Axis)  this Axis instance.
	 */
	tickFormat$1 : function(valueFunction) {
		this._tickFormat = valueFunction;
		return this;
	},

	/**
	 * Get the currently assigned tick format.
	 * @return (Object)  The tick format object, or null if a format has not been specified.
	 */
	tickFormat$2 : function() {
		return this._tickFormat;
	},

	/**
	 * Specify the size (length) of the inner and outer axis tick marks.
	 * @param (Object) size The size of the inner and outer tick marks.
	 * @return (com.ibm.rave.core.svg.Axis)  this Axis instance.
	 */
	tickSize$0 : function(size) {
		return this.tickSize$1(size, size);
	},

	/**
	 * Specify the size (length) of the axis tick marks.
	 * @param (Object) inner The size of ticks that will appear inside the bounds of the axis.
	 * @param (Object) outer The size of ticks that will appear at the ends of the axis.
	 * @return (com.ibm.rave.core.svg.Axis)  this Axis instance.
	 */
	tickSize$1 : function(inner, outer) {
		this.innerTickSize(inner);
		this.outerTickSize(outer);
		return this;
	},

	/**
	 * This method is included for backward compatibility. This is identical to calling  {@link #this.tickSize(Object, Object)}  (excluding the "extra" parameter).
	 * @param (Object) inner Inner tick size.
	 * @param (Object) extra Deprecated extra parameter.
	 * @param (Object) outer Outer tick size.
	 * @return (com.ibm.rave.core.svg.Axis)  This Axis instance.
	 */
	tickSize$2 : function(inner, extra, outer) {
		return this.tickSize$1(inner, outer);
	},

	/**
	 * Get the currently assigned <em>inner</em> tick size (in pixels). Default is 6.
	 * @return (double)  Tick size in pixels.
	 */
	tickSize$3 : function() {
		return this._innerTickSize;
	},

	/**
	 * Specify the size (length) of the inner axis tick marks.
	 * @param (Object) size The size of ticks that will appear inside the bounds of the axis.
	 * @return (com.ibm.rave.core.svg.Axis)  this Axis instance.
	 */
	innerTickSize$0 : function(size) {
		this._innerTickSize = + (size);
		return this;
	},

	/**
	 * Get the currently assigned inner tick size (in pixels). Default is 6.
	 * @return (double)  Tick size in pixels.
	 */
	innerTickSize$1 : function() {
		return this._innerTickSize;
	},

	/**
	 * Specify the size (length) of the outer axis tick marks.
	 * @param (Object) size The size of ticks that will appear at the outer bounds of the axis.
	 * @return (com.ibm.rave.core.svg.Axis)  this Axis instance.
	 */
	outerTickSize$0 : function(size) {
		this._outerTickSize = + (size);
		return this;
	},

	/**
	 * Get the currently assigned outer tick size (in pixels). Default is 6.
	 * @return (double)  Tick size in pixels.
	 */
	outerTickSize$1 : function() {
		return this._outerTickSize;
	},

	/**
	 * Specify the padding distance between tick marks and their labels.
	 * @param (Object) padding Padding value in pixels.
	 * @return (com.ibm.rave.core.svg.Axis)  this Axis instance.
	 */
	tickPadding$0 : function(padding) {
		this._tickPadding = + (padding);
		return this;
	},

	/**
	 * Get the currently assigned padding (in pixels). Default is 3.
	 * @return (double)  Padding distance in pixels.
	 */
	tickPadding$1 : function() {
		return this._tickPadding;
	},

	/**
	 * This is present in the d3 API, but is listed as deprecated and has no functionality.
	 */
	tickSubdivide$0 : function() {
		return 0;
	},

	/**
	 * This is present in the d3 API, but is listed as deprecated and has no functionality.
	 */
	tickSubdivide$1 : function(arg) {
		return this;
	},

	/**
	 * Specify a callback that will be invoked on Axis creation. On Java, this callback will receive two arguments - the axis group node and a selector containing a set of tick nodes. <p> On JavaScript, the callback will receive one argument - the selector of tick nodes. <p> Each tick node contains a line representing the tick and a text node representing the tick text. The tick nodes will be sorted in data order. <p> If the axis is currently part of a transition, the tick handler will be called for each frame of the animation.
	 * @param (com.ibm.rave.core.svg.AbstractTickHandler) callback The function to callback. Will receive two arguments - the axis group scene node and a selector containing the ticks.
	 * @return (com.ibm.rave.core.svg.Axis)  this Axis instance.
	 */
	ticksHandler$0 : function(callback) {
		this._tickHandler = callback;
		return this;
	},

	/**
	 * Specify a callback that will be invoked on Axis creation. On Java, this callback will receive two arguments - the axis group node and a selector containing a set of tick nodes. <p> On JavaScript, the callback will receive one argument - the selector of tick nodes. <p> Each tick node contains a line representing the tick and a text node representing the tick text. The tick nodes will be sorted in data order. <p> If the axis is currently part of a transition, the tick handler will be called for each frame of the animation.
	 * @param (com.ibm.rave.core.selector.RunFunction) callback The function to callback. Will receive two arguments - the axis group scene node and a selector containing the ticks.
	 * @return (com.ibm.rave.core.svg.Axis)  this Axis instance.
	 */
	ticksHandler$1 : function(callback) {
		this._tickHandler = callback;
		return this;
	},

	/**
	 * Get the currently assigned tick handler callback.
	 * @return (com.ibm.rave.core.selector.RunFunction)  the label overlap callback.
	 */
	ticksHandler$2 : function() {
		return this._tickHandler;
	},

	/** @expose */ 
	scale : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.scale$1();
		}
		return this.scale$0(a0);
	},

	/** @expose */ 
	orient : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.orient$1();
		}
		return this.orient$0(a0);
	},

	/** @expose */ 
	ticks : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.ticks$1();
		}
		return this.ticks$0.apply(this, args);
	},

	/** @expose */ 
	tickValues : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.tickValues$1();
		}
		return this.tickValues$0(a0);
	},

	/** @expose */ 
	tickFormat : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.tickFormat$2();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.tickFormat$1(a0);
		}
		return this.tickFormat$0(a0);
	},

	/** @expose */ 
	tickSize : function(a0, a1, a2) {
		var args = arguments;
		if (args.length == 0) {
			return this.tickSize$3();
		}
		if (args.length == 1) {
			return this.tickSize$0(a0);
		}
		if (args.length == 2) {
			return this.tickSize$1(a0, a1);
		}
		return this.tickSize$2(a0, a1, a2);
	},

	/** @expose */ 
	innerTickSize : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.innerTickSize$1();
		}
		return this.innerTickSize$0(a0);
	},

	/** @expose */ 
	outerTickSize : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.outerTickSize$1();
		}
		return this.outerTickSize$0(a0);
	},

	/** @expose */ 
	tickPadding : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.tickPadding$1();
		}
		return this.tickPadding$0(a0);
	},

	/** @expose */ 
	tickSubdivide : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.tickSubdivide$0();
		}
		return this.tickSubdivide$1(a0);
	},

	/** @expose */ 
	ticksHandler : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.ticksHandler$2();
		}
		if (args.length == 1 && typeof a0 === "function" && a0.length == 1) {
			return this.ticksHandler$1(a0);
		}
		return this.ticksHandler$0(a0);
	}
});

com_ibm_rave_core_svg_Axis.DeltaScale = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_scales_AbstractScale, {

	//wrappedScale : null,

	delta : 0,

	_$functionClassMethod : function() {
		var _$self = function(data, index, groupIndex) {
			return (_$self.wrappedScale.call(this, data, index, groupIndex)) + _$self.delta;
		};
		return _$self;
	},

	/** @expose */ 
	constructor : function(referencedScale, delta) {
		this.wrappedScale = referencedScale;
		this.delta = delta;
	},

	domain$0 : function(values) {
		return null;
	},

	domain$1 : function() {
		return null;
	},

	range$0 : function(values) {
		return null;
	},

	range$1 : function() {
		return null;
	},

	/** @expose */ 
	copy : function() {
		return null;
	},

	/** @expose */ 
	domain : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.domain$1();
		}
		return this.domain$0(a0);
	},

	/** @expose */ 
	range : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.range$1();
		}
		return this.range$0(a0);
	}
});

//com_ibm_rave_core_svg_Axis.BOTTOM_ORIENT = "bottom";
//com_ibm_rave_core_svg_Axis.TOP_ORIENT = "top";
//com_ibm_rave_core_svg_Axis.LEFT_ORIENT = "left";
//com_ibm_rave_core_svg_Axis.RIGHT_ORIENT = "right";
//com_ibm_rave_core_svg_Axis.PROPERTY_CHART = "__chart__";
//com_ibm_rave_core_svg_Axis.CLASS_DOMAIN = "domain";
//com_ibm_rave_core_svg_Axis.ATTR_TRANSFORM = "transform";
//com_ibm_rave_core_svg_Axis.ATTR_X = "x";
//com_ibm_rave_core_svg_Axis.ATTR_Y = "y";
//com_ibm_rave_core_svg_Axis.ATTR_X2 = "x2";
//com_ibm_rave_core_svg_Axis.ATTR_Y2 = "y2";
//com_ibm_rave_core_svg_Axis.ATTR_DY = "dy";
//com_ibm_rave_core_svg_Axis.ATTR_SVG_PATH_DATA = "d";
//com_ibm_rave_core_svg_Axis.CLASS_PROPERTY = "class";
//com_ibm_rave_core_svg_Axis.CLASS_TICK = "tick";
//com_ibm_rave_core_svg_Axis.STYLE_OPACITY = "opacity";
//com_ibm_rave_core_svg_Axis.STYLE_TEXT_ANCHOR = "text-anchor";
//com_ibm_rave_core_svg_Axis.ANCHOR_MIDDLE = "middle";
//com_ibm_rave_core_svg_Axis.ANCHOR_START = "start";
//com_ibm_rave_core_svg_Axis.ANCHOR_END = "end";
//com_ibm_rave_core_svg_Axis.DY_HORIZONTAL_TOP = "0em";
//com_ibm_rave_core_svg_Axis.DY_HORIZONTAL_BOTTOM = ".71em";
//com_ibm_rave_core_svg_Axis.DY_VERTICAL = ".32em";
//com_ibm_rave_core_svg_Axis.SVG_MOVETO = "M";
//com_ibm_rave_core_svg_Axis.SVG_VERTICAL_LINETO = "V";
//com_ibm_rave_core_svg_Axis.SVG_HORIZONTAL_LINETO = "H";
//com_ibm_rave_core_svg_Axis.SVG_PATH_SEPARATOR = ",";
//com_ibm_rave_core_svg_Axis.SVG_ZERO_COORD = "0";
//com_ibm_rave_core_svg_Axis.PROPERTY_TICK_HANDLER = "__tickHandler__";

//com_ibm_rave_core_svg_Axis.DEFAULT_ORIENT = "bottom";
//com_ibm_rave_core_svg_Axis.CLASS_DOMAIN_SELECTOR = "." + "domain";
//com_ibm_rave_core_svg_Axis.CLASS_TICK_SELECTOR = "." + "tick";
com_ibm_rave_core_svg_Axis._identity = com_ibm_rave_core_internal_util_Identity.create();
com_ibm_rave_core_svg_Axis.HORIZONTAL_TRANSFORM = function(ticks, scale, scale2) {
	ticks.attr("transform", function(data, index, groupIndex) {
		var value = (scale.call(this, data, index, groupIndex));
		if (!(isFinite(value))) {
			value = (scale2.call(this, data, index, groupIndex));
		}
		return "translate(" + value + ",0)";
	});
};
com_ibm_rave_core_svg_Axis.VERTICAL_TRANSFORM = function(ticks, scale, scale2) {
	ticks.attr("transform", function(data, index, groupIndex) {
		var value = (scale.call(this, data, index, groupIndex));
		if (!(isFinite(value))) {
			value = (scale2.call(this, data, index, groupIndex));
		}
		return "translate(0," + value + ")";
	});
};

// $source: com/ibm/rave/core/svg/Brush
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare, bind
//@import com/ibm/rave/core/internal/event/CustomDispatcher (runtime) // create
//@import com/ibm/rave/core/selector/Selector (runtime) // new
//@import com/ibm/rave/core/internal/nativeImpl/event/DragSuppress (runtime) // dragSuppress
//@import com/ibm/rave/core/nativeImpl/event/Mouse (runtime) // mousePoint
//@import com/ibm/rave/core/internal/nativeImpl/PlatformInitialization (runtime) // getWindow, getDocumentBodyElement
//@import com/ibm/rave/core/scales/AbstractScale (runtime) // scaleRange
//@import com/ibm/rave/core/transition/Transition (runtime) // newTransition
//@import com/ibm/rave/core/internal/nativeImpl/transitions/InheritedTransition (runtime) // get
//@import com/ibm/rave/core/interpolate/ArrayInterpolation (runtime) // ArrayInterpolation
//@import com/ibm/rave/core/event/BaseEvent (loadtime) // superclass
/**
 * A brush is an SVG control whereby the user can click and drag to select one- or two-dimensional regions of a given chart. As the brush control is manipulated by the user,(dragged, resized etc), it fires events so that listeners can react and redraw their chart accordingly.
 */
var com_ibm_rave_core_svg_Brush = com_ibm_rave_core_nativeImpl_Declare({

	//brushResizes : null,

	//brushCursor : null,

	//eventDispatcher : null,

	//origin : null,

	//center : null,

	//offset : null,

	//xExtent : null,

	//yExtent : null,

	//xExtentDomain : null,

	//yExtentDomain : null,

	//resizes : null,

	//xScale : null,

	//yScale : null,

	//brushstartMouseDown : null,

	//brushstartTouchStart : null,

	dragging : 0,

	xClamp : false,

	yClamp : false,

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * Draws or redraws this brush into the specified selection of elements. The brush may be drawn into multiple elements simultaneously, but note that these brushes would share the same backing extent; typically, a brush is drawn into only one element at a time. The selection can also be a transition, in which case the brush will perform an automatic transition. Use brush.event to dispatch brush events during the transition for animated brushing.
		 */
		function(args) {
			if (args !== null || arguments.length > 1){
				args = Array.prototype.slice.call(arguments, 0);
			}
			{
				_$self.brush(args[0]);
				return null;
			}
		};
		return _$self;
	},

	constructor : function() {
		this.eventDispatcher = com_ibm_rave_core_internal_event_CustomDispatcher.create$0(this, "brushstart", "brush", "brushend");
				/**
		 */
		{
			this.brushResizes = [["n", "e", "s", "w", "nw", "ne", "se", "sw"], ["e", "w"], ["n", "s"], []];
			this.brushCursor = {};
			this.brushCursor["n"] = "ns-resize";
			this.brushCursor["e"] = "ew-resize";
			this.brushCursor["s"] = "ns-resize";
			this.brushCursor["w"] = "ew-resize";
			this.brushCursor["nw"] = "nwse-resize";
			this.brushCursor["ne"] = "nesw-resize";
			this.brushCursor["se"] = "nwse-resize";
			this.brushCursor["sw"] = "nesw-resize";
			this.xScale = null;
			this.yScale = null;
			this.xExtent = [0.0, 0.0];
			this.yExtent = [0.0, 0.0];
			this.xClamp = true;
			this.yClamp = true;
			this.resizes = this.brushResizes[0];
			this.origin = [];
			var self = this;
			this.brushstartMouseDown = function(data, index, groupIndex, event) {
				self.handleBrushStartEvent(this, data, index, groupIndex, event, false);
			};
			this.brushstartTouchStart = function(data, index, groupIndex, event) {
				self.handleBrushStartEvent(this, data, index, groupIndex, event, true);
			};
		}
	},

	handleBrushStartEvent : function(context, data, index, groupIndex, event, touchEvent) {
		var self = this;
		var target = context;
		var eventTarget = new com_ibm_rave_core_selector_Selector().init(rave.event.target);
		var event_ = this.eventDispatcher.of(target, data, index, groupIndex);
		var g = new com_ibm_rave_core_selector_Selector().init(target);
		var resizing = "";
		var eventTargetDatum = eventTarget.datum();
		if ((eventTargetDatum)) {
			resizing = eventTargetDatum.toString();
		}
		var resizingX = (!(new RegExp("^(n|s)$", "g").test(resizing)) && this.xScale);
		var resizingY = (!(new RegExp("^(e|w)$", "g").test(resizing)) && this.yScale);
		this.dragging = +(eventTarget.classed("extent"));
		var dragRestore = com_ibm_rave_core_internal_nativeImpl_event_DragSuppress.dragSuppress(target);
		var originPoint = com_ibm_rave_core_nativeImpl_event_Mouse.mousePoint(target);
		this.origin[0] = originPoint[0];
		this.origin[1] = originPoint[1];
		this.offset = null;
		this.center = null;
		var keydown = function(data, index, groupIndex, event) {
			if ((rave.event).keyCode == 32) {
				if (!((self.dragging))) {
					self.center = null;
					self.origin[0] -= self.xExtent[1];
					self.origin[1] -= self.yExtent[1];
					self.dragging = 2;
				}
				rave.event.preventDefault();
			}
		};
		var keyup = function(data, index, groupIndex, event) {
			if ((rave.event).keyCode == 32 && self.dragging == 2) {
				self.origin[0] += self.xExtent[1];
				self.origin[1] += self.yExtent[1];
				self.dragging = 0;
				rave.event.preventDefault();
			}
		};
		var w = new com_ibm_rave_core_selector_Selector().init(com_ibm_rave_core_internal_nativeImpl_PlatformInitialization.getWindow(target)).on("keydown.brush", keydown).on("keyup.brush", keyup);
		var brushmove = function(data, index, groupIndex, event) {
			var p = com_ibm_rave_core_nativeImpl_event_Mouse.mousePoint(target);
			var point = [p[0], p[1]];
			var moved = false;
			if (self.offset) {
				point[0] += self.offset[0];
				point[1] += self.offset[1];
			}
			if (!((self.dragging))) {
				if ((rave.event).altKey) {
					if (!self.center) {
						self.center = [(self.xExtent[0] + self.xExtent[1]) / 2, (self.yExtent[0] + self.yExtent[1]) / 2];
					}
					self.origin[0] = self.xExtent[+(point[0] < self.center[0])];
					self.origin[1] = self.yExtent[+(point[1] < self.center[1])];
				} else {
					self.center = null;
				}
			}
			if (resizingX && self.move1(point, self.xScale, 0)) {
				self.redrawX(g);
				moved = true;
			}
			if (resizingY && self.move1(point, self.yScale, 1)) {
				self.redrawY(g);
				moved = true;
			}
			if (moved) {
				self.redraw(g);
				event_(new com_ibm_rave_core_svg_Brush.EventObject("brush", !((self.dragging)) ? "move" : "resize"));
			}
		};
		var brushend = function(data, index, groupIndex, event) {
			brushmove.call(this, data, index, groupIndex, event);
			g.style("pointer-events", "all").selectAll(".resize").style("display", self.empty() ? "none" : null);
			new com_ibm_rave_core_selector_Selector().init(com_ibm_rave_core_internal_nativeImpl_PlatformInitialization.getDocumentBodyElement()).style("cursor", null);
			w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
			dragRestore(false);
			event_(new com_ibm_rave_core_svg_Brush.EventObject("brushend", null));
		};
		if (touchEvent && (rave.event).changedTouches) {
			w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
		} else {
			w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
		}
		g.interrupt().selectAll("*").interrupt();
		if ((this.dragging)) {
			this.origin[0] = this.xExtent[0] - this.origin[0];
			this.origin[1] = this.yExtent[0] - this.origin[1];
		} else if ((resizing)) {
			var ex = +(new RegExp("w$", "g").test(resizing));
			var ey = +(new RegExp("^n", "g").test(resizing));
			this.offset = [this.xExtent[1 - ex] - this.origin[0], this.yExtent[1 - ey] - this.origin[1]];
			this.origin[0] = this.xExtent[ex];
			this.origin[1] = this.yExtent[ey];
		}
		if ((rave.event).altKey) {
			this.center = [this.origin[0], this.origin[1]];
		}
		g.style("pointer-events", "none").selectAll(".resize").style("display", null);
		new com_ibm_rave_core_selector_Selector().init(com_ibm_rave_core_internal_nativeImpl_PlatformInitialization.getDocumentBodyElement()).style("cursor", eventTarget.style("cursor"));
		event_(new com_ibm_rave_core_svg_Brush.EventObject("brushstart", null));
		brushmove.call(context, data, index, groupIndex, event);
	},

	move1 : function(point, scale, i) {
		var range = com_ibm_rave_core_scales_AbstractScale.scaleRange(scale);
		var r0 = range[0];
		var r1 = range[1];
		var position = this.origin[i];
		var extent = (i) ? this.yExtent : this.xExtent;
		var size = extent[1] - extent[0];
		var min, max;
		if ((this.dragging)) {
			r0 -= position;
			r1 -= size + position;
		}
		min = ((i) ? this.yClamp : this.xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
		if ((this.dragging)) {
			max = (min += position) + size;
		} else {
			if (this.center) {
				position = Math.max(r0, Math.min(r1, 2 * this.center[i] - min));
			}
			if (position < min) {
				max = min;
				min = position;
			} else {
				max = position;
			}
		}
		if (extent[0] != min || extent[1] != max) {
			if ((i)) {
				this.yExtentDomain = null;
			} else {
				this.xExtentDomain = null;
			}
			extent[0] = min;
			extent[1] = max;
			return true;
		}
		return false;
	},

	/**
	 * Draws or redraws this brush into the specified selection of elements. The brush may be drawn into multiple elements simultaneously, but note that these brushes would share the same backing extent; typically, a brush is drawn into only one element at a time. The selection can also be a transition, in which case the brush will perform an automatic transition. Use brush.event to dispatch brush events during the transition for animated brushing.
	 */
	/** @expose */ 
	brush : function(context) {
		var self = this;
		context.each(function(data, index, groupIndex) {
			var g = new com_ibm_rave_core_selector_Selector().init(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", self.brushstartMouseDown).on("touchstart.brush", self.brushstartTouchStart);
			var background = g.selectAll(".background").data([0.0]);
			background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
			g.selectAll(".extent").data([0.0]).enter().append("rect").attr("class", "extent").style("cursor", "move");
			var resize = g.selectAll(".resize").data(self.resizes, function(data, index, groupIndex) {
				return data;
			});
			resize.exit().remove();
			resize.enter().append("g").attr("class", function(data, index, groupIndex) {
				return "resize " + data;
			}).style("cursor", function(data, index, groupIndex) {
				return self.brushCursor[data];
			}).append("rect").attr("x", function(data, index, groupIndex) {
				return new RegExp("[ew]$", "g").test(data.toString()) ? -3 : null;
			}).attr("y", function(data, index, groupIndex) {
				return new RegExp("^[ns]", "g").test(data.toString()) ? -3 : null;
			}).attr("width", 6).attr("height", 6).style("visibility", "hidden");
			resize.style("display", self.empty() ? "none" : null);
			var gUpdate = com_ibm_rave_core_transition_Transition.newTransition(g);
			var backgroundUpdate = com_ibm_rave_core_transition_Transition.newTransition(background);
			var range;
			if (self.xScale) {
				range = com_ibm_rave_core_scales_AbstractScale.scaleRange(self.xScale);
				backgroundUpdate.attr("x", range[0]).attr("width", (range[1] - (range[0])));
				self.redrawX(gUpdate);
			}
			if (self.yScale) {
				range = com_ibm_rave_core_scales_AbstractScale.scaleRange(self.yScale);
				backgroundUpdate.attr("y", range[0]).attr("height", (range[1]) - (range[0]));
				self.redrawY(gUpdate);
			}
			self.redraw(gUpdate);
		});
	},

	/**
	 * Returns true if and only if the brush extent is empty. When a brush is created, it is initially empty; the brush may also become empty with a single click on the background without moving, or if the extent is cleared. A brush is considered empty if it has zero-width or zero-height. When the brush is empty, its extent is not strictly defined.
	 * @return (boolean)  true if the brush is empty, false otherwise
	 */
	/** @expose */ 
	empty : function() {
		var xDim = false;
		var yDim = false;
		if (this.xScale) {
			xDim = this.xExtent[0] == this.xExtent[1];
		}
		if (this.yScale) {
			yDim = this.yExtent[0] == this.yExtent[1];
		}
		return xDim || yDim;
	},

	/**
	 * Clears the extent, making the brush extent empty.
	 * @return (com.ibm.rave.core.svg.Brush)  this brush instance itself
	 */
	/** @expose */ 
	clear : function() {
		if (!(this.empty())) {
			this.xExtent = [0.0, 0.0];
			this.yExtent = [0.0, 0.0];
			this.xExtentDomain = this.yExtentDomain = null;
		}
		return this;
	},

	/**
	 * Gets the listener for the specified event type supported by brush: brushstart, brush,brushend
	 * @param (String) type the type of event to get the listener for
	 * @return (com.ibm.rave.core.selector.RunFunction)  the listener for the specified event or null if none was registered
	 */
	on$0 : function(type) {
		return this.eventDispatcher.on$0(type);
	},

	/**
	 * Sets a listener for the specified event type supported by brush: brushstart, brush,brushend
	 * @param (String) type the type of the brush event to listener for
	 * @param (com.ibm.rave.core.selector.RunFunction) listener the listener
	 * @return (com.ibm.rave.core.svg.Brush)  this brush instance itself
	 */
	on$1 : function(type, listener) {
		this.eventDispatcher.on$1(type, listener);
		return this;
	},

	/**
	 * Triggers brush events based on the type of the selection passed: if the selection passed is a selector, it dispatches a brush gesture to registered listeners as a three event sequence: brushstart, brush and brushend. This can be useful in triggering listeners after setting the brush extent programatically. If selection passed is a transition, registers the appropriate tweens so that the brush dispatches events over the course of the transition: a brushstart event when the transition starts from the previously-set extent, brush events for each tick of the transition, and finally a brushend event when the transition ends. Note that the transition will be interrupted if the user starts brushing before the transition ends.
	 * @param (com.ibm.rave.core.selector.Selection) g the selection to trigger events for
	 */
	/** @expose */ 
	event : com_ibm_rave_core_nativeImpl_Declare.bind(function(g) {
		var self = this;
		g.each(function(data, index, groupIndex) {
			var event_ = self.eventDispatcher.of(this, data, index, groupIndex);
			var brushExtent = this.rave_getProperty("__chart__");
			var extent1 = new com_ibm_rave_core_svg_Brush.BrushExtent(self.xExtent, self.yExtent, self.xExtentDomain, self.yExtentDomain);
			var extent0 = (!brushExtent) ? extent1 : brushExtent;
			this.rave_setProperty("__chart__", extent1);
			if (com_ibm_rave_core_internal_nativeImpl_transitions_InheritedTransition.get()) {
				new com_ibm_rave_core_selector_Selector().init(this).transition().each("start.brush", function(args) {
					if (args !== null || arguments.length > 1){
						args = Array.prototype.slice.call(arguments, 0);
					}
					{
						self.xExtentDomain = extent0.i;
						self.yExtentDomain = extent0.j;
						self.xExtent = extent0.x;
						self.yExtent = extent0.y;
						event_(new com_ibm_rave_core_svg_Brush.EventObject("brushstart", null));
						return null;
					}
				}).tween("brush:brush", function(data, index, groupIndex) {
					var xi = com_ibm_rave_core_interpolate_ArrayInterpolation.INSTANCE(self.xExtent, extent1.x);
					var yi = com_ibm_rave_core_interpolate_ArrayInterpolation.INSTANCE(self.yExtent, extent1.y);
					self.xExtentDomain = self.yExtentDomain = null;
					return function(t) {
						self.xExtent = extent1.x = (xi(t));
						self.yExtent = extent1.y = (yi(t));
						event_(new com_ibm_rave_core_svg_Brush.EventObject("brush", "resize"));
					};
				}).each("end.brush", function(args) {
					if (args !== null || arguments.length > 1){
						args = Array.prototype.slice.call(arguments, 0);
					}
					{
						self.xExtentDomain = extent1.i;
						self.yExtentDomain = extent1.j;
						event_(new com_ibm_rave_core_svg_Brush.EventObject("brush", "resize"));
						event_(new com_ibm_rave_core_svg_Brush.EventObject("brushend", null));
						return null;
					}
				});
			} else {
				event_(new com_ibm_rave_core_svg_Brush.EventObject("brushstart", null));
				event_(new com_ibm_rave_core_svg_Brush.EventObject("brush", "resize"));
				event_(new com_ibm_rave_core_svg_Brush.EventObject("brushend", null));
			}
		});
	}),

	redraw : function(g) {
		var self = this;
		g.selectAll(".resize").attr("transform", function(data, index, groupIndex) {
			return "translate(" + self.xExtent[+(new RegExp("e$", "g").test(data.toString()))] + "," + self.yExtent[+(new RegExp("^s", "g").test(data.toString()))] + ")";
		});
	},

	redrawX : function(g) {
		g.select(".extent").attr("x", this.xExtent[0]);
		g.selectAll(".extent,.n>rect,.s>rect").attr("width", this.xExtent[1] - this.xExtent[0]);
	},

	redrawY : function(g) {
		g.select(".extent").attr("y", this.yExtent[0]);
		g.selectAll(".extent,.e>rect,.w>rect").attr("height", this.yExtent[1] - this.yExtent[0]);
	},

	/**
	 * Gets the current x-scale associated with the brush. Default is null
	 * @return (com.ibm.rave.core.scales.AbstractScale)  the current x-scale associated with the brush.
	 */
	x$0 : function() {
		return this.xScale;
	},

	/**
	 * Sets the x-scale for the brush. The scale is typically defined as a quantitative scale, in which case the extent is in data space from the scale's domain; however, it may instead be defined as an ordinal scale, where the extent is in pixel space from the scale's range extent.
	 * @param (com.ibm.rave.core.scales.AbstractScale) z the scale to set
	 * @return (com.ibm.rave.core.svg.Brush)  this brush instance itself
	 */
	x$1 : function(z) {
		this.xScale = z;
		this.resizes = this.brushResizes[+(!((this.xScale))) << 1 | +(!((this.yScale)))];
		return this;
	},

	/**
	 * Gets the current y-scale associated with the brush. Default is null
	 * @return (com.ibm.rave.core.scales.AbstractScale)  the current y-scale associated with the brush.
	 */
	y$0 : function() {
		return this.yScale;
	},

	/**
	 * Sets the y-scale for the brush. The scale is typically defined as a quantitative scale, in which case the extent is in data space from the scale's domain; however, it may instead be defined as an ordinal scale, where the extent is in pixel space from the scale's range extent.
	 * @param (com.ibm.rave.core.scales.AbstractScale) z the scale to set
	 * @return (com.ibm.rave.core.svg.Brush)  this brush instance itself
	 */
	y$1 : function(z) {
		this.yScale = z;
		this.resizes = this.brushResizes[+(!((this.xScale))) << 1 | +(!((this.yScale)))];
		return this;
	},

	/**
	 * Gets the current clamping behavior of the brush. The clamping behavior definition depends on the associated scales. If both an x- and y-scale are available, then the clamping behavior is a list [ x, y ], where x and y are booleans that determine whether the each dimension of the two-dimensional extent should be clamped to its respective x- and y-scale. If only one of the x-scale and y-scale are available, then the clamping behavior is a Boolean referring to whether the one-dimensional extent should be clamped to that scale. If neither scale is available, then the clamping behavior is null.
	 * @return (Object)  the current clamping behavior
	 */
	clamp$0 : function() {
		return (this.xScale) && (this.yScale) ? [this.xClamp, this.yClamp] : (this.xScale) ? this.xClamp : (this.yScale) ? this.yClamp : null;
	},

	/**
	 * Sets the current clamping behavior of the brush. The clamping behavior definition depends on the associated scales. If both an x- and y-scale are available, then passed the clamping value is expected to be a list [ x, y ], where x and y are booleans that determine whether the each dimension of the two-dimensional extent should be clamped to its respective x- and y-scale. If only one of the x-scale and y-scale are available, then the passed clamping value is a Boolean referring to whether the one-dimensional extent should be clamped to that scale.
	 * @return (com.ibm.rave.core.svg.Brush)  this brush instance itself
	 */
	clamp$1 : function(z) {
		if ((this.xScale) && (this.yScale)) {
			this.xClamp = (z)[0];
			this.yClamp = (z)[1];
		} else if ((this.xScale)) {
			this.xClamp = (z);
		} else if ((this.yScale)) {
			this.yClamp = (z);
		}
		return this;
	},

	/**
	 * Gets the current brush extent. The definition of the extent depends on the associated scales. If both an x- and y-scale are available, then the extent is a list of two lists [‍​[x0, y0], [x1, y1]​], where x0 and y0 are the lower bounds of the extent, and x1 and y1 are the upper bounds of the extent. If only the x-scale is available, then the extent is defined as the list [x0, x1]; likewise, if only the y-scale is available, then the extent is [y0, y1]. If neither scale is available, then the extent is null.
	 * @return (Array)  the current extent
	 */
	extent$0 : function() {
		var x0, x1, y0, y1, t;
		x0 = x1 = y0 = y1 = t = 0;
		if ((this.xScale)) {
			if ((this.xExtentDomain)) {
				x0 = this.xExtentDomain[0];
				x1 = this.xExtentDomain[1];
			} else {
				x0 = this.xExtent[0];
				x1 = this.xExtent[1];
				if (this.xScale.invert) {
					x0 = this.xScale.invert(x0);
					x1 = this.xScale.invert(x1);
				}
				if (x1 < x0) {
					t = x0;
					x0 = x1;
					x1 = t;
				}
			}
		}
		if ((this.yScale)) {
			if ((this.yExtentDomain)) {
				y0 = this.yExtentDomain[0];
				y1 = this.yExtentDomain[1];
			} else {
				y0 = this.yExtent[0];
				y1 = this.yExtent[1];
				if (this.yScale.invert) {
					y0 = this.yScale.invert(y0);
					y1 = this.yScale.invert(y1);
				}
				if (y1 < y0) {
					t = y0;
					y0 = y1;
					y1 = t;
				}
			}
		}
		return (this.xScale) && (this.yScale) ? [[x0, y0], [x1, y1]] : (this.xScale) ? [x0, x1] : (this.yScale) ? [y0, y1] : null;
	},

	/**
	 * Sets the current brush extent and returns the brush. The definition of the extent depends on the associated scales. If both an x- and y-scale are available, then the extent passed is expected to be a list of two lists [‍​[x0, y0], [x1, y1]​], where x0 and y0 are the lower bounds of the extent, and x1 and y1 are the upper bounds of the extent. If only the x-scale is available, then the extent passed is expected to be list [x0, x1]; likewise, if only the y-scale is available, then the extent is [y0, y1] When the extent is set to values, the resulting extent is preserved exactly. However, as soon as the brush is moved by the user (on mousemove following a mousedown), then the extent will be recomputed by calling scale.invert. Note that, in this case, the values may be slightly imprecise due to the limited precision of pixels. Note that setting the extent does not automatically redraw the brush or dispatch any events to listeners. To redraw the brush, call run on a selection or transition; to cause the brush to dispatch events to listeners, use brush.event.
	 * @param (Array) z the value of the extent to set
	 * @return (com.ibm.rave.core.svg.Brush)  this brush instance itself
	 */
	extent$1 : function(z) {
		var x0, x1, y0, y1, t;
		x0 = x1 = y0 = y1 = t = 0;
		if ((this.xScale)) {
			var xObj0 = z[0];
			var xObj1 = z[1];
			if ((this.yScale)) {
				x0 = (xObj0)[0];
				x1 = (xObj1)[0];
			} else {
				x0 = xObj0;
				x1 = xObj1;
			}
			this.xExtentDomain = [x0, x1];
			if (this.xScale.invert) {
				x0 = this.xScale.call(this.xScale, x0, -1, -1);
				x1 = this.xScale.call(this.xScale, x1, -1, -1);
			}
			if (x1 < x0) {
				t = x0;
				x0 = x1;
				x1 = t;
			}
			if (x0 != this.xExtent[0] || x1 != this.xExtent[1]) {
				this.xExtent = [x0, x1];
			}
		}
		if ((this.yScale)) {
			var yObj0 = z[0];
			var yObj1 = z[1];
			if ((this.xScale)) {
				y0 = (yObj0)[1];
				y1 = (yObj1)[1];
			} else {
				y0 = yObj0;
				y1 = yObj1;
			}
			this.yExtentDomain = [y0, y1];
			if (this.yScale.invert) {
				y0 = this.yScale.call(this.yScale, y0, -1, -1);
				y1 = this.yScale.call(this.yScale, y1, -1, -1);
			}
			if (y1 < y0) {
				t = y0;
				y0 = y1;
				y1 = t;
			}
			if (y0 != this.yExtent[0] || y1 != this.yExtent[1]) {
				this.yExtent = [y0, y1];
			}
		}
		return this;
	},

	/** @expose */ 
	on : function(a0, a1) {
		var args = arguments;
		if (args.length == 1) {
			return this.on$0(a0);
		}
		return this.on$1(a0, a1);
	},

	/** @expose */ 
	x : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.x$0();
		}
		return this.x$1(a0);
	},

	/** @expose */ 
	y : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.y$0();
		}
		return this.y$1(a0);
	},

	/** @expose */ 
	clamp : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.clamp$0();
		}
		return this.clamp$1(a0);
	},

	/** @expose */ 
	extent : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.extent$0();
		}
		return this.extent$1(a0);
	}
});

/**
 * Creates a new brush with no default x- and y-scale, and an empty extent
 * @return (com.ibm.rave.core.svg.Brush)  the newly constructed brush
 */
/** @expose */ 
com_ibm_rave_core_svg_Brush.newBrush = function() {
	return new com_ibm_rave_core_svg_Brush();
};

/**
 * The event object fired by the brush control. There are three types of events: brushstart - on mousedown brush - on mousemove, if the brush extent has changed brushend - on mouseup Furthermore, only event of type brush will have a mode, which could be one of two types: move, or resize, for other types, the mode would be null
 */
com_ibm_rave_core_svg_Brush.EventObject = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_event_BaseEvent, {

	//mode : null,

	constructor : function(type, mode) {
		this.mode = mode;
	},

	/**
	 * The mode value of the event in case the event was of type brush. brushstart and brushend have no mode and will return null
	 * @return (String)  the value of mode of the event
	 */
	/** @expose */ 
	getMode : function() {
		return this.mode;
	}
});

com_ibm_rave_core_svg_Brush.BrushExtent = function(x, y, i, j) {
	this.x = x;
	this.y = y;
	this.i = i;
	this.j = j;
};

//com_ibm_rave_core_svg_Brush.CHART_PROP = "__chart__";


// $source: com/ibm/rave/core/internal/geo/MercatorPlaneProjectionFactory
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare anonymous, declare
//@import com/ibm/rave/core/geo/InvertiblePointProjector (runtime)
//@import com/ibm/rave/core/internal/geo/MercatorProjection (runtime) // new
//@import com/ibm/rave/core/internal/geo/ProjectionMutatorImpl (runtime) // internalMutate
/**
 */
var com_ibm_rave_core_internal_geo_MercatorPlaneProjectionFactory = com_ibm_rave_core_nativeImpl_Declare({

	/**
	 * @expose  
	 */
	raw : null,

	_$functionClassMethod : function() {
		var _$self = function() {
			var m = new com_ibm_rave_core_internal_geo_MercatorProjection();
			com_ibm_rave_core_internal_geo_ProjectionMutatorImpl.internalMutate(m, _$self.raw);
			m.init();
			return m;
		};
		return _$self;
	},

	constructor : function() {
		this.raw = new (com_ibm_rave_core_nativeImpl_Declare({

			_$functionClassMethod : function() {
				var _$self = function(λ, φ) {
					return [λ, Math.log(Math.tan(3.141592653589793 / 4 + φ / 2))];
				};
				return _$self;
			},

			supportInversion : function() {
				return true;
			},

			invert : function(x, y) {
				return [x, 2 * Math.atan(Math.exp(y)) - 1.5707963267948966];
			}

		}))();
	},

	/** @expose */ 
	getRaw : function() {
		return this.raw;
	}

	/**
	 */
	//constructor : function() {}
});

com_ibm_rave_core_internal_geo_MercatorPlaneProjectionFactory.INSTANCE = new com_ibm_rave_core_internal_geo_MercatorPlaneProjectionFactory();

// $source: com/ibm/rave/core/internal/geo/ResampleStreamListenerFactory
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/geo/TransformStreamListenerImpl (runtime) // new
//@import com/ibm/rave/core/internal/geo/ResampleStreamListener (runtime) // new
/**
 * A factory from creating resampling stream listeners.
 */
var com_ibm_rave_core_internal_geo_ResampleStreamListenerFactory = com_ibm_rave_core_nativeImpl_Declare({

	//pointProjector : null,

	cosMinDistance : 0,

	δ2 : 0,

	maxDepth : 0,

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * Wraps the specified stream listener with another that would apply resampling transform to any GeoJSON geometry before streaming it to the wrapped listener. 
		 * @param (com.ibm.rave.core.geo.StreamListener) listener the listener to wrap
		 * @return (com.ibm.rave.core.geo.StreamListener)  a wrapped stream listener that applies resampling transform to any input GeoJSON geometry 
		 */
		function(listener) {
			var self = _$self;
			if (_$self.maxDepth == 0) {
				var delegates = {};
				delegates["point"] = function(x, y, z) {
					var res = self.pointProjector(x, y, z);
					listener.point(res[0], res[1], NaN);
				};
				return new com_ibm_rave_core_internal_geo_TransformStreamListenerImpl(listener, delegates);
			}
			return new com_ibm_rave_core_internal_geo_ResampleStreamListener(_$self, listener);
		};
		return _$self;
	},

	constructor : function(projector) {
		this.δ2 = 0.5;
		this.pointProjector = projector;
		this.maxDepth = 16;
		this.cosMinDistance = Math.cos(30 * 0.017453292519943295);
	},

	/**
	 * Sets the value of the precision to use.
	 * @param (double) p the precision value to set
	 * @return (com.ibm.rave.core.internal.geo.ResampleStreamListenerFactory)  this ResampleStreamListenerFactory object itself
	 */
	precision$0 : function(p) {
		this.δ2 = p * p;
		if (this.δ2 > 0) {
			this.maxDepth = 16;
		} else {
			this.maxDepth = 0;
		}
		return this;
	},

	/**
	 * Returns the current precision value. The default is the square root of 0.5, which is almost 0.7
	 * @return (double)  the current precision value
	 */
	precision$1 : function() {
		return Math.sqrt(this.δ2);
	},

	getCosMinDistance : function() {
		return this.cosMinDistance;
	},

	getPrecisionSquared : function() {
		return this.δ2;
	},

	getMaxDepth : function() {
		return this.maxDepth;
	},

	getPointProjector : function() {
		return this.pointProjector;
	},

	precision : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.precision$1();
		}
		return this.precision$0(a0);
	}
});


// $source: com/ibm/rave/core/internal/geo/DelegatingStreamListener
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
/**
 * A helper class that provides basic delegation support for stream listeners. Clients can supply their own  handlers ( {@link (com.ibm.rave.core.internal.geo.DelegatingStreamListener.StreamStateHandler) StreamStateHandler}  or @link  {@link (com.ibm.rave.core.internal.geo.DelegatingStreamListener.StreamPointStateHandler) StreamPointStateHandler} ) for the various GeoJSOn streaming events/states and the DelegatingStreamListener listener will forward these events to the appropriate moreover, clients can change those handler based on the current stream state (e.g., in response to polygonStart event,  they might elect to change the handler for point event up until polugonEnd event) If the client is not interested in handling some event, then they can simply set the corresponding delegate to null.    
 * @see (com.ibm.rave.core.geo.StreamListener) StreamListener
 */
var com_ibm_rave_core_internal_geo_DelegatingStreamListener = com_ibm_rave_core_nativeImpl_Declare({

	//pointDelegate : null,

	//sphereDelegate : null,

	//lineStartDelegate : null,

	//lineEndDelegate : null,

	//polygonStartDelegate : null,

	//polygonEndDelegate : null,

	/**
	 * @expose  
	 */
	valid : false,

	/**
	 * @return (com.ibm.rave.core.internal.geo.DelegatingStreamListener.StreamPointStateHandler)  the pointDelegate
	 */
	getPointDelegate : function() {
		return this.pointDelegate;
	},

	/**
	 * @param (com.ibm.rave.core.internal.geo.DelegatingStreamListener.StreamPointStateHandler) pointDelegate  the pointDelegate to set
	 */
	setPointDelegate : function(pointDelegate) {
		this.pointDelegate = pointDelegate;
	},

	/**
	 * @return (com.ibm.rave.core.internal.geo.DelegatingStreamListener.StreamStateHandler)  the sphereDelegate
	 */
	getSphereDelegate : function() {
		return this.sphereDelegate;
	},

	/**
	 * @param (com.ibm.rave.core.internal.geo.DelegatingStreamListener.StreamStateHandler) sphereDelegate  the sphereDelegate to set
	 */
	setSphereDelegate : function(sphereDelegate) {
		this.sphereDelegate = sphereDelegate;
	},

	/**
	 * @return (com.ibm.rave.core.internal.geo.DelegatingStreamListener.StreamStateHandler)  the lineStartDelegate
	 */
	getLineStartDelegate : function() {
		return this.lineStartDelegate;
	},

	/**
	 * @param (com.ibm.rave.core.internal.geo.DelegatingStreamListener.StreamStateHandler) lineStartDelegate  the lineStartDelegate to set
	 */
	setLineStartDelegate : function(lineStartDelegate) {
		this.lineStartDelegate = lineStartDelegate;
	},

	/**
	 * @return (com.ibm.rave.core.internal.geo.DelegatingStreamListener.StreamStateHandler)  the lineEndDelegate
	 */
	getLineEndDelegate : function() {
		return this.lineEndDelegate;
	},

	/**
	 * @param (com.ibm.rave.core.internal.geo.DelegatingStreamListener.StreamStateHandler) lineEndDelegate  the lineEndDelegate to set
	 */
	setLineEndDelegate : function(lineEndDelegate) {
		this.lineEndDelegate = lineEndDelegate;
	},

	/**
	 * @return (com.ibm.rave.core.internal.geo.DelegatingStreamListener.StreamStateHandler)  the polygonStartDelegate
	 */
	getPolygonStartDelegate : function() {
		return this.polygonStartDelegate;
	},

	/**
	 * @param (com.ibm.rave.core.internal.geo.DelegatingStreamListener.StreamStateHandler) polygonStartDelegate  the polygonStartDelegate to set
	 */
	setPolygonStartDelegate : function(polygonStartDelegate) {
		this.polygonStartDelegate = polygonStartDelegate;
	},

	/**
	 * @return (com.ibm.rave.core.internal.geo.DelegatingStreamListener.StreamStateHandler)  the polygonEndDelegate
	 */
	getPolygonEndDelegate : function() {
		return this.polygonEndDelegate;
	},

	/**
	 * @param (com.ibm.rave.core.internal.geo.DelegatingStreamListener.StreamStateHandler) polygonEndDelegate  the polygonEndDelegate to set
	 */
	setPolygonEndDelegate : function(polygonEndDelegate) {
		this.polygonEndDelegate = polygonEndDelegate;
	},

	/** @expose */ 
	sphere : function() {
		if (this.sphereDelegate) {
			this.sphereDelegate();
		}
	},

	/** @expose */ 
	point : function(x, y, z) {
		if (this.pointDelegate) {
			this.pointDelegate(x, y, z);
		}
	},

	/** @expose */ 
	lineStart : function() {
		if (this.lineStartDelegate) {
			this.lineStartDelegate();
		}
	},

	/** @expose */ 
	lineEnd : function() {
		if (this.lineEndDelegate) {
			this.lineEndDelegate();
		}
	},

	/** @expose */ 
	polygonStart : function() {
		if (this.polygonStartDelegate) {
			this.polygonStartDelegate();
		}
	},

	/** @expose */ 
	polygonEnd : function() {
		if (this.polygonEndDelegate) {
			this.polygonEndDelegate();
		}
	},

	/**
	 * Set the value of validity of caching and reusing this listener. This could happen when one component creates and initializes the listener, but another uses it in which case the client must make sure that the listener is still cacheable and is still valid for reuse. This validity flag is should be checked only when listeners are cached and are about to be reused again. On creation, the listener is valid and this flag's value should not be used.  However, if the user of this listener decides to keep the listener around, it should check  if the listener is valid before using it again, else, the user should ask the creator component to make another up to date listener. In other words, this is a simplistic way to control caching of this listener.
	 * @param (boolean) valid the value of validity of this listener
	 */
	setValid : function(valid) {
		this.valid = valid;
	},

	/**
	 * A getter for the validity of the listener
	 * @return (boolean)  boolean representing the validity of the listener
	 */
	isValid : function() {
		return this.valid;
	}
});

/**
 * A tagging interface that is the base of all state handlers
 */
com_ibm_rave_core_internal_geo_DelegatingStreamListener.BaseStreamStateHandler = com_ibm_rave_core_nativeImpl_Declare.implement(


);


// $source: com/ibm/rave/core/geo/TransformStreamListener
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/geo/DelegatingStreamListener (loadtime) // superclass
/**
 * An interface to be implemented by all transform stream listeners
 */
var com_ibm_rave_core_geo_TransformStreamListener = rave_externs["TransformStreamListener"] = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_internal_geo_DelegatingStreamListener, {

	/**
	 * A getter for the wrapped stream listener
	 * @return (com.ibm.rave.core.geo.StreamListener)  the wrapped stream listener
	 */
	/** @expose */ 
	getStreamListener : function() {}
});


// $source: com/ibm/rave/core/internal/geo/TransformStreamListenerImpl
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/geo/TransformStreamListener (loadtime) // superclass
//@import com/ibm/rave/core/geo/StreamListener (runtime) // polygonStartHandler
/**
 * A GeoJSOn stream listener that is used to wrap another listener, and also accept a group of  state stream state handlers. If a state stream handler for a specific stream event is available, then it will be invoked in response to stream events, otherwise, the wrapped listener will be invoked instead. This allows the handlers to perform some transformation on geometry input (if required) and optionally forwarding it to the wrapped listener.
 * @see this.Geo#this.transform(Object)
 * @see (com.ibm.rave.core.geo.TransformStreamListenerFactory) TransformStreamListenerFactory
 */
var com_ibm_rave_core_internal_geo_TransformStreamListenerImpl = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_geo_TransformStreamListener, {

	//listener : null,

	constructor : function(listener, delegates) {
		this.listener = listener;
		var self = this;
		var handler = delegates["lineEnd"];
		if (handler) {
			this.lineEndDelegate = handler;
		} else {
			this.lineEndDelegate = function() {
				self.listener.lineEnd();
			};
		}
		handler = delegates["lineStart"];
		if (handler) {
			this.lineStartDelegate = handler;
		} else {
			this.lineStartDelegate = function() {
				self.listener.lineStart();
			};
		}
		handler = delegates["point"];
		if (handler) {
			this.pointDelegate = handler;
		} else {
			this.pointDelegate = function(x, y, z) {
				self.listener.point(x, y, z);
			};
		}
		handler = delegates["polygonEnd"];
		if (handler) {
			this.polygonEndDelegate = handler;
		} else {
			this.polygonEndDelegate = function() {
				self.listener.polygonEnd();
			};
		}
		handler = delegates[com_ibm_rave_core_geo_StreamListener.polygonStartHandler];
		if (handler) {
			this.polygonStartDelegate = handler;
		} else {
			this.polygonStartDelegate = function() {
				self.listener.polygonStart();
			};
		}
		handler = delegates["sphere"];
		if (handler) {
			this.sphereDelegate = handler;
		} else {
			this.sphereDelegate = function() {
				self.listener.sphere();
			};
		}
	},

	/**
	 * A getter for the wrapped stream listener
	 * @return (com.ibm.rave.core.geo.StreamListener)  the wrapped stream listener
	 */
	/** @expose */ 
	getStreamListener : function() {
		return this.listener;
	}
});


// $source: com/ibm/rave/core/geo/StreamListener
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
/**
 * An interface to be implemented by clients wishing to stream GeoJSON objects. Listeners are inherently stateful; the meaning of a point depends on whether the point is inside of a line,  and likewise a line is distinguished from a ring by a polygon
 */
var com_ibm_rave_core_geo_StreamListener = rave_externs["StreamListener"] = com_ibm_rave_core_nativeImpl_Declare.implement(

	/**
	 * Indicates the sphere (the globe; the unit sphere centered at {0,0,0}.
	 */
	//sphere : function() {},

	/**
	 * Indicates a point with the specified coordinates x and y and optionally z.  The coordinate system is unspecified and implementation-dependent; for example, projection streams require spherical coordinates in degrees as input.  Outside the context of a polygon or line, a point indicates a point geometry object (Point or MultiPoint).  Within a line or polygon ring, the point indicates a control point.
	 * @param (double) x the value of x coordinate
	 * @param (double) y the value of y coordinate
	 * @param (double) z the value of the z coordinate; if there is no z value specified in the GeoJSON file, then NaN will be passed.
	 */
	//point : function(x, y, z) {},

	/**
	 * Indicates the start of a line or ring. Within a polygon, indicates the start of a ring.  The first ring of a polygon is the exterior ring, and is typically clockwise.  Any subsequent rings indicate holes in the polygon, and are typically counterclockwise.
	 */
	//lineStart : function() {},

	/**
	 * Indicates the end of a line or ring. Within a polygon, indicates the end of a ring.  Unlike GeoJSON, the redundant closing coordinate of a ring is not indicated via point,  and instead is implied via lineEnd within a polygon.
	 */
	//lineEnd : function() {},

	/**
	 * Indicates the start of a polygon.  The first line of a polygon indicates the exterior ring, and any subsequent lines indicate interior holes.
	 */
	//polygonStart : function() {},

	/**
	 * Indicates the end of a polygon.
	 */
	//polygonEnd : function() {}
);

/** @expose */ 
com_ibm_rave_core_geo_StreamListener.pointHandler = "point";
/** @expose */ 
com_ibm_rave_core_geo_StreamListener.sphereHandler = "sphere";
/** @expose */ 
com_ibm_rave_core_geo_StreamListener.lineStartHandler = "lineStart";
/** @expose */ 
com_ibm_rave_core_geo_StreamListener.lineEndHandler = "lineEnd";
/** @expose */ 
com_ibm_rave_core_geo_StreamListener.polygonStartHandler = "polygonStart";
/** @expose */ 
com_ibm_rave_core_geo_StreamListener.polygonEndHandler = "polygonEnd";


// $source: com/ibm/rave/core/internal/geo/ResampleStreamListener
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/geo/DelegatingStreamListener (loadtime) // superclass
//@import com/ibm/rave/core/internal/geo/CartesianUtil (runtime) // cartesian
/**
 */
var com_ibm_rave_core_internal_geo_ResampleStreamListener = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_internal_geo_DelegatingStreamListener, {

	//factory : null,

	//listener : null,

	λ00 : 0, φ00 : 0, x00 : 0, y00 : 0, a00 : 0, b00 : 0, c00 : 0, λ0 : 0, x0 : 0, y0 : 0, a0 : 0, b0 : 0, c0 : 0,

	/**
	 */
	constructor : function(factory, listener) {
		this.factory = factory;
		this.listener = listener;
		var self = this;
		var point = function(x, y, z) {
			var res = self.factory.pointProjector(x, y, z);
			self.listener.point(res[0], res[1], NaN);
		};
		var linePoint = function(λ, φ, z) {
			var c = com_ibm_rave_core_internal_geo_CartesianUtil.cartesian([λ, φ]), p = self.factory.pointProjector(λ, φ, NaN);
			self.resampleLineTo(self.x0, self.y0, self.λ0, self.a0, self.b0, self.c0, self.x0 = p[0], self.y0 = p[1], self.λ0 = λ, self.a0 = c[0], self.b0 = c[1], self.c0 = c[2], self.factory.maxDepth, self.listener);
			self.listener.point(self.x0, self.y0, z);
		};
		var lineStart = function() {
			self.x0 = NaN;
			self.pointDelegate = linePoint;
			self.listener.lineStart();
		};
		var lineEnd = function() {
			self.pointDelegate = point;
			self.listener.lineEnd();
		};
		var ringPoint = function(λ, φ, z) {
			linePoint(self.λ00 = λ, self.φ00 = φ, z);
			self.x00 = self.x0;
			self.y00 = self.y0;
			self.a00 = self.a0;
			self.b00 = self.b0;
			self.c00 = self.c0;
			self.pointDelegate = linePoint;
		};
		var ringEnd = function() {
			self.resampleLineTo(self.x0, self.y0, self.λ0, self.a0, self.b0, self.c0, self.x00, self.y00, self.λ00, self.a00, self.b00, self.c00, self.factory.maxDepth, self.listener);
			self.lineEndDelegate = lineEnd;
			lineEnd();
		};
		var ringStart = function() {
			lineStart();
			self.pointDelegate = ringPoint;
			self.lineEndDelegate = ringEnd;
		};
		var polygonStart = function() {
			self.listener.polygonStart();
			self.lineStartDelegate = ringStart;
		};
		var polygonEnd = function() {
			self.listener.polygonEnd();
			self.lineStartDelegate = lineStart;
		};
		this.pointDelegate = point;
		this.lineStartDelegate = lineStart;
		this.lineEndDelegate = lineEnd;
		this.polygonStartDelegate = polygonStart;
		this.polygonEndDelegate = polygonEnd;
	},

	resampleLineTo : function(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, listener) {
		var _depth = depth;
		var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
		if (d2 > 4 * this.factory.δ2 && _depth-- > 0) {
			var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c);
			var φ2 = Math.asin(c /= m), λ2 = Math.abs(Math.abs(c) - 1) < 1.0E-6 || Math.abs(λ0 - λ1) < 1.0E-6 ? (λ0 + λ1) / 2 : Math.atan2(b, a);
			var p = this.factory.pointProjector(λ2, φ2, NaN);
			var x2 = p[0];
			var y2 = p[1];
			var dx2 = x2 - x0;
			var dy2 = y2 - y0;
			var dz = dy * dx2 - dx * dy2;
			if (dz * dz / d2 > this.factory.δ2 || Math.abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < this.factory.cosMinDistance) {
				this.resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, _depth, listener);
				listener.point(x2, y2, NaN);
				this.resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, _depth, listener);
			}
		}
	}
});


// $source: com/ibm/rave/core/internal/geo/CartesianUtil
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
/**
 * A collection of helper methods operating on point in Cartesian plane. 
 */
var com_ibm_rave_core_internal_geo_CartesianUtil = com_ibm_rave_core_nativeImpl_Declare({

	//constructor : function() {}
});

/**
 * Converts a point coordinates from spherical plane to Cartesian plane
 * @param (double[]) spherical the location in spherical plane to convert
 * @return (double[])  the x,y,z coordinates of the point in Cartesian plane
 */
com_ibm_rave_core_internal_geo_CartesianUtil.cartesian = function(spherical) {
	var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ);
	return [cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ)];
};

/**
 * Calculates the dot product of two 3D points in Cartesian plane
 * @param (double[]) a the first point x,y,z coordinates
 * @param (double[]) b the second point x,y,z coordinates
 * @return (double) the dot product (scalar value)
 */
com_ibm_rave_core_internal_geo_CartesianUtil.cartesianDot = function(a, b) {
	return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
};

/**
 * Calculates the cross product of two 3D points in Cartesian plane
 * @param (double[]) a the first point x,y,z coordinates
 * @param (double[]) b the second point x,y,z coordinates
 * @return (double[]) a new point (vector) holding whose coordinates are the cross product 
 */
com_ibm_rave_core_internal_geo_CartesianUtil.cartesianCross = function(a, b) {
	var x = a[1] * b[2] - a[2] * b[1];
	var y = a[2] * b[0] - a[0] * b[2];
	var z = a[0] * b[1] - a[1] * b[0];
	return [x, y, z];
};

/**
 * Adds one 3D point to another. This is done in place meaning the coordinates of the first point (a) will change
 * @param (double[]) a the first point x,y,z coordinates. It will hold the result of the add operation 
 * @param (double[]) b the second point x,y,z coordinates
 */
com_ibm_rave_core_internal_geo_CartesianUtil.cartesianAdd = function(a, b) {
	a[0] += b[0];
	a[1] += b[1];
	a[2] += b[2];
};

/**
 * Scale the coordinates of a given point by a specific factor
 * @param (double[]) vector the 3D point to scale
 * @param (double) k scale factor to apply
 * @return (double[]) a new point holding the scale result
 */
com_ibm_rave_core_internal_geo_CartesianUtil.cartesianScale = function(vector, k) {
	return [vector[0] * k, vector[1] * k, vector[2] * k];
};

/**
 * Normalizes a 3D point and modifies its coordinates accordingly
 * @param (double[]) d the point whose coordinates to normalize
 */
com_ibm_rave_core_internal_geo_CartesianUtil.cartesianNormalize = function(d) {
	var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
	d[0] /= l;
	d[1] /= l;
	d[2] /= l;
};


// $source: com/ibm/rave/core/internal/geo/ClipExtentStreamListenerFactory
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/geo/ClipExtentStreamListener (runtime) // new
/**
 */
var com_ibm_rave_core_internal_geo_ClipExtentStreamListenerFactory = com_ibm_rave_core_nativeImpl_Declare({

	x0 : 0, y0 : 0, x1 : 0, y1 : 0,

	_$functionClassMethod : function() {
		var _$self = function(listener) {
			return new com_ibm_rave_core_internal_geo_ClipExtentStreamListener(_$self.x0, _$self.y0, _$self.x1, _$self.y1, listener);
		};
		return _$self;
	},

	/**
	 */
	constructor : function(x0, y0, x1, y1) {
		this.x0 = x0;
		this.y0 = y0;
		this.x1 = x1;
		this.y1 = y1;
	}
});


// $source: com/ibm/rave/core/internal/geo/ClipExtentStreamListener
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/geo/TransformStreamListener (loadtime) // superclass
//@import com/ibm/rave/core/geom/ClipLine (runtime) // create
//@import com/ibm/rave/core/internal/geo/ClipBufferStreamListener (runtime) // new
//@import com/ibm/rave/core/geom/Line (runtime) // new
//@import com/ibm/rave/core/geom/PointStruct (runtime) // new
//@import com/ibm/rave/core/arrays/Merge (runtime) // merge
//@import com/ibm/rave/core/internal/geo/ClipUtil (runtime) // clipPolygon
//@import com/ibm/rave/core/internal/math/Trigonometry (runtime) // cross2d
/**
 */
var com_ibm_rave_core_internal_geo_ClipExtentStreamListener = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_geo_TransformStreamListener, {

	//listener : null,

	//clientListener : null,

	//bufferListener : null,

	//lineClipper : null,

	//comparator : null,

	//interpolator : null,

	//segments : null,

	//polygon : null,

	//ring : null,

	x0 : 0, y0 : 0, x1 : 0, y1 : 0,

	x__ : 0, y__ : 0, x_ : 0, y_ : 0,

	first : false, clean : false, v__ : false, v_ : false,

	constructor : function(x0, y0, x1, y1, clientListener) {
		var self = this;
		this.clientListener = clientListener;
		this.listener = clientListener;
		this.x0 = x0;
		this.y0 = y0;
		this.x1 = x1;
		this.y1 = y1;
		this.lineClipper = com_ibm_rave_core_geom_ClipLine.create(x0, y0, x1, y1);
		this.bufferListener = new com_ibm_rave_core_internal_geo_ClipBufferStreamListener();
		this.comparator = function(a, b) {
			var result = self.comparePoints(a.x, b.x);
			return (result == 0) ? 0 : (result > 0) ? 1 : -1;
		};
		this.interpolator = function(from, to, direction, listener) {
			var a = 0, a1 = 0;
			if (!from || (a = self.corner(from, direction)) != (a1 = self.corner(to, direction)) || (self.comparePoints(from, to) < 0) ^ (direction > 0)) {
				do {
					listener.point(a == 0 || a == 3 ? self.x0 : self.x1, a > 1 ? self.y1 : self.y0, NaN);
				} while ((a = (a + direction + 4) % 4) != a1);
			} else {
				listener.point(to[0], to[1], NaN);
			}
		};
		var point = function(x, y, z) {
			if (self.pointVisible(x, y)) {
				self.listener.point(x, y, NaN);
			}
		};
		var linePoint = function(x, y, z) {
			var _x = x;
			var _y = y;
			_x = Math.max(-1.0E9, Math.min(1.0E9, _x));
			_y = Math.max(-1.0E9, Math.min(1.0E9, _y));
			var v = self.pointVisible(_x, _y);
			if (self.polygon) {
				self.ring.push([_x, _y]);
			}
			if (self.first) {
				self.x__ = _x;
				self.y__ = _y;
				self.v__ = v;
				self.first = false;
				if (v) {
					self.listener.lineStart();
					self.listener.point(_x, _y, NaN);
				}
			} else {
				if (v && self.v_) {
					self.listener.point(_x, _y, NaN);
				} else {
					var l = new com_ibm_rave_core_geom_Line(new com_ibm_rave_core_geom_PointStruct(self.x_, self.y_), new com_ibm_rave_core_geom_PointStruct(_x, _y));
					if (self.lineClipper(l)) {
						if (!self.v_) {
							self.listener.lineStart();
							self.listener.point(l.a.x, l.a.y, NaN);
						}
						self.listener.point(l.b.x, l.b.y, NaN);
						if (!v) {
							self.listener.lineEnd();
						}
						self.clean = false;
					} else if (v) {
						self.listener.lineStart();
						self.listener.point(_x, _y, NaN);
						self.clean = false;
					}
				}
			}
			self.x_ = _x;
			self.y_ = _y;
			self.v_ = v;
		};
		var lineStart = function() {
			self.pointDelegate = linePoint;
			if (self.polygon) {
				self.polygon.push(self.ring = []);
			}
			self.first = true;
			self.v_ = false;
			self.x_ = self.y_ = NaN;
		};
		var lineEnd = function() {
			if (self.segments) {
				linePoint(self.x__, self.y__, NaN);
				if (self.v__ && self.v_) {
					self.bufferListener.rejoin();
				}
				self.segments.push(self.bufferListener.buffer());
			}
			self.pointDelegate = point;
			if (self.v_) {
				self.listener.lineEnd();
			}
		};
		var polygonStart = function() {
			self.listener = self.bufferListener;
			self.segments = [];
			self.polygon = [];
			self.clean = true;
		};
		var polygonEnd = function() {
			self.listener = self.clientListener;
			var mergedSegments = com_ibm_rave_core_arrays_Merge.merge(self.segments);
			var clipStartInside = self.insidePolygon([self.x0, self.y1]), inside = self.clean && clipStartInside, visible = mergedSegments.length > 0;
			if (inside || visible) {
				self.listener.polygonStart();
				if (inside) {
					self.listener.lineStart();
					self.interpolator(null, null, 1, self.listener);
					self.listener.lineEnd();
				}
				if (visible) {
					com_ibm_rave_core_internal_geo_ClipUtil.clipPolygon(mergedSegments, self.comparator, clipStartInside, self.interpolator, self.listener);
				}
				self.listener.polygonEnd();
			}
			self.segments = null;
			self.polygon = null;
			self.ring = null;
		};
		this.pointDelegate = point;
		this.lineStartDelegate = lineStart;
		this.lineEndDelegate = lineEnd;
		this.polygonStartDelegate = polygonStart;
		this.polygonEndDelegate = polygonEnd;
	},

	corner : function(p, direction) {
		return Math.abs(p[0] - this.x0) < 1.0E-6 ? direction > 0 ? 0 : 3 : Math.abs(p[0] - this.x1) < 1.0E-6 ? direction > 0 ? 2 : 1 : Math.abs(p[1] - this.y0) < 1.0E-6 ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
	},

	comparePoints : function(a, b) {
		var ca = this.corner(a, 1), cb = this.corner(b, 1);
		var result = ca != cb ? ca - cb : ca == 0 ? b[1] - a[1] : ca == 1 ? a[0] - b[0] : ca == 2 ? a[1] - b[1] : b[0] - a[0];
		return result;
	},

	pointVisible : function(x, y) {
		return this.x0 <= x && x <= this.x1 && this.y0 <= y && y <= this.y1;
	},

	insidePolygon : function(p) {
		var wn = 0;
		var n = this.polygon.length;
		var y = p[1];
		for (var i = 0; i < n; ++i) {
			var v = this.polygon[i];
			var a = v[0];
			for (var j = 1, m = v.length; j < m; ++j) {
				var b = v[j];
				if (a[1] <= y) {
					if (b[1] > y && com_ibm_rave_core_internal_math_Trigonometry.cross2d(a, b, p) > 0) {
						++wn;
					}
				} else {
					if (b[1] <= y && com_ibm_rave_core_internal_math_Trigonometry.cross2d(a, b, p) < 0) {
						--wn;
					}
				}
				a = b;
			}
		}
		return wn != 0;
	},

	/**
	 * A getter for the wrapped stream listener
	 * @return (com.ibm.rave.core.geo.StreamListener)  the wrapped stream listener
	 */
	/** @expose */ 
	getStreamListener : function() {
		return this.clientListener;
	}
});

com_ibm_rave_core_internal_geo_ClipExtentStreamListener.clipExtentMAX = 1e9;


// $source: com/ibm/rave/core/internal/geo/ClipBufferStreamListener
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
var com_ibm_rave_core_internal_geo_ClipBufferStreamListener = com_ibm_rave_core_nativeImpl_Declare({

	//lines : null,

	//line : null,

	constructor : function() {
		this.lines = [];
	},

	/** @expose */ 
	sphere : function() {},

	/** @expose */ 
	point : function(x, y, z) {
		this.line.push([x, y]);
	},

	/** @expose */ 
	lineStart : function() {
		this.lines.push(this.line = []);
	},

	/** @expose */ 
	lineEnd : function() {},

	/** @expose */ 
	polygonStart : function() {},

	/** @expose */ 
	polygonEnd : function() {},

	buffer : function() {
		var buff = this.lines;
		this.lines = [];
		this.line = null;
		return buff;
	},

	rejoin : function() {
		if (this.lines.length > 1) {
			this.lines.push(this.lines.pop().concat(this.lines.shift()));
		}
	}
});


// $source: com/ibm/rave/core/internal/geo/ClipStreamListenerFactory
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/geo/ClipStreamListener (runtime) // new
/**
 */
var com_ibm_rave_core_internal_geo_ClipStreamListenerFactory = com_ibm_rave_core_nativeImpl_Declare({

	//pointVisible : null,

	//clipLine : null,

	//interpolate : null,

	//clipStart : null,

	_$functionClassMethod : function() {
		var _$self = function(rotate, listener) {
			return new com_ibm_rave_core_internal_geo_ClipStreamListener(_$self.pointVisible, _$self.clipLine, _$self.interpolate, _$self.clipStart, rotate, listener);
		};
		return _$self;
	},

	/**
	 */
	constructor : function(pointVisible, clipLine, interpolate, clipStart) {
		this.pointVisible = pointVisible;
		this.clipLine = clipLine;
		this.interpolate = interpolate;
		this.clipStart = clipStart;
	}
});


// $source: com/ibm/rave/core/internal/geo/ClipUtil
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/geo/ClipExtentStreamListenerFactory (static) // new
//@import com/ibm/rave/core/internal/geo/ClipStreamListenerFactory (static) // new
//@import com/ibm/rave/core/internal/geo/CircleClipLineStreamListenerFactory (runtime) // new
//@import com/ibm/rave/core/internal/geo/GeoShapeGeneratorUtil (runtime) // newCircleInterpolator
//@import com/ibm/rave/core/internal/geo/AntimeridianClipLineStreamListenerFactory (runtime) // new
//@import com/ibm/rave/core/internal/geo/SphericalUtil (runtime) // sphericalEqual
//@import com/ibm/rave/core/internal/geo/ClipPolygonIntersection (runtime) // new
//@import com/ibm/rave/core/internal/math/Adder (runtime) // new
//@import com/ibm/rave/core/internal/geo/CartesianUtil (static) // cartesianNormalize, cartesian, cartesianCross
//@import com/ibm/rave/core/internal/math/Trigonometry (runtime) // asin
/**
 */
var com_ibm_rave_core_internal_geo_ClipUtil = com_ibm_rave_core_nativeImpl_Declare({


});

com_ibm_rave_core_internal_geo_ClipUtil.newClipExtentStreamListenerFactory = function(x0, y0, x1, y1) {
	return new com_ibm_rave_core_internal_geo_ClipExtentStreamListenerFactory(x0, y0, x1, y1);
};

com_ibm_rave_core_internal_geo_ClipUtil.newClipStreamListenerFactory = function(pointVisible, clipLine, interpolate, clipStart) {
	return new com_ibm_rave_core_internal_geo_ClipStreamListenerFactory(pointVisible, clipLine, interpolate, clipStart);
};

com_ibm_rave_core_internal_geo_ClipUtil.newClipCircleStreamListenerFactory = function(radius) {
	var circleClipLine = new com_ibm_rave_core_internal_geo_CircleClipLineStreamListenerFactory(radius);
	var interpolator = com_ibm_rave_core_internal_geo_GeoShapeGeneratorUtil.newCircleInterpolator(radius, 6 * 0.017453292519943295);
	return new com_ibm_rave_core_internal_geo_ClipStreamListenerFactory(circleClipLine.visible, circleClipLine, interpolator, circleClipLine.smallRadius ? [0.0, -radius] : [-3.141592653589793, radius - 3.141592653589793]);
};

com_ibm_rave_core_internal_geo_ClipUtil.newAntimeridianClipLineStreamListenerFactory = function() {
	var antimeridianClipLine = new com_ibm_rave_core_internal_geo_AntimeridianClipLineStreamListenerFactory();
	return new com_ibm_rave_core_internal_geo_ClipStreamListenerFactory(com_ibm_rave_core_internal_geo_ClipUtil.allVisible, antimeridianClipLine, com_ibm_rave_core_internal_geo_ClipUtil.clipAntimeridianInterpolator, [-3.141592653589793, -3.141592653589793 / 2]);
};

com_ibm_rave_core_internal_geo_ClipUtil.clipPolygon = function(segments, comparator, clipStartInside, interpolator, listener) {
	var subject = [];
	var clip = [];
	segments.forEach(function(segment, index, array) {
		var n = segment.length - 1;
		if (n <= 0) {
			return null;
		}
		var p0 = segment[0];
		var p1 = segment[n];
		if (com_ibm_rave_core_internal_geo_SphericalUtil.sphericalEqual((p0), (p1))) {
			listener.lineStart();
			for (var i = 0; i < n; ++i) {
				listener.point((p0 = segment[i])[0], p0[1], NaN);
			}
			listener.lineEnd();
			return null;
		}
		var a = new com_ibm_rave_core_internal_geo_ClipPolygonIntersection(p0, segment, null, true);
		var b = new com_ibm_rave_core_internal_geo_ClipPolygonIntersection(p0, null, a, false);
		a.o = b;
		subject.push(a);
		clip.push(b);
		a = new com_ibm_rave_core_internal_geo_ClipPolygonIntersection(p1, segment, null, false);
		b = new com_ibm_rave_core_internal_geo_ClipPolygonIntersection(p1, null, a, true);
		a.o = b;
		subject.push(a);
		clip.push(b);
		return null;
	});
	clip.sort(comparator);
	com_ibm_rave_core_internal_geo_ClipUtil.clipPolygonLinkCircular(subject);
	com_ibm_rave_core_internal_geo_ClipUtil.clipPolygonLinkCircular(clip);
	if (subject.length == 0) {
		return;
	}
	var entry = clipStartInside;
	for (var i = 0, n = clip.length; i < n; ++i) {
		clip[i].e = entry = !entry;
	}
	var start = subject[0];
	var points;
	var point;
	while (true) {
		var current = start;
		var isSubject = true;
		while (current.v) {
			if ((current = current.n) == start) {
				return;
			}
		}
		points = current.z;
		listener.lineStart();
		do {
			current.v = true;
			current.o.v = true;
			if (current.e) {
				if (isSubject) {
					for (var i = 0, n = points.length; i < n; ++i) {
						listener.point((point = points[i])[0], point[1], NaN);
					}
				} else {
					interpolator(current.x, current.n.x, 1, listener);
				}
				current = current.n;
			} else {
				if (isSubject) {
					points = current.p.z;
					for (var i = points.length - 1; i >= 0; --i) {
						listener.point((point = points[i])[0], point[1], NaN);
					}
				} else {
					interpolator(current.x, current.p.x, -1, listener);
				}
				current = current.p;
			}
			current = current.o;
			points = current.z;
			isSubject = !isSubject;
		} while (!(current.v));
		listener.lineEnd();
	}
};

com_ibm_rave_core_internal_geo_ClipUtil.clipPolygonLinkCircular = function(array) {
	var n = array.length;
	if (n == 0) {
		return;
	}
	var i = 0;
	var a = array[0];
	var b;
	while (++i < n) {
		a.n = b = array[i];
		b.p = a;
		a = b;
	}
	a.n = b = array[0];
	b.p = a;
};

com_ibm_rave_core_internal_geo_ClipUtil.pointInPolygon = function(point, polygon) {
	var _point = point;
	var polarAngle = 0, meridian = _point[0], parallel = _point[1];
	var winding = 0;
	var meridianNormal = [Math.sin(meridian), -Math.cos(meridian), 0];
	var areaRingSum = new com_ibm_rave_core_internal_math_Adder();
	for (var i = 0, n = polygon.length; i < n; ++i) {
		var ring = polygon[i];
		var m = ring.length;
		if (m == 0) {
			continue;
		}
		var point0 = ring[0];
		var λ0 = point0[0];
		var φ0 = point0[1] / 2 + 3.141592653589793 / 4;
		var sinφ0 = Math.sin(φ0);
		var cosφ0 = Math.cos(φ0);
		var j = 1;
		while (true) {
			if (j == m) {
				j = 0;
			}
			_point = ring[j];
			var λ = _point[0], φ = _point[1] / 2 + 3.141592653589793 / 4, sinφ = Math.sin(φ), cosφ = Math.cos(φ), dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, k = sinφ0 * sinφ;
			var antimeridian = adλ > 3.141592653589793;
			areaRingSum.add(Math.atan2(k * sdλ * Math.sin(adλ), cosφ0 * cosφ + k * Math.cos(adλ)));
			polarAngle += antimeridian ? dλ + sdλ * 6.283185307179586 : dλ;
			if (antimeridian ^ (λ0 >= meridian) ^ (λ >= meridian)) {
				var arc = com_ibm_rave_core_internal_geo_CartesianUtil.cartesianCross(com_ibm_rave_core_internal_geo_CartesianUtil.cartesian((point0)), com_ibm_rave_core_internal_geo_CartesianUtil.cartesian((_point)));
				com_ibm_rave_core_internal_geo_CartesianUtil.cartesianNormalize(arc);
				var intersection = com_ibm_rave_core_internal_geo_CartesianUtil.cartesianCross(meridianNormal, arc);
				com_ibm_rave_core_internal_geo_CartesianUtil.cartesianNormalize(intersection);
				var φarc = ((antimeridian ^ (dλ >= 0)) ? -1 : 1) * com_ibm_rave_core_internal_math_Trigonometry.asin(intersection[2]);
				if (parallel > φarc || parallel == φarc && (arc[0] != 0 || arc[1] != 0)) {
					winding += (antimeridian ^ (dλ >= 0)) ? 1 : -1;
				}
			}
			if (j++ == 0) {
				break;
			}
			λ0 = λ;
			sinφ0 = sinφ;
			cosφ0 = cosφ;
			point0 = _point;
		}
	}
	return (polarAngle < -1.0E-6 || polarAngle < 1.0E-6 && areaRingSum.valueOf() < 0) ^ ((winding & 1) != 0);
};

com_ibm_rave_core_internal_geo_ClipUtil.allVisible = function(x, y, z) {
	return true;
};
com_ibm_rave_core_internal_geo_ClipUtil.clipAntimeridianInterpolator = function(from, to, direction, listener) {
	var φ;
	if (!from) {
		φ = direction * 1.5707963267948966;
		listener.point(-3.141592653589793, φ, NaN);
		listener.point(0, φ, NaN);
		listener.point(3.141592653589793, φ, NaN);
		listener.point(3.141592653589793, 0, NaN);
		listener.point(3.141592653589793, -φ, NaN);
		listener.point(0, -φ, NaN);
		listener.point(-3.141592653589793, -φ, NaN);
		listener.point(-3.141592653589793, 0, NaN);
		listener.point(-3.141592653589793, φ, NaN);
	} else if (Math.abs(from[0] - to[0]) > 1.0E-6) {
		var s = from[0] < to[0] ? 3.141592653589793 : -3.141592653589793;
		φ = direction * s / 2;
		listener.point(-s, φ, NaN);
		listener.point(0, φ, NaN);
		listener.point(s, φ, NaN);
	} else {
		listener.point(to[0], to[1], NaN);
	}
};

// $source: com/ibm/rave/core/internal/geo/ClipStreamListener
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/geo/DelegatingStreamListener (loadtime) // superclass
//@import com/ibm/rave/core/internal/geo/ClipBufferStreamListener (runtime) // new
//@import com/ibm/rave/core/arrays/Merge (runtime) // merge
//@import com/ibm/rave/core/internal/geo/ClipUtil (runtime) // pointInPolygon, clipPolygon
/**
 */
var com_ibm_rave_core_internal_geo_ClipStreamListener = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_internal_geo_DelegatingStreamListener, {

	//pointVisible : null,

	//clipLine : null,

	//interpolate : null,

	//clipStart : null,

	//rotate : null,

	//listener : null,

	//comparator : null,

	//segments : null,

	//line : null,

	//bufferListener : null,

	//ringListener : null,

	//rotatedClipStart : null,

	//polygon : null,

	//ring : null,

	//clipSegmentLength1 : null,

	polygonStarted : false,

	constructor : function(pointVisible, clipLine, interpolate, clipStart, rotate, listener) {
		var self = this;
		this.pointVisible = pointVisible;
		this.clipLine = clipLine;
		this.interpolate = interpolate;
		this.clipStart = clipStart;
		this.rotate = rotate;
		this.listener = listener;
		this.line = clipLine(listener);
		this.bufferListener = new com_ibm_rave_core_internal_geo_ClipBufferStreamListener();
		this.ringListener = clipLine(this.bufferListener);
		this.rotatedClipStart = ((rotate.invert(clipStart[0], clipStart[1])));
		this.comparator = function(aa, bb) {
			var a = aa.x;
			var b = bb.x;
			var result = ((a[0] < 0 ? a[1] - 1.5707963267948966 - 1.0E-6 : 1.5707963267948966 - a[1]) - (b[0] < 0 ? b[1] - 1.5707963267948966 - 1.0E-6 : 1.5707963267948966 - b[1]));
			return (result == 0) ? 0 : (result > 0) ? 1 : -1;
		};
		this.clipSegmentLength1 = function(segment, index, array) {
			return segment.length > 1;
		};
		var point = function(λ, φ, z) {
			var _λ = λ;
			var _φ = φ;
			var point = self.rotate(_λ, _φ);
			if (self.pointVisible(_λ = point[0], _φ = point[1], NaN)) {
				self.listener.point(_λ, _φ, NaN);
			}
		};
		var pointLine = function(λ, φ, z) {
			var point = self.rotate(λ, φ);
			self.line.point(point[0], point[1], NaN);
		};
		var pointRing = function(λ, φ, z) {
			self.ring.push([λ, φ]);
			var point = self.rotate(λ, φ);
			self.ringListener.point(point[0], point[1], NaN);
		};
		var lineStart = function() {
			self.pointDelegate = pointLine;
			self.line.lineStart();
		};
		var lineEnd = function() {
			self.pointDelegate = point;
			self.line.lineEnd();
		};
		var ringStart = function() {
			self.ringListener.lineStart();
			self.ring = [];
		};
		var ringEnd = function() {
			pointRing(self.ring[0][0], self.ring[0][1], NaN);
			self.ringListener.lineEnd();
			var clean = self.ringListener.clean();
			var ringSegments = self.bufferListener.buffer();
			var segment;
			var n = ringSegments.length;
			self.ring.pop();
			self.polygon.push(self.ring);
			self.ring = null;
			if (n == 0) {
				return;
			}
			if ((clean & 1) != 0) {
				segment = ringSegments[0];
				n = segment.length - 1;
				var i = -1;
				var point;
				if (n > 0) {
					if (!self.polygonStarted) {
						self.listener.polygonStart();
						self.polygonStarted = true;
					}
					self.listener.lineStart();
					while (++i < n) {
						self.listener.point((point = segment[i])[0], point[1], NaN);
					}
					self.listener.lineEnd();
				}
				return;
			}
			if (n > 1 && ((clean & 2) != 0)) {
				ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
			}
			self.segments.push(ringSegments.filter(self.clipSegmentLength1));
		};
		var polygonStart = function() {
			self.pointDelegate = pointRing;
			self.lineStartDelegate = ringStart;
			self.lineEndDelegate = ringEnd;
			self.segments = [];
			self.polygon = [];
		};
		var polygonEnd = function() {
			self.pointDelegate = point;
			self.lineStartDelegate = lineStart;
			self.lineEndDelegate = lineEnd;
			var mergedSegments = com_ibm_rave_core_arrays_Merge.merge(self.segments);
			var clipStartInside = com_ibm_rave_core_internal_geo_ClipUtil.pointInPolygon(self.rotatedClipStart, self.polygon);
			if (mergedSegments.length > 0) {
				if (!self.polygonStarted) {
					self.listener.polygonStart();
					self.polygonStarted = true;
				}
				com_ibm_rave_core_internal_geo_ClipUtil.clipPolygon(mergedSegments, self.comparator, clipStartInside, self.interpolate, self.listener);
			} else if (clipStartInside) {
				if (!self.polygonStarted) {
					self.listener.polygonStart();
					self.polygonStarted = true;
				}
				self.listener.lineStart();
				self.interpolate(null, null, 1, self.listener);
				self.listener.lineEnd();
			}
			if (self.polygonStarted) {
				self.listener.polygonEnd();
				self.polygonStarted = false;
			}
			mergedSegments = self.polygon = null;
		};
		var sphere = function() {
			self.listener.polygonStart();
			self.listener.lineStart();
			self.interpolate(null, null, 1, self.listener);
			self.listener.lineEnd();
			self.listener.polygonEnd();
		};
		this.pointDelegate = point;
		this.lineStartDelegate = lineStart;
		this.lineEndDelegate = lineEnd;
		this.polygonStartDelegate = polygonStart;
		this.polygonEndDelegate = polygonEnd;
		this.sphereDelegate = sphere;
	}
});


// $source: com/ibm/rave/core/internal/geo/CircleClipLineStreamListenerFactory
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare anonymous, declare
//@import com/ibm/rave/core/internal/geo/CartesianUtil (runtime) // cartesianDot, cartesianScale, cartesianCross, cartesian, cartesianAdd
//@import com/ibm/rave/core/internal/geo/SphericalUtil (runtime) // sphericalEqual, spherical
//@import com/ibm/rave/core/internal/geo/ClipLineStreamListenerFactory (runtime)
/**
 */
var com_ibm_rave_core_internal_geo_CircleClipLineStreamListenerFactory = com_ibm_rave_core_nativeImpl_Declare({

	//visible : null,

	//point0 : null,

	radius : 0,

	cr : 0,

	smallRadius : false,

	notHemisphere : false,

	c0 : 0,

	v0 : false,

	v00 : false,

	clean : 0,

	round : 1e+6,

	_$functionClassMethod : function() {
		var _$self = function(listener) {
			var self = _$self;
			return new (com_ibm_rave_core_nativeImpl_Declare({

				sphere : function() {},

				point : function(λ, φ, z) {
					var point1 = [λ, φ], point2;
					var v = self.visible(λ, φ, NaN);
					var c = self.smallRadius ? v ? 0 : self.code(λ, φ) : v ? self.code(λ + (λ < 0 ? 3.141592653589793 : -3.141592653589793), φ) : 0;
					if ((!self.point0) && (self.v00 = self.v0 = v)) {
						listener.lineStart();
					}
					if (v != self.v0) {
						point2 = self.intersect(self.point0, point1, false);
						if (com_ibm_rave_core_internal_geo_SphericalUtil.sphericalEqual((self.point0), (point2)) || com_ibm_rave_core_internal_geo_SphericalUtil.sphericalEqual((point1), (point2))) {
							point1[0] = point1[0] + 1.0E-6;
							point1[1] = point1[1] + 1.0E-6;
							v = self.visible(point1[0], point1[1], NaN);
						}
					}
					if (v != self.v0) {
						self.clean = 0;
						if (v) {
							listener.lineStart();
							point2 = self.intersect(point1, self.point0, false);
							listener.point(point2[0], point2[1], NaN);
						} else {
							point2 = self.intersect(self.point0, point1, false);
							listener.point(point2[0], point2[1], NaN);
							listener.lineEnd();
						}
						self.point0 = point2;
					} else if (self.notHemisphere && (self.point0) && self.smallRadius ^ v) {
						var t;
						if (((c & self.c0) == 0) && ((t = self.intersect(point1, self.point0, true)))) {
							self.clean = 0;
							if (self.smallRadius) {
								listener.lineStart();
								listener.point(t[0][0], t[0][1], NaN);
								listener.point(t[1][0], t[1][1], NaN);
								listener.lineEnd();
							} else {
								listener.point(t[1][0], t[1][1], NaN);
								listener.lineEnd();
								listener.lineStart();
								listener.point(t[0][0], t[0][1], NaN);
							}
						}
					}
					if (v && ((!self.point0) || !(com_ibm_rave_core_internal_geo_SphericalUtil.sphericalEqual((self.point0), (point1))))) {
						listener.point(point1[0], point1[1], NaN);
					}
					self.point0 = point1;
					self.v0 = v;
					self.c0 = c;
				},

				lineStart : function() {
					self.v00 = self.v0 = false;
					self.clean = 1;
				},

				lineEnd : function() {
					if (self.v0) {
						listener.lineEnd();
					}
					self.point0 = null;
				},

				polygonStart : function() {},

				polygonEnd : function() {},

				clean : function() {
					return self.clean | ((self.v00 && self.v0) ? 1 << 1 : 0);
				}

			}))();
		};
		return _$self;
	},

	constructor : function(radius) {
		var self = this;
		this.radius = radius;
		this.cr = Math.cos(radius);
		this.smallRadius = (this.cr > 0);
		this.notHemisphere = Math.abs(this.cr) > 1.0E-6;
		this.visible = function(λ, φ, z) {
			return Math.round(Math.cos(λ) * Math.cos(φ) * 1000000.0) / 1000000.0 > Math.round(self.cr * 1000000.0) / 1000000.0;
		};
	},

	/**
	 * @return (com.ibm.rave.core.internal.geo.ClipUtil.PointVisiblity)  the visible
	 */
	getPointVisiblilty : function() {
		return this.visible;
	},

	/**
	 * @return (boolean)  the smallRadius
	 */
	isSmallRadius : function() {
		return this.smallRadius;
	},

	intersect : function(a, b, two) {
		var pa = com_ibm_rave_core_internal_geo_CartesianUtil.cartesian((a)), pb = com_ibm_rave_core_internal_geo_CartesianUtil.cartesian((b));
		var n1 = [1, 0, 0];
		var n2 = com_ibm_rave_core_internal_geo_CartesianUtil.cartesianCross(pa, pb);
		var n2n2 = com_ibm_rave_core_internal_geo_CartesianUtil.cartesianDot(n2, n2);
		var n1n2 = n2[0];
		var determinant = n2n2 - n1n2 * n1n2;
		if (!((determinant))) {
			if (!two) {
				return a;
			} else {
				return null;
			}
		}
		var c1 = this.cr * n2n2 / determinant, c2 = -this.cr * n1n2 / determinant;
		var n1xn2 = com_ibm_rave_core_internal_geo_CartesianUtil.cartesianCross(n1, n2), A = com_ibm_rave_core_internal_geo_CartesianUtil.cartesianScale(n1, c1), B = com_ibm_rave_core_internal_geo_CartesianUtil.cartesianScale(n2, c2);
		com_ibm_rave_core_internal_geo_CartesianUtil.cartesianAdd(A, B);
		var u = n1xn2;
		var w = com_ibm_rave_core_internal_geo_CartesianUtil.cartesianDot(A, u), uu = com_ibm_rave_core_internal_geo_CartesianUtil.cartesianDot(u, u), t2 = w * w - uu * (com_ibm_rave_core_internal_geo_CartesianUtil.cartesianDot(A, A) - 1);
		if (t2 < 0) {
			return null;
		}
		var t = Math.sqrt(t2);
		var q = com_ibm_rave_core_internal_geo_CartesianUtil.cartesianScale(u, (-w - t) / uu);
		com_ibm_rave_core_internal_geo_CartesianUtil.cartesianAdd(q, A);
		q = com_ibm_rave_core_internal_geo_SphericalUtil.spherical(q);
		if (!two) {
			return ((q));
		}
		var λ0 = a[0];
		var λ1 = b[0];
		var φ0 = a[1];
		var φ1 = b[1];
		var z;
		if (λ1 < λ0) {
			z = λ0;
			λ0 = λ1;
			λ1 = z;
		}
		var δλ = λ1 - λ0;
		var polar = Math.abs(δλ - 3.141592653589793) < 1.0E-6;
		var meridian = polar || δλ < 1.0E-6;
		if (!polar && φ1 < φ0) {
			z = φ0;
			φ0 = φ1;
			φ1 = z;
		}
		var pointIsBetween = false;
		if (meridian) {
			if (polar) {
				pointIsBetween = (φ0 + φ1 > 0) ^ (q[1] < (Math.abs(q[0] - λ0) < 1.0E-6 ? φ0 : φ1));
			} else {
				pointIsBetween = φ0 <= q[1] && q[1] <= φ1;
			}
		} else {
			pointIsBetween = (δλ > 3.141592653589793) ^ (λ0 <= q[0] && q[0] <= λ1);
		}
		if (pointIsBetween) {
			var q1 = com_ibm_rave_core_internal_geo_CartesianUtil.cartesianScale(u, (-w + t) / uu);
			com_ibm_rave_core_internal_geo_CartesianUtil.cartesianAdd(q1, A);
			return [((q)), ((com_ibm_rave_core_internal_geo_SphericalUtil.spherical(q1)))];
		}
		return null;
	},

	code : function(λ, φ) {
		var r = this.smallRadius ? this.radius : 3.141592653589793 - this.radius;
		var code = 0;
		if (λ < -r) {
			code |= 1;
		} else if (λ > r) {
			code |= 2;
		}
		if (φ < -r) {
			code |= 4;
		} else if (φ > r) {
			code |= 8;
		}
		return code;
	}
});


// $source: com/ibm/rave/core/internal/geo/SphericalUtil
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/math/Trigonometry (static) // asin
/**
 * A collection of helper methods operating on point in a spherical plane. 
 */
var com_ibm_rave_core_internal_geo_SphericalUtil = com_ibm_rave_core_nativeImpl_Declare({

	/**
	 */
	//constructor : function() {}
});

/**
 * Converts a point coordinates from Cartesian plane to spherical plane
 * @param (double[]) cartesian the location in Cartesian plane to convert
 * @return (double[]) the x,y coordinates of the point in spherical plane
 */
com_ibm_rave_core_internal_geo_SphericalUtil.spherical = function(cartesian) {
	return [Math.atan2(cartesian[1], cartesian[0]), com_ibm_rave_core_internal_math_Trigonometry.asin(cartesian[2])];
};

/**
 * Checks if two points in spherical plane are equal. Two points are considered equal  as long as the difference between their corresponding x, and y coordinates falls within Trigonometry.ε = 1E-6
 * @param (double[]) a the first point to compare
 * @param (double[]) b the second point to compare
 * @return (boolean)  true if they are equal, false otherwise
 */
com_ibm_rave_core_internal_geo_SphericalUtil.sphericalEqual = function(a, b) {
	return Math.abs(a[0] - b[0]) < 1.0E-6 && Math.abs(a[1] - b[1]) < 1.0E-6;
};

/**
 * Calculates the great-arc distance between two points in spherical plane
 * @param (double[]) a the first point 
 * @param (double[]) b the second point
 * @return (double)  the calculated distance
 */
com_ibm_rave_core_internal_geo_SphericalUtil.calculateDistance = function(a, b) {
	var Δλ = (b[0] - a[0]) * 0.017453292519943295, φ0 = a[1] * 0.017453292519943295, φ1 = b[1] * 0.017453292519943295, sinΔλ = Math.sin(Δλ), cosΔλ = Math.cos(Δλ), sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1), t;
	return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);
};


// $source: com/ibm/rave/core/internal/geo/GeoShapeGeneratorUtil
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/geo/SphericalUtil (runtime) // spherical
//@import com/ibm/rave/core/internal/geo/CartesianUtil (static) // cartesianNormalize, cartesian
//@import com/ibm/rave/core/internal/math/Trigonometry (runtime) // acos
//@import com/ibm/rave/core/Rave (runtime) // range
/**
 */
var com_ibm_rave_core_internal_geo_GeoShapeGeneratorUtil = com_ibm_rave_core_nativeImpl_Declare({


});

com_ibm_rave_core_internal_geo_GeoShapeGeneratorUtil.newCircleInterpolator = function(radius, precision) {
	var cr = Math.cos(radius), sr = Math.sin(radius);
	return function(from, to, direction, listener) {
		var fromAngle, toAngle;
		var step = direction * precision;
		if (from) {
			fromAngle = com_ibm_rave_core_internal_geo_GeoShapeGeneratorUtil.circleAngle(cr, from);
			toAngle = com_ibm_rave_core_internal_geo_GeoShapeGeneratorUtil.circleAngle(cr, to);
			if ((direction > 0) ? fromAngle < toAngle : fromAngle > toAngle) {
				fromAngle += direction * 6.283185307179586;
			}
		} else {
			fromAngle = radius + direction * 6.283185307179586;
			toAngle = radius - .5 * step;
		}
		var point;
		for (var t = fromAngle; (direction > 0) ? t > toAngle : t < toAngle; t -= step) {
			listener.point((point = com_ibm_rave_core_internal_geo_SphericalUtil.spherical([cr, -sr * Math.cos(t), -sr * Math.sin(t)]))[0], point[1], NaN);
		}
	};
};

com_ibm_rave_core_internal_geo_GeoShapeGeneratorUtil.circleAngle = function(cr, sphericalPoint) {
	var a = com_ibm_rave_core_internal_geo_CartesianUtil.cartesian((sphericalPoint));
	a[0] -= cr;
	com_ibm_rave_core_internal_geo_CartesianUtil.cartesianNormalize(a);
	var angle = com_ibm_rave_core_internal_math_Trigonometry.acos(-a[1]);
	return ((-a[2] < 0 ? -angle : angle) + 2 * 3.141592653589793 - 1.0E-6) % (2 * 3.141592653589793);
};

com_ibm_rave_core_internal_geo_GeoShapeGeneratorUtil.graticuleX = function(y0, y1, dy) {
	var array = com_ibm_rave_core_Rave.range(y0, y1 - 1.0E-6, dy).concat(y1);
	return function(x) {
		return array.map(function(currentValue, index, arr) {
			return [x, + (currentValue)];
		});
	};
};

com_ibm_rave_core_internal_geo_GeoShapeGeneratorUtil.graticuleY = function(x0, x1, dx) {
	var array = com_ibm_rave_core_Rave.range(x0, x1 - 1.0E-6, dx).concat(x1);
	return function(y) {
		return array.map(function(currentValue, index, arr) {
			return [+ (currentValue), y];
		});
	};
};


// $source: com/ibm/rave/core/internal/geo/AntimeridianClipLineStreamListenerFactory
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
/**
 */
var com_ibm_rave_core_internal_geo_AntimeridianClipLineStreamListenerFactory = com_ibm_rave_core_nativeImpl_Declare({

	λ0 : 0, φ0 : 0, sλ0 : 0,

	clean : 0,

	_$functionClassMethod : function() {
		var _$self = function(listener) {
			_$self.λ0 = _$self.φ0 = _$self.sλ0 = NaN;
			_$self.clean = 0;
			return new com_ibm_rave_core_internal_geo_AntimeridianClipLineStreamListenerFactory.AntimeridianClipLineStreamListener(_$self, listener);
		};
		return _$self;
	}
});

com_ibm_rave_core_internal_geo_AntimeridianClipLineStreamListenerFactory.clipAntimeridianIntersect = function(λ0, φ0, λ1, φ1) {
	var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1);
	return Math.abs(sinλ0_λ1) > 1.0E-6 ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;
};

com_ibm_rave_core_internal_geo_AntimeridianClipLineStreamListenerFactory.AntimeridianClipLineStreamListener = com_ibm_rave_core_nativeImpl_Declare({

	//listener : null,

	//self : null,

	constructor : function(_self, _listener) {
		this.self = _self;
		this.listener = _listener;
	},

	/** @expose */ 
	sphere : function() {},

	/** @expose */ 
	point : function(λ1, φ1, z) {
		var _λ1 = λ1;
		var sλ1 = _λ1 > 0 ? 3.141592653589793 : -3.141592653589793, dλ = Math.abs(_λ1 - this.self.λ0);
		if (Math.abs(dλ - 3.141592653589793) < 1.0E-6) {
			this.listener.point(this.self.λ0, this.self.φ0 = (this.self.φ0 + φ1) / 2 > 0 ? 1.5707963267948966 : -1.5707963267948966, NaN);
			this.listener.point(this.self.sλ0, this.self.φ0, NaN);
			this.listener.lineEnd();
			this.listener.lineStart();
			this.listener.point(sλ1, this.self.φ0, NaN);
			this.listener.point(_λ1, this.self.φ0, NaN);
			this.self.clean = 0;
		} else if (this.self.sλ0 != sλ1 && dλ >= 3.141592653589793) {
			if (Math.abs(this.self.λ0 - this.self.sλ0) < 1.0E-6) {
				this.self.λ0 -= this.self.sλ0 * 1.0E-6;
			}
			if (Math.abs(_λ1 - sλ1) < 1.0E-6) {
				_λ1 -= sλ1 * 1.0E-6;
			}
			this.self.φ0 = com_ibm_rave_core_internal_geo_AntimeridianClipLineStreamListenerFactory.clipAntimeridianIntersect(this.self.λ0, this.self.φ0, _λ1, φ1);
			this.listener.point(this.self.sλ0, this.self.φ0, NaN);
			this.listener.lineEnd();
			this.listener.lineStart();
			this.listener.point(sλ1, this.self.φ0, NaN);
			this.self.clean = 0;
		}
		this.listener.point(this.self.λ0 = _λ1, this.self.φ0 = φ1, NaN);
		this.self.sλ0 = sλ1;
	},

	/** @expose */ 
	lineStart : function() {
		this.listener.lineStart();
		this.self.clean = 1;
	},

	/** @expose */ 
	lineEnd : function() {
		this.listener.lineEnd();
		this.self.λ0 = this.self.φ0 = NaN;
	},

	/** @expose */ 
	polygonStart : function() {},

	/** @expose */ 
	polygonEnd : function() {},

	clean : function() {
		return 2 - this.self.clean;
	}
});


// $source: com/ibm/rave/core/internal/geo/ClipPolygonIntersection
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
/**
 */
var com_ibm_rave_core_internal_geo_ClipPolygonIntersection = com_ibm_rave_core_nativeImpl_Declare({

	//x : null,

	//z : null,

	//o : null,

	//n : null,

	//p : null,

	v : false,

	e : false,

	constructor : function(point, points, other, entry) {
		this.x = point;
		this.z = points;
		this.o = other;
		this.e = entry;
		this.v = false;
	},

	/**
	 * @return (boolean)  the v
	 */
	isVisited : function() {
		return this.v;
	},

	/**
	 * @param (boolean) v  the v to set
	 */
	setVisited : function(v) {
		this.v = v;
	},

	/**
	 * @return (Array)  the x
	 */
	getPoint : function() {
		return this.x;
	},

	/**
	 * @param (Array) x  the x to set
	 */
	setPoint : function(x) {
		this.x = x;
	},

	/**
	 * @return (Array)  the z
	 */
	getPoints : function() {
		return this.z;
	},

	/**
	 * @param (Array) z  the z to set
	 */
	setPoints : function(z) {
		this.z = z;
	},

	/**
	 * @return (com.ibm.rave.core.internal.geo.ClipPolygonIntersection)  the o
	 */
	getOtherIntersection : function() {
		return this.o;
	},

	/**
	 * @param (com.ibm.rave.core.internal.geo.ClipPolygonIntersection) o  the o to set
	 */
	setOtherIntersection : function(o) {
		this.o = o;
	},

	/**
	 * @return (boolean)  the e
	 */
	isEntry : function() {
		return this.e;
	},

	/**
	 * @param (boolean) e  the e to set
	 */
	setEntry : function(e) {
		this.e = e;
	},

	/**
	 * @return (com.ibm.rave.core.internal.geo.ClipPolygonIntersection)  the n
	 */
	getNext : function() {
		return this.n;
	},

	/**
	 * @param (com.ibm.rave.core.internal.geo.ClipPolygonIntersection) n  the n to set
	 */
	setNext : function(n) {
		this.n = n;
	},

	/**
	 * @return (com.ibm.rave.core.internal.geo.ClipPolygonIntersection)  the p
	 */
	getPrevious : function() {
		return this.p;
	},

	/**
	 * @param (com.ibm.rave.core.internal.geo.ClipPolygonIntersection) p  the p to set
	 */
	setPrevious : function(p) {
		this.p = p;
	}
});


// $source: com/ibm/rave/core/internal/math/Adder
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
/**
 * Adds floating point numbers with twice the normal precision. Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3) 305–363 (1997). Code adapted from GeographicLib by Charles F. F. Karney, http://geographiclib.sourceforge.net/ See lib/geographiclib/LICENSE for details.
 */
var com_ibm_rave_core_internal_math_Adder = com_ibm_rave_core_nativeImpl_Declare({

	s : 0,

	t : 0,

	/**
	 * Adds the passed value to the exisiting value of this adder.
	 * @param (double) y the double value to add
	 */
	add : function(y) {
		var s_temp, t_temp;
		var x = s_temp = y + this.t;
		var bv = x - y, av = x - bv;
		t_temp = y - av + (this.t - bv);
		var s_temp2 = this.s;
		x = this.s = s_temp + s_temp2;
		bv = x - s_temp;
		av = x - bv;
		this.t = s_temp - av + (s_temp2 - bv);
		if (this.s != 0) {
			this.t += t_temp;
		} else {
			this.s = t_temp;
		}
	},

	/**
	 * Resets the value of this Adder to zero so that it could be reused to sum up a different group of numbers 
	 */
	reset : function() {
		this.s = this.t = 0;
	},

	/**
	 * Returns the final sum of all double values passed to this adder
	 * @return (double)  The final sum
	 */
	valueOf : function() {
		return this.s;
	}
});


// $source: com/ibm/rave/core/internal/geo/SphericalRotation
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/math/Trigonometry (runtime) // asin
/**
 */
var com_ibm_rave_core_internal_geo_SphericalRotation = com_ibm_rave_core_nativeImpl_Declare({

	/**
	 */
	//constructor : function() {}
});

/**
 * Specifies a rotation in the form of an array, [λ, φ, γ].  The elements of the array are angles in degrees, and specify a rotation in the following order: longitudinal, latitudinal and about the origin.  If the last element of the array, γ, is omitted, this defaults to 0.  Returns a rotator function object, which rotates a given location in the same otr reverse order.
 * @param (double[]) location the location to rotate
 * @return (com.ibm.rave.core.geo.SphericalRotator)  the rotator
 * @see (com.ibm.rave.core.geo.SphericalRotator) SphericalRotator
 */
com_ibm_rave_core_internal_geo_SphericalRotation.newRotator = function(location) {
	var rfo = com_ibm_rave_core_internal_geo_SphericalRotation.rotation(location[0] % 360 * 0.017453292519943295, location[1] * 0.017453292519943295, location.length > 2 ? location[2] * 0.017453292519943295 : 0);
	var rotation = new com_ibm_rave_core_internal_geo_SphericalRotation.SphericalRotatorImpl();
	rotation.pointProjection = rfo;
	return rotation;
};

com_ibm_rave_core_internal_geo_SphericalRotation.compose = function(a, b) {
	var obj;
	if (a.invert && b.invert) {
		obj = new com_ibm_rave_core_internal_geo_SphericalRotation.ComposedInvertiblePointProjector();
	} else {
		obj = new com_ibm_rave_core_internal_geo_SphericalRotation.ComposedPointProjection();
	}
	obj.init(a, b);
	return obj;
};

com_ibm_rave_core_internal_geo_SphericalRotation.rotation = function(δλ, δφ, δγ) {
	return ((δλ)) ? (((δφ) || (δγ)) ? com_ibm_rave_core_internal_geo_SphericalRotation.compose(com_ibm_rave_core_internal_geo_SphericalRotation.rotationλ(δλ), com_ibm_rave_core_internal_geo_SphericalRotation.rotationφγ(δφ, δγ)) : com_ibm_rave_core_internal_geo_SphericalRotation.rotationλ(δλ)) : (((δφ) || (δγ)) ? com_ibm_rave_core_internal_geo_SphericalRotation.rotationφγ(δφ, δγ) : com_ibm_rave_core_internal_geo_SphericalRotation.identityRotation);
};

com_ibm_rave_core_internal_geo_SphericalRotation.rotationλ = function(δλ) {
	var obj = new com_ibm_rave_core_internal_geo_SphericalRotation.PointProjectionλ();
	obj.δλ = δλ;
	return obj;
};

com_ibm_rave_core_internal_geo_SphericalRotation.rotationφγ = function(δφ, δγ) {
	var cosδφ = Math.cos(δφ), sinδφ = Math.sin(δφ), cosδγ = Math.cos(δγ), sinδγ = Math.sin(δγ);
	var obj = new com_ibm_rave_core_internal_geo_SphericalRotation.PointProjectionφγ();
	obj.init(cosδφ, sinδφ, cosδγ, sinδγ);
	return obj;
};

com_ibm_rave_core_internal_geo_SphericalRotation.SphericalRotatorImpl = com_ibm_rave_core_nativeImpl_Declare({

	//pointProjection : null,

	_$functionClassMethod : function() {
		var _$self = function(coordinates) {
			var _coordinates = coordinates;
			_coordinates = _$self.pointProjection(_coordinates[0] * 0.017453292519943295, _coordinates[1] * 0.017453292519943295);
			_coordinates[0] *= 57.29577951308232;
			_coordinates[1] *= 57.29577951308232;
			return _coordinates;
		};
		return _$self;
	},

	init : function(pointProjection) {
		this.pointProjection = pointProjection;
	},

	/** @expose */ 
	invert : function(coordinates) {
		var _coordinates = coordinates;
		_coordinates = this.pointProjection.invert(_coordinates[0] * 0.017453292519943295, _coordinates[1] * 0.017453292519943295);
		_coordinates[0] *= 57.29577951308232;
		_coordinates[1] *= 57.29577951308232;
		return _coordinates;
	}
});

com_ibm_rave_core_internal_geo_SphericalRotation.IdentityPointProjection = com_ibm_rave_core_nativeImpl_Declare({

	_$functionClassMethod : function() {
		var _$self = function(λ, φ) {
			return [λ > 3.141592653589793 ? λ - 6.283185307179586 : λ < -3.141592653589793 ? λ + 6.283185307179586 : λ, φ];
		};
		return _$self;
	},

	/** @expose */ 
	invert : function(λ, φ) {
		return [λ, φ];
	},

	/** @expose */ 
	supportInversion : function() {
		return true;
	}
});

com_ibm_rave_core_internal_geo_SphericalRotation.ComposedPointProjection = com_ibm_rave_core_nativeImpl_Declare({

	//a : null,

	//b : null,

	_$functionClassMethod : function() {
		var _$self = function(λ, φ) {
			var x = _$self.a(λ, φ);
			return _$self.b(x[0], x[1]);
		};
		return _$self;
	},

	/**
	 * @param (com.ibm.rave.core.geo.PointProjector) a
	 * @param (com.ibm.rave.core.geo.PointProjector) b
	 */
	init : function(a, b) {
		this.a = a;
		this.b = b;
	},

	/** @expose */ 
	supportInversion : function() {
		return false;
	}
});

com_ibm_rave_core_internal_geo_SphericalRotation.ComposedInvertiblePointProjector = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_internal_geo_SphericalRotation.ComposedPointProjection, {

	/** @expose */ 
	invert : function(λ, φ) {
		var x = (this.b).invert(λ, φ);
		if (x) {
			return (this.a).invert(x[0], x[1]);
		}
		return null;
	},

	/** @expose */ 
	supportInversion : function() {
		return true;
	}
});

com_ibm_rave_core_internal_geo_SphericalRotation.PointProjectionλ = com_ibm_rave_core_nativeImpl_Declare({

	δλ : 0,

	_$functionClassMethod : function() {
		var _$self = function(λ, φ) {
			var _λ = λ;
			_λ += _$self.δλ;
			return [_λ > 3.141592653589793 ? _λ - 6.283185307179586 : _λ < -3.141592653589793 ? _λ + 6.283185307179586 : _λ, φ];
		};
		return _$self;
	},

	init : function(δλ) {
		this.δλ = δλ;
	},

	/** @expose */ 
	invert : function(λ, φ) {
		var _λ = λ;
		_λ -= this.δλ;
		return [_λ > 3.141592653589793 ? _λ - 6.283185307179586 : _λ < -3.141592653589793 ? _λ + 6.283185307179586 : _λ, φ];
	},

	/** @expose */ 
	supportInversion : function() {
		return true;
	}
});

com_ibm_rave_core_internal_geo_SphericalRotation.PointProjectionφγ = com_ibm_rave_core_nativeImpl_Declare({

	cosδφ : 0, sinδφ : 0, cosδγ : 0, sinδγ : 0,

	_$functionClassMethod : function() {
		var _$self = function(λ, φ) {
			var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * _$self.cosδφ + x * _$self.sinδφ;
			return [Math.atan2(y * _$self.cosδγ - k * _$self.sinδγ, x * _$self.cosδφ - z * _$self.sinδφ), com_ibm_rave_core_internal_math_Trigonometry.asin(k * _$self.cosδγ + y * _$self.sinδγ)];
		};
		return _$self;
	},

	init : function(cosδφ, sinδφ, cosδγ, sinδγ) {
		this.cosδφ = cosδφ;
		this.sinδφ = sinδφ;
		this.cosδγ = cosδγ;
		this.sinδγ = sinδγ;
	},

	/** @expose */ 
	invert : function(λ, φ) {
		var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * this.cosδγ - y * this.sinδγ;
		return [Math.atan2(y * this.cosδγ + z * this.sinδγ, x * this.cosδφ + k * this.sinδφ), com_ibm_rave_core_internal_math_Trigonometry.asin(k * this.cosδφ - x * this.sinδφ)];
	},

	/** @expose */ 
	supportInversion : function() {
		return true;
	}
});

com_ibm_rave_core_internal_geo_SphericalRotation.identityRotation = new com_ibm_rave_core_internal_geo_SphericalRotation.IdentityPointProjection();

// $source: com/ibm/rave/core/geo/TransformStreamListenerFactory
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/geo/TransformStreamListenerImpl (static) // new
/**
 * A factory used to create TransformStreamListeners
 */
var com_ibm_rave_core_geo_TransformStreamListenerFactory = com_ibm_rave_core_nativeImpl_Declare({

	//delegates : null,

	constructor : function(delegates) {
		this.delegates = delegates;
	},

	/**
	 * Creates a new TransformStreamListener that wraps the passed listener. The factory uses the stream state handlers map passed to it when it got constructed and passes them to each TransformStreamListener it creates 
	 * @param (com.ibm.rave.core.geo.StreamListener) listener the listener to wrap
	 * @return (com.ibm.rave.core.geo.TransformStreamListener)  the newly created TransformStreamListener
	 */
	/** @expose */ 
	stream : function(listener) {
		return new com_ibm_rave_core_internal_geo_TransformStreamListenerImpl(listener, this.delegates);
	}
});

/**
 * Factory method to create a TransformStreamListenerFactory. It creates a new stream transform factory using the specified map of stream state delegate handlers.  The map may contain implementations of any of the standard stream listener delegate function classes:  StreamStateHandler for sphere, lineStart, lineEnd, polygonStart and polygonEnd, and StreamPointStateHandler for point. Each entry in the map should use a specific key as that represent the event to be handled, these keys are declared  as constants on TransformStreamListener class. For example, a sphere handler's entry should be keyed with  TransformStreamListener.sphereHandler value and so on.   Any method that is not present in the specified map will be implemented as a pass-through directly to the wrapped stream listener.
 * @param (Object) delegates a map of standard stream state handlers to delegate to
 * @return (com.ibm.rave.core.geo.TransformStreamListenerFactory)  the newly created TransformStreamListenerFactory object
 */
/** @expose */ 
com_ibm_rave_core_geo_TransformStreamListenerFactory.create = function(delegates) {
	return new com_ibm_rave_core_geo_TransformStreamListenerFactory(delegates);
};

/**
 * A convenience method to create a TransformStreamListeners that is only interested in  transforming point geometry events.
 * @param (com.ibm.rave.core.geo.StreamListener) listener the listener to wrap
 * @param (com.ibm.rave.core.internal.geo.DelegatingStreamListener.StreamPointStateHandler) handler the point state handler
 * @return (com.ibm.rave.core.geo.TransformStreamListener)  the newly created TransformStreamListener
 */
/** @expose */ 
com_ibm_rave_core_geo_TransformStreamListenerFactory.transformPoint = function(listener, handler) {
	var delegates = {};
	delegates["point"] = handler;
	return new com_ibm_rave_core_internal_geo_TransformStreamListenerImpl(listener, delegates);
};


// $source: com/ibm/rave/core/internal/geo/ProjectionMutatorImpl
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/geo/InvertibleProjectionImpl (runtime) // new
//@import com/ibm/rave/core/internal/geo/ProjectionImpl (runtime) // new
/**
 */
var com_ibm_rave_core_internal_geo_ProjectionMutatorImpl = com_ibm_rave_core_nativeImpl_Declare({

	//factory : null,

	//projection : null,

	_$functionClassMethod : function() {
		var _$self = function(args) {
			if (args !== null || arguments.length > 1){
				args = Array.prototype.slice.call(arguments);
			}
			{
				var projector = _$self.factory.apply(_$self.factory, args);
				if (!_$self.projection) {
					if (projector.invert) {
						_$self.projection = new com_ibm_rave_core_internal_geo_InvertibleProjectionImpl();
					} else {
						_$self.projection = new com_ibm_rave_core_internal_geo_ProjectionImpl();
					}
				}
				return com_ibm_rave_core_internal_geo_ProjectionMutatorImpl.internalMutate(_$self.projection, projector);
			}
		};
		return _$self;
	},

	constructor : function(factory) {
		this.factory = factory;
	}
});

com_ibm_rave_core_internal_geo_ProjectionMutatorImpl.internalMutate = function(projection, projector) {
	projection.pointProjector = projector;
	return projection.reset();
};

com_ibm_rave_core_internal_geo_ProjectionMutatorImpl.newProjectionMutator = function(factory) {
	return new com_ibm_rave_core_internal_geo_ProjectionMutatorImpl(factory);
};


// $source: com/ibm/rave/core/internal/geo/ProjectionImpl
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare, bind
//@import com/ibm/rave/core/internal/geo/ResampleStreamListenerFactory (runtime) // new
//@import com/ibm/rave/core/internal/geo/ClipUtil (runtime) // newClipCircleStreamListenerFactory, newClipExtentStreamListenerFactory, newAntimeridianClipLineStreamListenerFactory
//@import com/ibm/rave/core/internal/geo/SphericalRotation (runtime) // compose, rotation
//@import com/ibm/rave/core/geo/TransformStreamListenerFactory (static) // transformPoint
//@import com/ibm/rave/core/internal/geo/ProjectionMutatorImpl (static) // newProjectionMutator
/**
 */
var com_ibm_rave_core_internal_geo_ProjectionImpl = com_ibm_rave_core_nativeImpl_Declare({

	//clipAngleValue : null,

	//clipExtentValue : null,

	//pointProjector : null,

	//rotator : null,

	//projectResample : null,

	//preclip : null,

	//postclip : null,

	//streamListener : null,

	//projectRotate : null,

	x : 480, y : 250, λ : 0, φ : 0, δλ : 0, δφ : 0, δγ : 0,

	k : 150, δx : 0, δy : 0,

	_$functionClassMethod : function() {
		var _$self = function(point) {
			var p = _$self.projectRotate(point[0] * 0.017453292519943295, point[1] * 0.017453292519943295);
			return [p[0] * _$self.k + _$self.δx, _$self.δy - p[1] * _$self.k];
		};
		return _$self;
	},

	constructor : function() {
		var self = this;
		this.projectResample = new com_ibm_rave_core_internal_geo_ResampleStreamListenerFactory(function(x, y, z) {
			var result = self.pointProjector(x, y);
			return [result[0] * self.k + self.δx, self.δy - result[1] * self.k];
		});
		this.preclip = com_ibm_rave_core_internal_geo_ClipUtil.newAntimeridianClipLineStreamListenerFactory();
	},

	/** @expose */ 
	supportInversion : function() {
		return false;
	},

	/** @expose */ 
	supportStreaming : function() {
		return true;
	},

	rotate$0 : function() {
		return [this.δλ * 57.29577951308232, this.δφ * 57.29577951308232, this.δγ * 57.29577951308232];
	},

	rotate$1 : function(rotation) {
		this.δλ = rotation[0] % 360 * 0.017453292519943295;
		this.δφ = rotation[1] % 360 * 0.017453292519943295;
		this.δγ = rotation.length > 2 ? rotation[2] % 360 * 0.017453292519943295 : 0;
		return this.reset();
	},

	center$0 : function() {
		return [this.λ * 57.29577951308232, this.φ * 57.29577951308232];
	},

	center$1 : function(c) {
		this.λ = c[0] % 360 * 0.017453292519943295;
		this.φ = c[1] % 360 * 0.017453292519943295;
		return this.reset();
	},

	translate$0 : function() {
		return [this.x, this.y];
	},

	translate$1 : function(t) {
		this.x = + (t[0]);
		this.y = + (t[1]);
		return this.reset();
	},

	scale$0 : function() {
		return this.k;
	},

	scale$1 : function(s) {
		this.k = + (s);
		return this.reset();
	},

	clipAngle$0 : function() {
		return this.clipAngleValue;
	},

	clipAngle$1 : function(a) {
		if (a == null) {
			this.clipAngleValue = null;
			this.preclip = com_ibm_rave_core_internal_geo_ClipUtil.newAntimeridianClipLineStreamListenerFactory();
		} else {
			this.preclip = com_ibm_rave_core_internal_geo_ClipUtil.newClipCircleStreamListenerFactory((this.clipAngleValue = + (a)) * 0.017453292519943295);
		}
		return this.invalidate();
	},

	clipExtent$0 : function() {
		return this.clipExtentValue;
	},

	clipExtent$1 : function(e) {
		this.clipExtentValue = e;
		if (e) {
			this.postclip = com_ibm_rave_core_internal_geo_ClipUtil.newClipExtentStreamListenerFactory(e[0][0], e[0][1], e[1][0], e[1][1]);
		} else {
			this.postclip = null;
		}
		return this.invalidate();
	},

	precision$0 : function() {
		return this.projectResample.precision$1();
	},

	precision$1 : function(p) {
		this.projectResample.precision$0(p);
		return this;
	},

	/** @expose */ 
	stream : com_ibm_rave_core_nativeImpl_Declare.bind(function(listener) {
		if (this.streamListener) {
			this.streamListener.valid = false;
		}
		this.streamListener = com_ibm_rave_core_internal_geo_ProjectionImpl.projectionRadians(this.preclip(this.rotator, this.projectResample(this.postclip ? this.postclip(listener) : listener)));
		this.streamListener.valid = true;
		return this.streamListener;
	}),

	/**
	 * @return (com.ibm.rave.core.geo.PointProjector)  the project
	 */
	getPointProjector : function() {
		return this.pointProjector;
	},

	/**
	 * @param (com.ibm.rave.core.geo.PointProjector) project  the project to set
	 */
	setPointProjector : function(project) {
		this.pointProjector = project;
	},

	reset : function() {
		this.projectRotate = com_ibm_rave_core_internal_geo_SphericalRotation.compose(this.rotator = com_ibm_rave_core_internal_geo_SphericalRotation.rotation(this.δλ, this.δφ, this.δγ), this.pointProjector);
		var center = this.pointProjector(this.λ, this.φ);
		this.δx = this.x - center[0] * this.k;
		this.δy = this.y + center[1] * this.k;
		return this.invalidate();
	},

	invalidate : function() {
		if (this.streamListener) {
			this.streamListener.valid = false;
			this.streamListener = null;
		}
		return this;
	},

	/** @expose */ 
	rotate : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.rotate$0();
		}
		return this.rotate$1(a0);
	},

	/** @expose */ 
	center : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.center$0();
		}
		return this.center$1(a0);
	},

	/** @expose */ 
	translate : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.translate$0();
		}
		return this.translate$1(a0);
	},

	/** @expose */ 
	scale : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.scale$0();
		}
		return this.scale$1(a0);
	},

	/** @expose */ 
	clipAngle : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.clipAngle$0();
		}
		return this.clipAngle$1(a0);
	},

	/** @expose */ 
	clipExtent : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.clipExtent$0();
		}
		return this.clipExtent$1(a0);
	},

	/** @expose */ 
	precision : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.precision$0();
		}
		return this.precision$1(a0);
	}
});

com_ibm_rave_core_internal_geo_ProjectionImpl.projectionRadians = function(stream) {
	return com_ibm_rave_core_geo_TransformStreamListenerFactory.transformPoint(stream, function(x, y, z) {
		stream.point(x * 0.017453292519943295, y * 0.017453292519943295, NaN);
	});
};

com_ibm_rave_core_internal_geo_ProjectionImpl.newProjection = function(projetor) {
	return com_ibm_rave_core_internal_geo_ProjectionMutatorImpl.newProjectionMutator(function(args) {
		if (args !== null || arguments.length > 1){
			args = Array.prototype.slice.call(arguments);
		}
		{
			return projetor;
		}
	})();
};


// $source: com/ibm/rave/core/internal/geo/InvertibleProjectionImpl
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/geo/ProjectionImpl (loadtime) // superclass
/**
 */
var com_ibm_rave_core_internal_geo_InvertibleProjectionImpl = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_internal_geo_ProjectionImpl, {

	/** @expose */ 
	invert : function(point) {
		var p = (this.projectRotate).invert((point[0] - this.δx) / this.k, (this.δy - point[1]) / this.k);
		if (p) {
			return [p[0] * 57.29577951308232, p[1] * 57.29577951308232];
		}
		return undefined;
	},

	/** @expose */ 
	supportInversion : function() {
		return true;
	}
});


// $source: com/ibm/rave/core/internal/geo/MercatorProjection
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/geo/InvertibleProjectionImpl (loadtime) // superclass
//@import com/ibm/rave/core/internal/geo/ProjectionImpl (runtime)
/**
 */
var com_ibm_rave_core_internal_geo_MercatorProjection = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_internal_geo_InvertibleProjectionImpl, {

	clipAuto : false,

	init : function() {
		this.clipExtent$1(null);
	},

	/** @expose */ 
	scale$1 : function(scale) {
		com_ibm_rave_core_internal_geo_ProjectionImpl.prototype.scale$1.call(this, scale);
		if (this.clipAuto) {
			return this.clipExtent$1(null);
		}
		return this;
	},

	translate$1 : function(translate) {
		com_ibm_rave_core_internal_geo_ProjectionImpl.prototype.translate$1.call(this, translate);
		if (this.clipAuto) {
			return this.clipExtent$1(null);
		}
		return this;
	},

	clipExtent$1 : function(clipExtent) {
		com_ibm_rave_core_internal_geo_ProjectionImpl.prototype.clipExtent$1.call(this, clipExtent);
		if (this.clipAuto = !clipExtent) {
			var k = 3.141592653589793 * com_ibm_rave_core_internal_geo_ProjectionImpl.prototype.scale$0.call(this);
			var t = com_ibm_rave_core_internal_geo_ProjectionImpl.prototype.translate$0.call(this);
			com_ibm_rave_core_internal_geo_ProjectionImpl.prototype.clipExtent$1.call(this, [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]]);
		}
		return this;
	},

	clipExtent$0 : function() {
		if (this.clipAuto) {
			return null;
		}
		return com_ibm_rave_core_internal_geo_ProjectionImpl.prototype.clipExtent$0.call(this);
	},

	/** @expose */ 
	clipExtent : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.clipExtent$0();
		}
		return this.clipExtent$1(a0);
	}

	/**
	 * @param  pointProjector
	 * @param  projection
	 */
	//constructor : function() {}
});


// $source: com/ibm/rave/core/internal/geo/TransverseMercatorProjectionFactory
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare anonymous, declare
//@import com/ibm/rave/core/geo/InvertiblePointProjector (runtime)
//@import com/ibm/rave/core/internal/geo/TransverseMercatorProjection (runtime) // new
//@import com/ibm/rave/core/internal/geo/ProjectionMutatorImpl (runtime) // internalMutate
/**
 */
var com_ibm_rave_core_internal_geo_TransverseMercatorProjectionFactory = com_ibm_rave_core_nativeImpl_Declare({

	/**
	 * @expose  
	 */
	raw : null,

	_$functionClassMethod : function() {
		var _$self = function() {
			var m = new com_ibm_rave_core_internal_geo_TransverseMercatorProjection();
			com_ibm_rave_core_internal_geo_ProjectionMutatorImpl.internalMutate(m, _$self.raw);
			m.init();
			return m;
		};
		return _$self;
	},

	constructor : function() {
		this.raw = new (com_ibm_rave_core_nativeImpl_Declare({

			_$functionClassMethod : function() {
				var _$self = function(λ, φ) {
					return [Math.log(Math.tan(3.141592653589793 / 4 + φ / 2)), -λ];
				};
				return _$self;
			},

			supportInversion : function() {
				return true;
			},

			invert : function(x, y) {
				return [-y, 2 * Math.atan(Math.exp(x)) - 1.5707963267948966];
			}

		}))();
	},

	/** @expose */ 
	getRaw : function() {
		return this.raw;
	}

	/**
	 */
	//constructor : function() {}
});

com_ibm_rave_core_internal_geo_TransverseMercatorProjectionFactory.INSTANCE = new com_ibm_rave_core_internal_geo_TransverseMercatorProjectionFactory();

// $source: com/ibm/rave/core/internal/geo/TransverseMercatorProjection
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/geo/MercatorProjection (loadtime) // superclass
//@import com/ibm/rave/core/internal/geo/ProjectionImpl (runtime)
/**
 */
var com_ibm_rave_core_internal_geo_TransverseMercatorProjection = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_internal_geo_MercatorProjection, {

	init : function() {
		com_ibm_rave_core_internal_geo_MercatorProjection.prototype.init.call(this);
		com_ibm_rave_core_internal_geo_ProjectionImpl.prototype.rotate$1.call(this, [0.0, 0.0, 90.0]);
	},

	rotate$0 : function() {
		var r = com_ibm_rave_core_internal_geo_ProjectionImpl.prototype.rotate$0.call(this);
		return [r[0], r[1], r[2] - 90];
	},

	rotate$1 : function(r) {
		return com_ibm_rave_core_internal_geo_ProjectionImpl.prototype.rotate$1.call(this, [r[0], r[1], r.length > 2 ? r[2] + 90 : 90]);
	},

	center$0 : function() {
		var c = com_ibm_rave_core_internal_geo_ProjectionImpl.prototype.center$0.call(this);
		return [c[1], -c[0]];
	},

	center$1 : function(c) {
		return com_ibm_rave_core_internal_geo_ProjectionImpl.prototype.center$1.call(this, [-c[1], c[0]]);
	},

	/** @expose */ 
	rotate : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.rotate$0();
		}
		return this.rotate$1(a0);
	},

	/** @expose */ 
	center : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.center$0();
		}
		return this.center$1(a0);
	}

	/**
	 * @param  rawPointProjector
	 */
	//constructor : function() {}
});


// $source: com/ibm/rave/core/internal/geo/PlaneProjectionFactoryImpl
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare anonymous, declare
//@import com/ibm/rave/core/internal/geo/InvertibleProjectionImpl (runtime) // new
//@import com/ibm/rave/core/internal/geo/ProjectionMutatorImpl (runtime) // internalMutate
//@import com/ibm/rave/core/internal/geo/AzimuthalPointProjectorFactory (runtime) // AzimuthalPointProjectorFactory
//@import com/ibm/rave/core/geo/InvertiblePointProjector (runtime)
//@import com/ibm/rave/core/internal/math/Trigonometry (runtime) // acos, sinci
/**
 */
var com_ibm_rave_core_internal_geo_PlaneProjectionFactoryImpl = com_ibm_rave_core_nativeImpl_Declare({

	/**
	 * @expose  
	 */
	raw : null,

	_$functionClassMethod : function() {
		var _$self = function() {
			var projection = new com_ibm_rave_core_internal_geo_InvertibleProjectionImpl();
			com_ibm_rave_core_internal_geo_ProjectionMutatorImpl.internalMutate(projection, _$self.raw);
			return projection;
		};
		return _$self;
	},

	/**
	 */
	constructor : function(projector) {
		this.raw = projector;
	},

	/** @expose */ 
	getRaw : function() {
		return this.raw;
	}
});

com_ibm_rave_core_internal_geo_PlaneProjectionFactoryImpl.newAzimuthalEqualAreaProjectionFactory = function() {
	var projector = com_ibm_rave_core_internal_geo_AzimuthalPointProjectorFactory.INSTANCE(function(x) {
		return Math.sqrt(2 / (1 + x));
	}, function(x) {
		return 2 * Math.asin(x / 2);
	});
	return new com_ibm_rave_core_internal_geo_PlaneProjectionFactoryImpl(projector);
};

com_ibm_rave_core_internal_geo_PlaneProjectionFactoryImpl.newAzimuthalEquidistantProjectionFactory = function() {
	var projector = com_ibm_rave_core_internal_geo_AzimuthalPointProjectorFactory.INSTANCE(function(x) {
		var c = Math.acos(x);
		return (c) ? c / Math.sin(c) : c;
	}, function(x) {
		return x;
	});
	return new com_ibm_rave_core_internal_geo_PlaneProjectionFactoryImpl(projector);
};

com_ibm_rave_core_internal_geo_PlaneProjectionFactoryImpl.newEquirectangularProjectionFactory = function() {
	var projector = new (com_ibm_rave_core_nativeImpl_Declare({

		_$functionClassMethod : function() {
			var _$self = function(λ, φ) {
				return [λ, φ];
			};
			return _$self;
		},

		supportInversion : function() {
			return true;
		},

		invert : function(x, y) {
			return [x, y];
		}

	}))();
	return new com_ibm_rave_core_internal_geo_PlaneProjectionFactoryImpl(projector);
};

com_ibm_rave_core_internal_geo_PlaneProjectionFactoryImpl.newGnomonicProjectionFactory = function() {
	var projector = com_ibm_rave_core_internal_geo_AzimuthalPointProjectorFactory.INSTANCE(function(x) {
		return 1 / x;
	}, function(x) {
		return Math.atan(x);
	});
	return new com_ibm_rave_core_internal_geo_PlaneProjectionFactoryImpl(projector);
};

com_ibm_rave_core_internal_geo_PlaneProjectionFactoryImpl.newOrthographicProjectionFactory = function() {
	var projector = com_ibm_rave_core_internal_geo_AzimuthalPointProjectorFactory.INSTANCE(function(x) {
		return 1;
	}, function(x) {
		return Math.asin(x);
	});
	return new com_ibm_rave_core_internal_geo_PlaneProjectionFactoryImpl(projector);
};

com_ibm_rave_core_internal_geo_PlaneProjectionFactoryImpl.newStereographicProjectionFactory = function() {
	var projector = com_ibm_rave_core_internal_geo_AzimuthalPointProjectorFactory.INSTANCE(function(x) {
		return 1 / (1 + x);
	}, function(x) {
		return 2 * Math.atan(x);
	});
	return new com_ibm_rave_core_internal_geo_PlaneProjectionFactoryImpl(projector);
};

com_ibm_rave_core_internal_geo_PlaneProjectionFactoryImpl.newWinkelTripelProjectionFactory = function() {
	var projector = new (com_ibm_rave_core_nativeImpl_Declare({

		_$functionClassMethod : function() {
			var _$self = function(λ, φ) {
				var λ2 = λ / 2;
				var cosφ = Math.cos(φ), sincia = com_ibm_rave_core_internal_math_Trigonometry.sinci(com_ibm_rave_core_internal_math_Trigonometry.acos(cosφ * Math.cos(λ2)));
				var a = 2 * cosφ * Math.sin(λ2) * sincia;
				var b = Math.sin(φ) * sincia;
				return [(a + λ / 1.5707963267948966) / 2, (b + φ) / 2];
			};
			return _$self;
		},

		supportInversion : function() {
			return true;
		},

		invert : function(x, y) {
			var λ = x, φ = y, i = 25, δλ, δφ;
			do {
				δλ = δφ = 0;
				var cosφ = Math.cos(φ), sinφ = Math.sin(φ), sin_2φ = Math.sin(2 * φ), sin2φ = sinφ * sinφ, cos2φ = cosφ * cosφ, sinλ = Math.sin(λ), cosλ_2 = Math.cos(λ / 2), sinλ_2 = Math.sin(λ / 2), sin2λ_2 = sinλ_2 * sinλ_2, C = 1 - cos2φ * cosλ_2 * cosλ_2, F, E = (C != 0) ? com_ibm_rave_core_internal_math_Trigonometry.acos(cosφ * cosλ_2) * Math.sqrt(F = 1 / C) : (F = 0);
				var fx = .5 * (2 * E * cosφ * sinλ_2 + λ / 1.5707963267948966) - x, fy = .5 * (E * sinφ + φ) - y, δxδλ = .5 * F * (cos2φ * sin2λ_2 + E * cosφ * cosλ_2 * sin2φ) + .5 / 1.5707963267948966, δxδφ = F * (sinλ * sin_2φ / 4 - E * sinφ * sinλ_2), δyδλ = .125 * F * (sin_2φ * sinλ_2 - E * sinφ * cos2φ * sinλ), δyδφ = .5 * F * (sin2φ * cosλ_2 + E * sin2λ_2 * cosφ) + .5, denominator = δxδφ * δyδλ - δyδφ * δxδλ;
				δλ = (fy * δxδφ - fx * δyδφ) / denominator;
				δφ = (fx * δyδλ - fy * δxδλ) / denominator;
				λ -= δλ;
				φ -= δφ;
			} while ((Math.abs(δλ) > 1.0E-6 || Math.abs(δφ) > 1.0E-6) && --i > 0);
			return [λ, φ];
		}

	}))();
	return new com_ibm_rave_core_internal_geo_PlaneProjectionFactoryImpl(projector);
};


// $source: com/ibm/rave/core/internal/geo/AzimuthalPointProjectorFactory
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare anonymous, declare
//@import com/ibm/rave/core/geo/InvertiblePointProjector (runtime)
/**
 */
var com_ibm_rave_core_internal_geo_AzimuthalPointProjectorFactory = com_ibm_rave_core_nativeImpl_Declare({

	_$functionClassMethod : function() {
		var _$self = function(args) {
			if (args !== null || arguments.length > 1){
				args = Array.prototype.slice.call(arguments);
			}
			{
				var scale = args[0];
				var angle = args[1];
				return new (com_ibm_rave_core_nativeImpl_Declare({

					_$functionClassMethod : function() {
						var _$self = function(λ, φ) {
							var cosλ = Math.cos(λ), cosφ = Math.cos(φ), k = scale(cosλ * cosφ);
							return [k * cosφ * Math.sin(λ), k * Math.sin(φ)];
						};
						return _$self;
					},

					supportInversion : function() {
						return true;
					},

					invert : function(x, y) {
						var ρ = Math.sqrt(x * x + y * y), c = angle(ρ), sinc = Math.sin(c), cosc = Math.cos(c);
						return [Math.atan2(x * sinc, ρ * cosc), Math.asin((ρ) ? y * sinc / ρ : ρ)];
					}

				}))();
			}
		};
		return _$self;
	}

	//constructor : function() {}
});

com_ibm_rave_core_internal_geo_AzimuthalPointProjectorFactory.INSTANCE = new com_ibm_rave_core_internal_geo_AzimuthalPointProjectorFactory();

// $source: com/ibm/rave/core/internal/geo/ConicProjectionFactoryImpl
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare anonymous, declare
//@import com/ibm/rave/core/internal/geo/ConicProjectionImpl (runtime) // new
//@import com/ibm/rave/core/geo/InvertiblePointProjector (runtime)
//@import com/ibm/rave/core/internal/math/Trigonometry (runtime) // asin, sgn
//@import com/ibm/rave/core/internal/geo/MercatorPlaneProjectionFactory (runtime) // MercatorPlaneProjectionFactory
/**
 */
var com_ibm_rave_core_internal_geo_ConicProjectionFactoryImpl = com_ibm_rave_core_nativeImpl_Declare({

	/**
	 * @expose  
	 */
	raw : null,

	_$functionClassMethod : function() {
		var _$self = function() {
			return new com_ibm_rave_core_internal_geo_ConicProjectionImpl(_$self.raw);
		};
		return _$self;
	},

	/**
	 */
	constructor : function(factory) {
		this.raw = factory;
	},

	/** @expose */ 
	getRaw : function() {
		return this.raw;
	}
});

com_ibm_rave_core_internal_geo_ConicProjectionFactoryImpl.newConicEqualAreaProjectionFactory = function() {
	var factory = function(args) {
		if (args !== null || arguments.length > 1){
			args = Array.prototype.slice.call(arguments);
		}
		{
			var φ0 = args[0];
			var φ1 = args[1];
			var sinφ0 = Math.sin(φ0), n = (sinφ0 + Math.sin(φ1)) / 2, C = 1 + sinφ0 * (2 * n - sinφ0), ρ0 = Math.sqrt(C) / n;
			return new (com_ibm_rave_core_nativeImpl_Declare({

				_$functionClassMethod : function() {
					var _$self = function(λ, φ) {
						var _λ = λ;
						var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;
						return [ρ * Math.sin(_λ *= n), ρ0 - ρ * Math.cos(_λ)];
					};
					return _$self;
				},

				supportInversion : function() {
					return true;
				},

				invert : function(x, y) {
					var ρ0_y = ρ0 - y;
					return [Math.atan2(x, ρ0_y) / n, com_ibm_rave_core_internal_math_Trigonometry.asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n))];
				}

			}))();
		}
	};
	return new com_ibm_rave_core_internal_geo_ConicProjectionFactoryImpl(factory);
};

com_ibm_rave_core_internal_geo_ConicProjectionFactoryImpl.newConicEquidistantProjectionFactory = function() {
	var factory = function(args) {
		if (args !== null || arguments.length > 1){
			args = Array.prototype.slice.call(arguments);
		}
		{
			var φ0 = args[0];
			var φ1 = args[1];
			var cosφ0 = Math.cos(φ0), n = φ0 == φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0), G = cosφ0 / n + φ0;
			if (Math.abs(n) < 1.0E-6) {
				return new (com_ibm_rave_core_nativeImpl_Declare({

					_$functionClassMethod : function() {
						var _$self = function(λ, φ) {
							return [λ, φ];
						};
						return _$self;
					},

					supportInversion : function() {
						return true;
					},

					invert : function(x, y) {
						return [x, y];
					}

				}))();
			}
			return new (com_ibm_rave_core_nativeImpl_Declare({

				_$functionClassMethod : function() {
					var _$self = function(λ, φ) {
						var ρ = G - φ;
						return [ρ * Math.sin(n * λ), G - ρ * Math.cos(n * λ)];
					};
					return _$self;
				},

				supportInversion : function() {
					return true;
				},

				invert : function(x, y) {
					var ρ0_y = G - y;
					return [Math.atan2(x, ρ0_y) / n, G - com_ibm_rave_core_internal_math_Trigonometry.sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y)];
				}

			}))();
		}
	};
	return new com_ibm_rave_core_internal_geo_ConicProjectionFactoryImpl(factory);
};

com_ibm_rave_core_internal_geo_ConicProjectionFactoryImpl.newConicConformalProjectionFactory = function() {
	var factory = function(args) {
		if (args !== null || arguments.length > 1){
			args = Array.prototype.slice.call(arguments);
		}
		{
			var φ0 = args[0];
			var φ1 = args[1];
			var cosφ0 = Math.cos(φ0), n = φ0 == φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(Math.tan(3.141592653589793 / 4 + φ1 / 2) / Math.tan(3.141592653589793 / 4 + φ0 / 2)), F = cosφ0 * Math.pow(Math.tan(3.141592653589793 / 4 + φ0 / 2), n) / n;
			if (!((n))) {
				return com_ibm_rave_core_internal_geo_MercatorPlaneProjectionFactory.INSTANCE.raw;
			}
			return new (com_ibm_rave_core_nativeImpl_Declare({

				_$functionClassMethod : function() {
					var _$self = function(λ, φ) {
						var _φ = φ;
						if (F > 0) {
							if (_φ < -1.5707963267948966 + 1.0E-6) {
								_φ = -1.5707963267948966 + 1.0E-6;
							}
						} else {
							if (_φ > 1.5707963267948966 - 1.0E-6) {
								_φ = 1.5707963267948966 - 1.0E-6;
							}
						}
						var ρ = F / Math.pow(Math.tan(3.141592653589793 / 4 + _φ / 2), n);
						return [ρ * Math.sin(n * λ), F - ρ * Math.cos(n * λ)];
					};
					return _$self;
				},

				supportInversion : function() {
					return true;
				},

				invert : function(x, y) {
					var ρ0_y = F - y, ρ = com_ibm_rave_core_internal_math_Trigonometry.sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);
					return [Math.atan2(x, ρ0_y) / n, 2 * Math.atan(Math.pow(F / ρ, 1 / n)) - 1.5707963267948966];
				}

			}))();
		}
	};
	return new com_ibm_rave_core_internal_geo_ConicProjectionFactoryImpl(factory);
};


// $source: com/ibm/rave/core/internal/geo/ConicProjectionImpl
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/geo/InvertibleProjectionImpl (loadtime) // superclass
//@import com/ibm/rave/core/internal/geo/ProjectionMutatorImpl (runtime) // internalMutate
/**
 */
var com_ibm_rave_core_internal_geo_ConicProjectionImpl = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_internal_geo_InvertibleProjectionImpl, {

	//rawPointProjectorFactory : null,

	φ0 : 0, φ1 : 0,

	/**
	 */
	constructor : function(rawPointProjectorFactory) {
		this.φ0 = 0;
		this.φ1 = 3.141592653589793 / 3;
		this.rawPointProjectorFactory = rawPointProjectorFactory;
		var projector = rawPointProjectorFactory(this.φ0, this.φ1);
		com_ibm_rave_core_internal_geo_ProjectionMutatorImpl.internalMutate(this, projector);
	},

	parallels$0 : function() {
		return [this.φ0 / 3.141592653589793 * 180, this.φ1 / 3.141592653589793 * 180];
	},

	parallels$1 : function(p) {
		var projector = this.rawPointProjectorFactory(this.φ0 = p[0] * 3.141592653589793 / 180, this.φ1 = p[1] * 3.141592653589793 / 180);
		com_ibm_rave_core_internal_geo_ProjectionMutatorImpl.internalMutate(this, projector);
		return this;
	},

	/** @expose */ 
	parallels : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.parallels$0();
		}
		return this.parallels$1(a0);
	}
});


// $source: com/ibm/rave/core/internal/geo/Stream
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/nativeImpl/arrays/ES6Map (runtime) // create
/**
 * An object that converts a GeoJSON input object to a stream: a series of method calls on a stream listener. Basically it reads the passed GeoJSON object and invokes the relevant callback on the listener informing it of its current "state" (i.e., which  portion of the GeoJSON it is currently reading and the relevant values if any) While both features and geometry objects are supported as input, the stream interface only describes the geometry,  and thus additional feature properties are not visible to listeners.
 */
var com_ibm_rave_core_internal_geo_Stream = com_ibm_rave_core_nativeImpl_Declare({

	/**
	 * Starts the streaming process by reading the passed GeoJSON object and invoking the pertinent listener method  as it traverses GeoJSON object's features, geometry and sub objects, e.g., point, sphere etc.
	 * @param (Object) json the JSON object to read and stream. If null, then no streaming will occur
	 * @param (com.ibm.rave.core.geo.StreamListener) listener the listener to inform of what's being read from the JSON object. If null,then no streaming will occur
	 * @see (com.ibm.rave.core.geo.StreamListener) StreamListener
	 */
	stream : function(json, listener) {
		if (json && listener) {
			var handler = com_ibm_rave_core_internal_geo_Stream.handlers.get(json["type"]);
			if (handler) {
				handler(json, listener);
			}
		}
	}

	//constructor : function() {}
});

com_ibm_rave_core_internal_geo_Stream.createAndInit = function() {
	var _handlers = com_ibm_rave_core_nativeImpl_arrays_ES6Map.create();
	_handlers.set("FeatureCollection", function(featureCollection, listener) {
		var features = featureCollection["features"];
		if (features) {
			for (var i = 0, n = features.length; i < n; ++i) {
				var feature = features[i];
				if (feature) {
					var geometry = feature["geometry"];
					if (geometry) {
						var handler = com_ibm_rave_core_internal_geo_Stream.handlers.get(geometry["type"]);
						if (handler) {
							handler(geometry, listener);
						}
					}
				}
			}
		}
	});
	_handlers.set("Feature", function(feature, listener) {
		var geometry = feature["geometry"];
		if (geometry) {
			var handler = com_ibm_rave_core_internal_geo_Stream.handlers.get(geometry["type"]);
			if (handler) {
				handler(geometry, listener);
			}
		}
	});
	_handlers.set("Sphere", function(json, listener) {
		listener.sphere();
	});
	_handlers.set("Point", function(json, listener) {
		var coordinates = json["coordinates"];
		if (coordinates) {
			if (coordinates.length == 2) {
				listener.point(+ (coordinates[0]), + (coordinates[1]), NaN);
			} else if (coordinates.length == 3) {
				listener.point(+ (coordinates[0]), + (coordinates[1]), + (coordinates[2]));
			}
		}
	});
	_handlers.set("MultiPoint", function(json, listener) {
		var coordinatesList = json["coordinates"];
		if (coordinatesList) {
			var n = coordinatesList.length;
			var i = -1;
			while (++i < n) {
				var coordinates = coordinatesList[i];
				if (coordinates) {
					if (coordinates.length == 2) {
						listener.point(+ (coordinates[0]), + (coordinates[1]), NaN);
					} else if (coordinates.length == 3) {
						listener.point(+ (coordinates[0]), + (coordinates[1]), + (coordinates[2]));
					}
				}
			}
		}
	});
	_handlers.set("LineString", function(json, listener) {
		var coordinatesList = json["coordinates"];
		if (coordinatesList) {
			com_ibm_rave_core_internal_geo_Stream.streamLine(coordinatesList, listener, 0);
		}
	});
	_handlers.set("MultiLineString", function(json, listener) {
		var coordinatesList = json["coordinates"];
		if (coordinatesList) {
			var n = coordinatesList.length;
			var i = -1;
			while (++i < n) {
				var coordinates = coordinatesList[i];
				if (coordinates) {
					com_ibm_rave_core_internal_geo_Stream.streamLine(coordinates, listener, 0);
				}
			}
		}
	});
	_handlers.set("Polygon", function(json, listener) {
		var coordinatesList = json["coordinates"];
		if (coordinatesList) {
			com_ibm_rave_core_internal_geo_Stream.streamPolygon(coordinatesList, listener);
		}
	});
	_handlers.set("MultiPolygon", function(json, listener) {
		var coordinatesList = json["coordinates"];
		if (coordinatesList) {
			var n = coordinatesList.length;
			var i = -1;
			while (++i < n) {
				var coordinates = coordinatesList[i];
				if (coordinates) {
					com_ibm_rave_core_internal_geo_Stream.streamPolygon(coordinates, listener);
				}
			}
		}
	});
	_handlers.set("GeometryCollection", function(json, listener) {
		var geometries = json["geometries"];
		if (geometries) {
			var i = -1, n = geometries.length;
			while (++i < n) {
				var geometry = geometries[i];
				if (geometry) {
					var handler = com_ibm_rave_core_internal_geo_Stream.handlers.get(geometry["type"]);
					if (handler) {
						handler(geometry, listener);
					}
				}
			}
		}
	});
	return _handlers;
};

com_ibm_rave_core_internal_geo_Stream.streamLine = function(coordinatesList, listener, closed) {
	var i = -1;
	var n = coordinatesList.length - closed;
	listener.lineStart();
	while (++i < n) {
		var coordinates = coordinatesList[i];
		if (coordinates) {
			if (coordinates.length == 2) {
				listener.point(+ (coordinates[0]), + (coordinates[1]), NaN);
			} else if (coordinates.length == 3) {
				listener.point(+ (coordinates[0]), + (coordinates[1]), + (coordinates[2]));
			}
		}
	}
	listener.lineEnd();
};

com_ibm_rave_core_internal_geo_Stream.streamPolygon = function(coordinatesList, listener) {
	var i = -1;
	var n = coordinatesList.length;
	listener.polygonStart();
	while (++i < n) {
		var coordList = coordinatesList[i];
		if (coordList) {
			com_ibm_rave_core_internal_geo_Stream.streamLine(coordList, listener, 1);
		}
	}
	listener.polygonEnd();
};

/**
 * The singleton instance 
 */
com_ibm_rave_core_internal_geo_Stream.INSTANCE = new com_ibm_rave_core_internal_geo_Stream();
com_ibm_rave_core_internal_geo_Stream.handlers = com_ibm_rave_core_internal_geo_Stream.createAndInit();

// $source: com/ibm/rave/core/internal/geo/SphericalArea
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/math/Adder (runtime) // new
//@import com/ibm/rave/core/internal/geo/DelegatingStreamListener (runtime) // new
//@import com/ibm/rave/core/geo/Geo (runtime) // Geo
/**
 */
var com_ibm_rave_core_internal_geo_SphericalArea = com_ibm_rave_core_nativeImpl_Declare({

	//areaRingSum : null,

	//areaStreamListener : null,

	//sphere : null,

	//polygonStart : null,

	//polygonEnd : null,

	//point : null,

	//nextPoint : null,

	//lineEnd : null,

	//areaRingStart : null,

	λ00 : 0, φ00 : 0, λ0 : 0, cosφ0 : 0, sinφ0 : 0,

	areaSum : 0,

	constructor : function() {
		this.areaRingSum = new com_ibm_rave_core_internal_math_Adder();
		this.areaStreamListener = new com_ibm_rave_core_internal_geo_DelegatingStreamListener();
				/**
		 */
		{
			var self = this;
			this.sphere = function() {
				self.areaSum += 4 * 3.141592653589793;
			};
			this.polygonStart = function() {
				self.areaRingSum.reset();
				self.areaStreamListener.lineStartDelegate = self.areaRingStart;
			};
			this.polygonEnd = function() {
				var area = 2 * self.areaRingSum.valueOf();
				self.areaSum += (area < 0) ? 4 * 3.141592653589793 + area : area;
				self.areaStreamListener.lineStartDelegate = null;
				self.areaStreamListener.lineEndDelegate = null;
				self.areaStreamListener.pointDelegate = null;
			};
			this.point = function(λ, φ, z) {
				var _φ = φ;
				self.λ0 = (self.λ00 = λ) * 0.017453292519943295;
				self.cosφ0 = Math.cos(_φ = (self.φ00 = _φ) * 0.017453292519943295 / 2 + 3.141592653589793 / 4);
				self.sinφ0 = Math.sin(_φ);
				self.areaStreamListener.pointDelegate = self.nextPoint;
			};
			this.nextPoint = function(λ, φ, z) {
				var _λ = λ * 0.017453292519943295;
				var _φ = φ * 0.017453292519943295 / 2 + 3.141592653589793 / 4;
				var dλ = _λ - self.λ0;
				var sdλ = (dλ >= 0) ? 1 : -1;
				var adλ = sdλ * dλ;
				var cosφ = Math.cos(_φ);
				var sinφ = Math.sin(_φ);
				var k = self.sinφ0 * sinφ;
				var u = self.cosφ0 * cosφ + k * Math.cos(adλ);
				var v = k * sdλ * Math.sin(adλ);
				self.areaRingSum.add(Math.atan2(v, u));
				self.λ0 = _λ;
				self.cosφ0 = cosφ;
				self.sinφ0 = sinφ;
			};
			this.lineEnd = function() {
				self.nextPoint(self.λ00, self.φ00, NaN);
			};
			this.areaRingStart = function() {
				self.λ00 = self.φ00 = self.λ0 = self.cosφ0 = self.sinφ0 = 0;
				self.areaStreamListener.pointDelegate = self.point;
				self.areaStreamListener.lineEndDelegate = self.lineEnd;
			};
			this.areaStreamListener.sphereDelegate = this.sphere;
			this.areaStreamListener.polygonStartDelegate = this.polygonStart;
			this.areaStreamListener.polygonEndDelegate = this.polygonEnd;
		}
	},

	/**
	 * Getter method for the Adder object used by this SphericalArea object
	 * @return (com.ibm.rave.core.internal.math.Adder)  the Adder 
	 */
	getAreaRingSum : function() {
		return this.areaRingSum;
	},

	/**
	 * Getter method for the stream listener object used by this SphericalArea object
	 * @return (com.ibm.rave.core.geo.StreamListener)  the stream listener
	 */
	getAreaStreamListener : function() {
		return this.areaStreamListener;
	},

	/**
	 * Returns the spherical area of the specified feature in steradians.  See also path.area, which computes the projected area on the Cartesian plane
	 * @param (Object) json the JSON object containing the feature whose area is computed
	 * @return (double) the area is steradians (The unit of solid angle)
	 */
	calculateArea : function(json) {
		this.areaSum = 0;
		com_ibm_rave_core_geo_Geo.INSTANCE.stream(json, this.areaStreamListener);
		return this.areaSum;
	}
});


// $source: com/ibm/rave/core/internal/geo/SphericalBounds
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/geo/SphericalArea (runtime) // new
//@import com/ibm/rave/core/internal/geo/DelegatingStreamListener (runtime) // new
//@import com/ibm/rave/core/geo/Geo (runtime) // Geo
//@import com/ibm/rave/core/internal/geo/CartesianUtil (runtime) // cartesianNormalize, cartesianCross, cartesian
//@import com/ibm/rave/core/internal/geo/SphericalUtil (runtime) // spherical
/**
 */
var com_ibm_rave_core_internal_geo_SphericalBounds = com_ibm_rave_core_nativeImpl_Declare({

	//p0 : null,

	//range : null,

	//ranges : null,

	//sphericalArea : null,

	//areaStreamListener : null,

	//boundsStreamListener : null,

	//rangeComparator : null,

	//point : null,

	//linePoint : null,

	//lineStart : null,

	//lineEnd : null,

	//ringPoint : null,

	//ringStart : null,

	//ringEnd : null,

	//polygonStart : null,

	//polygonEnd : null,

	λ0 : 0, φ0 : 0, λ1 : 0, φ1 : 0, λ_ : 0, λ__ : 0, φ__ : 0, dλSum : 0,

	constructor : function() {
		this.sphericalArea = new com_ibm_rave_core_internal_geo_SphericalArea();
		this.areaStreamListener = this.sphericalArea.areaStreamListener;
		this.boundsStreamListener = new com_ibm_rave_core_internal_geo_DelegatingStreamListener();
		this.rangeComparator = function(a, b) {
			var diff = a[0] - b[0];
			if (diff > 0) {
				return 1;
			}
			if (diff < 0) {
				return -1;
			}
			return 0;
		};
		{
			var self = this;
			this.point = function(λ, φ, z) {
				self.range = [self.λ0 = λ, self.λ1 = λ];
				self.ranges.push(self.range);
				if (φ < self.φ0) {
					self.φ0 = φ;
				}
				if (φ > self.φ1) {
					self.φ1 = φ;
				}
			};
			this.linePoint = function(λ, φ, z) {
				var p = com_ibm_rave_core_internal_geo_CartesianUtil.cartesian([λ * 0.017453292519943295, φ * 0.017453292519943295]);
				if (self.p0) {
					var normal = com_ibm_rave_core_internal_geo_CartesianUtil.cartesianCross(self.p0, p);
					var equatorial = [normal[1], -normal[0], 0];
					var inflection = com_ibm_rave_core_internal_geo_CartesianUtil.cartesianCross(equatorial, normal);
					com_ibm_rave_core_internal_geo_CartesianUtil.cartesianNormalize(inflection);
					inflection = com_ibm_rave_core_internal_geo_SphericalUtil.spherical(inflection);
					var dλ = λ - self.λ_;
					var s = dλ > 0 ? 1 : -1;
					var λi = inflection[0] * 57.29577951308232 * s;
					var antimeridian = Math.abs(dλ) > 180;
					if (antimeridian ^ (s * self.λ_ < λi && λi < s * λ)) {
						var φi = inflection[1] * 57.29577951308232;
						if (φi > self.φ1) {
							self.φ1 = φi;
						}
					} else {
						λi = (λi + 360) % 360 - 180;
						if (antimeridian ^ (s * self.λ_ < λi && λi < s * λ)) {
							var φi = -inflection[1] * 57.29577951308232;
							if (φi < self.φ0) {
								self.φ0 = φi;
							}
						} else {
							if (φ < self.φ0) {
								self.φ0 = φ;
							}
							if (φ > self.φ1) {
								self.φ1 = φ;
							}
						}
					}
					if (antimeridian) {
						if (λ < self.λ_) {
							if (self.angle(self.λ0, λ) > self.angle(self.λ0, self.λ1)) {
								self.λ1 = λ;
							}
						} else {
							if (self.angle(λ, self.λ1) > self.angle(self.λ0, self.λ1)) {
								self.λ0 = λ;
							}
						}
					} else {
						if (self.λ1 >= self.λ0) {
							if (λ < self.λ0) {
								self.λ0 = λ;
							}
							if (λ > self.λ1) {
								self.λ1 = λ;
							}
						} else {
							if (λ > self.λ_) {
								if (self.angle(self.λ0, λ) > self.angle(self.λ0, self.λ1)) {
									self.λ1 = λ;
								}
							} else {
								if (self.angle(λ, self.λ1) > self.angle(self.λ0, self.λ1)) {
									self.λ0 = λ;
								}
							}
						}
					}
				} else {
					self.point(λ, φ, NaN);
				}
				self.p0 = p;
				self.λ_ = λ;
			};
			this.lineStart = function() {
				self.boundsStreamListener.pointDelegate = self.linePoint;
			};
			this.lineEnd = function() {
				self.range[0] = self.λ0;
				self.range[1] = self.λ1;
				self.boundsStreamListener.pointDelegate = self.point;
				self.p0 = null;
			};
			this.ringPoint = function(λ, φ, z) {
				if (self.p0) {
					var dλ = λ - self.λ_;
					self.dλSum += (Math.abs(dλ) > 180) ? dλ + (dλ > 0 ? 360 : -360) : dλ;
				} else {
					self.λ__ = λ;
					self.φ__ = φ;
				}
				self.areaStreamListener.point(λ, φ, NaN);
				self.linePoint(λ, φ, NaN);
			};
			this.ringStart = function() {
				self.areaStreamListener.lineStart();
			};
			this.ringEnd = function() {
				self.ringPoint(self.λ__, self.φ__, NaN);
				self.areaStreamListener.lineEnd();
				if (Math.abs(self.dλSum) > 1.0E-6) {
					self.λ0 = -(self.λ1 = 180);
				}
				self.range[0] = self.λ0;
				self.range[1] = self.λ1;
				self.p0 = null;
			};
			this.polygonStart = function() {
				self.boundsStreamListener.pointDelegate = self.ringPoint;
				self.boundsStreamListener.lineStartDelegate = self.ringStart;
				self.boundsStreamListener.lineEndDelegate = self.ringEnd;
				self.dλSum = 0;
				self.areaStreamListener.polygonStart();
			};
			this.polygonEnd = function() {
				self.areaStreamListener.polygonEnd();
				self.boundsStreamListener.pointDelegate = self.point;
				self.boundsStreamListener.lineStartDelegate = self.lineStart;
				self.boundsStreamListener.lineEndDelegate = self.lineEnd;
				if (self.sphericalArea.areaRingSum.valueOf() < 0) {
					self.λ0 = -(self.λ1 = 180);
					self.φ0 = -(self.φ1 = 90);
				} else if (self.dλSum > 1.0E-6) {
					self.φ1 = 90;
				} else if (self.dλSum < -1.0E-6) {
					self.φ0 = -90;
				}
				self.range[0] = self.λ0;
				self.range[1] = self.λ1;
			};
			this.boundsStreamListener.pointDelegate = this.point;
			this.boundsStreamListener.lineStartDelegate = this.lineStart;
			this.boundsStreamListener.lineEndDelegate = this.lineEnd;
			this.boundsStreamListener.polygonStartDelegate = this.polygonStart;
			this.boundsStreamListener.polygonEndDelegate = this.polygonEnd;
		}
	},

	withinRange : function(x, range) {
		return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
	},

	angle : function(λ0, λ1) {
		var _λ1 = λ1;
		return (_λ1 -= λ0) < 0 ? _λ1 + 360 : _λ1;
	},

	/**
	 * Returns the spherical bounding box for the specified feature.  The bounding box is represented by a two-dimensional array: [​[left, bottom], [right, top]​],  where left is the minimum longitude, bottom is the minimum latitude, right is maximum longitude,  and top is the maximum latitude.  See also path.bounds, which computes the projected bounding box on the Cartesian plane.
	 * @param (Object) feature the GeoJSON object containing the feature whose bounds are computed
	 * @return (double[][])  the spherical bounding box
	 */
	calculateBounds : function(feature) {
		this.φ1 = this.λ1 = -(this.λ0 = this.φ0 = Infinity);
		this.ranges = [];
		com_ibm_rave_core_geo_Geo.INSTANCE.stream(feature, this.boundsStreamListener);
		var n = this.ranges.length;
		if (n > 0) {
			this.ranges.sort(this.rangeComparator);
			var b;
			var a = this.ranges[0];
			var merged = [];
			merged.push(a);
			for (var i = 1; i < n; ++i) {
				b = this.ranges[i];
				if (this.withinRange(b[0], a) || this.withinRange(b[1], a)) {
					if (this.angle(a[0], b[1]) > this.angle(a[0], a[1])) {
						a[1] = b[1];
					}
					if (this.angle(b[0], a[1]) > this.angle(a[0], a[1])) {
						a[0] = b[0];
					}
				} else {
					merged.push(a = b);
				}
			}
			var best = -Infinity, dλ;
			n = merged.length - 1;
			a = merged[n];
			for (var i = 0; i <= n; a = b, ++i) {
				b = merged[i];
				if ((dλ = this.angle(a[1], b[0])) > best) {
					best = dλ;
					this.λ0 = b[0];
					this.λ1 = a[1];
				}
			}
		}
		this.ranges = null;
		this.range = null;
		return (this.λ0 == Infinity || this.φ0 == Infinity) ? com_ibm_rave_core_internal_geo_SphericalBounds.NULL_BOUNDS : [[this.λ0, this.φ0], [this.λ1, this.φ1]];
	}
});

com_ibm_rave_core_internal_geo_SphericalBounds.NULL_BOUNDS = [[NaN, NaN], [NaN, NaN]];

// $source: com/ibm/rave/core/internal/geo/SphericalCentroid
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/geo/DelegatingStreamListener (runtime) // new
//@import com/ibm/rave/core/geo/Geo (runtime) // Geo
//@import com/ibm/rave/core/internal/math/Trigonometry (runtime) // acos, asin
/**
 */
var com_ibm_rave_core_internal_geo_SphericalCentroid = com_ibm_rave_core_nativeImpl_Declare({

	//centroidStreamListener : null,

	//centroidPoint : null,

	//centroidLineStart : null,

	//centroidLineStart_point : null,

	//centroidLineStart_nextPoint : null,

	//centroidLineEnd : null,

	//polygonStart : null,

	//polygonEnd : null,

	//centroidRingStart : null,

	//centroidRingStart_point : null,

	//centroidRingStart_nextPoint : null,

	//centroidRingStart_lineEnd : null,

	centroidW0 : 0, centroidW1 : 0, centroidX0 : 0, centroidY0 : 0, centroidZ0 : 0, centroidX1 : 0, centroidY1 : 0, centroidZ1 : 0, centroidX2 : 0, centroidY2 : 0, centroidZ2 : 0,

	ringStart_λ00 : 0, ringStart_φ00 : 0, ringStart_x0 : 0, ringStart_y0 : 0, ringStart_z0 : 0,

	lineStart_x0 : 0, lineStart_y0 : 0, lineStart_z0 : 0,

	constructor : function() {
		this.centroidStreamListener = new com_ibm_rave_core_internal_geo_DelegatingStreamListener();
				/**
		 */
		{
			var self = this;
			this.centroidPoint = function(λ, φ, z) {
				var _λ = λ;
				var _φ = φ;
				_λ *= 0.017453292519943295;
				var cosφ = Math.cos(_φ *= 0.017453292519943295);
				self.centroidPointXYZ(cosφ * Math.cos(_λ), cosφ * Math.sin(_λ), Math.sin(_φ));
			};
			this.centroidLineStart = function() {
				self.lineStart_x0 = self.lineStart_y0 = self.lineStart_z0 = 0;
				self.centroidStreamListener.pointDelegate = self.centroidLineStart_point;
			};
			this.centroidLineStart_point = function(λ, φ, z) {
				var _λ = λ;
				var _φ = φ;
				_λ *= 0.017453292519943295;
				var cosφ = Math.cos(_φ *= 0.017453292519943295);
				self.lineStart_x0 = cosφ * Math.cos(_λ);
				self.lineStart_y0 = cosφ * Math.sin(_λ);
				self.lineStart_z0 = Math.sin(_φ);
				self.centroidStreamListener.pointDelegate = self.centroidLineStart_nextPoint;
				self.centroidPointXYZ(self.lineStart_x0, self.lineStart_y0, self.lineStart_z0);
			};
			this.centroidLineStart_nextPoint = function(λ, φ, zz) {
				var _λ = λ;
				var _φ = φ;
				_λ *= 0.017453292519943295;
				var cosφ = Math.cos(_φ *= 0.017453292519943295);
				var x = cosφ * Math.cos(_λ);
				var y = cosφ * Math.sin(_λ);
				var z = Math.sin(_φ);
				var temp;
				var w = Math.atan2(Math.sqrt((temp = self.lineStart_y0 * z - self.lineStart_z0 * y) * temp + (temp = self.lineStart_z0 * x - self.lineStart_x0 * z) * temp + (temp = self.lineStart_x0 * y - self.lineStart_y0 * x) * temp), self.lineStart_x0 * x + self.lineStart_y0 * y + self.lineStart_z0 * z);
				self.centroidW1 += w;
				self.centroidX1 += w * (self.lineStart_x0 + (self.lineStart_x0 = x));
				self.centroidY1 += w * (self.lineStart_y0 + (self.lineStart_y0 = y));
				self.centroidZ1 += w * (self.lineStart_z0 + (self.lineStart_z0 = z));
				self.centroidPointXYZ(self.lineStart_x0, self.lineStart_y0, self.lineStart_z0);
			};
			this.centroidLineEnd = function() {
				self.centroidStreamListener.pointDelegate = self.centroidPoint;
			};
			this.polygonStart = function() {
				self.centroidStreamListener.lineStartDelegate = self.centroidRingStart;
			};
			this.polygonEnd = function() {
				self.centroidStreamListener.lineStartDelegate = self.centroidLineStart;
			};
			this.centroidRingStart = function() {
				self.ringStart_λ00 = self.ringStart_φ00 = self.ringStart_x0 = self.ringStart_y0 = self.ringStart_z0 = 0;
				self.centroidStreamListener.pointDelegate = self.centroidRingStart_point;
				self.centroidStreamListener.lineEndDelegate = self.centroidRingStart_lineEnd;
			};
			this.centroidRingStart_point = function(λ, φ, z) {
				var _λ = λ;
				var _φ = φ;
				self.ringStart_λ00 = _λ;
				self.ringStart_φ00 = _φ;
				self.centroidStreamListener.pointDelegate = self.centroidRingStart_nextPoint;
				_λ *= 0.017453292519943295;
				var cosφ = Math.cos(_φ *= 0.017453292519943295);
				self.ringStart_x0 = cosφ * Math.cos(_λ);
				self.ringStart_y0 = cosφ * Math.sin(_λ);
				self.ringStart_z0 = Math.sin(_φ);
				self.centroidPointXYZ(self.ringStart_x0, self.ringStart_y0, self.ringStart_z0);
			};
			this.centroidRingStart_nextPoint = function(λ, φ, zz) {
				var _λ = λ;
				var _φ = φ;
				_λ *= 0.017453292519943295;
				var cosφ = Math.cos(_φ *= 0.017453292519943295), x = cosφ * Math.cos(_λ), y = cosφ * Math.sin(_λ), z = Math.sin(_φ), cx = self.ringStart_y0 * z - self.ringStart_z0 * y, cy = self.ringStart_z0 * x - self.ringStart_x0 * z, cz = self.ringStart_x0 * y - self.ringStart_y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = self.ringStart_x0 * x + self.ringStart_y0 * y + self.ringStart_z0 * z;
				var v = (m == 0 || isNaN(m)) ? m : -com_ibm_rave_core_internal_math_Trigonometry.acos(u) / m;
				var w = Math.atan2(m, u);
				self.centroidX2 += v * cx;
				self.centroidY2 += v * cy;
				self.centroidZ2 += v * cz;
				self.centroidW1 += w;
				self.centroidX1 += w * (self.ringStart_x0 + (self.ringStart_x0 = x));
				self.centroidY1 += w * (self.ringStart_y0 + (self.ringStart_y0 = y));
				self.centroidZ1 += w * (self.ringStart_z0 + (self.ringStart_z0 = z));
				self.centroidPointXYZ(self.ringStart_x0, self.ringStart_y0, self.ringStart_z0);
			};
			this.centroidRingStart_lineEnd = function() {
				self.centroidRingStart_nextPoint(self.ringStart_λ00, self.ringStart_φ00, NaN);
				self.centroidStreamListener.lineEndDelegate = self.centroidLineEnd;
				self.centroidStreamListener.pointDelegate = self.centroidPoint;
			};
			this.centroidStreamListener.pointDelegate = this.centroidPoint;
			this.centroidStreamListener.lineStartDelegate = this.centroidLineStart;
			this.centroidStreamListener.lineEndDelegate = this.centroidLineEnd;
			this.centroidStreamListener.polygonStartDelegate = this.polygonStart;
			this.centroidStreamListener.polygonEndDelegate = this.polygonEnd;
		}
	},

	centroidPointXYZ : function(x, y, z) {
		++this.centroidW0;
		this.centroidX0 += (x - this.centroidX0) / this.centroidW0;
		this.centroidY0 += (y - this.centroidY0) / this.centroidW0;
		this.centroidZ0 += (z - this.centroidZ0) / this.centroidW0;
	},

	/**
	 * Returns the spherical centroid of the specified feature.  See also path.centroid, which computes the projected centroid on the Cartesian plane.
	 * @param (Object) feature the GeoJSON object containing the feature whose area is computed
	 * @return (double[]) the point representing the centroid
	 */
	calculateCentroid : function(feature) {
		this.centroidW0 = this.centroidW1 = this.centroidX0 = this.centroidY0 = this.centroidZ0 = this.centroidX1 = this.centroidY1 = this.centroidZ1 = this.centroidX2 = this.centroidY2 = this.centroidZ2 = 0;
		this.ringStart_λ00 = this.ringStart_φ00 = this.ringStart_x0 = this.ringStart_y0 = this.ringStart_z0 = 0;
		this.lineStart_x0 = this.lineStart_y0 = this.lineStart_z0 = 0;
		com_ibm_rave_core_geo_Geo.INSTANCE.stream(feature, this.centroidStreamListener);
		var x = this.centroidX2;
		var y = this.centroidY2;
		var z = this.centroidZ2;
		var m = x * x + y * y + z * z;
		if (m < 1.0E-12) {
			x = this.centroidX1;
			y = this.centroidY1;
			z = this.centroidZ1;
			if (this.centroidW1 < 1.0E-6) {
				x = this.centroidX0;
				y = this.centroidY0;
				z = this.centroidZ0;
			}
			m = x * x + y * y + z * z;
			if (m < 1.0E-12) {
				return com_ibm_rave_core_internal_geo_SphericalCentroid.NULL_CENTROID;
			}
		}
		return [Math.atan2(y, x) * 57.29577951308232, com_ibm_rave_core_internal_math_Trigonometry.asin(z / Math.sqrt(m)) * 57.29577951308232];
	}
});

com_ibm_rave_core_internal_geo_SphericalCentroid.NULL_CENTROID = [NaN, NaN];

// $source: com/ibm/rave/core/internal/geo/SphericalLength
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/geo/DelegatingStreamListener (runtime) // new
//@import com/ibm/rave/core/geo/Geo (runtime) // Geo
/**
 */
var com_ibm_rave_core_internal_geo_SphericalLength = com_ibm_rave_core_nativeImpl_Declare({

	//lengthStreamListener : null,

	//lineStart : null,

	//lineEnd : null,

	//point : null,

	//nextPoint : null,

	λ0 : 0, sinφ0 : 0, cosφ0 : 0,

	lengthSum : 0,

	constructor : function() {
		this.lengthStreamListener = new com_ibm_rave_core_internal_geo_DelegatingStreamListener();
				/**
		 */
		{
			var self = this;
			this.lineStart = function() {
				self.λ0 = self.sinφ0 = self.cosφ0 = 0;
				self.lengthStreamListener.pointDelegate = self.point;
				self.lengthStreamListener.lineEndDelegate = self.lineEnd;
			};
			this.lineEnd = function() {
				self.lengthStreamListener.pointDelegate = null;
				self.lengthStreamListener.lineEndDelegate = null;
			};
			this.point = function(λ, φ, z) {
				var _φ = φ;
				self.λ0 = λ * 0.017453292519943295;
				self.sinφ0 = Math.sin(_φ *= 0.017453292519943295);
				self.cosφ0 = Math.cos(_φ);
				self.lengthStreamListener.pointDelegate = self.nextPoint;
			};
			this.nextPoint = function(λ, φ, z) {
				var _λ = λ;
				var _φ = φ;
				var sinφ = Math.sin(_φ *= 0.017453292519943295), cosφ = Math.cos(_φ), t = Math.abs((_λ *= 0.017453292519943295) - self.λ0), cosΔλ = Math.cos(t);
				self.lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = self.cosφ0 * sinφ - self.sinφ0 * cosφ * cosΔλ) * t), self.sinφ0 * sinφ + self.cosφ0 * cosφ * cosΔλ);
				self.λ0 = _λ;
				self.sinφ0 = sinφ;
				self.cosφ0 = cosφ;
			};
			this.lengthStreamListener.lineStartDelegate = this.lineStart;
		}
	},

	/**
	 * Returns the great-arc length of the specified feature in radians.  For polygons, returns the perimeter of the exterior ring plus that of any interior rings.
	 * @param (Object) feature the GeoJSON object containing the feature whose length is computed
	 * @return (double)  the great-arc length
	 */
	calculateLength : function(feature) {
		this.lengthSum = 0;
		com_ibm_rave_core_geo_Geo.INSTANCE.stream(feature, this.lengthStreamListener);
		return this.lengthSum;
	}
});


// $source: com/ibm/rave/core/internal/geo/SphericalInterpolation
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/math/Trigonometry (runtime) // haversin
var com_ibm_rave_core_internal_geo_SphericalInterpolation = com_ibm_rave_core_nativeImpl_Declare({


});

/**
 * Returns an interpolator given the two locations a and b.  Each location must be represented as a two-element array of [longitude, latitude].  The returned interpolator is a function which takes a single parameter t as input, where t ranges from 0 to 1.  A value of 0 returns the location a, while a value of 1 returns the location b.  Intermediate values interpolate from a to b along the spanning great arc.
 * @param (double[]) source the first location
 * @param (double[]) target the second location
 * @return (com.ibm.rave.core.interpolate.Interpolator)  the interpolator
 */
com_ibm_rave_core_internal_geo_SphericalInterpolation.newInterpolator = function(source, target) {
	var x0 = source[0] * 0.017453292519943295;
	var y0 = source[1] * 0.017453292519943295;
	var x1 = target[0] * 0.017453292519943295;
	var y1 = target[1] * 0.017453292519943295;
	var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(com_ibm_rave_core_internal_math_Trigonometry.haversin(y1 - y0) + cy0 * cy1 * com_ibm_rave_core_internal_math_Trigonometry.haversin(x1 - x0))), k = 1 / Math.sin(d);
	if ((d)) {
		return function(t) {
			var _t = t;
			var B = Math.sin(_t *= d) * k;
			var A = Math.sin(d - _t) * k;
			var x = A * kx0 + B * kx1;
			var y = A * ky0 + B * ky1;
			var z = A * sy0 + B * sy1;
			return [Math.atan2(y, x) * 57.29577951308232, Math.atan2(z, Math.sqrt(x * x + y * y)) * 57.29577951308232];
		};
	}
	return function(t) {
		return [x0 * 57.29577951308232, y0 * 57.29577951308232];
	};
};


// $source: com/ibm/rave/core/geo/CircleShapeGenerator
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/geo/GeoShapeGeneratorUtil (runtime) // newCircleInterpolator
//@import com/ibm/rave/core/internal/geo/SphericalRotation (runtime) // rotation
//@import com/ibm/rave/core/internal/geo/DelegatingStreamListener (runtime) // new
/**
 * A class that is used to build a GeoJSON Polygon geometry object approximating a circle.
 */
var com_ibm_rave_core_geo_CircleShapeGenerator = com_ibm_rave_core_nativeImpl_Declare({

	//originObject : null,

	//interpolator : null,

	precisionValue : 0,

	angleValue : 0,

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * Builds a GeoJSON Polygon approximating a circle.
		 * @param (java.lang.Object[]) originArgs arguments passed by the caller that will be passed to the originValueFunction 
		 * @return (Object)  the GeoJson geometry object
		 */
		function(originArgs) {
			if (originArgs !== null || arguments.length > 1){
				originArgs = Array.prototype.slice.call(arguments);
			}
			{
				var center = (typeof _$self.originObject === "function") ? (_$self.originObject).apply((_$self.originObject), originArgs) : _$self.originObject;
				var rotate = com_ibm_rave_core_internal_geo_SphericalRotation.rotation(-center[0] * 0.017453292519943295, -center[1] * 0.017453292519943295, 0);
				var ring = [];
				var coordinates = [];
				coordinates.push(ring);
				var listener = new com_ibm_rave_core_internal_geo_DelegatingStreamListener();
				listener.pointDelegate = function(x, y, z) {
					var invertedPoint = rotate.invert(x, y);
					invertedPoint[0] *= 57.29577951308232;
					invertedPoint[1] *= 57.29577951308232;
					ring.push((((invertedPoint))));
				};
				if (_$self.interpolator) {
					_$self.interpolator(null, null, 1, listener);
				}
				var json = {};
				json["type"] = "Polygon";
				json["coordinates"] = coordinates;
				return json;
			}
		};
		return _$self;
	},

	/**
	 * Return the current value of circle origin. Depending on how the client initialized this valuae, it could be either a simple x,y coordinates, or,a ValueFunction   The default is a point whose coordinates are [0,0]
	 * @return (Object) the current value of the circle origin
	 */
	origin$0 : function() {
		return this.originObject;
	},

	/**
	 * Sets the coordinates of the circle origin
	 * @param (double[]) originPoint the x and y coordinates to use for the circle origin value
	 * @return (com.ibm.rave.core.geo.CircleShapeGenerator)  this CircleShapeGenerator object itself
	 */
	origin$1 : function(originPoint) {
		this.originObject = originPoint;
		return this;
	},

	/**
	 * Sets a value function to be used to figure out the origin of this circle
	 * @param (com.ibm.rave.core.geo.CircleShapeGenerator.ValueFunction) originFn the value function used to get circle origin
	 * @return (com.ibm.rave.core.geo.CircleShapeGenerator)  this CircleShapeGenerator object itself
	 */
	origin$2 : function(originFn) {
		this.originObject = originFn;
		return this;
	},

	/**
	 * Returns the current angular radius of the circle in degrees The default value is 90°
	 * @return (double)  the angular radius of the circle in degrees
	 */
	angle$0 : function() {
		return this.angleValue;
	},

	/**
	 * Sets the angular radius of the circle in degrees
	 * @param (Object) x the value to set. The object could be either a Double or a string that parses to a Double number
	 * @return (com.ibm.rave.core.geo.CircleShapeGenerator)  the angular radius of the circle in degrees
	 */
	angle$1 : function(x) {
		this.interpolator = com_ibm_rave_core_internal_geo_GeoShapeGeneratorUtil.newCircleInterpolator((this.angleValue = + (x)) * 0.017453292519943295, this.precisionValue * 0.017453292519943295);
		return this;
	},

	/**
	 * Returns the current precision value in degrees, which defaults to 6° Precision value is used when interpolating circle segments. These interpolated  segments are inserted when a feature is clipped by the circle.
	 * @return (double)  the precision value
	 */
	precision$0 : function() {
		return this.precisionValue;
	},

	/**
	 * Sets the current precision value in degrees. Precision value is used when interpolating circle segments. These interpolated  segments are inserted when a feature is clipped by the circle.
	 * @return (com.ibm.rave.core.geo.CircleShapeGenerator)  this CircleShapeGenerator object itself
	 */
	precision$1 : function(x) {
		this.interpolator = com_ibm_rave_core_internal_geo_GeoShapeGeneratorUtil.newCircleInterpolator(this.angleValue * 0.017453292519943295, (this.precisionValue = + (x)) * 0.017453292519943295);
		return this;
	},

	/** @expose */ 
	origin : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.origin$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.origin$2(a0);
		}
		return this.origin$1(a0);
	},

	/** @expose */ 
	angle : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.angle$0();
		}
		return this.angle$1(a0);
	},

	/** @expose */ 
	precision : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.precision$0();
		}
		return this.precision$1(a0);
	}

	//constructor : function() {}
});

/**
 * Constructs and initialize the CircleShapeGenerator to default values
 * @return (com.ibm.rave.core.geo.CircleShapeGenerator)  the newly constructed CircleShapeGenerator object
 */
com_ibm_rave_core_geo_CircleShapeGenerator.newCircleShapeGenerator = function() {
	var circle = new com_ibm_rave_core_geo_CircleShapeGenerator();
	circle.precisionValue = 6;
	circle.originObject = com_ibm_rave_core_geo_CircleShapeGenerator.DEFAULT_ORIGIN;
	circle.angle(90);
	return circle;
};

com_ibm_rave_core_geo_CircleShapeGenerator.DEFAULT_ORIGIN = [0, 0];

// $source: com/ibm/rave/core/geo/GreatArcShapeGenerator
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/geo/SphericalUtil (runtime) // calculateDistance
/**
 * @deprecated  use {type: "LineString"} or Rave.geo.distance instead.
 */
var com_ibm_rave_core_geo_GreatArcShapeGenerator = com_ibm_rave_core_nativeImpl_Declare({

	//sourceObject : null,

	//targetObject : null,

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * Builds a GeoJSON LineString approximating a great arc.
		 * @param (java.lang.Object[]) pointsArgs The value of pointArgs depends on the type of source and target objects. By default, GreatArcShapeGenerator initializes the source and target object to a ValueFunction that expects a GreatArcPointsStruct as a parameter, therefore, if the client never changed the source and target objects then the pointsArgs must be of type GreatArcPointsStruct. If, however, the client changed the source and target objects, then the pointsArgs could be unnecessary iff the source and target points are arrays of doubles or, it would be whatever arguments the client's ValueFunction expects.  
		 * @return (Object)  the GeoJson geometry object
		 */
		function(pointsArgs) {
			if (pointsArgs !== null || arguments.length > 1){
				pointsArgs = Array.prototype.slice.call(arguments);
			}
			{
				var source = (typeof _$self.sourceObject === "function") ? (_$self.sourceObject).apply((_$self.sourceObject), pointsArgs) : _$self.sourceObject;
				var target = (typeof _$self.targetObject === "function") ? (_$self.targetObject).apply((_$self.targetObject), pointsArgs) : _$self.targetObject;
				var coordinates = [];
				coordinates.push((((source))));
				coordinates.push((((target))));
				var json = {};
				json["type"] = "LineString";
				json["coordinates"] = coordinates;
				return json;
			}
		};
		return _$self;
	},

	/**
	 */
	constructor : function() {
		this.sourceObject = function(pointsArgs) {
			if (pointsArgs !== null || arguments.length > 1){
				pointsArgs = Array.prototype.slice.call(arguments);
			}
			{
				return (pointsArgs[0]).source;
			}
		};
		this.targetObject = function(pointsArgs) {
			if (pointsArgs !== null || arguments.length > 1){
				pointsArgs = Array.prototype.slice.call(arguments);
			}
			{
				return (pointsArgs[0]).target;
			}
		};
	},

	/**
	 * Calculates the distance between the source and target points
	 * @param (java.lang.Object[]) pointsArgs The value of pointArgs depends on the type of source and target objects. By default, GreatArcShapeGenerator initializes the source and target object to a ValueFunction that expects a GreatArcPointsStruct as a parameter, therefore, if the client never changed the source and target objects then the pointsArgs must be of type GreatArcPointsStruct. If, however, the client changed the source and target objects, then the pointsArgs could be unnecessary iff the source and target points are arrays of doubles or, it would be whatever arguments the client's ValueFunction expects.  
	 * @return (double)  the distance between the source and target point
	 */
	/** @expose */ 
	distance : function(pointsArgs) {
		if (pointsArgs !== null || arguments.length > 1){
			pointsArgs = Array.prototype.slice.call(arguments);
		}
		{
			var source = (typeof this.sourceObject === "function") ? (this.sourceObject).apply((this.sourceObject), pointsArgs) : this.sourceObject;
			var target = (typeof this.targetObject === "function") ? (this.targetObject).apply((this.targetObject), pointsArgs) : this.targetObject;
			return com_ibm_rave_core_internal_geo_SphericalUtil.calculateDistance(source, target);
		}
	},

	/**
	 * Return the current value of source point. Depending on how the client initialized this value, it could be either a simple array with x,y coordinates, or,a ValueFunction The default is ValueFunction that expects a GreatArcPointsStruct as a parameter
	 * @return (Object) the current value of the source point
	 */
	source$0 : function() {
		return this.sourceObject;
	},

	/**
	 * Sets the coordinates of the source point
	 * @param (double[]) sourcePoint the x and y coordinates to use for the source point value
	 * @return (com.ibm.rave.core.geo.GreatArcShapeGenerator)  this GreatArcShapeGenerator object itself
	 */
	source$1 : function(sourcePoint) {
		this.sourceObject = sourcePoint;
		return this;
	},

	/**
	 * Sets a value function to be used to figure out the source point value of this great arc
	 * @param (com.ibm.rave.core.geo.GreatArcShapeGenerator.ValueFunction) sourceFn the value function used to get source point
	 * @return (com.ibm.rave.core.geo.GreatArcShapeGenerator)  this GreatArcShapeGenerator object itself
	 */
	source$2 : function(sourceFn) {
		this.sourceObject = sourceFn;
		return this;
	},

	/**
	 * Return the current value of target point. Depending on how the client initialized this value, it could be either a simple array with x,y coordinates, or,a ValueFunction The default is ValueFunction that expects a GreatArcPointsStruct as a parameter
	 * @return (Object) the current value of the target point
	 */
	target$0 : function() {
		return this.targetObject;
	},

	/**
	 * Sets the coordinates of the target point
	 * @param (double[]) targetPoint the x and y coordinates to use for the source point value
	 * @return (com.ibm.rave.core.geo.GreatArcShapeGenerator)  this GreatArcShapeGenerator object itself
	 */
	target$1 : function(targetPoint) {
		this.targetObject = targetPoint;
		return this;
	},

	/**
	 * Sets a value function to be used to figure out the target point value of this great arc
	 * @param (com.ibm.rave.core.geo.GreatArcShapeGenerator.ValueFunction) targetFn the value function used to get target point
	 * @return (com.ibm.rave.core.geo.GreatArcShapeGenerator)  this GreatArcShapeGenerator object itself
	 */
	target$2 : function(targetFn) {
		this.targetObject = targetFn;
		return this;
	},

	/**
	 * This function is deprecated and has no impact. The precision value is always zero
	 * @return (com.ibm.rave.core.geo.GreatArcShapeGenerator)  this GreatArcShapeGenerator object itself
	 * @deprecated
	 */
	precision$0 : function(x) {
		return this;
	},

	/**
	 * This function is deprecated. The precision value returned is always zero
	 * @return (double)  the precision value always zero
	 * @deprecated
	 */
	precision$1 : function() {
		return 0;
	},

	/** @expose */ 
	source : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.source$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.source$2(a0);
		}
		return this.source$1(a0);
	},

	/** @expose */ 
	target : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.target$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.target$2(a0);
		}
		return this.target$1(a0);
	},

	/** @expose */ 
	precision : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.precision$1();
		}
		return this.precision$0(a0);
	}
});

/**
 * Constructs a GreatArcShapeGenerator
 * @return (com.ibm.rave.core.geo.GreatArcShapeGenerator)  the newly constructed GreatArcShapeGenerator object
 */
com_ibm_rave_core_geo_GreatArcShapeGenerator.newGreatArcShapeGenerator = function() {
	return new com_ibm_rave_core_geo_GreatArcShapeGenerator();
};

com_ibm_rave_core_geo_GreatArcShapeGenerator.GreatArcPointsStruct = rave_externs["GreatArcPointsStruct"] = com_ibm_rave_core_nativeImpl_Declare({

	/** @expose */ 
	source : null,

	/** @expose */ 
	target : null
});


// $source: com/ibm/rave/core/geo/GraticuleShapeGenerator
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare, bind
//@import com/ibm/rave/core/Rave (runtime) // range
//@import com/ibm/rave/core/internal/geo/GeoShapeGeneratorUtil (runtime) // graticuleX, graticuleY
/**
 * A class that is used to build and MultiLineString geometry object representing all meridians and parallels for this graticule.
 */
var com_ibm_rave_core_geo_GraticuleShapeGenerator = com_ibm_rave_core_nativeImpl_Declare({

	//x : null, //y : null, //X : null, //Y : null,

	x1 : 0, x0 : 0, X1 : 0, X0 : 0, y1 : 0, y0 : 0, Y1 : 0, Y0 : 0, dx : 0, dy : 0, DX : 0, DY : 0, precisionValue : 0,

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * Builds a MultiLineString geometry object representing all meridians and parallels for this graticule.
		 * @return (Object)  the GeoJson geometry object
		 */
		function() {
			var coordinates = (_$self.generateLines());
			var json = {};
			json["type"] = "MultiLineString";
			json["coordinates"] = coordinates;
			return json;
		};
		return _$self;
	},

	generateLines : function() {
		var self = this;
		var array_X = com_ibm_rave_core_Rave.range(Math.ceil(this.X0 / this.DX) * this.DX, this.X1, this.DX).map(function(currentValue, index, array) {
			return self.X(+ (currentValue));
		});
		var array_Y = com_ibm_rave_core_Rave.range(Math.ceil(this.Y0 / this.DY) * this.DY, this.Y1, this.DY).map(function(currentValue, index, array) {
			return self.Y(+ (currentValue));
		});
		var array_x = com_ibm_rave_core_Rave.range(Math.ceil(this.x0 / this.dx) * this.dx, this.x1, this.dx).filter(function(currentValue, index, array) {
			return Math.abs(+ (currentValue) % self.DX) > 1.0E-6;
		}).map(function(currentValue, index, array) {
			return self.x(+ (currentValue));
		});
		var array_y = com_ibm_rave_core_Rave.range(Math.ceil(this.y0 / this.dy) * this.dy, this.y1, this.dy).filter(function(currentValue, index, array) {
			return Math.abs(+ (currentValue) % self.DY) > 1.0E-6;
		}).map(function(currentValue, index, array) {
			return self.y(+ (currentValue));
		});
		return array_X.concat(array_Y, array_x, array_y);
	},

	/**
	 * Returns an array of LineString geometry objects, one for each meridian or parallel for this graticule.
	 * @return (Array)  the array of LineString geometry objects
	 */
	/** @expose */ 
	lines : com_ibm_rave_core_nativeImpl_Declare.bind(function() {
		return this.generateLines().map(function(currentValue, index, array) {
			var coordinates = (currentValue);
			var json = {};
			json["type"] = "LineString";
			json["coordinates"] = coordinates;
			return json;
		});
	}),

	/**
	 * Returns a Polygon geometry object representing the outline of this graticule, i.e. along the meridians and parallels defining its extent.
	 * @return (Object)  the Polygon geometry object
	 */
	/** @expose */ 
	outline : com_ibm_rave_core_nativeImpl_Declare.bind(function() {
		var coords = this.X(this.X0).concat(this.Y(this.Y1).slice(1), this.X(this.X1).reverse().slice(1), this.Y(this.Y0).reverse().slice(1));
		var coordinates = [];
		coordinates.push((coords));
		var json = {};
		json["type"] = "Polygon";
		json["coordinates"] = coordinates;
		return json;
	}),

	/**
	 * Returns the current minor extent
	 * @return (Array)  the current minor extent
	 */
	extent$0 : function() {
		return this.minorExtent();
	},

	/**
	 * Sets the major and minor extents of this graticule.
	 * @param (Array) ext   the extent value to set
	 * @return (com.ibm.rave.core.geo.GraticuleShapeGenerator)  this GraticuleShapeGenerator object itself
	 */
	extent$1 : function(ext) {
		return this.majorExtent(ext).minorExtent(ext);
	},

	/**
	 * Returns the current major extent The default value of major extent is from [-180°, -90° + Trigonometry.ε] to [180°, 90° - Trigonometry.ε]
	 * @return (Array)  the current major extent
	 */
	majorExtent$0 : function() {
		return [[this.X0, this.Y0], [this.X1, this.Y1]];
	},

	/**
	 * Sets the major extent of this graticule
	 * @param (Array) ext the extent value to set
	 * @return (com.ibm.rave.core.geo.GraticuleShapeGenerator)  this GraticuleShapeGenerator object itself
	 */
	majorExtent$1 : function(ext) {
		this.X0 = + (ext[0][0]);
		this.X1 = + (ext[1][0]);
		this.Y0 = + (ext[0][1]);
		this.Y1 = + (ext[1][1]);
		if (this.X0 > this.X1) {
			var temp = this.X0;
			this.X0 = this.X1;
			this.X1 = temp;
		}
		if (this.Y0 > this.Y1) {
			var temp = this.Y0;
			this.Y0 = this.Y1;
			this.Y1 = temp;
		}
		return this.precision(this.precisionValue);
	},

	/**
	 * Returns the current minor extent The default value of minor extent is from [-180°, -80° - Trigonometry.ε] to [180°, 80° + Trigonometry.ε]
	 * @return (Array)  the current minor extent
	 */
	minorExtent$0 : function() {
		return [[this.x0, this.y0], [this.x1, this.y1]];
	},

	/**
	 * Sets the minor extent of this graticule
	 * @param (Array) ext the extent value to set
	 * @return (com.ibm.rave.core.geo.GraticuleShapeGenerator)  this GraticuleShapeGenerator object itself
	 */
	minorExtent$1 : function(ext) {
		this.x0 = + (ext[0][0]);
		this.x1 = + (ext[1][0]);
		this.y0 = + (ext[0][1]);
		this.y1 = + (ext[1][1]);
		if (this.x0 > this.x1) {
			var temp = this.x0;
			this.x0 = this.x1;
			this.x1 = temp;
		}
		if (this.y0 > this.y1) {
			var temp = this.y0;
			this.y0 = this.y1;
			this.y1 = temp;
		}
		return this.precision(this.precisionValue);
	},

	/**
	 * Returns the current minor step
	 * @return (Array)  the current minor step
	 */
	step$0 : function() {
		return this.minorStep();
	},

	/**
	 * Sets the major and minor step point (DX,DY) for this graticule
	 * @param (Array) s the step value to use
	 * @return (com.ibm.rave.core.geo.GraticuleShapeGenerator)  this GraticuleShapeGenerator object itself
	 */
	step$1 : function(s) {
		return this.majorStep(s).minorStep(s);
	},

	/**
	 * Returns the current major step The default value is [90°, 360°]
	 * @return (Array)  the current major step
	 */
	majorStep$0 : function() {
		return [this.DX, this.DY];
	},

	/**
	 * Sets the major step for this graticule
	 * @param (Array) s the step value to set
	 * @return (com.ibm.rave.core.geo.GraticuleShapeGenerator)  this GraticuleShapeGenerator object itself
	 */
	majorStep$1 : function(s) {
		this.DX = + (s[0]);
		this.DY = + (s[1]);
		return this;
	},

	/**
	 * Returns the current minor step The default value is [10°, 10°]
	 * @return (Array)  the current minor step
	 */
	minorStep$0 : function() {
		return [this.dx, this.dy];
	},

	/**
	 * Sets the minor step for this graticule
	 * @param (Array) s the step value to set
	 * @return (com.ibm.rave.core.geo.GraticuleShapeGenerator)  this GraticuleShapeGenerator object itself
	 */
	minorStep$1 : function(s) {
		this.dx = + (s[0]);
		this.dy = + (s[1]);
		return this;
	},

	/**
	 * Returns the current precision, which defaults to 2.5°
	 * @return (double)  the current precision
	 */
	precision$0 : function() {
		return this.precisionValue;
	},

	/**
	 * Sets the precision for this graticule, in degrees
	 * @param (double) p the precision value to set
	 * @return (com.ibm.rave.core.geo.GraticuleShapeGenerator)  this GraticuleShapeGenerator object itself
	 */
	precision$1 : function(p) {
		this.precisionValue = + (p);
		this.x = com_ibm_rave_core_internal_geo_GeoShapeGeneratorUtil.graticuleX(this.y0, this.y1, 90);
		this.y = com_ibm_rave_core_internal_geo_GeoShapeGeneratorUtil.graticuleY(this.x0, this.x1, this.precisionValue);
		this.X = com_ibm_rave_core_internal_geo_GeoShapeGeneratorUtil.graticuleX(this.Y0, this.Y1, 90);
		this.Y = com_ibm_rave_core_internal_geo_GeoShapeGeneratorUtil.graticuleY(this.X0, this.X1, this.precisionValue);
		return this;
	},

	/** @expose */ 
	extent : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.extent$0();
		}
		return this.extent$1(a0);
	},

	/** @expose */ 
	majorExtent : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.majorExtent$0();
		}
		return this.majorExtent$1(a0);
	},

	/** @expose */ 
	minorExtent : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.minorExtent$0();
		}
		return this.minorExtent$1(a0);
	},

	/** @expose */ 
	step : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.step$0();
		}
		return this.step$1(a0);
	},

	/** @expose */ 
	majorStep : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.majorStep$0();
		}
		return this.majorStep$1(a0);
	},

	/** @expose */ 
	minorStep : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.minorStep$0();
		}
		return this.minorStep$1(a0);
	},

	/** @expose */ 
	precision : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.precision$0();
		}
		return this.precision$1(a0);
	}

	//constructor : function() {}
});

/**
 * Constructs and initialize the GraticuleShapeGenerator to default values
 * @return (com.ibm.rave.core.geo.GraticuleShapeGenerator)  the newly constructed GraticuleShapeGenerator object
 */
com_ibm_rave_core_geo_GraticuleShapeGenerator.newGraticuleShapeGenerator = function() {
	var graticule = new com_ibm_rave_core_geo_GraticuleShapeGenerator();
	graticule.dx = 10;
	graticule.dy = 10;
	graticule.DX = 90;
	graticule.DY = 360;
	graticule.precisionValue = 2.5;
	graticule.majorExtent([[-180.0, -90.0 + 1.0E-6], [180.0, 90.0 - 1.0E-6]]);
	return graticule.minorExtent([[-180.0, -80.0 - 1.0E-6], [180.0, 80.0 + 1.0E-6]]);
};


// $source: com/ibm/rave/core/geo/ClipExtentStreamListenerTransform
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/geo/ClipUtil (runtime) // newClipExtentStreamListenerFactory
/**
 * A class representing a stream transform that implements axis-aligned rectangle clipping.  This is typically used to clip geometry to the viewport after projecting.
 */
var com_ibm_rave_core_geo_ClipExtentStreamListenerTransform = com_ibm_rave_core_nativeImpl_Declare({

	//transformListener : null,

	//clip : null,

	x0 : 0, y0 : 0, x1 : 0, y1 : 0,

	/**
	 * create the transformListener given a streamListener
	 * @param (com.ibm.rave.core.geo.StreamListener) listener
	 * @return (com.ibm.rave.core.geo.TransformStreamListener)  transformListener
	 */
	/** @expose */ 
	stream : function(listener) {
		if (this.transformListener) {
			this.transformListener.valid = false;
		}
		this.transformListener = this.clip(listener);
		this.transformListener.valid = true;
		return this.transformListener;
	},

	/**
	 * Sets the clip extent to the specified rectangle [​[x0, y0], [x1, y1]​]
	 * @param (Array) ext the upper and lower corners of the clipping rectangle to use
	 * @return (com.ibm.rave.core.geo.ClipExtentStreamListenerTransform)  the this clip extent transform object itself 
	 */
	extent$0 : function(ext) {
		this.clip = com_ibm_rave_core_internal_geo_ClipUtil.newClipExtentStreamListenerFactory(this.x0 = + (ext[0][0]), this.y0 = + (ext[0][1]), this.x1 = + (ext[1][0]), this.y1 = + (ext[1][1]));
		if (this.transformListener) {
			this.transformListener.valid = false;
			this.transformListener = null;
		}
		return this;
	},

	/**
	 * Returns the current clip extent, which defaults to [​[0, 0], [960, 500]​].
	 * @return (Array)  current clip extent
	 */
	extent$1 : function() {
		return [[this.x0, this.y0], [this.x1, this.y1]];
	},

	/** @expose */ 
	extent : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.extent$1();
		}
		return this.extent$0(a0);
	}

	/**
	 */
	//constructor : function() {}
});

/**
 * Create a new stream transform that implements axis-aligned rectangle clipping.  This is typically used to clip geometry to the viewport after projecting.
 * @return (com.ibm.rave.core.geo.ClipExtentStreamListenerTransform)  the newly created clip extent
 */
/** @expose */ 
com_ibm_rave_core_geo_ClipExtentStreamListenerTransform.newClipExtent = function() {
	var clipExtent = new com_ibm_rave_core_geo_ClipExtentStreamListenerTransform();
	return clipExtent.extent([[0.0, 0.0], [960.0, 500.0]]);
};


// $source: com/ibm/rave/core/internal/geo/AlbersUsaProjection
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/geo/ConicProjectionFactoryImpl (runtime) // newConicEqualAreaProjectionFactory
//@import com/ibm/rave/core/internal/geo/DelegatingStreamListener (runtime) // new
//@import com/ibm/rave/core/geo/StreamListener (runtime) // StreamListener
//@import com/ibm/rave/core/internal/geo/TransformStreamListenerImpl (runtime) // new
/**
 */
var com_ibm_rave_core_internal_geo_AlbersUsaProjection = com_ibm_rave_core_nativeImpl_Declare({

	//point : null,

	//lower48 : null, //alaska : null, //hawaii : null,

	//pointStream : null,

	//lower48Point : null, //alaskaPoint : null, //hawaiiPoint : null,

	_$functionClassMethod : function() {
		var _$self = function(coordinates) {
			var x = coordinates[0], y = coordinates[1];
			_$self.point = null;
			_$self.lower48Point(x, y, NaN);
			if (_$self.point) {
				return _$self.point;
			}
			_$self.alaskaPoint(x, y, NaN);
			if (_$self.point) {
				return _$self.point;
			}
			_$self.hawaiiPoint(x, y, NaN);
			return _$self.point;
		};
		return _$self;
	},

	/**
	 */
	constructor : function() {
		var self = this;
		this.lower48 = com_ibm_rave_core_internal_geo_AlbersUsaProjection.newAlbersProjection();
		var cea = com_ibm_rave_core_internal_geo_ConicProjectionFactoryImpl.newConicEqualAreaProjectionFactory()();
		cea.rotate([154.0, 0.0]).center([-2.0, 58.5]);
		cea.parallels([55.0, 65.0]);
		this.alaska = cea;
		cea = com_ibm_rave_core_internal_geo_ConicProjectionFactoryImpl.newConicEqualAreaProjectionFactory()();
		cea.rotate([157.0, 0.0]).center([-3.0, 19.9]);
		cea.parallels([8.0, 18.0]);
		this.hawaii = cea;
		this.pointStream = new com_ibm_rave_core_internal_geo_DelegatingStreamListener();
		this.pointStream.pointDelegate = function(x, y, z) {
			self.point = [x, y];
		};
	},

	rotate$0 : function() {
		throw new Error();
	},

	rotate$1 : function(rotation) {
		throw new Error();
	},

	center$0 : function() {
		throw new Error();
	},

	center$1 : function(c) {
		throw new Error();
	},

	clipAngle$0 : function() {
		throw new Error();
	},

	clipAngle$1 : function(a) {
		throw new Error();
	},

	clipExtent$0 : function() {
		throw new Error();
	},

	clipExtent$1 : function(e) {
		throw new Error();
	},

	/** @expose */ 
	invert : function(coordinates) {
		var k = this.lower48.scale();
		var t = this.lower48.translate();
		var x = (coordinates[0] - t[0]) / k;
		var y = (coordinates[1] - t[1]) / k;
		return (y >= .120 && y < .234 && x >= -.425 && x < -.214 ? this.alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? this.hawaii : this.lower48).invert(coordinates);
	},

	translate$0 : function() {
		return this.lower48.translate();
	},

	translate$1 : function(t) {
		var k = this.lower48.scale();
		var x = + (t[0]);
		var y = + (t[1]);
		this.lower48Point = this.lower48.translate(t).clipExtent([[x - .455 * k, y - .238 * k], [x + .455 * k, y + .238 * k]]).stream(this.pointStream).pointDelegate;
		this.alaskaPoint = this.alaska.translate([x - .307 * k, y + .201 * k]).clipExtent([[x - .425 * k + 1.0E-6, y + .120 * k + 1.0E-6], [x - .214 * k - 1.0E-6, y + .234 * k - 1.0E-6]]).stream(this.pointStream).pointDelegate;
		this.hawaiiPoint = this.hawaii.translate([x - .205 * k, y + .212 * k]).clipExtent([[x - .214 * k + 1.0E-6, y + .166 * k + 1.0E-6], [x - .115 * k - 1.0E-6, y + .234 * k - 1.0E-6]]).stream(this.pointStream).pointDelegate;
		return this;
	},

	scale$0 : function() {
		return this.lower48.scale();
	},

	scale$1 : function(s) {
		this.lower48.scale(s);
		this.alaska.scale(+ (s) * .35);
		this.hawaii.scale(s);
		return this.translate$1(this.lower48.translate());
	},

	precision$0 : function() {
		return this.lower48.precision();
	},

	precision$1 : function(p) {
		this.lower48.precision(p);
		this.alaska.precision(p);
		this.hawaii.precision(p);
		return this;
	},

	/** @expose */ 
	stream : function(listener) {
		var lower48Stream = this.lower48.stream(listener), alaskaStream = this.alaska.stream(listener), hawaiiStream = this.hawaii.stream(listener);
		var delegates = {};
		delegates["point"] = function(x, y, z) {
			lower48Stream.point(x, y, z);
			alaskaStream.point(x, y, z);
			hawaiiStream.point(x, y, z);
		};
		delegates["sphere"] = function() {
			lower48Stream.sphere();
			alaskaStream.sphere();
			hawaiiStream.sphere();
		};
		delegates["lineStart"] = function() {
			lower48Stream.lineStart();
			alaskaStream.lineStart();
			hawaiiStream.lineStart();
		};
		delegates["lineEnd"] = function() {
			lower48Stream.lineEnd();
			alaskaStream.lineEnd();
			hawaiiStream.lineEnd();
		};
		delegates[com_ibm_rave_core_geo_StreamListener.polygonStartHandler] = function() {
			lower48Stream.polygonStart();
			alaskaStream.polygonStart();
			hawaiiStream.polygonStart();
		};
		delegates["polygonEnd"] = function() {
			lower48Stream.polygonEnd();
			alaskaStream.polygonEnd();
			hawaiiStream.polygonEnd();
		};
		return new com_ibm_rave_core_internal_geo_TransformStreamListenerImpl(listener, delegates);
	},

	/** @expose */ 
	supportInversion : function() {
		return true;
	},

	/** @expose */ 
	supportStreaming : function() {
		return true;
	},

	/** @expose */ 
	rotate : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.rotate$0();
		}
		return this.rotate$1(a0);
	},

	/** @expose */ 
	center : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.center$0();
		}
		return this.center$1(a0);
	},

	/** @expose */ 
	clipAngle : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.clipAngle$0();
		}
		return this.clipAngle$1(a0);
	},

	/** @expose */ 
	clipExtent : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.clipExtent$0();
		}
		return this.clipExtent$1(a0);
	},

	/** @expose */ 
	translate : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.translate$0();
		}
		return this.translate$1(a0);
	},

	/** @expose */ 
	scale : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.scale$0();
		}
		return this.scale$1(a0);
	},

	/** @expose */ 
	precision : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.precision$0();
		}
		return this.precision$1(a0);
	}
});

com_ibm_rave_core_internal_geo_AlbersUsaProjection.newAlbersUsaProjection = function() {
	var a = new com_ibm_rave_core_internal_geo_AlbersUsaProjection();
	a.scale$1(1070);
	return a;
};

com_ibm_rave_core_internal_geo_AlbersUsaProjection.newAlbersProjection = function() {
	var cea = com_ibm_rave_core_internal_geo_ConicProjectionFactoryImpl.newConicEqualAreaProjectionFactory()();
	cea.rotate([96.0, 0.0]).center([-.6, 38.7]);
	cea.parallels([29.5, 45.5]).scale(1070);
	return cea;
};


// $source: com/ibm/rave/core/geo/Geo
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/RegistryService (loadtime) // superclass
//@import com/ibm/rave/core/internal/geo/MercatorPlaneProjectionFactory (runtime) // MercatorPlaneProjectionFactory
//@import com/ibm/rave/core/internal/geo/TransverseMercatorProjectionFactory (runtime) // TransverseMercatorProjectionFactory
//@import com/ibm/rave/core/internal/geo/PlaneProjectionFactoryImpl (runtime) // newAzimuthalEquidistantProjectionFactory, newAzimuthalEqualAreaProjectionFactory, newWinkelTripelProjectionFactory, newOrthographicProjectionFactory, newStereographicProjectionFactory, newGnomonicProjectionFactory, newEquirectangularProjectionFactory
//@import com/ibm/rave/core/internal/geo/ConicProjectionFactoryImpl (runtime) // newConicEqualAreaProjectionFactory, newConicConformalProjectionFactory, newConicEquidistantProjectionFactory
//@import com/ibm/rave/core/internal/geo/Stream (runtime) // Stream
//@import com/ibm/rave/core/internal/geo/SphericalArea (runtime) // new
//@import com/ibm/rave/core/internal/geo/SphericalBounds (runtime) // new
//@import com/ibm/rave/core/internal/geo/SphericalCentroid (runtime) // new
//@import com/ibm/rave/core/internal/geo/SphericalUtil (loadtime) // calculateDistance
//@import com/ibm/rave/core/internal/geo/SphericalLength (runtime) // new
//@import com/ibm/rave/core/internal/geo/SphericalInterpolation (loadtime) // newInterpolator
//@import com/ibm/rave/core/internal/geo/SphericalRotation (loadtime) // newRotator
//@import com/ibm/rave/core/geo/CircleShapeGenerator (loadtime) // newCircleShapeGenerator
//@import com/ibm/rave/core/geo/GreatArcShapeGenerator (loadtime) // newGreatArcShapeGenerator
//@import com/ibm/rave/core/geo/GraticuleShapeGenerator (loadtime) // newGraticuleShapeGenerator
//@import com/ibm/rave/core/geo/TransformStreamListenerFactory (loadtime) // create
//@import com/ibm/rave/core/geo/ClipExtentStreamListenerTransform (loadtime) // newClipExtent
//@import com/ibm/rave/core/internal/geo/ProjectionImpl (loadtime) // newProjection
//@import com/ibm/rave/core/internal/geo/ProjectionMutatorImpl (loadtime) // newProjectionMutator
//@import com/ibm/rave/core/internal/geo/AlbersUsaProjection (loadtime) // newAlbersUsaProjection, newAlbersProjection
//@import com/ibm/rave/core/internal/geo/GeoPathGeneratorImpl (runtime) // newGeoPathGenerator
/**
 * The Geography component. A collection of various functions used to project spherical coordinates, latitude & longitude math Used primarily to generate paths to draw maps as specified in GeoJSON objects.
 */
var com_ibm_rave_core_geo_Geo = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_RegistryService, {

	/**
	 * A projection factory that constructs Mercator projection The spherical Mercator projection is commonly used by tiled mapping libraries. It is conformal;  however, it introduces severe area distortion at world scale and thus is not recommended for choropleths.
	 */
	/** @expose */ 
	mercator : null,

	/**
	 * A projection factory that constructs a transverse Mercator projection
	 */
	/** @expose */ 
	transverseMercator : null,

	/**
	 * A projection factory that constructs an azimuthal equal-area projection which is suitable for choropleths
	 */
	/** @expose */ 
	azimuthalEqualArea : null,

	/**
	 * A projection factory that constructs azimuthal equidistant projection which preserves distances from the projection’s center:  the distance from any projected point to the projection’s center is proportional to the great arc distance.  Thus, circles around the projection’s center are projected to circles on the Cartesian plane.  This can be useful for visualizing distances relative to a point of reference, such as commute distances.
	 */
	/** @expose */ 
	azimuthalEquidistant : null,

	/**
	 * A projection factory that constructs an equal-distance (from some standard point or line) conic projection.
	 */
	/** @expose */ 
	conicEquidistant : null,

	/**
	 * A projection factory that constrcuts Lambert’s conformal conic projection which projects the globe conformally onto a cone. Conformal, or orthomorphic, map projections preserve angles locally, implying that they map infinitesimal circles of  constant size anywhere on the Earth to infinitesimal circles of varying sizes on the map
	 */
	/** @expose */ 
	conicConformal : null,

	/**
	 * A projection factory that constructs an equal-area conic projection.  This kind of projection is recommended for choropleths as it preserves the relative areas of geographic features.
	 */
	/** @expose */ 
	conicEqualArea : null,

	/**
	 * A projection factory that constructs an equirectangular projection. The equirectangular, or plate carrée projection, is the simplest possible geographic projection:  the identity function. It is neither equal-area nor conformal, but is sometimes used for raster data.
	 */
	/** @expose */ 
	equirectangular : null,

	/**
	 * A projection factory that constructs a stereographic projection. The stereographic projection is another perspective (azimuthal) projection.  The point of perspective is on the surface of the sphere, looking in; it is thus commonly used for celestial charts
	 */
	/** @expose */ 
	stereographic : null,

	/**
	 * A projection factory that constructs an orthographic projection. The orthographic projection is an azimuthal projection suitable for displaying a single hemisphere;  the point of perspective is at infinity
	 */
	/** @expose */ 
	orthographic : null,

	/**
	 * A projection factory that constructs a gnomonic projection. The gnomonic projection is an azimuthal projection that projects great circles as straight lines
	 */
	/** @expose */ 
	gnomonic : null,

	/**
	 * A projection factory that constructs Winkel Tripel projection.
	 */
	/** @expose */ 
	winkel3 : null,

	constructor : function() {
		this.mercator = com_ibm_rave_core_internal_geo_MercatorPlaneProjectionFactory.INSTANCE;
		this.transverseMercator = com_ibm_rave_core_internal_geo_TransverseMercatorProjectionFactory.INSTANCE;
		this.azimuthalEqualArea = com_ibm_rave_core_internal_geo_PlaneProjectionFactoryImpl.newAzimuthalEqualAreaProjectionFactory();
		this.azimuthalEquidistant = com_ibm_rave_core_internal_geo_PlaneProjectionFactoryImpl.newAzimuthalEquidistantProjectionFactory();
		this.conicEquidistant = com_ibm_rave_core_internal_geo_ConicProjectionFactoryImpl.newConicEquidistantProjectionFactory();
		this.conicConformal = com_ibm_rave_core_internal_geo_ConicProjectionFactoryImpl.newConicConformalProjectionFactory();
		this.conicEqualArea = com_ibm_rave_core_internal_geo_ConicProjectionFactoryImpl.newConicEqualAreaProjectionFactory();
		this.equirectangular = com_ibm_rave_core_internal_geo_PlaneProjectionFactoryImpl.newEquirectangularProjectionFactory();
		this.stereographic = com_ibm_rave_core_internal_geo_PlaneProjectionFactoryImpl.newStereographicProjectionFactory();
		this.orthographic = com_ibm_rave_core_internal_geo_PlaneProjectionFactoryImpl.newOrthographicProjectionFactory();
		this.gnomonic = com_ibm_rave_core_internal_geo_PlaneProjectionFactoryImpl.newGnomonicProjectionFactory();
		this.winkel3 = com_ibm_rave_core_internal_geo_PlaneProjectionFactoryImpl.newWinkelTripelProjectionFactory();
	},

	/**
	 * Starts the streaming process by reading the passed GeoJSON object and invoking the pertinent listener method  as it traverses GeoJSON object's features, geometry and sub objects, e.g., point, sphere etc.
	 * @param (Object) json The GeoJSON object to stream. (A feature or geometry JSON object could be passed as well)
	 * @param (com.ibm.rave.core.geo.StreamListener) listener The listener to be whose methods are to be invoked as the GeoJSON object is processed
	 * @see (com.ibm.rave.core.internal.geo.Stream) Stream  
	 * @see (com.ibm.rave.core.geo.StreamListener) StreamListener
	 */
	/** @expose */ 
	stream : function(json, listener) {
		com_ibm_rave_core_internal_geo_Stream.INSTANCE.stream(json, listener);
	},

	/**
	 * Returns the spherical area of the specified feature in steradians.  See also path.area, which computes the projected area on the Cartesian plane
	 * @param (Object) json the GeoJSON object containing the feature whose area is computed
	 * @return (double) the area in steradians (The unit of solid angle)
	 */
	/** @expose */ 
	area : function(json) {
		var sphericalArea = new com_ibm_rave_core_internal_geo_SphericalArea();
		return sphericalArea.calculateArea(json);
	},

	/**
	 * Returns the spherical bounding box for the specified feature.  The bounding box is represented by a two-dimensional array: [​[left, bottom], [right, top]​],  where left is the minimum longitude, bottom is the minimum latitude, right is maximum longitude,  and top is the maximum latitude.  See also path.bounds, which computes the projected bounding box on the Cartesian plane.
	 * @param (Object) feature the GeoJSON object containing the feature whose bounds are computed
	 * @return (double[][])  the spherical bounding box
	 */
	/** @expose */ 
	bounds : function(feature) {
		var sphericalBounds = new com_ibm_rave_core_internal_geo_SphericalBounds();
		return sphericalBounds.calculateBounds(feature);
	},

	/**
	 * Returns the spherical centroid of the specified feature.  See also path.centroid, which computes the projected centroid on the Cartesian plane.
	 * @param (Object) feature the GeoJSON object containing the feature whose centroid is computed
	 * @return (double[]) the point representing the centroid
	 */
	/** @expose */ 
	centroid : function(feature) {
		var sphericalCentroid = new com_ibm_rave_core_internal_geo_SphericalCentroid();
		return sphericalCentroid.calculateCentroid(feature);
	},

	/**
	 * Returns the great-arc distance in radians between the two points a and b.  Each point is specified as an array [longitude, latitude], with coordinates expressed in decimal degrees.
	 * @param (double[]) a the first point
	 * @param (double[]) b the second point
	 * @return (double)  the great-arc distance
	 */
	/** @expose */ 
	distance : com_ibm_rave_core_internal_geo_SphericalUtil.calculateDistance,

	/**
	 * Returns the great-arc length of the specified feature in radians.  For polygons, returns the perimeter of the exterior ring plus that of any interior rings.
	 * @param (Object) feature the GeoJSON object containing the feature whose length is computed
	 * @return (double)  the great-arc length
	 */
	/** @expose */ 
	length : function(feature) {
		var sphericalLength = new com_ibm_rave_core_internal_geo_SphericalLength();
		return sphericalLength.calculateLength(feature);
	},

	/**
	 * Returns an interpolator given the two locations a and b.  Each location must be represented as a two-element array of [longitude, latitude].  The returned interpolator is a functor which takes a single parameter t as input, where t ranges from 0 to 1.  A value of 0 returns the location a, while a value of 1 returns the location b.  Intermediate values interpolate from a to b along the spanning great arc.
	 * @param (double[]) source the first location
	 * @param (double[]) target the second location
	 * @return (com.ibm.rave.core.interpolate.Interpolator)  the interpolator
	 * @see (com.ibm.rave.core.interpolate.Interpolator) Interpolator
	 */
	/** @expose */ 
	interpolate : com_ibm_rave_core_internal_geo_SphericalInterpolation.newInterpolator,

	/**
	 * Specifies a rotation in the form of an array, [λ, φ, γ].  The elements of the array are angles in degrees, and specify a rotation in the following order: longitudinal, latitudinal and about the origin.  If the last element of the array, γ, is omitted, this defaults to 0.  Returns a rotator function object, which rotates a given location in the same or reverse order.
	 * @param (double[]) location the location to rotate
	 * @return (com.ibm.rave.core.geo.SphericalRotator)  the rotator
	 * @see (com.ibm.rave.core.geo.SphericalRotator) SphericalRotator
	 */
	/** @expose */ 
	rotation : com_ibm_rave_core_internal_geo_SphericalRotation.newRotator,

	/**
	 * Constructs a GeoJSON feature generator for creating circles centered at a given geographic location with a given radius in degrees.
	 * @return (com.ibm.rave.core.geo.CircleShapeGenerator)  circle shape generator
	 * @see (com.ibm.rave.core.geo.CircleShapeGenerator) CircleShapeGenerator
	 */
	/** @expose */ 
	circle : com_ibm_rave_core_geo_CircleShapeGenerator.newCircleShapeGenerator,

	/**
	 * Constructs a GeoJSON feature of type LineString generator for creating a great arc from a source point to a target point
	 * @return (com.ibm.rave.core.geo.GreatArcShapeGenerator)  great arc shape generator
	 * @see (com.ibm.rave.core.geo.GreatArcShapeGenerator) GreatArcShapeGenerator
	 * @deprecated  use {type: "LineString"} or Rave.geo.distance instead.
	 */
	/** @expose */ 
	greatArc : com_ibm_rave_core_geo_GreatArcShapeGenerator.newGreatArcShapeGenerator,

	/**
	 * Constructs a GeoJSON feature generator for creating graticules.
	 * @return (com.ibm.rave.core.geo.GraticuleShapeGenerator)  graticule shape generator 
	 * @see (com.ibm.rave.core.geo.GraticuleShapeGenerator) GraticuleShapeGenerator
	 */
	/** @expose */ 
	graticule : com_ibm_rave_core_geo_GraticuleShapeGenerator.newGraticuleShapeGenerator,

	/**
	 * Creates a new stream transform factory using the specified map of stream state delegate handlers.  The map may contain implementations of any of the standard stream listener delegate function classes:  StreamStateHandler for sphere, lineStart, lineEnd, polygonStart and polygonEnd, and StreamPointStateHandler for point. Each entry in the map should use a specific key as that represent the event to be handled, these keys are declared  as constants on StreamListener interface. For example, a sphere handler's entry should be keyed with  StreamListener.sphereHandler value and so on.   Any method that is not present in the specified map will be implemented as a pass-through directly to the wrapped stream listener.
	 * @param (Object) delegates the map containing the state handlers to be used when creating the transform stream listener
	 * @return (com.ibm.rave.core.geo.TransformStreamListenerFactory)  an instance of TransformStreamListenerFactory that could be used  to wrap a stream listener in order to create a transform stream listener
	 */
	/** @expose */ 
	transform : com_ibm_rave_core_geo_TransformStreamListenerFactory.create,

	/**
	 * Create a new stream transform that implements axis-aligned rectangle clipping.  This is typically used to clip geometry to the viewport after projecting.
	 * @return (com.ibm.rave.core.geo.ClipExtentStreamListenerTransform)  the clip extent stream listener transform
	 */
	/** @expose */ 
	clipExtent : com_ibm_rave_core_geo_ClipExtentStreamListenerTransform.newClipExtent,

	/**
	 * Constructs a new base projection from the specified raw point projector
	 * @param (com.ibm.rave.core.geo.PointProjector) projetor the point projector to use when constructing the base projection
	 * @return (com.ibm.rave.core.geo.Projection)  the newly created base projection
	 */
	/** @expose */ 
	projection : com_ibm_rave_core_internal_geo_ProjectionImpl.newProjection,

	/**
	 * Constructs a new base projection mutator from the specified raw point projector factory A project mutator can be used to construct a new base projection by calling the mutator's mutate function
	 * @param (com.ibm.rave.core.geo.PointProjectorFactory) projectorFactory the point projector factory to use 
	 * @return (com.ibm.rave.core.geo.ProjectionMutator)  the project mutator
	 */
	/** @expose */ 
	projectionMutator : com_ibm_rave_core_internal_geo_ProjectionMutatorImpl.newProjectionMutator,

	/**
	 * An alias for conicEqualArea, with USA-centric defaults: scale 1000, translate [480, 250], rotation [96°, 0°], center -0.6°, 38.7° and parallels [29.5°, 45.5°],  making it suitable for displaying the United States, centered around Hutchinson, Kansas in a 960×500 area.  The central meridian and parallels are specified by the USGS in the 1970 National Atlas.
	 * @return (com.ibm.rave.core.geo.ConicProjection)  the newly constructed albers projection
	 */
	/** @expose */ 
	albers : com_ibm_rave_core_internal_geo_AlbersUsaProjection.newAlbersProjection,

	/**
	 * Constructs Albers USA projection which is a composite projection of four Albers projections designed to display the forty-eight lower United States alongside Alaska and Hawaii.  Although intended for choropleths (Heat Map), it scales the area of Alaska by a factor of 0.35x (a lie factor of 3);  Hawaii is shown at the same scale as the lower forty-eight. This projection does not support the following projection methods: rotate, center, clipAngle and clipExtent. This projection does not provide a raw point projector.
	 * @return (com.ibm.rave.core.geo.InvertibleProjection)  the newly constructed albers-USA projection
	 */
	/** @expose */ 
	albersUsa : com_ibm_rave_core_internal_geo_AlbersUsaProjection.newAlbersUsaProjection,

	/**
	 * Creates a new geographic path generator with the default settings: the  albersUsa projection and a point radius of 4.5 pixels. This geographic path generator is basically an SVG shape generators: given a geometry or feature GeoJSON object,  it generates the path data string suitable for the "d" attribute of an SVG path element.
	 * @return (com.ibm.rave.core.geo.GeoPathGenerator)  the newly created geographic path generator
	 */
	/** @expose */ 
	path : function() {
		return com_ibm_rave_core_internal_geo_GeoPathGeneratorImpl.newGeoPathGenerator();
	}

	//constructor : function() {}
});

/**
 * The global singleton of the Geo component
 */
/** @expose */ 
com_ibm_rave_core_geo_Geo.INSTANCE = new com_ibm_rave_core_geo_Geo();

// $source: com/ibm/rave/core/internal/geo/GeoPathGeneratorImpl
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare, bind
//@import com/ibm/rave/core/internal/geo/BufferPathContextStreamListener (runtime) // new
//@import com/ibm/rave/core/internal/geo/DrawingPathContextStreamListener (runtime) // new
//@import com/ibm/rave/core/internal/geo/PathAreaStreamListener (runtime) // new
//@import com/ibm/rave/core/internal/geo/Stream (runtime) // Stream
//@import com/ibm/rave/core/internal/geo/PathCentroidStreamListener (runtime) // new
//@import com/ibm/rave/core/internal/geo/PathBoundsStreamListener (runtime) // new
//@import com/ibm/rave/core/internal/geo/TransformStreamListenerImpl (runtime) // new
//@import com/ibm/rave/core/internal/geo/ResampleStreamListenerFactory (runtime) // new
//@import com/ibm/rave/core/internal/geo/ProjectionImpl (runtime) // projectionRadians
//@import com/ibm/rave/core/internal/geo/AlbersUsaProjection (static) // newAlbersUsaProjection
/**
 */
var com_ibm_rave_core_internal_geo_GeoPathGeneratorImpl = com_ibm_rave_core_nativeImpl_Declare({

	//pointRadiusValue : null,

	//basicProjection : null,

	//drawingContext : null,

	//projectStream : null,

	//contextStream : null,

	//cacheStream : null,

	//pathCentroid : null,

	//pathArea : null,

	//pathBounds : null,

	_$functionClassMethod : function() {
		var _$self = function(data, index, groupIndex) {
			var object = data;
			if (object) {
				if (typeof _$self.pointRadiusValue === "function") {
					_$self.contextStream.pointRadius(+ ((_$self.pointRadiusValue)(object, index)));
				}
				if (!_$self.cacheStream || !(_$self.cacheStream.valid)) {
					_$self.cacheStream = _$self.projectStream(_$self.contextStream);
				}
				com_ibm_rave_core_internal_geo_Stream.INSTANCE.stream(object, _$self.cacheStream);
			}
			return _$self.contextStream.result();
		};
		return _$self;
	},

	constructor : function() {
		this.pointRadiusValue = (4.5);
	},

	/**
	 * @return (com.ibm.rave.core.geo.DrawingContext)  the context
	 */
	context$0 : function() {
		return this.drawingContext;
	},

	/**
	 * @param (com.ibm.rave.core.geo.DrawingContext) context  the context to set
	 */
	context$1 : function(context) {
		this.drawingContext = context;
		if (!this.drawingContext) {
			this.contextStream = new com_ibm_rave_core_internal_geo_BufferPathContextStreamListener();
		} else {
			this.contextStream = new com_ibm_rave_core_internal_geo_DrawingPathContextStreamListener(this.drawingContext);
		}
		if (!(typeof this.pointRadiusValue === "function")) {
			this.contextStream.pointRadius(+ (this.pointRadiusValue));
		}
		return this.reset();
	},

	/** @expose */ 
	area : com_ibm_rave_core_nativeImpl_Declare.bind(function(object) {
		this.pathArea = new com_ibm_rave_core_internal_geo_PathAreaStreamListener();
		com_ibm_rave_core_internal_geo_Stream.INSTANCE.stream(object, this.projectStream(this.pathArea));
		return this.pathArea.pathAreaSum;
	}),

	/** @expose */ 
	centroid : com_ibm_rave_core_nativeImpl_Declare.bind(function(object) {
		this.pathCentroid = new com_ibm_rave_core_internal_geo_PathCentroidStreamListener();
		com_ibm_rave_core_internal_geo_Stream.INSTANCE.stream(object, this.projectStream(this.pathCentroid));
		return (this.pathCentroid.centroidZ2) ? [this.pathCentroid.centroidX2 / this.pathCentroid.centroidZ2, this.pathCentroid.centroidY2 / this.pathCentroid.centroidZ2] : (this.pathCentroid.centroidZ1) ? [this.pathCentroid.centroidX1 / this.pathCentroid.centroidZ1, this.pathCentroid.centroidY1 / this.pathCentroid.centroidZ1] : (this.pathCentroid.centroidZ0) ? [this.pathCentroid.centroidX0 / this.pathCentroid.centroidZ0, this.pathCentroid.centroidY0 / this.pathCentroid.centroidZ0] : [NaN, NaN];
	}),

	/** @expose */ 
	bounds : function(object) {
		this.pathBounds = new com_ibm_rave_core_internal_geo_PathBoundsStreamListener();
		com_ibm_rave_core_internal_geo_Stream.INSTANCE.stream(object, this.projectStream(this.pathBounds));
		return [[this.pathBounds.pathBoundsX0, this.pathBounds.pathBoundsY0], [this.pathBounds.pathBoundsX1, this.pathBounds.pathBoundsY1]];
	},

	/**
	 * @return (com.ibm.rave.core.geo.BasicProjection)  the projection
	 */
	projection$0 : function() {
		return this.basicProjection;
	},

	/**
	 * @param (com.ibm.rave.core.geo.BasicProjection) projection  the projection to set
	 */
	projection$1 : function(projection) {
		this.basicProjection = projection;
		if (this.basicProjection) {
			if (this.basicProjection.stream) {
				var self = this;
				this.projectStream = function(listener) {
					return (self.basicProjection).stream(listener);
				};
			} else {
				this.projectStream = this.pathProjectStream(projection);
			}
		} else {
			this.projectStream = function(listener) {
				return new com_ibm_rave_core_internal_geo_TransformStreamListenerImpl(listener, {});
			};
		}
		return this.reset();
	},

	/**
	 * @return (Object)  the pointRadius
	 */
	pointRadius$0 : function() {
		return this.pointRadiusValue;
	},

	/**
	 * @param (Object) value  the pointRadius to set
	 */
	pointRadius$1 : function(value) {
		if (typeof value === "function") {
			this.pointRadiusValue = value;
		} else {
			this.pointRadiusValue = + (value);
			this.contextStream.pointRadius(+ (value));
		}
		return this;
	},

	reset : function() {
		this.cacheStream = null;
		return this;
	},

	pathProjectStream : function(projection) {
		var resampleFactory = new com_ibm_rave_core_internal_geo_ResampleStreamListenerFactory(function(x, y, z) {
			return (projection([x * 57.29577951308232, y * 57.29577951308232]));
		});
		return function(listener) {
			return com_ibm_rave_core_internal_geo_ProjectionImpl.projectionRadians(resampleFactory(listener));
		};
	},

	/** @expose */ 
	context : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.context$0();
		}
		return this.context$1(a0);
	},

	/** @expose */ 
	projection : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.projection$0();
		}
		return this.projection$1(a0);
	},

	/** @expose */ 
	pointRadius : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.pointRadius$0();
		}
		return this.pointRadius$1(a0);
	}

	/**
	 */
	//constructor : function() {}
});

com_ibm_rave_core_internal_geo_GeoPathGeneratorImpl.newGeoPathGenerator = function() {
	var path = new com_ibm_rave_core_internal_geo_GeoPathGeneratorImpl();
	return path.projection$1(com_ibm_rave_core_internal_geo_AlbersUsaProjection.newAlbersUsaProjection()).context(null);
};


// $source: com/ibm/rave/core/internal/geo/BufferPathContextStreamListener
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/geo/DelegatingStreamListener (loadtime) // superclass
/**
 */
var com_ibm_rave_core_internal_geo_BufferPathContextStreamListener = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_internal_geo_DelegatingStreamListener, {

	//pointCircle : null,

	//buffer : null,

	constructor : function() {
		this.buffer = [];
				/**
		 */
		{
			this.pointCircle = this.pathBufferCircle(4.5);
			var self = this;
			var point = function(x, y, z) {
				self.buffer.push("M", (x), ",", (y), self.pointCircle);
			};
			var pointLine = function(x, y, z) {
				self.buffer.push("L", (x), ",", (y));
			};
			var pointLineStart = function(x, y, z) {
				self.buffer.push("M", (x), ",", (y));
				self.pointDelegate = pointLine;
			};
			var lineStart = function() {
				self.pointDelegate = pointLineStart;
			};
			var lineEnd = function() {
				self.pointDelegate = point;
			};
			var lineEndPolygon = function() {
				self.buffer.push("Z");
			};
			var polygonStart = function() {
				self.lineEndDelegate = lineEndPolygon;
			};
			var polygonEnd = function() {
				self.lineEndDelegate = lineEnd;
				self.pointDelegate = point;
			};
			this.pointDelegate = point;
			this.lineStartDelegate = lineStart;
			this.lineEndDelegate = lineEnd;
			this.polygonStartDelegate = polygonStart;
			this.polygonEndDelegate = polygonEnd;
		}
	},

	pointRadius : function(r) {
		this.pointCircle = this.pathBufferCircle(r);
		return this;
	},

	result : function() {
		if (this.buffer.length > 0) {
			var result = this.buffer.join("");
			this.buffer = [];
			return result;
		}
		return null;
	},

	pathBufferCircle : function(radius) {
		return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
	}
});


// $source: com/ibm/rave/core/internal/geo/DrawingPathContextStreamListener
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/geo/DelegatingStreamListener (loadtime) // superclass
/**
 */
var com_ibm_rave_core_internal_geo_DrawingPathContextStreamListener = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_internal_geo_DelegatingStreamListener, {

	//context : null,

	pointRadiusValue : 0,

	/**
	 */
	constructor : function(context) {
		this.pointRadiusValue = (4.5);
		this.context = context;
		var self = this;
		var point = function(x, y, z) {
			self.context.moveTo(x + self.pointRadiusValue, y);
			self.context.arc(x, y, self.pointRadiusValue, 0, 6.283185307179586);
		};
		var pointLine = function(x, y, z) {
			self.context.lineTo(x, y);
		};
		var pointLineStart = function(x, y, z) {
			self.context.moveTo(x, y);
			self.pointDelegate = pointLine;
		};
		var lineStart = function() {
			self.pointDelegate = pointLineStart;
		};
		var lineEndPolygon = function() {
			self.context.closePath();
		};
		var polygonStart = function() {
			self.lineEndDelegate = lineEndPolygon;
		};
		var lineEnd = function() {
			self.pointDelegate = point;
		};
		var polygonEnd = function() {
			self.lineEndDelegate = lineEnd;
			self.pointDelegate = point;
		};
		this.pointDelegate = point;
		this.lineStartDelegate = lineStart;
		this.lineEndDelegate = lineEnd;
		this.polygonStartDelegate = polygonStart;
		this.polygonEndDelegate = polygonEnd;
	},

	pointRadius : function(r) {
		this.pointRadiusValue = r;
		return this;
	},

	result : function() {
		return null;
	}
});


// $source: com/ibm/rave/core/internal/geo/PathAreaStreamListener
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/geo/DelegatingStreamListener (loadtime) // superclass
/**
 */
var com_ibm_rave_core_internal_geo_PathAreaStreamListener = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_internal_geo_DelegatingStreamListener, {

	pathAreaSum : 0, pathAreaPolygon : 0,

	ringStart_x00 : 0, ringStart_y00 : 0, ringStart_x0 : 0, ringStart_y0 : 0,

	/**
	 * @return (double)  the pathAreaSum
	 */
	getPathAreaSum : function() {
		return this.pathAreaSum;
	},

	/**
	 */
	constructor : function() {
		var self = this;
		var pathAreaRingStart_nextPoint = function(x, y, zz) {
			self.pathAreaPolygon += self.ringStart_y0 * x - self.ringStart_x0 * y;
			self.ringStart_x0 = x;
			self.ringStart_y0 = y;
		};
		var pathAreaRingStart_point = function(x, y, z) {
			self.pointDelegate = pathAreaRingStart_nextPoint;
			self.ringStart_x00 = self.ringStart_x0 = x;
			self.ringStart_y00 = self.ringStart_y0 = y;
		};
		var pathAreaRingStart_lineEnd = function() {
			pathAreaRingStart_nextPoint(self.ringStart_x00, self.ringStart_y00, NaN);
		};
		var pathAreaRingStart = function() {
			self.ringStart_x00 = self.ringStart_y00 = self.ringStart_x0 = self.ringStart_y0 = 0;
			self.pointDelegate = pathAreaRingStart_point;
			self.lineEndDelegate = pathAreaRingStart_lineEnd;
		};
		var polygonStart = function() {
			self.pathAreaPolygon = 0;
			self.lineStartDelegate = pathAreaRingStart;
		};
		var polygonEnd = function() {
			self.pointDelegate = null;
			self.lineStartDelegate = null;
			self.lineEndDelegate = null;
			self.pathAreaSum += Math.abs(self.pathAreaPolygon / 2);
		};
		this.polygonStartDelegate = polygonStart;
		this.polygonEndDelegate = polygonEnd;
	}
});


// $source: com/ibm/rave/core/internal/geo/PathCentroidStreamListener
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/geo/DelegatingStreamListener (loadtime) // superclass
/**
 */
var com_ibm_rave_core_internal_geo_PathCentroidStreamListener = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_internal_geo_DelegatingStreamListener, {

	centroidX0 : 0, centroidY0 : 0, centroidZ0 : 0, centroidX1 : 0, centroidY1 : 0, centroidZ1 : 0, centroidX2 : 0, centroidY2 : 0, centroidZ2 : 0,

	lineStart_x0 : 0, lineStart_y0 : 0,

	ringStart_x00 : 0, ringStart_y00 : 0, ringStart_x0 : 0, ringStart_y0 : 0,

	/**
	 */
	constructor : function() {
		var self = this;
		var centroidPoint = function(x, y, z) {
			self.centroidX0 += x;
			self.centroidY0 += y;
			++self.centroidZ0;
		};
		var centroidLineStart_nextPoint = function(x, y, zz) {
			var dx = x - self.lineStart_x0, dy = y - self.lineStart_y0, z = Math.sqrt(dx * dx + dy * dy);
			self.centroidX1 += z * (self.lineStart_x0 + x) / 2;
			self.centroidY1 += z * (self.lineStart_y0 + y) / 2;
			self.centroidZ1 += z;
			centroidPoint(self.lineStart_x0 = x, self.lineStart_y0 = y, NaN);
		};
		var centroidLineStart_point = function(x, y, z) {
			self.pointDelegate = centroidLineStart_nextPoint;
			centroidPoint(self.lineStart_x0 = x, self.lineStart_y0 = y, NaN);
		};
		var centroidLineStart = function() {
			self.lineStart_x0 = self.lineStart_y0 = 0;
			self.pointDelegate = centroidLineStart_point;
		};
		var centroidLineEnd = function() {
			self.pointDelegate = centroidPoint;
		};
		var centroidRingStart_nextPoint = function(x, y, zz) {
			var dx = x - self.ringStart_x0, dy = y - self.ringStart_y0, z = Math.sqrt(dx * dx + dy * dy);
			self.centroidX1 += z * (self.ringStart_x0 + x) / 2;
			self.centroidY1 += z * (self.ringStart_y0 + y) / 2;
			self.centroidZ1 += z;
			z = self.ringStart_y0 * x - self.ringStart_x0 * y;
			self.centroidX2 += z * (self.ringStart_x0 + x);
			self.centroidY2 += z * (self.ringStart_y0 + y);
			self.centroidZ2 += z * 3;
			centroidPoint(self.ringStart_x0 = x, self.ringStart_y0 = y, NaN);
		};
		var centroidRingStart_point = function(x, y, z) {
			self.pointDelegate = centroidRingStart_nextPoint;
			centroidPoint(self.ringStart_x00 = self.ringStart_x0 = x, self.ringStart_y00 = self.ringStart_y0 = y, NaN);
		};
		var centroidRingStart_lineEnd = function() {
			centroidRingStart_nextPoint(self.ringStart_x00, self.ringStart_y00, NaN);
		};
		var centroidRingStart = function() {
			self.ringStart_x00 = self.ringStart_y00 = self.ringStart_x0 = self.ringStart_y0 = 0;
			self.pointDelegate = centroidRingStart_point;
			self.lineEndDelegate = centroidRingStart_lineEnd;
		};
		var polygonStart = function() {
			self.lineStartDelegate = centroidRingStart;
		};
		var polygonEnd = function() {
			self.pointDelegate = centroidPoint;
			self.lineStartDelegate = centroidLineStart;
			self.lineEndDelegate = centroidLineEnd;
		};
		this.pointDelegate = centroidPoint;
		this.lineStartDelegate = centroidLineStart;
		this.lineEndDelegate = centroidLineEnd;
		this.polygonStartDelegate = polygonStart;
		this.polygonEndDelegate = polygonEnd;
	},

	/**
	 * @return (double)  the centroidX0
	 */
	getCentroidX0 : function() {
		return this.centroidX0;
	},

	/**
	 * @return (double)  the centroidY0
	 */
	getCentroidY0 : function() {
		return this.centroidY0;
	},

	/**
	 * @return (double)  the centroidZ0
	 */
	getCentroidZ0 : function() {
		return this.centroidZ0;
	},

	/**
	 * @return (double)  the centroidX1
	 */
	getCentroidX1 : function() {
		return this.centroidX1;
	},

	/**
	 * @return (double)  the centroidY1
	 */
	getCentroidY1 : function() {
		return this.centroidY1;
	},

	/**
	 * @return (double)  the centroidZ1
	 */
	getCentroidZ1 : function() {
		return this.centroidZ1;
	},

	/**
	 * @return (double)  the centroidX2
	 */
	getCentroidX2 : function() {
		return this.centroidX2;
	},

	/**
	 * @return (double)  the centroidY2
	 */
	getCentroidY2 : function() {
		return this.centroidY2;
	},

	/**
	 * @return (double)  the centroidZ2
	 */
	getCentroidZ2 : function() {
		return this.centroidZ2;
	}
});


// $source: com/ibm/rave/core/internal/geo/PathBoundsStreamListener
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/geo/DelegatingStreamListener (loadtime) // superclass
/**
 */
var com_ibm_rave_core_internal_geo_PathBoundsStreamListener = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_internal_geo_DelegatingStreamListener, {

	pathBoundsX1 : 0, pathBoundsY1 : 0, pathBoundsX0 : 0, pathBoundsY0 : 0,

	/**
	 */
	constructor : function() {
		this.pathBoundsX1 = this.pathBoundsY1 = -(this.pathBoundsX0 = this.pathBoundsY0 = Infinity);
		var self = this;
		var point = function(x, y, z) {
			if (x < self.pathBoundsX0) {
				self.pathBoundsX0 = x;
			}
			if (x > self.pathBoundsX1) {
				self.pathBoundsX1 = x;
			}
			if (y < self.pathBoundsY0) {
				self.pathBoundsY0 = y;
			}
			if (y > self.pathBoundsY1) {
				self.pathBoundsY1 = y;
			}
		};
		this.pointDelegate = point;
	},

	/**
	 * @return (double)  the pathBoundsX1
	 */
	getPathBoundsX1 : function() {
		return this.pathBoundsX1;
	},

	/**
	 * @return (double)  the pathBoundsY1
	 */
	getPathBoundsY1 : function() {
		return this.pathBoundsY1;
	},

	/**
	 * @return (double)  the pathBoundsX0
	 */
	getPathBoundsX0 : function() {
		return this.pathBoundsX0;
	},

	/**
	 * @return (double)  the pathBoundsY0
	 */
	getPathBoundsY0 : function() {
		return this.pathBoundsY0;
	}
});


// $source: com/ibm/rave/core/globalization/Bidi
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/locale/Locale (runtime) // getInstance
/**
 * Class that handles bidi string formatting. Uses the default Locale (en_US) object but can still format LTR, RTL and AUTO formatted strings.
 * @author  jim
 */
var com_ibm_rave_core_globalization_Bidi = com_ibm_rave_core_nativeImpl_Declare({

	/** @expose */ 
	format : null,

	constructor : function() {
		this.format = com_ibm_rave_core_locale_Locale.getInstance().getDefault().bidiStringFormat;
	}

	//constructor : function() {}
});

/** @expose */ 
com_ibm_rave_core_globalization_Bidi.INSTANCE = new com_ibm_rave_core_globalization_Bidi();

// $source: com/ibm/rave/core/util/Namespace
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/internal/util/NamespaceUtil (runtime) // getQName, NamespaceUtil
/**
 * SVG has a different namespace from HTML, so Rave  provides a few tools to simplify dealing with namespaces.
 */
var com_ibm_rave_core_util_Namespace = com_ibm_rave_core_nativeImpl_Declare({

	/**
	 * The map of registered namespace prefixes. Additional prefixes may be assigned as needed to create elements or attributes in other namespaces. 
	 */
	/** @expose */ 
	prefix : null,

	constructor : function() {
		this.prefix = com_ibm_rave_core_internal_util_NamespaceUtil.NAMESPACES;
	},

	/**
	 * Qualifies the specified name, which may have a namespace prefix.  If the name contains a colon (":"), the substring before the colon  is interpreted as the namespace prefix, which must be registered in rave.ns.prefix.  The return value is an object with space and local attributes containing the full  namespace URL and the local name.  For example, the result of qualify("svg:text") is: <pre> {space: "http://www.w3.org/2000/svg", local: "text"} </pre> If the name does not contain a colon, this function merely returns the input name.
	 * @param (String) name The name to qualify.
	 * @return (Object)  A qualified name object, or if the name does not contain a colon, the input name.
	 */
	/** @expose */ 
	qualify : function(name) {
		var qname = com_ibm_rave_core_internal_util_NamespaceUtil.getQName(name);
		if (qname["space"] != null) {
			return qname;
		}
		return qname["local"];
	}

	//constructor : function() {}
});

/**
 * The singleton of the Namespace component
 */
/** @expose */ 
com_ibm_rave_core_util_Namespace.INSTANCE = new com_ibm_rave_core_util_Namespace();

// $source: com/ibm/rave/core/util/StringFormatter
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
/**
 * The parametrization utility, which will replace {i} parameters with supplied arguments. For example: <code> Rave.formatter.format( "The quick brown {0} jumps over the lazy {1}", "fox", "dog"); </code> produces "The quick brown fox jumps over the lazy dog";
 */
var com_ibm_rave_core_util_StringFormatter = com_ibm_rave_core_nativeImpl_Declare({

	/**
	 * @param (String) pattern pattern string to use. Current formatting rules support substituting bracketed numbers as indexes into the args array. For instance this code returns true <p> <code>format("This {1} a {2}", "is", "test").equals("This is a test");</code>  
	 * @param (java.lang.String[]) args an array of strings to be formatted based on pattern.
	 * @return (String)  formatted string
	 */
	/** @expose */ 
	format : function(pattern, args) {
		if (args !== null || arguments.length > 2){
			args = Array.prototype.slice.call(arguments, 1);
		}
		{
			if (!args) {
				return pattern;
			}
			var regex = new RegExp("\\{(\\d+)\\}", "g");
			var formatted = pattern;
			var matched;
			while ((matched = regex.exec(formatted))) {
				var number = ~~ (matched[1]);
				if (number < args.length) {
					var match = matched[0];
					formatted = formatted.replace(match, args[number]);
				}
			}
			regex = new RegExp("'\\{'", "");
			matched = null;
			while ((matched = regex.exec(formatted))) {
				var match = matched[0];
				formatted = formatted.replace(match, "{");
			}
			regex = new RegExp("'\\}'", "");
			matched = null;
			while ((matched = regex.exec(formatted))) {
				var match = matched[0];
				formatted = formatted.replace(match, "}");
			}
			return formatted;
		}
	}

	//constructor : function() {}
});

/** @expose */ 
com_ibm_rave_core_util_StringFormatter.OPEN_BRACE_ESCAPE = "'\\{'";
/** @expose */ 
com_ibm_rave_core_util_StringFormatter.CLOSED_BRACE_ESCAPE = "'\\}'";

/** @expose */ 
com_ibm_rave_core_util_StringFormatter.INSTANCE = new com_ibm_rave_core_util_StringFormatter();

// $source: com/ibm/rave/core/interpolate/Interpolate
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/interpolate/Interpolators (runtime) // Interpolators
/**
 * Rave has many built-in interpolators to simplify the transitioning of arbitrary values;  an interpolator is a function that maps a parametric value t in the domain [0,1] to a  color, number or arbitrary value.
 */
var com_ibm_rave_core_interpolate_Interpolate = com_ibm_rave_core_nativeImpl_Declare({

	_$functionClassMethod : function() {
		var _$self = 		/**
		 * Returns the default interpolator between the two values a and b. The type of interpolator  is based on the type of the end value b, using the following algorithm: If b is a color, interpolateRgb is used. If b is a string, interpolateString is used. If b is an array, interpolateArray is used. If b is an object and not coercible to a number, interpolateObject is used. Otherwise, interpolateNumber is used. Based on the chosen interpolator, a is coerced to a suitable corresponding type.  The color check applies to both instances of rave.rgb and other color spaces  as well as color strings of the form /^(#|rgb\(|hsl\()/ or a CSS named colors. The behavior of this default interpolator may be extended to support additional  types by pushing custom interpolators onto the rave.interpolators array.
		 */
		function(a, b) {
			return com_ibm_rave_core_interpolate_Interpolators.INSTANCE.getInterpolator(a, b);
		};
		return _$self;
	}

	//constructor : function() {}
});

/** @expose */ 
com_ibm_rave_core_interpolate_Interpolate.INSTANCE = new com_ibm_rave_core_interpolate_Interpolate();

// $source: com/ibm/rave/core/nativeImpl/xhr/XhrIdentity
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2014
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/

//@import com/ibm/rave/core/nativeImpl/xhr/Xhr

var com_ibm_rave_core_nativeImpl_xhr_XhrIdentity = {

	INSTANCE : com_ibm_rave_core_nativeImpl_xhr_Xhr(function(request) {
		return request;
	})
};

// $source: com/ibm/rave/core/nativeImpl/xhr/XhrText
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2014
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/

//@import com/ibm/rave/core/nativeImpl/xhr/Xhr

var com_ibm_rave_core_nativeImpl_xhr_XhrText = {

	INSTANCE : com_ibm_rave_core_nativeImpl_xhr_Xhr(function(request) {
		return request.responseText;
	})
};

// $source: com/ibm/rave/core/nativeImpl/xhr/XhrJson
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2014
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/

//@import com/ibm/rave/core/nativeImpl/xhr/Xhr

var com_ibm_rave_core_nativeImpl_xhr_XhrJson = (function() {
	function rave_json(request) {
		return JSON.parse(request.responseText);
	};

	return {
		INSTANCE : function(url, callback) {
		  return com_ibm_rave_core_nativeImpl_xhr_Xhr.create(url, "application/json", rave_json, callback);
		}
	}
})();

	

// $source: com/ibm/rave/core/nativeImpl/xhr/XhrHtml
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2014
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/

//@import com/ibm/rave/core/nativeImpl/xhr/Xhr

var com_ibm_rave_core_nativeImpl_xhr_XhrHtml = (function() {
	function rave_html(request) {
		var range = rave_document.createRange();
		range.selectNode(rave_document.body);
		return range.createContextualFragment(request.responseText);
	};

	return {
		INSTANCE : function(url, callback) {
		  return com_ibm_rave_core_nativeImpl_xhr_Xhr.create(url, "text/html", rave_html, callback);
		}
	}
})();

	

// $source: com/ibm/rave/core/nativeImpl/xhr/XhrXml
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2014
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/

//@import com/ibm/rave/core/nativeImpl/xhr/Xhr

var com_ibm_rave_core_nativeImpl_xhr_XhrXml = {

	INSTANCE : com_ibm_rave_core_nativeImpl_xhr_Xhr(function(request) {
		return request.responseXML;
	})
};

// $source: com/ibm/rave/core/nativeImpl/dsv/Dsv
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2014
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/


//@import com/ibm/rave/core/nativeImpl/arrays/ES6Map
//@import com/ibm/rave/core/nativeImpl/xhr/Xhr

var com_ibm_rave_core_nativeImpl_dsv_Dsv = function(delimiter, mimeType) {
  
	var reFormat = new RegExp("[\"" + delimiter + "\n]"),
      delimiterCode = delimiter.charCodeAt(0);

  function dsv(url, row, callback) {
    if (arguments.length < 3) callback = row, row = null;
    var xhr = com_ibm_rave_core_nativeImpl_xhr_Xhr.create(url, mimeType, row == null ? response : typedResponse(row), callback);
 
    /**@expose*/
    xhr.row = function(_) {
      return arguments.length
          ? xhr.response((row = _) == null ? response : typedResponse(_))
          : row;
    };

    return xhr;
  }

  function response(request) {
    return dsv.parse(request.responseText);
  }

  function typedResponse(f) {
    return function(request) {
      return dsv.parse(request.responseText, f);
    };
  }
  /**@expose*/
  dsv.parse = function(text, f) {
    var o;
    return dsv.parseRows(text, function(row, i) {
      if (o) return o(row, i - 1);
      var a = new Function("d", "return {" + row.map(function(name, i) {
        return JSON.stringify(name) + ": d[" + i + "]";
      }).join(",") + "}");
      o = f ? function(row, i) { return f(a(row), i); } : a;
    });
  };
/**@expose*/
  dsv.parseRows = function(text, f) {
    var EOL = {}, // sentinel value for end-of-line
        EOF = {}, // sentinel value for end-of-file
        rows = [], // output rows
        N = text.length,
        I = 0, // current character index
        n = 0, // the current line number
        t, // the current token
        eol; // is the current token followed by EOL?

    function token() {
      if (I >= N) return EOF; // special case: end of file
      if (eol) return eol = false, EOL; // special case: end of line

      // special case: quotes
      var j = I;
      if (text.charCodeAt(j) === 34) {
        var i = j;
        while (i++ < N) {
          if (text.charCodeAt(i) === 34) {
            if (text.charCodeAt(i + 1) !== 34) break;
            ++i;
          }
        }
        I = i + 2;
        var c = text.charCodeAt(i + 1);
        if (c === 13) {
          eol = true;
          if (text.charCodeAt(i + 2) === 10) ++I;
        } else if (c === 10) {
          eol = true;
        }
        return text.slice(j + 1, i).replace(/""/g, "\"");
      }

      // common case: find next delimiter or newline
      while (I < N) {
        var c = text.charCodeAt(I++), k = 1;
        if (c === 10) eol = true; // \n
        else if (c === 13) { eol = true; if (text.charCodeAt(I) === 10) ++I, ++k; } // \r|\r\n
        else if (c !== delimiterCode) continue;
        return text.slice(j, I - k);
      }

      // special case: last token before EOF
      return text.slice(j);
    }

    while ((t = token()) !== EOF) {
      var a = [];
      while (t !== EOL && t !== EOF) {
        a.push(t);
        t = token();
      }
      if (f && (a = f(a, n++)) == null) continue;
      rows.push(a);
    }

    return rows;
  };
/**@expose*/
  dsv.format = function(rows) {
    if (Array.isArray(rows[0])) return dsv.formatRows(rows); // deprecated; use formatRows
    var fieldSet = new com_ibm_rave_core_nativeImpl_arrays_ES6Map, fields = [];

    // Compute unique fields in order of discovery.
    rows.forEach(function(row) {
      for (var field in row) {
        if (!fieldSet.has(field)) {
        	fieldSet.set(field,1)
        	fields.push(field);
        }
      }
    });

    return [fields.map(formatValue).join(delimiter)].concat(rows.map(function(row) {
      return fields.map(function(field) {
        return formatValue(row[field]);
      }).join(delimiter);
    })).join("\n");
  };
  
  /**@expose*/
  dsv.formatRows = function(rows) {
    return rows.map(formatRow).join("\n");
  };

  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }

  function formatValue(text) {
    return reFormat.test(text) ? "\"" + text.replace(/\"/g, "\"\"") + "\"" : text;
  }

  return dsv;
};

com_ibm_rave_core_nativeImpl_dsv_Dsv.INSTANCE = com_ibm_rave_core_nativeImpl_dsv_Dsv;
// $source: com/ibm/rave/core/nativeImpl/dsv/Csv
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2014
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/

//@import com/ibm/rave/core/nativeImpl/dsv/Dsv


var com_ibm_rave_core_nativeImpl_dsv_Csv = {
		INSTANCE : com_ibm_rave_core_nativeImpl_dsv_Dsv(",", "text/csv")
		};
// $source: com/ibm/rave/core/nativeImpl/dsv/Tsv
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2014
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/

//@import com/ibm/rave/core/nativeImpl/dsv/Dsv
 
var com_ibm_rave_core_nativeImpl_dsv_Tsv = {
		INSTANCE : com_ibm_rave_core_nativeImpl_dsv_Dsv("\t", "text/tab-separated-values")
		};
// $source: com/ibm/rave/core/collections/MapFunctionClass
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/nativeImpl/arrays/ES6Map (loadtime) // new, create
var com_ibm_rave_core_collections_MapFunctionClass = rave_externs["MapFunctionClass"] = com_ibm_rave_core_nativeImpl_Declare({

	_$functionClassMethod : function() {
		var _$self = function(a0, a1) {
			var args = arguments;
			if (args.length == 0) {
				return _$self.createMap$0();
			}
			if (args.length == 1 && (a0 == null || Object.prototype.toString.call(a0) === "[object Array]")) {
				return _$self.createMap$3(a0);
			}
			if (args.length == 1 && (a0 == null || com_ibm_rave_core_nativeImpl_Object.isInstanceOf(a0, com_ibm_rave_core_nativeImpl_arrays_ES6Map))) {
				return _$self.createMap$2(a0);
			}
			if (args.length == 1) {
				return _$self.createMap$1(a0);
			}
			return _$self.createMap$4(a0, a1);
		};
		return _$self;
	},

	/**
	 * @return (com.ibm.rave.core.nativeImpl.arrays.ES6Map)  ES6Map.
	 * @see this.ES6Map#this.create()
	 */
	createMap$0 : com_ibm_rave_core_nativeImpl_arrays_ES6Map.create,

	/**
	 * @param (Object) map
	 * @return (com.ibm.rave.core.nativeImpl.arrays.ES6Map)  ES6Map
	 * @see this.ES6Map#this.create(java_util_Map)
	 */
	createMap$1 : com_ibm_rave_core_nativeImpl_arrays_ES6Map.create,

	/**
	 * @param (com.ibm.rave.core.nativeImpl.arrays.ES6Map) map
	 * @return (com.ibm.rave.core.nativeImpl.arrays.ES6Map)  ES6Map
	 * @see this.ES6Map#this.create(com_ibm_rave_core_nativeImpl_arrays_ES6Map)
	 */
	createMap$2 : function(map) {
		return com_ibm_rave_core_nativeImpl_arrays_ES6Map.create(map);
	},

	/**
	 * @param (Array) input value array
	 * @return (com.ibm.rave.core.nativeImpl.arrays.ES6Map)  ES6Map
	 * @see this.ES6Map#this.create(com_ibm_rave_core_nativeImpl_arrays_ES6Map)
	 */
	createMap$3 : function(input) {
		var map = com_ibm_rave_core_nativeImpl_arrays_ES6Map.create();
		if (input) {
			for (var i = 0; i < input.length; i = i + 1) {
				map.set(i, input[i]);
			}
		}
		return com_ibm_rave_core_nativeImpl_arrays_ES6Map.create(map);
	},

	/**
	 * @param (Array) input value array
	 * @param (com.ibm.rave.core.selector.ValueFunction) callback the accessor function to use to get the value
	 * @return (com.ibm.rave.core.nativeImpl.arrays.ES6Map)  ES6Map
	 * @see this.ES6Map#this.create(com_ibm_rave_core_nativeImpl_arrays_ES6Map)
	 */
	createMap$4 : function(input, callback) {
		var len = input.length;
		var map = com_ibm_rave_core_nativeImpl_arrays_ES6Map.create();
		for (var i = 0; i < len; i = i + 1) {
			var currentValue = input[i];
			if (currentValue) {
				map.set(callback.call(input, currentValue, i, -1), currentValue);
			}
		}
		return com_ibm_rave_core_nativeImpl_arrays_ES6Map.create(map);
	}
});


// $source: com/ibm/rave/core/Rave
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/math/TransformParser (loadtime) // create
//@import com/ibm/rave/core/selector/Selector (static) // new
//@import com/ibm/rave/core/transition/Transition (loadtime) // newTransition
//@import com/ibm/rave/core/arrays/Merge (loadtime) // merge
//@import com/ibm/rave/core/arrays/MinMax (loadtime) // min, max
//@import com/ibm/rave/core/arrays/Quantile (loadtime) // quantile
//@import com/ibm/rave/core/arrays/Deviation (loadtime) // deviation
//@import com/ibm/rave/core/arrays/Variance (loadtime) // variance
//@import com/ibm/rave/core/arrays/Mean (loadtime) // mean
//@import com/ibm/rave/core/arrays/Median (loadtime) // median
//@import com/ibm/rave/core/arrays/Extent (loadtime) // extent
//@import com/ibm/rave/core/arrays/Sum (loadtime) // sum
//@import com/ibm/rave/core/arrays/Zip (loadtime) // zip
//@import com/ibm/rave/core/arrays/Permute (loadtime) // permute
//@import com/ibm/rave/core/arrays/Shuffle (loadtime) // shuffle
//@import com/ibm/rave/core/arrays/Range (loadtime) // create
//@import com/ibm/rave/core/arrays/Bisector (loadtime) // create, Bisector
//@import com/ibm/rave/core/event/Dispatcher (static) // create
//@import com/ibm/rave/core/nativeImpl/event/Mouse (loadtime) // mousePoint
//@import com/ibm/rave/core/event/TouchUtil (loadtime) // touchFromSource, touch
//@import com/ibm/rave/core/nativeImpl/event/Touches (loadtime) // touches
//@import com/ibm/rave/core/color/Colors (loadtime) // newHSL, newHCL, newRGBA, newRGB, newLAB
//@import com/ibm/rave/core/format/Round (loadtime) // round
//@import com/ibm/rave/core/nativeImpl/format/Requote (loadtime) // requote
//@import com/ibm/rave/core/format/FormatPrefix (loadtime) // formatPrefix
//@import com/ibm/rave/core/nativeImpl/arrays/AssociativeArrays (loadtime) // entries, values, keys
//@import com/ibm/rave/core/arrays/Nest (static) // new
//@import com/ibm/rave/core/internal/nativeImpl/PlatformInitialization (static) // init, getDocument, getDocumentElement
//@import com/ibm/rave/core/arrays/Pairs (loadtime) // pairs
//@import com/ibm/rave/core/arrays/RaveSet (loadtime) // create
//@import com/ibm/rave/core/Configuration (static) // Configuration
//@import com/ibm/rave/core/textMetrics/CanvasUtil (static) // CanvasUtil
//@import com/ibm/rave/core/nativeImpl/event/EventTracker (static) // EventTracker
//@import com/ibm/rave/core/nativeImpl/timer/Timer (static) // Timer
//@import com/ibm/rave/core/geom/Geom (static) // Geom
//@import com/ibm/rave/core/scales/Scales (static) // Scales
//@import com/ibm/rave/core/layout/Layout (static) // Layout
//@import com/ibm/rave/core/capabilities/Capabilities (static) // Capabilities
//@import com/ibm/rave/core/svg/SVG (static) // getInstance
//@import com/ibm/rave/core/geo/Geo (static) // Geo
//@import com/ibm/rave/core/behavior/Behavior (static) // Behavior
//@import com/ibm/rave/core/time/Time (static) // getInstance
//@import com/ibm/rave/core/globalization/Bidi (static) // Bidi
//@import com/ibm/rave/core/util/Namespace (static) // Namespace
//@import com/ibm/rave/core/math/Random (static) // Random
//@import com/ibm/rave/core/locale/NumberFormat (static) // new
//@import com/ibm/rave/core/locale/Locale (static) // Locale, getInstance
//@import com/ibm/rave/core/util/StringFormatter (static) // StringFormatter
//@import com/ibm/rave/core/arrays/Sort (static) // Sort
//@import com/ibm/rave/core/ease/Easing (static) // Easing
//@import com/ibm/rave/core/color/Color (static) // new
//@import com/ibm/rave/core/interpolate/Interpolators (static) // Interpolators
//@import com/ibm/rave/core/interpolate/Interpolate (static) // Interpolate
//@import com/ibm/rave/core/interpolate/ColorInterpolation (static) // ColorInterpolation
//@import com/ibm/rave/core/interpolate/StringInterpolation (static) // StringInterpolation
//@import com/ibm/rave/core/interpolate/NumberInterpolation (static) // NumberInterpolation
//@import com/ibm/rave/core/interpolate/RoundInterpolation (static) // RoundInterpolation
//@import com/ibm/rave/core/interpolate/ArrayInterpolation (static) // ArrayInterpolation
//@import com/ibm/rave/core/nativeImpl/interpolate/ObjectInterpolation (static) // ObjectInterpolation
//@import com/ibm/rave/core/interpolate/TransformInterpolation (static) // TransformInterpolation
//@import com/ibm/rave/core/interpolate/ZoomInterpolation (static) // ZoomInterpolation
//@import com/ibm/rave/core/nativeImpl/xhr/XhrIdentity (static) // XhrIdentity
//@import com/ibm/rave/core/nativeImpl/xhr/XhrText (static) // XhrText
//@import com/ibm/rave/core/nativeImpl/xhr/XhrJson (static) // XhrJson
//@import com/ibm/rave/core/nativeImpl/xhr/XhrHtml (static) // XhrHtml
//@import com/ibm/rave/core/nativeImpl/xhr/XhrXml (static) // XhrXml
//@import com/ibm/rave/core/nativeImpl/dsv/Dsv (static) // Dsv
//@import com/ibm/rave/core/nativeImpl/dsv/Csv (static) // Csv
//@import com/ibm/rave/core/nativeImpl/dsv/Tsv (static) // Tsv
//@import com/ibm/rave/core/collections/MapFunctionClass (static) // new
var com_ibm_rave_core_Rave = rave_externs["Rave"] = {

	//constructor : function() {}
};

/**
 * @see (com.ibm.rave.core.transform.Transform) Transform
 */
/** @expose */ 
com_ibm_rave_core_Rave.transform = com_ibm_rave_core_nativeImpl_math_TransformParser.create;

/**
 * @see this.Selector#this.init(com_ibm_rave_core_scene_SceneNode)
 */
com_ibm_rave_core_Rave.select$0 = function(node) {
	return new com_ibm_rave_core_selector_Selector().init(node);
};

/**
 * @see this.Selector#this.init(String)
 */
com_ibm_rave_core_Rave.select$1 = function(query) {
	return new com_ibm_rave_core_selector_Selector().init(query);
};

/**
 * @see this.Selector#this.initAll()
 */
com_ibm_rave_core_Rave.selectAll$0 = function(nodes) {
	return new com_ibm_rave_core_selector_Selector().initAll(nodes);
};

/**
 * @see this.Selector#this.initAll(String)
 */
com_ibm_rave_core_Rave.selectAll$1 = function(query) {
	return new com_ibm_rave_core_selector_Selector().initAll(query);
};

/**
 * @see this.Transition#this.newTransition()
 */
com_ibm_rave_core_Rave.transition$0 = com_ibm_rave_core_transition_Transition.newTransition;

/**
 * @see this.Transition#this.newTransition(com_ibm_rave_core_selector_Selection)
 */
com_ibm_rave_core_Rave.transition$1 = com_ibm_rave_core_transition_Transition.newTransition;

/**
 * @see this.Transition#this.newTransition()
 */
com_ibm_rave_core_Rave.transition$2 = com_ibm_rave_core_transition_Transition.newTransition;

/**
 * @see this.Transition#this.newTransition(, )
 */
com_ibm_rave_core_Rave.transition$3 = com_ibm_rave_core_transition_Transition.newTransition;

/**
 * @see this.Merge#this.merge(Array)
 */
/** @expose */ 
com_ibm_rave_core_Rave.merge = com_ibm_rave_core_arrays_Merge.merge;

/**
 * @see this.MinMax#this.max(Array)
 */
com_ibm_rave_core_Rave.max$0 = com_ibm_rave_core_arrays_MinMax.max$0;

/**
 * @see this.MinMax#this.max(Array, com_ibm_rave_core_selector_ValueFunction)
 */
com_ibm_rave_core_Rave.max$1 = com_ibm_rave_core_arrays_MinMax.max$1;

/**
 * @see this.MinMax#this.min(Array)
 */
com_ibm_rave_core_Rave.min$0 = com_ibm_rave_core_arrays_MinMax.min$0;

/**
 * @see this.MinMax#this.min(Array, com_ibm_rave_core_selector_ValueFunction)
 */
com_ibm_rave_core_Rave.min$1 = com_ibm_rave_core_arrays_MinMax.min$1;

/**
 * @see this.Quantile#this.quantile(Array, )
 */
/** @expose */ 
com_ibm_rave_core_Rave.quantile = com_ibm_rave_core_arrays_Quantile.quantile;

/**
 * @see this.Deviation#this.deviation()
 */
com_ibm_rave_core_Rave.deviation$0 = com_ibm_rave_core_arrays_Deviation.deviation$0;

/**
 * @see  Deviation#deviation(Object[], ValueFunction).
 */
com_ibm_rave_core_Rave.deviation$1 = com_ibm_rave_core_arrays_Deviation.deviation$1;

/**
 * @see this.Variance#this.variance()
 */
com_ibm_rave_core_Rave.variance$0 = com_ibm_rave_core_arrays_Variance.variance$0;

/**
 * @see this.Variance#this.variance(, com_ibm_rave_core_selector_ValueFunction)
 */
com_ibm_rave_core_Rave.variance$1 = com_ibm_rave_core_arrays_Variance.variance$1;

/**
 * @see this.Mean#this.mean()
 */
com_ibm_rave_core_Rave.mean$0 = com_ibm_rave_core_arrays_Mean.mean$0;

/**
 * @see this.Mean#this.mean(, com_ibm_rave_core_selector_ValueFunction)
 */
com_ibm_rave_core_Rave.mean$1 = com_ibm_rave_core_arrays_Mean.mean$1;

/**
 * @see this.Median#this.median()
 */
com_ibm_rave_core_Rave.median$0 = com_ibm_rave_core_arrays_Median.median$0;

/**
 * @see this.Median#this.median(, com_ibm_rave_core_selector_ValueFunction)
 */
com_ibm_rave_core_Rave.median$1 = com_ibm_rave_core_arrays_Median.median$1;

/**
 * @see this.Extent#this.extent()
 */
com_ibm_rave_core_Rave.extent$0 = com_ibm_rave_core_arrays_Extent.extent$0;

/**
 * @see this.Extent#this.extent(, com_ibm_rave_core_selector_ValueFunction)
 */
com_ibm_rave_core_Rave.extent$1 = com_ibm_rave_core_arrays_Extent.extent$1;

/**
 * @see this.Sum#this.sum(Array)
 */
com_ibm_rave_core_Rave.sum$0 = com_ibm_rave_core_arrays_Sum.sum$0;

/**
 * @see this.Sum#this.sum(Array, com_ibm_rave_core_selector_ValueFunction)
 */
com_ibm_rave_core_Rave.sum$1 = com_ibm_rave_core_arrays_Sum.sum$1;

/**
 * @see this.Zip#this.zip(Array...)
 */
/** @expose */ 
com_ibm_rave_core_Rave.zip = com_ibm_rave_core_arrays_Zip.zip;

/**
 * Uses the zip operator as a two-dimensional matrix transpose.
 * @see this.Zip#this.zip(Array...)
 */
/** @expose */ 
com_ibm_rave_core_Rave.transpose = function(objects) {
	return com_ibm_rave_core_arrays_Zip.zip.apply(com_ibm_rave_core_arrays_Zip, objects);
};

/**
 * @see this.Permute#this.permute(Array, Array)
 */
/** @expose */ 
com_ibm_rave_core_Rave.permute = com_ibm_rave_core_arrays_Permute.permute;

/**
 * @see this.Shuffle#this.shuffle(Array)
 */
com_ibm_rave_core_Rave.shuffle$0 = com_ibm_rave_core_arrays_Shuffle.shuffle$0;

/**
 * @see this.Shuffle#this.shuffle(Array)
 */
com_ibm_rave_core_Rave.shuffle$1 = com_ibm_rave_core_arrays_Shuffle.shuffle$1;

/**
 * @see this.Shuffle#this.shuffle(Array)
 */
com_ibm_rave_core_Rave.shuffle$2 = com_ibm_rave_core_arrays_Shuffle.shuffle$2;

/**
 * @see this.Range#this.create(Object)
 */
com_ibm_rave_core_Rave.range$0 = com_ibm_rave_core_arrays_Range.create;

/**
 * @see this.Range#this.create(Object, Object)
 */
com_ibm_rave_core_Rave.range$1 = com_ibm_rave_core_arrays_Range.create;

/**
 * @see this.Range#this.create(Object, Object, Object)
 */
com_ibm_rave_core_Rave.range$2 = com_ibm_rave_core_arrays_Range.create;

/**
 * @see this.Bisector#this.create(com_ibm_rave_core_util_Comparator)
 */
com_ibm_rave_core_Rave.bisector$0 = com_ibm_rave_core_arrays_Bisector.create;

/**
 * @see this.Bisector#this.create(com_ibm_rave_core_functions_DoubleValueFunction)
 */
com_ibm_rave_core_Rave.bisector$1 = com_ibm_rave_core_arrays_Bisector.create;

/**
 * @see this.Dispatcher#this.create(String...)
 */
/** @expose */ 
com_ibm_rave_core_Rave.dispatch = function(types) {
	if (types !== null || arguments.length > 1){
		types = Array.prototype.slice.call(arguments);
	}
	{
		return com_ibm_rave_core_event_Dispatcher.create.apply(com_ibm_rave_core_event_Dispatcher, types);
	}
};

/**
 * @see this.Mouse#this.mousePoint(com_ibm_rave_core_scene_SceneNode)
 */
/** @expose */ 
com_ibm_rave_core_Rave.mouse = com_ibm_rave_core_nativeImpl_event_Mouse.mousePoint;

/**
 * @see this.TouchUtil#this.touch(, , )
 */
com_ibm_rave_core_Rave.touch$0 = com_ibm_rave_core_event_TouchUtil.touch;

/**
 * @see this.TouchUtil#this.touchFromSource(com_ibm_rave_core_scene_SceneNode, String)
 */
com_ibm_rave_core_Rave.touch$1 = com_ibm_rave_core_event_TouchUtil.touchFromSource;

/**
 * @see this.Touches#this.touches(com_ibm_rave_core_scene_SceneNode)
 */
com_ibm_rave_core_Rave.touches$0 = com_ibm_rave_core_nativeImpl_event_Touches.touches;

/**
 * @see this.Touches#this.touches(, )
 */
com_ibm_rave_core_Rave.touches$1 = com_ibm_rave_core_nativeImpl_event_Touches.touches;

/**
 * @see this.Colors#this.newLAB(, , )
 */
com_ibm_rave_core_Rave.lab$0 = com_ibm_rave_core_color_Colors.newLAB;

/**
 * @see this.Colors#this.newLAB(Object)
 */
com_ibm_rave_core_Rave.lab$1 = com_ibm_rave_core_color_Colors.newLAB;

/**
 * @see this.Colors#this.newHCL(, , )
 */
com_ibm_rave_core_Rave.hcl$0 = com_ibm_rave_core_color_Colors.newHCL;

/**
 * @see this.Colors#this.newHCL(Object)
 */
com_ibm_rave_core_Rave.hcl$1 = com_ibm_rave_core_color_Colors.newHCL;

/**
 * @see this.Colors#this.newHSL(, , )
 */
com_ibm_rave_core_Rave.hsl$0 = com_ibm_rave_core_color_Colors.newHSL;

/**
 * @see this.Colors#this.newHSL(Object)
 */
com_ibm_rave_core_Rave.hsl$1 = com_ibm_rave_core_color_Colors.newHSL;

/**
 * @see this.Colors#this.newRGB(, , )
 */
com_ibm_rave_core_Rave.rgb$0 = com_ibm_rave_core_color_Colors.newRGB;

/**
 * @see this.Colors#this.newRGB(Object)
 */
com_ibm_rave_core_Rave.rgb$1 = com_ibm_rave_core_color_Colors.newRGB;

/**
 * @see this.Colors#this.newRGBA(, , , )
 */
/** @expose */ 
com_ibm_rave_core_Rave.rgba = com_ibm_rave_core_color_Colors.newRGBA;

/**
 * @see this.Round#this.round(, )
 */
/** @expose */ 
com_ibm_rave_core_Rave.round = com_ibm_rave_core_format_Round.round;

/**
 * @see this.Requote#this.requote(String)
 */
/** @expose */ 
com_ibm_rave_core_Rave.requote = com_ibm_rave_core_nativeImpl_format_Requote.requote;

/**
 * @see this.FormatPrefix#this.formatPrefix(, Number)
 */
/** @expose */ 
com_ibm_rave_core_Rave.formatPrefix = com_ibm_rave_core_format_FormatPrefix.formatPrefix;

/**
 * @see this.AssociativeArrays#this.keys(java_util_Map)
 * @return (Array)  list of keys for a given map
 */
/** @expose */ 
com_ibm_rave_core_Rave.keys = com_ibm_rave_core_nativeImpl_arrays_AssociativeArrays.keys;

/**
 * @see this.AssociativeArrays#this.values(java_util_Map)
 * @return (Array)  list of values for a given map
 */
/** @expose */ 
com_ibm_rave_core_Rave.values = com_ibm_rave_core_nativeImpl_arrays_AssociativeArrays.values;

/**
 * @see this.AssociativeArrays#this.entries(java_util_Map)
 * @return (Array)  list of key and value pair for a given map
 */
/** @expose */ 
com_ibm_rave_core_Rave.entries = com_ibm_rave_core_nativeImpl_arrays_AssociativeArrays.entries;

/**
 * Creates a new nest operator. The set of keys is initially empty. If the map or entries operator is invoked before any key functions are registered, the nest operator simply returns the input array.
 * @return (com.ibm.rave.core.arrays.Nest)  the nest operator
 */
/** @expose */ 
com_ibm_rave_core_Rave.nest = function() {
	return new com_ibm_rave_core_arrays_Nest();
};

/** @expose */ 
com_ibm_rave_core_Rave.selection = function() {
	return new com_ibm_rave_core_selector_Selector().init(com_ibm_rave_core_internal_nativeImpl_PlatformInitialization.getDocumentElement(com_ibm_rave_core_internal_nativeImpl_PlatformInitialization.getDocument()));
};

/**
 * @param (java.lang.Object[]) array
 * @return (java.lang.Object[])  Object[]
 * @see this.Pairs#this.pairs()
 */
/** @expose */ 
com_ibm_rave_core_Rave.pairs = com_ibm_rave_core_arrays_Pairs.pairs;

/**
 * Constructs a new set. If array is specified, adds the given array of string values to the returned set.
 * @return (com.ibm.rave.core.arrays.RaveSet)  a new Set
 * @see this.RaveSet#this.create()
 */
com_ibm_rave_core_Rave.set$0 = com_ibm_rave_core_arrays_RaveSet.create;

/**
 * Constructs a new set. If array is specified, adds the given array of string values to the returned set.
 * @return (com.ibm.rave.core.arrays.RaveSet)  a new Set
 * @see this.RaveSet#this.create()
 */
com_ibm_rave_core_Rave.set$1 = com_ibm_rave_core_arrays_RaveSet.create;

/**
 * Create and return an image of the chart , which contains this scene node, maintaining the current zoom level. E.g. awt implementations: <code> String tag; ImageCreatedCallback callback = new ImageCreatedCallback() { public void ready(Object arg) { BufferedImage image = (BufferedImage) arg; ... }; SceneNode node = root.select(tag).node(); Rave.getImage(node, callback); </code> the exact type of the image object depends on ImageFactory associated with the the scene node
 * @param (com.ibm.rave.core.scene.SceneNode) context scene node on the chart
 * @param (com.ibm.rave.core.scene.ImageCreatedCallback) callback a callback function to be called when image is ready. The call will receive image data object as an argument
 * @see (com.ibm.rave.core.scene.ImageFactory) ImageFactory
 * @see (com.ibm.rave.core.scene.ImageCreatedCallback) ImageCreatedCallback             
 */
/** @expose */ 
com_ibm_rave_core_Rave.getImage = function(context, callback) {
	var config = com_ibm_rave_core_Configuration.INSTANCE;
	var factory = config.getImageFactory(context.rave_getNamespaceURI());
	if (factory) {
		factory(context, callback);
	}
};

/** @expose */ 
com_ibm_rave_core_Rave.select = function(a0) {
	var args = arguments;
	if (args.length == 1 && (a0 == null || typeof a0 === "string")) {
		return com_ibm_rave_core_Rave.select$1(a0);
	}
	return com_ibm_rave_core_Rave.select$0(a0);
};

/** @expose */ 
com_ibm_rave_core_Rave.selectAll = function(a0) {
	var args = arguments;
	if (args.length == 1 && (a0 == null || Object.prototype.toString.call(a0) === "[object Array]")) {
		return com_ibm_rave_core_Rave.selectAll$0(a0);
	}
	return com_ibm_rave_core_Rave.selectAll$1(a0);
};

/** @expose */ 
com_ibm_rave_core_Rave.transition = function(a0, a1) {
	var args = arguments;
	if (args.length == 0) {
		return com_ibm_rave_core_Rave.transition$0();
	}
	if (args.length == 1 && (a0 == null || typeof a0 === "string")) {
		return com_ibm_rave_core_Rave.transition$2(a0);
	}
	if (args.length == 1) {
		return com_ibm_rave_core_Rave.transition$1(a0);
	}
	return com_ibm_rave_core_Rave.transition$3(a0, a1);
};

/** @expose */ 
com_ibm_rave_core_Rave.max = function(a0, a1) {
	var args = arguments;
	if (args.length == 1) {
		return com_ibm_rave_core_Rave.max$0(a0);
	}
	return com_ibm_rave_core_Rave.max$1(a0, a1);
};

/** @expose */ 
com_ibm_rave_core_Rave.min = function(a0, a1) {
	var args = arguments;
	if (args.length == 1) {
		return com_ibm_rave_core_Rave.min$0(a0);
	}
	return com_ibm_rave_core_Rave.min$1(a0, a1);
};

/** @expose */ 
com_ibm_rave_core_Rave.deviation = function(a0, a1) {
	var args = arguments;
	if (args.length == 1) {
		return com_ibm_rave_core_Rave.deviation$0(a0);
	}
	return com_ibm_rave_core_Rave.deviation$1(a0, a1);
};

/** @expose */ 
com_ibm_rave_core_Rave.variance = function(a0, a1) {
	var args = arguments;
	if (args.length == 1) {
		return com_ibm_rave_core_Rave.variance$0(a0);
	}
	return com_ibm_rave_core_Rave.variance$1(a0, a1);
};

/** @expose */ 
com_ibm_rave_core_Rave.mean = function(a0, a1) {
	var args = arguments;
	if (args.length == 1) {
		return com_ibm_rave_core_Rave.mean$0(a0);
	}
	return com_ibm_rave_core_Rave.mean$1(a0, a1);
};

/** @expose */ 
com_ibm_rave_core_Rave.median = function(a0, a1) {
	var args = arguments;
	if (args.length == 1) {
		return com_ibm_rave_core_Rave.median$0(a0);
	}
	return com_ibm_rave_core_Rave.median$1(a0, a1);
};

/** @expose */ 
com_ibm_rave_core_Rave.extent = function(a0, a1) {
	var args = arguments;
	if (args.length == 1) {
		return com_ibm_rave_core_Rave.extent$0(a0);
	}
	return com_ibm_rave_core_Rave.extent$1(a0, a1);
};

/** @expose */ 
com_ibm_rave_core_Rave.sum = function(a0, a1) {
	var args = arguments;
	if (args.length == 1) {
		return com_ibm_rave_core_Rave.sum$0(a0);
	}
	return com_ibm_rave_core_Rave.sum$1(a0, a1);
};

/** @expose */ 
com_ibm_rave_core_Rave.shuffle = function(a0, a1, a2) {
	var args = arguments;
	if (args.length == 1) {
		return com_ibm_rave_core_Rave.shuffle$0(a0);
	}
	if (args.length == 2) {
		return com_ibm_rave_core_Rave.shuffle$1(a0, a1);
	}
	return com_ibm_rave_core_Rave.shuffle$2(a0, a1, a2);
};

/** @expose */ 
com_ibm_rave_core_Rave.range = function(a0, a1, a2) {
	var args = arguments;
	if (args.length == 1) {
		return com_ibm_rave_core_Rave.range$0(a0);
	}
	if (args.length == 2) {
		return com_ibm_rave_core_Rave.range$1(a0, a1);
	}
	return com_ibm_rave_core_Rave.range$2(a0, a1, a2);
};

/** @expose */ 
com_ibm_rave_core_Rave.bisector = function(a0) {
	var args = arguments;
	if (args.length == 1 && typeof a0 === "function" && a0.length == 2) {
		return com_ibm_rave_core_Rave.bisector$0(a0);
	}
	return com_ibm_rave_core_Rave.bisector$1(a0);
};

/** @expose */ 
com_ibm_rave_core_Rave.touch = function(a0, a1, a2) {
	var args = arguments;
	if (args.length == 2) {
		return com_ibm_rave_core_Rave.touch$1(a0, a1);
	}
	return com_ibm_rave_core_Rave.touch$0(a0, a1, a2);
};

/** @expose */ 
com_ibm_rave_core_Rave.touches = function(a0, a1) {
	var args = arguments;
	if (args.length == 1) {
		return com_ibm_rave_core_Rave.touches$0(a0);
	}
	return com_ibm_rave_core_Rave.touches$1(a0, a1);
};

/** @expose */ 
com_ibm_rave_core_Rave.lab = function(a0, a1, a2) {
	var args = arguments;
	if (args.length == 1) {
		return com_ibm_rave_core_Rave.lab$1(a0);
	}
	return com_ibm_rave_core_Rave.lab$0(a0, a1, a2);
};

/** @expose */ 
com_ibm_rave_core_Rave.hcl = function(a0, a1, a2) {
	var args = arguments;
	if (args.length == 1) {
		return com_ibm_rave_core_Rave.hcl$1(a0);
	}
	return com_ibm_rave_core_Rave.hcl$0(a0, a1, a2);
};

/** @expose */ 
com_ibm_rave_core_Rave.hsl = function(a0, a1, a2) {
	var args = arguments;
	if (args.length == 1) {
		return com_ibm_rave_core_Rave.hsl$1(a0);
	}
	return com_ibm_rave_core_Rave.hsl$0(a0, a1, a2);
};

/** @expose */ 
com_ibm_rave_core_Rave.rgb = function(a0, a1, a2) {
	var args = arguments;
	if (args.length == 1) {
		return com_ibm_rave_core_Rave.rgb$1(a0);
	}
	return com_ibm_rave_core_Rave.rgb$0(a0, a1, a2);
};

/** @expose */ 
com_ibm_rave_core_Rave.set = function(a0) {
	var args = arguments;
	if (args.length == 0) {
		return com_ibm_rave_core_Rave.set$0();
	}
	return com_ibm_rave_core_Rave.set$1(a0);
};

{
	com_ibm_rave_core_internal_nativeImpl_PlatformInitialization();
}

/**
 * The currently registered CSS engine for this platform. May be null if the platform already includes a CSS engine (native web for instance).
 * @see (com.ibm.rave.core.css.CSSEngine) CSSEngine
 */
/** @expose */ 
com_ibm_rave_core_Rave.css = null;
/**
 * @see (com.ibm.rave.core.textMetrics.CanvasUtil) CanvasUtil
 */
/** @expose */ 
com_ibm_rave_core_Rave.canvas = com_ibm_rave_core_textMetrics_CanvasUtil.INSTANCE;
/**
 * @see (com.ibm.rave.core.nativeImpl.event.EventTracker) EventTracker
 */
/** @expose */ 
com_ibm_rave_core_Rave.event = com_ibm_rave_core_nativeImpl_event_EventTracker.INSTANCE;
/**
 * @see (com.ibm.rave.core.Configuration) Configuration
 */
/** @expose */ 
com_ibm_rave_core_Rave.configuration = com_ibm_rave_core_Configuration.INSTANCE;
/**
 * @see (com.ibm.rave.core.nativeImpl.timer.Timer) Timer
 */
/** @expose */ 
com_ibm_rave_core_Rave.timer = com_ibm_rave_core_nativeImpl_timer_Timer.INSTANCE;
/**
 * @see (com.ibm.rave.core.geom.Geom) Geom
 */
/** @expose */ 
com_ibm_rave_core_Rave.geom = com_ibm_rave_core_geom_Geom.INSTANCE;
/**
 * @see (com.ibm.rave.core.scales.Scales) Scales
 */
/** @expose */ 
com_ibm_rave_core_Rave.scale = com_ibm_rave_core_scales_Scales.INSTANCE;
/**
 * @see (com.ibm.rave.core.layout.Layout) Layout
 */
/** @expose */ 
com_ibm_rave_core_Rave.layout = com_ibm_rave_core_layout_Layout.INSTANCE;
/**
 * @see (com.ibm.rave.core.capabilities.Capabilities) Capabilities
 */
/** @expose */ 
com_ibm_rave_core_Rave.capabilities = com_ibm_rave_core_capabilities_Capabilities.INSTANCE;
/**
 * @see (com.ibm.rave.core.svg.SVG) SVG
 */
/** @expose */ 
com_ibm_rave_core_Rave.svg = com_ibm_rave_core_svg_SVG.getInstance();
/**
 * @see (com.ibm.rave.core.geo.Geo) Geo
 */
/** @expose */ 
com_ibm_rave_core_Rave.geo = com_ibm_rave_core_geo_Geo.INSTANCE;
/**
 * @see (com.ibm.rave.core.behavior.Behavior) Behavior
 */
/** @expose */ 
com_ibm_rave_core_Rave.behavior = com_ibm_rave_core_behavior_Behavior.INSTANCE;
/**
 * @see (com.ibm.rave.core.time.Time) Time
 */
/** @expose */ 
com_ibm_rave_core_Rave.time = com_ibm_rave_core_time_Time.getInstance();
/**
 * @see (com.ibm.rave.core.globalization.Bidi) Bidi
 */
/** @expose */ 
com_ibm_rave_core_Rave.bidi = com_ibm_rave_core_globalization_Bidi.INSTANCE;
/**
 * @see (com.ibm.rave.core.util.Namespace) Namespace
 */
/** @expose */ 
com_ibm_rave_core_Rave.ns = com_ibm_rave_core_util_Namespace.INSTANCE;
/**
 * @see (com.ibm.rave.core.math.Random) Random
 */
/** @expose */ 
com_ibm_rave_core_Rave.random = com_ibm_rave_core_math_Random.INSTANCE;
/**
 * @see this.NumberFormat#this.INSTANCE
 */
/** @expose */ 
com_ibm_rave_core_Rave.format = new com_ibm_rave_core_locale_NumberFormat(com_ibm_rave_core_locale_Locale.DEFAULT_LOCALE);
/**
 * @see this.StringFormatter#com_ibm_rave_core_util_StringFormatter.INSTANCE
 */
/** @expose */ 
com_ibm_rave_core_Rave.formatter = com_ibm_rave_core_util_StringFormatter.INSTANCE;
/**
 * @see this.Locale#this.locale
 */
/** @expose */ 
com_ibm_rave_core_Rave.locale = com_ibm_rave_core_locale_Locale.getInstance();
/**
 * @see this.Bisector#com_ibm_rave_core_arrays_Bisector.bisectLeft
 */
/** @expose */ 
com_ibm_rave_core_Rave.bisectLeft = com_ibm_rave_core_arrays_Bisector.bisectLeft;
/**
 * @see this.Bisector#com_ibm_rave_core_arrays_Bisector.bisectRight
 */
/** @expose */ 
com_ibm_rave_core_Rave.bisectRight = com_ibm_rave_core_arrays_Bisector.bisectRight;
/**
 * @see this.Bisector#com_ibm_rave_core_arrays_Bisector.bisect
 */
/** @expose */ 
com_ibm_rave_core_Rave.bisect = com_ibm_rave_core_arrays_Bisector.bisect;
/**
 * @see this.Sort#com_ibm_rave_core_arrays_Sort.descending
 */
/** @expose */ 
com_ibm_rave_core_Rave.descending = com_ibm_rave_core_arrays_Sort.descending;
/**
 * @see this.Sort#com_ibm_rave_core_arrays_Sort.descending
 */
/** @expose */ 
com_ibm_rave_core_Rave.ascending = com_ibm_rave_core_arrays_Sort.ascending;
/**
 * @see (com.ibm.rave.core.ease.Easing) Easing
 */
/** @expose */ 
com_ibm_rave_core_Rave.ease = com_ibm_rave_core_ease_Easing.INSTANCE;
/**
 * A base type is provided if you want to extend the core with additional color spaces. This type enables automatic RGB interpolation is detected via instanceof.
 */
/** @expose */ 
com_ibm_rave_core_Rave.color = com_ibm_rave_core_color_Color;
/**
 * @see (com.ibm.rave.core.interpolate.Interpolators) Interpolators
 */
/** @expose */ 
com_ibm_rave_core_Rave.interpolators = com_ibm_rave_core_interpolate_Interpolators.INSTANCE;
/**
 * @see this.Interpolate#com_ibm_rave_core_interpolate_Interpolate.INSTANCE
 */
/** @expose */ 
com_ibm_rave_core_Rave.interpolate = com_ibm_rave_core_interpolate_Interpolate.INSTANCE;
/**
 * @see this.ColorInterpolation#com_ibm_rave_core_interpolate_ColorInterpolation.HCLINSTANCE
 */
/** @expose */ 
com_ibm_rave_core_Rave.interpolateHcl = com_ibm_rave_core_interpolate_ColorInterpolation.HCLINSTANCE;
/**
 * @see this.ColorInterpolation#com_ibm_rave_core_interpolate_ColorInterpolation.HSLINSTANCE
 */
/** @expose */ 
com_ibm_rave_core_Rave.interpolateHsl = com_ibm_rave_core_interpolate_ColorInterpolation.HSLINSTANCE;
/**
 * @see this.ColorInterpolation#com_ibm_rave_core_interpolate_ColorInterpolation.LABINSTANCE
 */
/** @expose */ 
com_ibm_rave_core_Rave.interpolateLab = com_ibm_rave_core_interpolate_ColorInterpolation.LABINSTANCE;
/**
 * @see this.ColorInterpolation#com_ibm_rave_core_interpolate_ColorInterpolation.RGBINSTANCE
 */
/** @expose */ 
com_ibm_rave_core_Rave.interpolateRgb = com_ibm_rave_core_interpolate_ColorInterpolation.RGBINSTANCE;
/**
 * @see this.StringInterpolation#com_ibm_rave_core_interpolate_StringInterpolation.INSTANCE
 */
/** @expose */ 
com_ibm_rave_core_Rave.interpolateString = com_ibm_rave_core_interpolate_StringInterpolation.INSTANCE;
/**
 * @see this.NumberInterpolation#com_ibm_rave_core_interpolate_NumberInterpolation.INSTANCE
 */
/** @expose */ 
com_ibm_rave_core_Rave.interpolateNumber = com_ibm_rave_core_interpolate_NumberInterpolation.INSTANCE;
/**
 * @see this.RoundInterpolation#com_ibm_rave_core_interpolate_RoundInterpolation.INSTANCE
 */
/** @expose */ 
com_ibm_rave_core_Rave.interpolateRound = com_ibm_rave_core_interpolate_RoundInterpolation.INSTANCE;
/**
 * @see this.ArrayInterpolation#com_ibm_rave_core_interpolate_ArrayInterpolation.INSTANCE
 */
/** @expose */ 
com_ibm_rave_core_Rave.interpolateArray = com_ibm_rave_core_interpolate_ArrayInterpolation.INSTANCE;
/**
 * @see this.ObjectInterpolation#com_ibm_rave_core_nativeImpl_interpolate_ObjectInterpolation.INSTANCE
 */
/** @expose */ 
com_ibm_rave_core_Rave.interpolateObject = com_ibm_rave_core_nativeImpl_interpolate_ObjectInterpolation.INSTANCE;
/**
 * @see this.TransformInterpolation#com_ibm_rave_core_interpolate_TransformInterpolation.INSTANCE
 */
/** @expose */ 
com_ibm_rave_core_Rave.interpolateTransform = com_ibm_rave_core_interpolate_TransformInterpolation.INSTANCE;
/**
 * @see this.ZoomInterpolation#com_ibm_rave_core_interpolate_ZoomInterpolation.INSTANCE
 */
/** @expose */ 
com_ibm_rave_core_Rave.interpolateZoom = com_ibm_rave_core_interpolate_ZoomInterpolation.INSTANCE;
/** @expose */ 
com_ibm_rave_core_Rave.xhr = com_ibm_rave_core_nativeImpl_xhr_XhrIdentity.INSTANCE;
/** @expose */ 
com_ibm_rave_core_Rave.text = com_ibm_rave_core_nativeImpl_xhr_XhrText.INSTANCE;
/** @expose */ 
com_ibm_rave_core_Rave.json = com_ibm_rave_core_nativeImpl_xhr_XhrJson.INSTANCE;
/** @expose */ 
com_ibm_rave_core_Rave.html = com_ibm_rave_core_nativeImpl_xhr_XhrHtml.INSTANCE;
/** @expose */ 
com_ibm_rave_core_Rave.xml = com_ibm_rave_core_nativeImpl_xhr_XhrXml.INSTANCE;
/** @expose */ 
com_ibm_rave_core_Rave.dsv = com_ibm_rave_core_nativeImpl_dsv_Dsv.INSTANCE;
/** @expose */ 
com_ibm_rave_core_Rave.csv = com_ibm_rave_core_nativeImpl_dsv_Csv.INSTANCE;
/** @expose */ 
com_ibm_rave_core_Rave.tsv = com_ibm_rave_core_nativeImpl_dsv_Tsv.INSTANCE;
/**
 * Map function
 */
/** @expose */ 
com_ibm_rave_core_Rave.map = new com_ibm_rave_core_collections_MapFunctionClass();

// $source: com/ibm/rave/core/internal/selector/mirror/MirroredSelector
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
//@import com/ibm/rave/core/selector/Selector (loadtime) // superclass
//@import com/ibm/rave/core/internal/selector/mirror/MirroredSceneNodeHelper (runtime) // mirrorRoot, unMirrorNode
//@import com/ibm/rave/core/Rave (static) // Rave
//@import com/ibm/rave/core/internal/selector/mirror/MirroredSceneNodeExtension (runtime) // extend
//@import com/ibm/rave/core/Configuration (static) // Configuration
//@import com/ibm/rave/core/internal/selector/mirror/MirrorUtil (runtime) // isGroupNode
//@import com/ibm/rave/core/internal/util/QueryUtil (runtime) // getQueryEngine
/**
 * Selector returned by a call to Selector.mirror(). Handles additional mirroring functionality.
 */
var com_ibm_rave_core_internal_selector_mirror_MirroredSelector = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_selector_Selector, {

	/** @expose */ 
	getSelectorFactory : function() {
		return com_ibm_rave_core_internal_selector_mirror_MirroredSelector.factory;
	},

	/**
	 * Internal constructor for a selector containing mirrored objects.
	 */
	constructor : function() {
		this.needsNodeExtension = true;
	},

	/**
	 * Mirror a selector consisting of nodes (i.e. svg, "g", etc).
	 */
	/** @expose */ 
	mirror : function(mirror) {
		this.each(function(data, index, groupIndex) {
			if (mirror) {
				com_ibm_rave_core_internal_selector_mirror_MirroredSceneNodeHelper.mirrorRoot(this);
			} else {
				com_ibm_rave_core_internal_selector_mirror_MirroredSceneNodeHelper.unMirrorNode(this);
			}
		});
		return this;
	}
});

/**
 * Register the mirror extension for scene nodes.
 * @param (String) URI
 */
com_ibm_rave_core_internal_selector_mirror_MirroredSelector.register = function(URI) {
	com_ibm_rave_core_Rave.configuration.addSceneNodeExtensionFactory(URI, function(node, context) {
		com_ibm_rave_core_internal_selector_mirror_MirroredSceneNodeExtension.extend(node);
	}, 0);
	com_ibm_rave_core_Configuration.INSTANCE.registerFilter(com_ibm_rave_core_internal_selector_mirror_MirroredSelector.MIRROR_FILTER, com_ibm_rave_core_internal_selector_mirror_MirroredSelector.filterFunction);
};

com_ibm_rave_core_internal_selector_mirror_MirroredSelector.MIRROR_FILTER = "rave-mirror-filter";

com_ibm_rave_core_internal_selector_mirror_MirroredSelector.factory = function() {
	return new com_ibm_rave_core_internal_selector_mirror_MirroredSelector();
};
com_ibm_rave_core_internal_selector_mirror_MirroredSelector.filterFunction = function(item, query) {
	if (com_ibm_rave_core_internal_selector_mirror_MirrorUtil.isGroupNode(item)) {
		if (query != null) {
			return com_ibm_rave_core_internal_util_QueryUtil.getQueryEngine(item).querySelector(query, item);
		}
		return null;
	}
	return item;
};

// $source: com/ibm/rave/core/scales/LinearScale
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare, bind
//@import com/ibm/rave/core/scales/AbstractScale (loadtime) // scaleExtent, superclass
//@import com/ibm/rave/core/Rave (static) // formatPrefix, range, Rave
//@import com/ibm/rave/core/internal/scales/Polylinear (runtime) // new
//@import com/ibm/rave/core/internal/scales/Bilinear (runtime) // new
//@import com/ibm/rave/core/internal/interpolate/UninterpolateClamp (runtime) // new
//@import com/ibm/rave/core/internal/interpolate/UninterpolateNumber (runtime) // new
//@import com/ibm/rave/core/interpolate/RoundInterpolation (runtime) // new
//@import com/ibm/rave/core/internal/scales/Nice (static) // scaleNice, niceStep
//@import com/ibm/rave/core/locale/NumberFormat (runtime) // NumberFormat
//@import com/ibm/rave/core/nativeImpl/arrays/ES6Map (runtime) // create
/**
 * LinearScale maps a numerical input domain (a set [min, max]) to a numerical output range (another set [min, max]). The domain and range parameters for this scale are expected to be arrays of length 2 containing [min, max].
 */
var com_ibm_rave_core_scales_LinearScale = rave_externs["LinearScale"] = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_scales_AbstractScale, {

	//_domain : null,

	//_range : null,

	/** @expose */ 
	_interpolate : null,

	//output : null,

	/** @expose */ 
	input : null,

	/** @expose */ 
	_clamp : false,

	_$functionClassMethod : function() {
		var _$self = function(data, index, groupIndex) {
			return _$self.output(data);
		};
		return _$self;
	},

	constructor : function(domain, range, interpolate, clamp) {
		this._domain = [0, 1];
		this._range = [0, 1];
		this._interpolate = com_ibm_rave_core_Rave.interpolate;
				/**
		 * @param (Array) domain
		 * @param (Array) range
		 * @param (com.ibm.rave.core.interpolate.InterpolatorFactory) interpolate
		 * @param (java.lang.Boolean) clamp
		 */
		{
			if (domain) {
				this.domain(domain);
			}
			if (range) {
				this.range(range);
			}
			if (interpolate) {
				this._interpolate = interpolate;
			}
			if (clamp != null) {
				this._clamp = clamp;
			}
			var self = this;
			this.invert = function(y) {
				return self.input(y);
			};
			this.ticks = function(tickArguments) {
				if (tickArguments !== null || arguments.length > 1){
					tickArguments = Array.prototype.slice.call(arguments);
				}
				{
					return com_ibm_rave_core_scales_LinearScale.linearTicks.apply(this, [self._domain].concat(tickArguments));
				}
			};
			this.tickFormat = function(tickArguments) {
				if (tickArguments !== null || arguments.length > 1){
					tickArguments = Array.prototype.slice.call(arguments);
				}
				{
					var count = tickArguments.length > 0 ? + (tickArguments[0]) : null;
					var format = tickArguments.length > 1 ? tickArguments[1] : null;
					return com_ibm_rave_core_scales_LinearScale.linearTickFormat(self._domain, count, ((typeof format === "string" || format instanceof String)) ? format : null);
				}
			};
			this.rescale();
		}
	},

	rescale : function() {
		var linear = Math.min(this._domain.length, this._range.length) > 2 ? new com_ibm_rave_core_internal_scales_Polylinear() : new com_ibm_rave_core_internal_scales_Bilinear();
		var uninterpolator = this._clamp ? new com_ibm_rave_core_internal_interpolate_UninterpolateClamp() : new com_ibm_rave_core_internal_interpolate_UninterpolateNumber();
		this.output = linear(this._domain, this._range, uninterpolator, this._interpolate);
		this.input = linear(this._range, this._domain, uninterpolator, com_ibm_rave_core_Rave.interpolate);
		return this;
	},

	domain$0 : function(values) {
		this._domain = [];
		for (var __i_enFor0 = 0, __exp_enFor0 = values, __len_enFor0 = __exp_enFor0.length;
				__i_enFor0 < __len_enFor0; ++__i_enFor0) {
			var o = __exp_enFor0[__i_enFor0];
			this._domain.push(+ (o));
		}
		return this.rescale();
	},

	domain$1 : function() {
		return this._domain;
	},

	range$0 : function(values) {
		this._range = [];
		for (var __i_enFor0 = 0, __exp_enFor0 = values, __len_enFor0 = __exp_enFor0.length;
				__i_enFor0 < __len_enFor0; ++__i_enFor0) {
			var o = __exp_enFor0[__i_enFor0];
			this._range.push(o);
		}
		return this.rescale();
	},

	range$1 : function() {
		return this._range;
	},

	/**
	 * Sets the scale's output range to the specified array of values, while also setting the scale's interpolator to Rave.interpolateRound. This is a convenience routine for when the values output by the scale should be exact integers, such as to avoid antialiasing artifacts. It is also possible to round the output values manually after the scale is applied.
	 * @param (Array) x Output range values.
	 * @return (com.ibm.rave.core.scales.LinearScale)  This scale.
	 */
	/** @expose */ 
	rangeRound : function(x) {
		return this.range(x).interpolate(new com_ibm_rave_core_interpolate_RoundInterpolation());
	},

	/**
	 * If boolean is specified, enables or disables clamping accordingly. By default, clamping is disabled, such that if a value outside the input domain is passed to the scale, the scale may return a value outside the output range through linear extrapolation. For example, with the default domain and range of [0,1], an input value of 2 will return an output value of 2. If clamping is enabled, the normalized domain parameter t is clamped to the range [0,1], such that the return value of the scale is always within the scale's output range. If boolean is not specified, returns whether or not the scale currently clamps values to within the output range.
	 * @param (boolean) c True or False to Enable or Disable (respectively) clamping.
	 * @return (com.ibm.rave.core.scales.LinearScale)  This scale.
	 */
	clamp$0 : function(c) {
		this._clamp = c;
		return this.rescale();
	},

	/**
	 * If boolean is specified, enables or disables clamping accordingly. By default, clamping is disabled, such that if a value outside the input domain is passed to the scale, the scale may return a value outside the output range through linear extrapolation. For example, with the default domain and range of [0,1], an input value of 2 will return an output value of 2. If clamping is enabled, the normalized domain parameter t is clamped to the range [0,1], such that the return value of the scale is always within the scale's output range. If boolean is not specified, returns whether or not the scale currently clamps values to within the output range.
	 * @return (boolean)  True if clamping is enabled, false otherwise.
	 */
	clamp$1 : function() {
		return this._clamp;
	},

	/**
	 * If factory is specified, sets the scale's output interpolator using the specified factory. The interpolator factory defaults to {@link this.Rave#com_ibm_rave_core_Rave.interpolate} , and is used to map the normalized domain parameter t in [0,1] to the corresponding value in the output range. The interpolator factory will be used to construct interpolators for each adjacent pair of values from the output range. If factory is not specified, returns the scale's interpolator factory.
	 * @param (com.ibm.rave.core.interpolate.InterpolatorFactory) interpolate The interpolator factory to assign to this scale.
	 * @return (com.ibm.rave.core.scales.LinearScale)  this
	 */
	interpolate$0 : function(interpolate) {
		this._interpolate = interpolate;
		return this.rescale();
	},

	/**
	 * If factory is specified, sets the scale's output interpolator using the specified factory. The interpolator factory defaults to {@link this.Rave#com_ibm_rave_core_Rave.interpolate} , and is used to map the normalized domain parameter t in [0,1] to the corresponding value in the output range. The interpolator factory will be used to construct interpolators for each adjacent pair of values from the output range. If factory is not specified, returns the scale's interpolator factory.
	 * @return (Object)  The interpolator factory assigned to this scale.
	 */
	interpolate$1 : function() {
		return this._interpolate;
	},

	/**
	 * Extends the domain so that it starts and ends on nice round values. This method typically modifies the scale's domain, and may only extend the bounds to the nearest round value. The precision of the round value is dependent on the extent of the domain dx according to the following formula: exp(round(log(dx)) - 1). Nicing is useful if the domain is computed from data and may be irregular. For example, for a domain of [0.20147987687960267, 0.996679553296417], the nice domain is [0.2, 1]. If the domain has more than two values, nicing the domain only affects the first and last value. The optional tick count argument allows greater control over the step size used to extend the bounds, guaranteeing that the returned ticks will exactly cover the domain.
	 * @return (com.ibm.rave.core.scales.LinearScale)  this
	 */
	nice$0 : function() {
		com_ibm_rave_core_scales_LinearScale.linearNice(this._domain, 10);
		return this.rescale();
	},

	/**
	 * Extends the domain so that it starts and ends on nice round values. This method typically modifies the scale's domain, and may only extend the bounds to the nearest round value. The precision of the round value is dependent on the extent of the domain dx according to the following formula: exp(round(log(dx)) - 1). Nicing is useful if the domain is computed from data and may be irregular. For example, for a domain of [0.20147987687960267, 0.996679553296417], the nice domain is [0.2, 1]. If the domain has more than two values, nicing the domain only affects the first and last value. The optional tick count argument allows greater control over the step size used to extend the bounds, guaranteeing that the returned ticks will exactly cover the domain.
	 * @param (Number) tickCount
	 * @return (com.ibm.rave.core.scales.LinearScale)  this
	 */
	nice$1 : function(tickCount) {
		com_ibm_rave_core_scales_LinearScale.linearNice(this._domain, tickCount);
		return this.rescale();
	},

	/**
	 * Extends the domain so that it starts and ends on nice round values. This method typically modifies the scale's domain, and may only extend the bounds to the nearest round value. The precision of the round value is dependent on the extent of the domain dx according to the following formula: exp(round(log(dx)) - 1). Nicing is useful if the domain is computed from data and may be irregular. For example, for a domain of [0.20147987687960267, 0.996679553296417], the nice domain is [0.2, 1]. If the domain has more than two values, nicing the domain only affects the first and last value. The optional tick count argument allows greater control over the step size used to extend the bounds, guaranteeing that the returned ticks will exactly cover the domain. Only a Time-based scale supports the usage of Time Intervals.
	 * @param (Number) tickCount
	 * @return (com.ibm.rave.core.scales.LinearScale)  this
	 */
	nice$2 : function(interval, tickCount) {
		return null;
	},

	nice$3 : function(interval) {
		return null;
	},

	/** @expose */ 
	copy : com_ibm_rave_core_nativeImpl_Declare.bind(function() {
		return new com_ibm_rave_core_scales_LinearScale(this.domain(), this.range(), this._interpolate, this._clamp);
	}),

	/** @expose */ 
	domain : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.domain$1();
		}
		return this.domain$0(a0);
	},

	/** @expose */ 
	range : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.range$1();
		}
		return this.range$0(a0);
	},

	/** @expose */ 
	clamp : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.clamp$1();
		}
		return this.clamp$0(a0);
	},

	/** @expose */ 
	interpolate : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.interpolate$1();
		}
		return this.interpolate$0(a0);
	},

	/** @expose */ 
	nice : function(a0, a1) {
		var args = arguments;
		if (args.length == 0) {
			return this.nice$0();
		}
		if (args.length == 1 && (a0 == null || typeof a0 === "number")) {
			return this.nice$1(a0);
		}
		if (args.length == 1) {
			return this.nice$3(a0);
		}
		return this.nice$2(a0, a1);
	}
});

/**
 * @param (Array) domain
 * @param (Number) tickArguments
 * @return (Array)  List of "nice"ed domain values
 */
com_ibm_rave_core_scales_LinearScale.linearNice = function(domain, tickArguments) {
	return com_ibm_rave_core_internal_scales_Nice.scaleNice(domain, com_ibm_rave_core_internal_scales_Nice.niceStep(com_ibm_rave_core_scales_LinearScale.linearTickRange(domain, tickArguments)[2]));
};

/**
 * @param (Array) domain
 * @param (Number) tickCount
 * @return (Array)  an array of the start, stop and step values
 */
/** @expose */ 
com_ibm_rave_core_scales_LinearScale.linearTickRange = function(domain, tickCount) {
	var m = tickCount != null ? tickCount : 10;
	var extent = com_ibm_rave_core_scales_AbstractScale.scaleExtent(domain);
	var span = + (extent[1]) - + (extent[0]);
	var step = Math.pow(10, Math.floor(Math.log(span / m) / Math.log(10)));
	var err = m / span * step;
	if (err <= 0.15) {
		step *= 10;
	} else if (err <= 0.35) {
		step *= 5;
	} else if (err <= 0.75) {
		step *= 2;
	}
	extent[0] = Math.ceil(+ (extent[0]) / step) * step;
	extent[1] = Math.floor(+ (extent[1]) / step) * step + step * .5;
	extent.splice(2, 0, step);
	return extent;
};

/**
 * @param  _domain2
 * @param (java.lang.Object[]) tickArguments
 * @return (Array)  The ticks
 */
com_ibm_rave_core_scales_LinearScale.linearTicks = function(domain, tickArguments) {
	if (tickArguments !== null || arguments.length > 2){
		tickArguments = Array.prototype.slice.call(arguments, 1);
	}
	{
		var tickCount = tickArguments && tickArguments.length > 0 ? + (tickArguments[0]) : null;
		var extents = com_ibm_rave_core_scales_LinearScale.linearTickRange(domain, tickCount);
		return (com_ibm_rave_core_Rave.range(+ (extents[0]), + (extents[1]), + (extents[2])));
	}
};

/**
 * @param (Array) domain
 * @param (Number) m
 * @param (String) format
 * @return (com.ibm.rave.core.selector.ValueFunction)  Formatted tick labels
 */
com_ibm_rave_core_scales_LinearScale.linearTickFormat = function(domain, m, format) {
	var _format = format;
	var range = com_ibm_rave_core_scales_LinearScale.linearTickRange(domain, m);
	if ((_format)) {
		var match = new RegExp(com_ibm_rave_core_locale_NumberFormat.format_re, "i").exec(_format);
		match.shift();
		if (match.length >= 8 && match[8] == "s") {
			var d = Math.max(Math.abs(+ (range[0])), Math.abs(+ (range[1])));
			var prefix = com_ibm_rave_core_Rave.formatPrefix(d, null);
			if (!((match[7]))) {
				match[7] = "." + com_ibm_rave_core_scales_LinearScale.linearPrecision(prefix.scale(+ (range[2])));
			}
			match[8] = "f";
			var numFormat = com_ibm_rave_core_Rave.format(match.join(""));
			return function(data, index, groupIndex) {
				return numFormat.call(this, prefix.scale(+ (data)), index, groupIndex) + prefix.symbol;
			};
		}
		if (!((match[7]))) {
			match[7] = "." + com_ibm_rave_core_scales_LinearScale.linearFormatPrecision(match[8], range);
		}
		_format = match.join("");
	} else {
		var value = + (range[2]);
		_format = ",." + com_ibm_rave_core_scales_LinearScale.linearPrecision(value) + "f";
	}
	return com_ibm_rave_core_Rave.format(_format);
};

com_ibm_rave_core_scales_LinearScale.initialize_linearFormatSignificant = function() {
	var linearFormatSignificant = com_ibm_rave_core_nativeImpl_arrays_ES6Map.create();
	linearFormatSignificant.set("s", 1);
	linearFormatSignificant.set("g", 1);
	linearFormatSignificant.set("p", 1);
	linearFormatSignificant.set("r", 1);
	linearFormatSignificant.set("e", 1);
	return linearFormatSignificant;
};

/**
 * @param (double) value
 * @return (int)  int
 */
com_ibm_rave_core_scales_LinearScale.linearPrecision = function(value) {
	return ~~-Math.floor(Math.log(value) / Math.log(10) + 0.01);
};

/**
 * @param (String) type
 * @param (Array) range
 * @return (Number)  Number
 */
com_ibm_rave_core_scales_LinearScale.linearFormatPrecision = function(type, range) {
	var d = + (range[2]);
	var p = com_ibm_rave_core_scales_LinearScale.linearPrecision(d);
	if (com_ibm_rave_core_scales_LinearScale.linearFormatSignificant.get(type) != null) {
		var precision = com_ibm_rave_core_scales_LinearScale.linearPrecision(Math.max(Math.abs(+ (range[0])), Math.abs(+ (range[1]))));
		var typeValue = 0;
		if (!(0 <= type.indexOf("e"))) {
			typeValue = 1;
		}
		return Math.abs(p - precision + typeValue);
	} else {
		var typeValue = 0;
		if (type == "%") {
			typeValue = 1;
		}
		return p - typeValue * 2;
	}
};

/** @expose */ 
com_ibm_rave_core_scales_LinearScale.DEFAULT_TICKS = 10;

com_ibm_rave_core_scales_LinearScale.linearFormatSignificant = com_ibm_rave_core_scales_LinearScale.initialize_linearFormatSignificant();

// $source: com/ibm/rave/core/time/DateTimeScale
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare, bind
//@import com/ibm/rave/core/scales/LinearScale (loadtime) // linearTickRange, superclass
//@import com/ibm/rave/core/arrays/Bisector (runtime) // Bisector
//@import com/ibm/rave/core/time/Time (static) // getInstance
//@import com/ibm/rave/core/scales/AbstractScale (runtime) // scaleExtent
//@import com/ibm/rave/core/internal/scales/Nice (runtime) // scaleNice
//@import com/ibm/rave/core/internal/scales/NiceIdentity (loadtime) // new, superclass
//@import com/ibm/rave/core/internal/nativeImpl/Lang (runtime) // isNumber
/**
 * Rave's time scale is an extension of rave.scale.linear that uses JavaScript Date objects as  the domain representation. Thus, unlike the normal linear scale, domain values are coerced  to dates rather than numbers; similarly, the invert function returns a date. Most  conveniently, the time scale also provides suitable ticks based on time intervals, taking  the pain out of generating axes for nearly any time-based domain. A scale object, such as that returned by rave.time.scale, is both an object and a function.  That is: you can call the scale like any other function, and the scale has additional  methods that change its behavior. Like other classes in Rave, scales follow the method chaining  pattern where setter methods return the scale itself, allowing multiple setters to be invoked  in a concise statement.
 */
var com_ibm_rave_core_time_DateTimeScale = rave_externs["DateTimeScale"] = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_scales_LinearScale, {

	//_format : null,

	//_methods : null,

	//_methodsYear : null,

	/**
	 * If dates is specified, sets the scale's input domain to the specified array of dates.  The array must contain two or more dates. If the elements in the given array are not dates,  they will be coerced to dates; this coercion happens similarly when the scale is called.  If dates is not specified, returns the scale's current input domain.  Although time scales typically have just two dates in their domain, you can specify more  than two dates for a polylinear scale. In this case, there must be an equivalent number of values in the output range.
	 * @return (Array)  Array of Date objects.
	 */
	/** @expose */ 
	domain$1 : com_ibm_rave_core_nativeImpl_Declare.bind(function() {
		return com_ibm_rave_core_scales_LinearScale.prototype.domain$1.call(this).map(com_ibm_rave_core_time_DateTimeScale.scaleDate);
	}),

	/**
	 * Returns an exact copy of this time scale. Changes to this scale will not affect the returned scale, and vice versa.
	 * @return (com.ibm.rave.core.time.DateTimeScale)  copy TimeScale
	 */
	/** @expose */ 
	copy : com_ibm_rave_core_nativeImpl_Declare.bind(function() {
		return new com_ibm_rave_core_time_DateTimeScale(this.domain$1(), this.range(), this._interpolate, this._clamp, this._format, this._methods, this._methodsYear);
	}),

	constructor : function(domain, range, interpolate, clamp, format, methods, methodsYear) {
		this._format = format;
		this._methods = methods;
		this._methodsYear = methodsYear;
		var self = this;
		this.invert = function(y) {
			return self.invertDate(y);
		};
		this.ticks = function(tickArguments) {
			if (tickArguments !== null || arguments.length > 1){
				tickArguments = Array.prototype.slice.call(arguments);
			}
			{
				return self.timeTicks.apply(self, tickArguments);
			}
		};
		this.tickFormat = function(tickArguments) {
			if (tickArguments !== null || arguments.length > 1){
				tickArguments = Array.prototype.slice.call(arguments);
			}
			{
				return self.timeTickFormat.apply(self, tickArguments);
			}
		};
	},

	tickMethod : com_ibm_rave_core_nativeImpl_Declare.bind(function(extent, tickCount) {
		var span = + (extent[1]) - + (extent[0]);
		var target = span / tickCount;
		var i = com_ibm_rave_core_arrays_Bisector.bisect(com_ibm_rave_core_time_DateTimeScale.scaleSteps, target);
		if (i == com_ibm_rave_core_time_DateTimeScale.scaleSteps.length) {
			var list = extent.map(function(currentValue, index, array) {
				return + (currentValue) / 31536e6;
			});
			return [this._methodsYear, com_ibm_rave_core_scales_LinearScale.linearTickRange(list, tickCount)[2]];
		} else if (i == 0) {
			return [com_ibm_rave_core_time_Time.getInstance().millisecond, com_ibm_rave_core_scales_LinearScale.linearTickRange(extent, tickCount)[2]];
		}
		var index = target / (com_ibm_rave_core_time_DateTimeScale.scaleSteps[i - 1]) < (com_ibm_rave_core_time_DateTimeScale.scaleSteps[i]) / target ? i - 1 : i;
		return this._methods[index];
	}),

	nice$0 : function() {
		return this.nice$1(10);
	},

	nice$1 : function(tickCount) {
		var domain = this.domain$1();
		var extent = com_ibm_rave_core_scales_AbstractScale.scaleExtent(domain);
		var method = this.tickMethod(extent, tickCount);
		return this.nice$2(method[0], method[1]);
	},

	nice$3 : function(interval) {
		return this.nice$2(interval, 0);
	},

	nice$2 : function(interval, tickCount) {
		var skip = tickCount;
		return this.domain(com_ibm_rave_core_internal_scales_Nice.scaleNice(this.domain$1(), skip > 1 ? new com_ibm_rave_core_time_DateTimeScale.TimeNiceIdentity(interval, skip) : new com_ibm_rave_core_internal_scales_NiceIdentity(function(x) {
			return interval.floor(new Date(x)).getTime();
		}, function(x) {
			return interval.ceil(new Date(x)).getTime();
		})));
	},

	/**
	 * Returns representative dates from the scale's input domain. The returned tick dates are uniformly spaced (modulo irregular time intervals, such as months and leap years), have human-readable values (such as midnights), and are guaranteed to be within the extent of the input domain. Ticks are often used to display reference lines, or tick marks, in conjunction with the visualized data. If count is a number, then approximately count ticks will be returned. If count is not specified, it defaults to 10. The specified count is only a hint; the scale may return more or fewer values depending on the input domain. If a time interval is specified, then the time interval’s range function will be used to generate ticks, being passed the optional step argument, if any. For example, to create ten default ticks, say: scale.ticks(10); While to create ticks at 15-minute intervals, say: scale.ticks(rave.time.minute, 15); Note: for UTC scales, be sure to use the appropriate UTC range method (such as rave.time.minute.utc). The following time intervals are considered for automatic ticks: 1-, 5-, 15- and 30-second. 1-, 5-, 15- and 30-minute. 1-, 3-, 6- and 12-hour. 1- and 2-day. 1-week. 1- and 3-month. 1-year. This set of time intervals is somewhat arbitrary and additional values may be added in the future. RAVE NOTE: Rave Supports TimeRanges to be used instead of TimeIntervals (delegating to the range's interval) Rave does not support this deprecated feature.
	 * @param  TimeInterval | tickCount
	 * @param  tickCount
	 */
	timeTicks : function(tickArguments) {
		if (tickArguments !== null || arguments.length > 1){
			tickArguments = Array.prototype.slice.call(arguments);
		}
		{
			var domain = this.domain$1();
			var extent = com_ibm_rave_core_scales_AbstractScale.scaleExtent(domain);
			var interval;
			var count = 0;
			if (tickArguments.length > 0) {
				if (com_ibm_rave_core_internal_nativeImpl_Lang.isNumber(tickArguments[0])) {
					count = tickArguments[0];
				} else {
					interval = tickArguments[0];
				}
			}
			if (interval && tickArguments.length > 1) {
				if (com_ibm_rave_core_internal_nativeImpl_Lang.isNumber(tickArguments[1])) {
					count = tickArguments[1];
				}
			}
			var method;
			if (!interval) {
				if (tickArguments.length > 1) {
					count = tickArguments[1];
				}
				method = this.tickMethod(extent, count != 0 ? count : 10);
				interval = method[0];
				count = method[1];
			}
			var skip = count;
			var date1 = extent[0];
			var date2 = extent[1];
			if (interval.range) {
				return (interval).range(date1, new Date(date2.getTime() + 1), skip < 1 ? 1 : skip);
			}
			return (interval)(date1, new Date(date2.getTime() + 1), skip < 1 ? 1 : skip);
		}
	},

	/**
	 * Returns a time format function suitable for displaying a tick value. The scale's built-in tick format automatically computes the appropriate display based on the input date. The following time formats are considered: <ul> <li>%Y - for year boundaries, such as "2011".</li> <li>%B - for month boundaries, such as "February".</li> <li>%b %d - for week boundaries, such as "Feb 06".</li> <li>%a %d - for day boundaries, such as "Mon 07".</li> <li>%I %p - for hour boundaries, such as "01 AM".</li> <li>%I:%M - for minute boundaries, such as "01:23".</li> <li>:%S - for second boundaries, such as ":45".</li> <li>.%L - milliseconds for all other times, such as ".012".</li> </ul>
	 * @param (java.lang.Object[]) tickArguments Optional arguments (typically passed in by Axis) which are not used by TimeScale
	 * @return (com.ibm.rave.core.selector.ValueFunction)  Time format function
	 */
	timeTickFormat : function(tickArguments) {
		if (tickArguments !== null || arguments.length > 1){
			tickArguments = Array.prototype.slice.call(arguments);
		}
		{
			return this._format;
		}
	},

	invertDate : function(x) {
		return com_ibm_rave_core_time_DateTimeScale.scaleDate(this.input(x), 0, null);
	},

	/** @expose */ 
	nice : com_ibm_rave_core_nativeImpl_Declare.bind(function(a0, a1) {
		var args = arguments;
		if (args.length == 0) {
			return this.nice$0();
		}
		if (args.length == 1 && (a0 == null || typeof a0 === "number")) {
			return this.nice$1(a0);
		}
		if (args.length == 1) {
			return this.nice$3(a0);
		}
		return this.nice$2(a0, a1);
	})
});

com_ibm_rave_core_time_DateTimeScale.ScaleDate = com_ibm_rave_core_nativeImpl_Declare({

	_$functionClassMethod : function() {
		var _$self = function(currentValue, index, array) {
			return new Date(+ (currentValue));
		};
		return _$self;
	}
});

/**
 * Overrides NiceIdentity for more functionality 
 */
com_ibm_rave_core_time_DateTimeScale.TimeNiceIdentity = rave_externs["TimeNiceIdentity"] = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_internal_scales_NiceIdentity, {

	//interval : null,

	skip : 0,

	constructor : function(interval, skip) {
		this.interval = interval;
		this.skip = skip;
		var self = this;
		this.floor = function(dateNumber) {
			var newDate = new Date(dateNumber);
			while (self.skipped(newDate = interval.floor(newDate))) {
				newDate = new Date(newDate.getTime() - 1);
			}
			return newDate.getTime();
		};
		this.ceil = function(dateNumber) {
			var newDate = new Date(dateNumber);
			while (self.skipped(newDate = interval.ceil(newDate))) {
				newDate = new Date(newDate.getTime() + 1);
			}
			return newDate.getTime();
		};
	},

	skipped : function(date) {
		return this.interval.range(date, new Date(date.getTime() + 1), this.skip).length == 0;
	}
});

com_ibm_rave_core_time_DateTimeScale.scaleDate = new com_ibm_rave_core_time_DateTimeScale.ScaleDate();
com_ibm_rave_core_time_DateTimeScale.scaleSteps = [1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6];
/**
 * local methods map: for UTC scales, be sure to use the appropriate UTC range  method (such as rave.time.minute.utc). The following time intervals are considered for automatic ticks: 1-, 5-, 15- and 30-second. 1-, 5-, 15- and 30-minute. 1-, 3-, 6- and 12-hour. 1- and 2-day. 1-week. 1- and 3-month. 1-year. This set of time intervals is somewhat arbitrary and additional values may be  added in the future.
 */
/** @expose */ 
com_ibm_rave_core_time_DateTimeScale.localMethods = [[com_ibm_rave_core_time_Time.getInstance().second, 1], [com_ibm_rave_core_time_Time.getInstance().second, 5], [com_ibm_rave_core_time_Time.getInstance().second, 15], [com_ibm_rave_core_time_Time.getInstance().second, 30], [com_ibm_rave_core_time_Time.getInstance().minute, 1], [com_ibm_rave_core_time_Time.getInstance().minute, 5], [com_ibm_rave_core_time_Time.getInstance().minute, 15], [com_ibm_rave_core_time_Time.getInstance().minute, 30], [com_ibm_rave_core_time_Time.getInstance().hour, 1], [com_ibm_rave_core_time_Time.getInstance().hour, 3], [com_ibm_rave_core_time_Time.getInstance().hour, 6], [com_ibm_rave_core_time_Time.getInstance().hour, 12], [com_ibm_rave_core_time_Time.getInstance().day, 1], [com_ibm_rave_core_time_Time.getInstance().day, 2], [com_ibm_rave_core_time_Time.getInstance().week, 1], [com_ibm_rave_core_time_Time.getInstance().month, 1], [com_ibm_rave_core_time_Time.getInstance().month, 3], [com_ibm_rave_core_time_Time.getInstance().year, 1]];
/**
 * Map the localMethods local time interval to utc time interval
 */
/** @expose */ 
com_ibm_rave_core_time_DateTimeScale.utcMethods = com_ibm_rave_core_time_DateTimeScale.localMethods.map(function(currentValue, index, array) {
	return [(currentValue[0]).utc, currentValue[1]];
});
/**
 * Returns the appropriate ValueFunction depending on the format used
 */
/** @expose */ 
com_ibm_rave_core_time_DateTimeScale.localFormat = com_ibm_rave_core_time_Time.getInstance().format.multi([[".%L", function(data, index, groupIndex) {
	return (data).getMilliseconds();
}], [":%S", function(data, index, groupIndex) {
	return (data).getSeconds();
}], ["%I:%M", function(data, index, groupIndex) {
	return (data).getMinutes();
}], ["%I %p", function(data, index, groupIndex) {
	return (data).getHours();
}], ["%a %d", function(data, index, groupIndex) {
	var date = data;
	return (date.getDay()) && date.getDate() != 1 ? 1 : 0;
}], ["%b %d", function(data, index, groupIndex) {
	return (data).getDate() != 1 ? 1 : 0;
}], ["%B", function(data, index, groupIndex) {
	return (data).getMonth();
}], ["%Y", function(data, index, groupIndex) {
	return 1;
}]]);
/**
 * Configure formatting for UTC time
 */
/** @expose */ 
com_ibm_rave_core_time_DateTimeScale.utcFormat = com_ibm_rave_core_time_Time.getInstance().format.utc.multi([[".%L", function(data, index, groupIndex) {
	return (data).getUTCMilliseconds();
}], [":%S", function(data, index, groupIndex) {
	return (data).getUTCSeconds();
}], ["%I:%M", function(data, index, groupIndex) {
	return (data).getUTCMinutes();
}], ["%I %p", function(data, index, groupIndex) {
	return (data).getUTCHours();
}], ["%a %d", function(data, index, groupIndex) {
	var date = data;
	return (date.getUTCDay()) && date.getUTCDate() != 1 ? 1 : 0;
}], ["%b %d", function(data, index, groupIndex) {
	return (data).getUTCDate() != 1 ? 1 : 0;
}], ["%B", function(data, index, groupIndex) {
	return (data).getUTCMonth();
}], ["%Y", function(data, index, groupIndex) {
	return 1;
}]]);
/**
 * rave_time_scaleLocalMethods.year = rave_time.year;
 */
/** @expose */ 
com_ibm_rave_core_time_DateTimeScale.localMethodsYear = com_ibm_rave_core_time_Time.getInstance().year;
/**
 * rave_time_scaleUtcMethods.year = rave_time.year.utc
 */
/** @expose */ 
com_ibm_rave_core_time_DateTimeScale.utcMethodsYear = com_ibm_rave_core_time_Time.getInstance().year.utc;

// $source: com/ibm/rave/core/internal/nativeImpl/Functor
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2014
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/

// @import com/ibm/rave/core/Rave
/**
 * Takes an object and always returns a function. If the object is a
 * function, return it. Otherwise return a function that returns the object.
 * 
 * Mapped to rave.functor().
 * 
 * Only available in Javascript.
 */
com_ibm_rave_core_Rave["functor"] = function(v) {
	return typeof v === "function" ? v : function() {
		return v;
	};
};
// $source: com/ibm/rave/core/internal/nativeImpl/Rebind
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2014
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/

// @import com/ibm/rave/core/Rave

/**
 * Copies the methods with the specified names from source to target, and returns target. 
 * Calling one of the named methods on the target object invokes the same-named method 
 * on the source object, passing any arguments passed to the target method, and using the 
 * source object as the this context. If the source method returns the source object, the 
 * target method returns the target object (“setter” method); otherwise, the target method 
 * returns the return value of the source method (“getter” mode). The rebind operator allows 
 * inherited methods (mix-ins) to be rebound to a subclass on a different object.
 * 
 * Mapped to rave.rebind().
 * 
 * Only available in Javascript.
 */
com_ibm_rave_core_Rave["rebind"] = function(target, source) {
	  var i = 1, n = arguments.length, method;
	  while (++i < n) target[method = arguments[i]] = rave_rebind(target, source, source[method]);
	  
	  /**
	   * Method is assumed to be a standard Rave getter-setter:
	   * If passed with no arguments, gets the value.
	   * If passed with arguments, sets the value and returns the target.
	   */
	  function rave_rebind(target, source, method) {
		  return function() {
		    var value = method.apply(source, arguments);
		    return value === source ? target : value;
		  };
		}
	  return target;
};
// $source: com/ibm/rave/core/internal/nativeImpl/version/Version

// @import com/ibm/rave/core/Rave
com_ibm_rave_core_Rave["version"] = new String("2.0.0");
com_ibm_rave_core_Rave["version"]["build"] = "2.0.0.20151123-2007";
com_ibm_rave_core_Rave["version"]["vendor"] = "IBM Rapidly Adaptive Visualization Engine";

			
// $source: com/ibm/rave/core/internal/nativeImpl/Module
/************************************************************************
** IBM Confidential
**
** IBM Business Analytics: Rapidly Adaptive Visualization Engine
**
** (C) Copyright IBM Corp. 2014, 2015
**
** The source code for this program is not published or otherwise divested of its trade secrets, 
** irrespective of what has been deposited with the U.S. Copyright Office.
************************************************************************/

// Must be the first import
// @import ./ModuleHeader

// @import com/ibm/rave/core/Rave
// @import com/ibm/rave/core/behavior/Zoom
// @import com/ibm/rave/core/internal/transitions/Tweener
// @import com/ibm/rave/core/selector/Selector
// @import com/ibm/rave/core/selector/EnterSelector
// @import com/ibm/rave/core/transition/Transition
// @import com/ibm/rave/core/nativeImpl/Declare
// @import com/ibm/rave/core/internal/nativeImpl/Functor
// @import com/ibm/rave/core/internal/nativeImpl/Rebind
// @import com/ibm/rave/core/internal/nativeImpl/version/Version

var rave = com_ibm_rave_core_Rave;

// rave#event should be undefined to start
delete rave.event;

// satisfy prototype extension mechanism of selectors and transitions
rave["selection"].prototype = com_ibm_rave_core_selector_Selector.prototype;
rave["transition"].prototype = com_ibm_rave_core_transition_Transition.prototype;

// version info
rave["version"] = com_ibm_rave_core_Rave["version"];

// patch wheel event in zoom
// https://developer.mozilla.org/en-US/docs/Mozilla_event_reference/wheel
if (rave_document) {
	if (!("onwheel" in rave_document.createElement("div"))) {
		if ("onmousewheel" in rave_document) {
			com_ibm_rave_core_behavior_Zoom.zoomDelta = function() { 
				if (typeof rave.event["wheelDelta"] !== "undefined") {
					return rave.event["wheelDelta"];
				}
				return -rave.event["deltaY"] * (rave.event["deltaMode"] != 0 ? 120 : 1);
			};
			com_ibm_rave_core_behavior_Zoom.zoomWheel = "mousewheel";
		} else {
			com_ibm_rave_core_behavior_Zoom.zoomDelta = function() { return -rave.event["detail"]; };
			com_ibm_rave_core_behavior_Zoom.zoomWheel = "MozMousePixelScroll";
		}
	}
}

// end patching the translated code

com_ibm_rave_core_internal_transitions_Tweener.earlyScheduleSupport = true;

if (typeof define === "function" && define.amd) {
	define(rave);
} else if (typeof module === "object" && module.exports) {
	module.exports = rave;
}

// expose Rave class to the global variable rave
global["rave"] = rave;

global["rave"]["selection"]["enter"] = com_ibm_rave_core_selector_EnterSelector;
global["rave"]["_"] = {
	"com_ibm_rave_core_nativeImpl_Declare" : com_ibm_rave_core_nativeImpl_Declare,
	"com_ibm_rave_core_nativeImpl_Object" : com_ibm_rave_core_nativeImpl_Object,
	"com_ibm_rave_core_internal_nativeImpl_Lang" : com_ibm_rave_core_internal_nativeImpl_Lang,
	"com_ibm_rave_core_geom_PointStruct" : com_ibm_rave_core_geom_PointStruct,
	"com_ibm_rave_core_scene_SceneNodeType" : com_ibm_rave_core_scene_SceneNodeType,
	"rave_document" : rave_document,
	"rave_documentElement" : rave_documentElement,
	"rave_window" : rave_window
};

global["rave"]["internal"] = rave_externs;


// $source: com/ibm/rave/core/selector/SelectorDelegate
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare anonymous, declare
//@import com/ibm/rave/core/selector/Selector (loadtime) // superclass
/**
 * The delegate mechanism for a selector.  
 */
var com_ibm_rave_core_selector_SelectorDelegate = rave_externs["SelectorDelegate"] = com_ibm_rave_core_nativeImpl_Declare(com_ibm_rave_core_selector_Selector, {

	//selector : null,

	/**
	 * Create a delegate selector. 
	 */
	/** @expose */ 
	constructor : function() {},

	/**
	 * Set the delegate selector. 
	 * @param (com.ibm.rave.core.selector.Selector) selector The selector to delegate to. 
	 * @return (com.ibm.rave.core.selector.Selector)  The extended selector. 
	 */
	/** @expose */ 
	setDelegate : function(selector) {
		this.selector = selector;
		return this;
	},

	/**
	 * Create the extension to the selector. Concrete classes will implement this method and return an instance of themselves.
	 * @param (com.ibm.rave.core.selector.Selector) s The core selector.
	 * @return (com.ibm.rave.core.selector.Selector)  The extended selector.
	 */
	/** @expose */ 
	create : function(s) {},

	/**
	 * @see Selector#this.append(String)
	 */
	append$0 : function(name) {
		return this.create(this.selector.append$0(name));
	},

	/**
	 * @see Selector#this.append(com_ibm_rave_core_selector_ValueFunction)
	 */
	append$1 : function(elementFunction) {
		return this.create(this.selector.append$1(elementFunction));
	},

	/**
	 * @see Selection#this.attr(Object)
	 */
	attr$0 : function(value) {
		this.selector.attr$0(value);
		return this;
	},

	/**
	 * @see Selector#this.attr(String)
	 */
	attr$3 : function(attribute) {
		return this.selector.attr$3(attribute);
	},

	/**
	 * @see Selector#this.attr(String, Object)
	 */
	attr$1 : function(attribute, value) {
		this.selector.attr$1(attribute, value);
		return this;
	},

	/**
	 * @see Selector#this.attr(String, com_ibm_rave_core_selector_ValueFunction)
	 */
	attr$2 : function(attribute, valueFunction) {
		this.selector.attr$2(attribute, valueFunction);
		return this;
	},

	/**
	 * @see Selector#this.classed(String)
	 */
	classed$0 : function(className) {
		return this.selector.classed$0(className);
	},

	/**
	 * @see Selector#this.classed(Object)
	 */
	classed$1 : function(value) {
		this.selector.classed$1(value);
		return this;
	},

	/**
	 * @see Selector#this.classed(String, )
	 */
	classed$2 : function(className, add) {
		this.selector.classed$2(className, add);
		return this;
	},

	/**
	 * @see Selector#this.classed(String, com_ibm_rave_core_selector_ValueFunction)
	 */
	classed$3 : function(className, valueFunction) {
		this.selector.classed$3(className, valueFunction);
		return this;
	},

	/**
	 * @see Selector#this.call(com_ibm_rave_core_selector_RunFunction, )
	 */
	call$0 : function(callback, args) {
		if (args !== null || arguments.length > 2){
			args = Array.prototype.slice.call(arguments, 1);
		}
		{
			this.selector.call.apply(this.selector, [callback].concat(args));
			return this;
		}
	},

	/**
	 * @see Selector#this.data()
	 */
	data$0 : function() {
		return this.selector.data$0();
	},

	/**
	 * @see Selector#this.datum()
	 */
	datum$0 : function() {
		return this.selector.datum$0();
	},

	/**
	 * @see Selector#this.datum(com_ibm_rave_core_selector_ValueFunction)
	 */
	datum$1 : function(valueFn) {
		this.selector.datum$1(valueFn);
		return this;
	},

	/**
	 * @see Selector#this.datum(Object)
	 */
	datum$2 : function(value) {
		this.selector.datum$2(value);
		return this;
	},

	/**
	 * @see Selector#this.data(com_ibm_rave_core_selector_ValueFunction)
	 */
	data$1 : function(value) {
		return this.create(this.selector.data$1(value));
	},

	/**
	 * @see Selector#this.data(com_ibm_rave_core_selector_ValueFunction, com_ibm_rave_core_selector_ValueFunction)
	 */
	data$2 : function(value, key) {
		return this.create(this.selector.data$2(value, key));
	},

	/**
	 * @see Selector#this.data()
	 */
	data$3 : function(value) {
		return this.create(this.selector.data$3(value));
	},

	/**
	 * @see Selector#this.data(, com_ibm_rave_core_selector_ValueFunction)
	 */
	data$4 : function(value, key) {
		return this.create(this.selector.data$4(value, key));
	},

	/**
	 * @see Selection#this.empty()
	 */
	/** @expose */ 
	empty : function() {
		return this.selector.empty();
	},

	/**
	 * @see Selector#this.enter()
	 */
	/** @expose */ 
	enter : function() {
		var self = this;
		var d = new (com_ibm_rave_core_nativeImpl_Declare([com_ibm_rave_core_selector_SelectorDelegate], {

			create : function(s) {
				return self.create(s);
			}

		}))();
		return d.setDelegate(this.selector.enter());
	},

	/**
	 * @see Selector#this.exit()
	 */
	/** @expose */ 
	exit : function() {
		return this.create(this.selector.exit());
	},

	/**
	 * @see Selector#this.each(com_ibm_rave_core_selector_CallbackFunction)
	 */
	each$0 : function(callback) {
		this.selector.each(callback);
		return this;
	},

	/**
	 * @see Selector#this.filter(com_ibm_rave_core_selector_ValueFunction)
	 */
	filter$0 : function(filterFunction) {
		return this.create(this.selector.filter$0(filterFunction));
	},

	/**
	 * @see Selector#this.filter(String)
	 */
	filter$1 : function(filter) {
		return this.create(this.selector.filter$1(filter));
	},

	/**
	 * @see Selector#this.html()
	 */
	html$0 : function() {
		return this.selector.html$0();
	},

	/**
	 * @see Selector#this.html(Object)
	 */
	html$1 : function(value) {
		this.selector.html$1(value);
		return this;
	},

	/**
	 * @see Selector#this.html(com_ibm_rave_core_selector_ValueFunction)
	 */
	html$2 : function(valueFunction) {
		this.selector.html$2(valueFunction);
		return this;
	},

	/**
	 * @see Selector#this.insert(com_ibm_rave_core_selector_ValueFunction, String)
	 */
	insert$0 : function(elementFunction, before) {
		return this.create(this.selector.insert$0(elementFunction, before));
	},

	/**
	 * @see Selector#this.insert(com_ibm_rave_core_selector_ValueFunction, com_ibm_rave_core_selector_ValueFunction)
	 */
	insert$1 : function(nameFunction, beforeFunction) {
		return this.create(this.selector.insert$1(nameFunction, beforeFunction));
	},

	/**
	 * @see Selector#this.insert(String, String)
	 */
	insert$2 : function(name, before) {
		return this.create(this.selector.insert$2(name, before));
	},

	/**
	 * @see Selector#this.insert(String, com_ibm_rave_core_selector_ValueFunction)
	 */
	insert$3 : function(type, beforeFunction) {
		return this.create(this.selector.insert$3(type, beforeFunction));
	},

	/**
	 * @see Selector#this.interrupt()
	 */
	interrupt$0 : function() {
		this.selector.interrupt$0();
		return this;
	},

	/**
	 * @see Selector#this.interrupt(String)
	 */
	interrupt$1 : function(name) {
		this.selector.interrupt$1(name);
		return this;
	},

	/**
	 * @see Selector#this.init(com_ibm_rave_core_scene_SceneNode)
	 */
	init$0 : function(node) {
		this.selector.init$0(node);
		return this;
	},

	/**
	 * @see Selector#this.initAll()
	 */
	initAll$0 : function(nodes) {
		this.selector.initAll$0(nodes);
		return this;
	},

	/**
	 * @see Selector#this.init(String)
	 */
	init$1 : function(query) {
		this.selector.init$1(query);
		return this;
	},

	/**
	 * @see Selector#this.initAll(String)
	 */
	initAll$1 : function(query) {
		this.selector.initAll$1(query);
		return this;
	},

	/**
	 * @see Selection#this.node()
	 */
	/** @expose */ 
	node : function() {
		return this.selector.node();
	},

	/**
	 * @see Selector#this.on(String)
	 */
	on$0 : function(eventName) {
		return this.selector.on$0(eventName);
	},

	/**
	 * @see Selector#this.on(Object)
	 */
	on$1 : function(value) {
		this.selector.on$1(value);
		return this;
	},

	/**
	 * @see Selector#this.on(String, com_ibm_rave_core_selector_SelectorEventListener)
	 */
	on$2 : function(eventName, listener) {
		this.selector.on$2(eventName, listener);
		return this;
	},

	/**
	 * @see Selector#this.on(String, com_ibm_rave_core_selector_SelectorEventListener, )
	 */
	on$3 : function(eventName, listener, useCapture) {
		this.selector.on$3(eventName, listener, useCapture);
		return this;
	},

	/**
	 * @see Selector#this.owner()
	 */
	owner$0 : function() {
		return this.selector.owner$0();
	},

	/**
	 * @see Selector#this.owner(com_ibm_rave_core_scene_SceneNode)
	 */
	owner$1 : function(owner) {
		this.selector.owner$1(owner);
		return this;
	},

	/**
	 * @see Selector#this.owner(com_ibm_rave_core_selector_ValueFunction)
	 */
	owner$2 : function(owner) {
		this.selector.owner$2(owner);
		return this;
	},

	/**
	 * @see Selector#this.order()
	 */
	/** @expose */ 
	order : function() {
		this.selector.order();
		return this;
	},

	/**
	 * @see Selector#this.mirror()
	 */
	/** @expose */ 
	mirror : function(mirror) {
		return this.create(this.selector.mirror(mirror));
	},

	/**
	 * @see Selector#this.property(String)
	 */
	property$0 : function(key) {
		return this.selector.property$0(key);
	},

	/**
	 * @see Selector#this.property(Object)
	 */
	property$1 : function(value) {
		this.selector.property$1(value);
		return this;
	},

	/**
	 * @see Selector#this.property(String, Object)
	 */
	property$2 : function(key, value) {
		this.selector.property$2(key, value);
		return this;
	},

	/**
	 * @see Selector#this.property(String, com_ibm_rave_core_selector_ValueFunction)
	 */
	property$3 : function(key, valueFunction) {
		this.selector.property$3(key, valueFunction);
		return this;
	},

	/**
	 * @see Selector#this.remove()
	 */
	/** @expose */ 
	remove : function() {
		this.selector.remove();
		return this;
	},

	/**
	 * @see Selection#this.size()
	 */
	/** @expose */ 
	size : function() {
		return this.selector.size();
	},

	/**
	 * @see Selector#this.select(Object)
	 */
	select$0 : function(query) {
		return this.create(this.selector.select$0(query));
	},

	/**
	 * @see Selector#this.select(com_ibm_rave_core_selector_ValueFunction)
	 */
	select$1 : function(valueFunction) {
		return this.create(this.selector.select$1(valueFunction));
	},

	/**
	 * @see Selector#this.selectAll(String)
	 */
	selectAll$0 : function(query) {
		return this.create(this.selector.selectAll$0(query));
	},

	/**
	 * @see Selector#this.selectAll(com_ibm_rave_core_selector_ValueFunction)
	 */
	selectAll$1 : function(sel) {
		return this.create(this.selector.selectAll$1(sel));
	},

	/**
	 * @see Selector#this.extension(String)
	 */
	/** @expose */ 
	extension$0 : function(key) {
		return this.selector.extension(key);
	},

	/**
	 * @see Selection#this.style(Object)
	 */
	style$0 : function(value) {
		this.selector.style$0(value);
		return this;
	},

	/**
	 * @see Selection#this.style(Object, String)
	 */
	style$1 : function(value, priority) {
		this.selector.style$1(value, priority);
		return this;
	},

	/**
	 * @see Selector#this.style(String)
	 */
	style$6 : function(styleName) {
		return this.selector.style$6(styleName);
	},

	/**
	 * @see Selector#this.style(String, Object)
	 */
	style$2 : function(styleName, value) {
		this.selector.style$2(styleName, value);
		return this;
	},

	/**
	 * @see Selector#this.style(String, Object, String)
	 */
	style$4 : function(styleName, value, priority) {
		this.selector.style$4(styleName, value, priority);
		return this;
	},

	/**
	 * @see Selector#this.style(String, com_ibm_rave_core_selector_ValueFunction)
	 */
	style$3 : function(styleName, valueFunction) {
		this.selector.style$3(styleName, valueFunction);
		return this;
	},

	/**
	 * @see Selector#this.style(String, com_ibm_rave_core_selector_ValueFunction, String)
	 */
	style$5 : function(styleName, valueFunction, priority) {
		this.selector.style$5(styleName, valueFunction, priority);
		return this;
	},

	/**
	 * @see Selector#this.sort(com_ibm_rave_core_util_Comparator)
	 */
	sort$1 : function(c) {
		this.selector.sort$1(c);
		return this;
	},

	/**
	 * @see Selector#this.sort()
	 */
	sort$0 : function() {
		this.selector.sort();
		return this;
	},

	/**
	 * @see Selector#this.text()
	 */
	text$2 : function() {
		return this.selector.text$2();
	},

	/**
	 * @see Selector#this.text(Object)
	 */
	text$0 : function(value) {
		this.selector.text$0(value);
		return this;
	},

	/**
	 * @see Selector#this.text(com_ibm_rave_core_selector_ValueFunction)
	 */
	text$1 : function(valueFunction) {
		this.selector.text$1(valueFunction);
		return this;
	},

	/**
	 * @see Selector#this.transition()
	 */
	transition$0 : function() {
		return this.selector.transition$0();
	},

	/**
	 * @see Selector#this.transition(String)
	 */
	transition$1 : function(name) {
		return this.selector.transition$1(name);
	},

	/**
	 * @see Selector#this.dispose()
	 */
	/** @expose */ 
	dispose : function() {
		this.selector.dispose();
		return this;
	},

	/** @expose */ 
	append : function(a0) {
		var args = arguments;
		if (args.length == 1 && (a0 == null || typeof a0 === "string")) {
			return this.append$0(a0);
		}
		return this.append$1(a0);
	},

	/** @expose */ 
	attr : function(a0, a1) {
		var args = arguments;
		if (args.length == 1 && (a0 == null || typeof a0 === "string")) {
			return this.attr$3(a0);
		}
		if (args.length == 1) {
			return this.attr$0(a0);
		}
		if (args.length == 2 && (a0 == null || typeof a0 === "string") && typeof a1 === "function") {
			return this.attr$2(a0, a1);
		}
		return this.attr$1(a0, a1);
	},

	/** @expose */ 
	classed : function(a0, a1) {
		var args = arguments;
		if (args.length == 1 && (a0 == null || typeof a0 === "string")) {
			return this.classed$0(a0);
		}
		if (args.length == 1) {
			return this.classed$1(a0);
		}
		if (args.length == 2 && (a0 == null || typeof a0 === "string") && typeof a1 === "function") {
			return this.classed$3(a0, a1);
		}
		return this.classed$2(a0, a1);
	},

	/** @expose */ 
	call : function(a0, a1) {
		var args = arguments;
		return this.call$0.apply(this, args);
	},

	/** @expose */ 
	data : function(a0, a1) {
		var args = arguments;
		if (args.length == 0) {
			return this.data$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.data$1(a0);
		}
		if (args.length == 1 && (a0 == null || Object.prototype.toString.call(a0) === "[object Array]")) {
			return this.data$3(a0);
		}
		if (args.length == 2 && typeof a0 === "function" && typeof a1 === "function") {
			return this.data$2(a0, a1);
		}
		if (args.length == 2 && (a0 == null || Object.prototype.toString.call(a0) === "[object Array]") && typeof a1 === "function") {
			return this.data$4(a0, a1);
		}
		return com_ibm_rave_core_selector_Selector.prototype.data.apply(this, args);
	},

	/** @expose */ 
	datum : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.datum$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.datum$1(a0);
		}
		return this.datum$2(a0);
	},

	/** @expose */ 
	each : function(a0) {
		var args = arguments;
		return this.each$0(a0);
	},

	/** @expose */ 
	filter : function(a0) {
		var args = arguments;
		if (args.length == 1 && typeof a0 === "function") {
			return this.filter$0(a0);
		}
		if (args.length == 1 && (a0 == null || typeof a0 === "string")) {
			return this.filter$1(a0);
		}
		return Array.prototype.filter.apply(this, args);
	},

	/** @expose */ 
	html : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.html$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.html$2(a0);
		}
		return this.html$1(a0);
	},

	/** @expose */ 
	insert : function(a0, a1) {
		var args = arguments;
		if (args.length == 2 && typeof a0 === "function" && (a1 == null || typeof a1 === "string")) {
			return this.insert$0(a0, a1);
		}
		if (args.length == 2 && typeof a0 === "function" && typeof a1 === "function") {
			return this.insert$1(a0, a1);
		}
		if (args.length == 2 && (a0 == null || typeof a0 === "string") && (a1 == null || typeof a1 === "string")) {
			return this.insert$2(a0, a1);
		}
		return this.insert$3(a0, a1);
	},

	/** @expose */ 
	interrupt : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.interrupt$0();
		}
		return this.interrupt$1(a0);
	},

	/** @expose */ 
	init : function(a0) {
		var args = arguments;
		if (args.length == 1 && (a0 == null || typeof a0 === "string")) {
			return this.init$1(a0);
		}
		return this.init$0(a0);
	},

	/** @expose */ 
	initAll : function(a0) {
		var args = arguments;
		if (args.length == 1 && (a0 == null || Object.prototype.toString.call(a0) === "[object Array]")) {
			return this.initAll$0(a0);
		}
		return this.initAll$1(a0);
	},

	/** @expose */ 
	on : function(a0, a1, a2) {
		var args = arguments;
		if (args.length == 1 && (a0 == null || typeof a0 === "string")) {
			return this.on$0(a0);
		}
		if (args.length == 1) {
			return this.on$1(a0);
		}
		if (args.length == 2) {
			return this.on$2(a0, a1);
		}
		return this.on$3(a0, a1, a2);
	},

	/** @expose */ 
	owner : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.owner$0();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.owner$2(a0);
		}
		return this.owner$1(a0);
	},

	/** @expose */ 
	property : function(a0, a1) {
		var args = arguments;
		if (args.length == 1 && (a0 == null || typeof a0 === "string")) {
			return this.property$0(a0);
		}
		if (args.length == 1) {
			return this.property$1(a0);
		}
		if (args.length == 2 && (a0 == null || typeof a0 === "string") && typeof a1 === "function") {
			return this.property$3(a0, a1);
		}
		return this.property$2(a0, a1);
	},

	/** @expose */ 
	select : function(a0) {
		var args = arguments;
		if (args.length == 1 && typeof a0 === "function") {
			return this.select$1(a0);
		}
		return this.select$0(a0);
	},

	/** @expose */ 
	selectAll : function(a0) {
		var args = arguments;
		if (args.length == 1 && (a0 == null || typeof a0 === "string")) {
			return this.selectAll$0(a0);
		}
		return this.selectAll$1(a0);
	},

	/** @expose */ 
	style : function(a0, a1, a2) {
		var args = arguments;
		if (args.length == 1 && (a0 == null || typeof a0 === "string")) {
			return this.style$6(a0);
		}
		if (args.length == 1) {
			return this.style$0(a0);
		}
		if (args.length == 2 && (a0 == null || typeof a0 === "string") && typeof a1 === "function") {
			return this.style$3(a0, a1);
		}
		if (args.length == 2 && (a0 == null || typeof a0 === "string") && (a1 == null || Object.prototype.toString.call(a1) !== "[object Array]")) {
			return this.style$2(a0, a1);
		}
		if (args.length == 2) {
			return this.style$1(a0, a1);
		}
		if (args.length == 3 && (a0 == null || typeof a0 === "string") && typeof a1 === "function" && (a2 == null || typeof a2 === "string")) {
			return this.style$5(a0, a1, a2);
		}
		return this.style$4(a0, a1, a2);
	},

	/** @expose */ 
	sort : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.sort$0();
		}
		return this.sort$1(a0);
	},

	/** @expose */ 
	text : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.text$2();
		}
		if (args.length == 1 && typeof a0 === "function") {
			return this.text$1(a0);
		}
		return this.text$0(a0);
	},

	/** @expose */ 
	transition : function(a0) {
		var args = arguments;
		if (args.length == 0) {
			return this.transition$0();
		}
		return this.transition$1(a0);
	}
});


// $source: com/ibm/rave/core/svg/AbstractTickHandler
/************************************************************************
 ** IBM Confidential
 **
 ** IBM Business Analytics: Rapidly Adaptive Visualization Engine
 **
 ** (C) Copyright IBM Corp. 2015
 **
 ** The source code for this program is not published or otherwise divested of its trade secrets, 
 ** irrespective of what has been deposited with the U.S. Copyright Office.
 ************************************************************************/
// GENERATED
//@import com/ibm/rave/core/nativeImpl/Declare (loadtime) // declare
var com_ibm_rave_core_svg_AbstractTickHandler = rave_externs["AbstractTickHandler"] = com_ibm_rave_core_nativeImpl_Declare({

	/**
	 * Reset the work that was done when the tick handler was run.
	 * @param (com.ibm.rave.core.selector.Selection) ticks The selection containing the ticks to reset. 
	 */
	/** @expose */ 
	reset : function(ticks) {}
});


})();
